
package sifxml

import (
  "fmt"
  "log"
  "strconv"
  "encoding/json"
  "reflect"

  "github.com/qdm12/reprint"
  )

// Property/Value pair, used to set multiple properties of a container together
type Prop struct {
  Key string
  Value interface{}
}

// Check whether value is allowed in a codeset, based on the associated codeset values map
func CodesetContains(codeset map[string]struct{}, value interface{}) bool {

 	vstr, ok := value.(string)
 	if !ok {
 		return ok
 	}
 	_, ok = codeset[vstr]
 	return ok
}

func (a *Int) UnmarshalJSON(b []byte) error {
  type temporary Int
	err := json.Unmarshal(b, (*temporary)(a))
  if err != nil {
    var str string
    err = json.Unmarshal(b, &str)
      if err != nil {
        return err
        }
        aI, err:=strconv.Atoi(str)
      if err != nil {
        return err
        }
        *a = Int(aI)
    }
  return nil
}

func (a *Float) UnmarshalJSON(b []byte) error {
  type temporary Float
	err := json.Unmarshal(b, (*temporary)(a))
  if err != nil {
    var str string
    err = json.Unmarshal(b, &str)
      if err != nil {
        return err
        }
        aI, err:=strconv.ParseFloat(str, 64)
      if err != nil {
        return err
        }
        *a = Float(aI)
    }
  return nil
}

func (a *Bool) UnmarshalJSON(b []byte) error {
  type temporary Bool
	err := json.Unmarshal(b, (*temporary)(a))
  if err != nil {
    var str string
    err = json.Unmarshal(b, &str)
      if err != nil {
        return err
        }
        *a = Bool(str == "true")
    }
  return nil
}


// Create a slice of pointers to the object type
func ActivitySlice() []*Activity {
  return make([]*Activity, 0)
  }
// Create a slice of pointers to the object type
func AddressCollectionSlice() []*AddressCollection {
  return make([]*AddressCollection, 0)
  }
// Create a slice of pointers to the object type
func AggregateCharacteristicInfoSlice() []*AggregateCharacteristicInfo {
  return make([]*AggregateCharacteristicInfo, 0)
  }
// Create a slice of pointers to the object type
func AggregateStatisticFactSlice() []*AggregateStatisticFact {
  return make([]*AggregateStatisticFact, 0)
  }
// Create a slice of pointers to the object type
func AggregateStatisticInfoSlice() []*AggregateStatisticInfo {
  return make([]*AggregateStatisticInfo, 0)
  }
// Create a slice of pointers to the object type
func CalendarDateSlice() []*CalendarDate {
  return make([]*CalendarDate, 0)
  }
// Create a slice of pointers to the object type
func CalendarSummarySlice() []*CalendarSummary {
  return make([]*CalendarSummary, 0)
  }
// Create a slice of pointers to the object type
func CensusCollectionSlice() []*CensusCollection {
  return make([]*CensusCollection, 0)
  }
// Create a slice of pointers to the object type
func ChargedLocationInfoSlice() []*ChargedLocationInfo {
  return make([]*ChargedLocationInfo, 0)
  }
// Create a slice of pointers to the object type
func CollectionAcquittalSlice() []*CollectionAcquittal {
  return make([]*CollectionAcquittal, 0)
  }
// Create a slice of pointers to the object type
func CollectionDeclarationSlice() []*CollectionDeclaration {
  return make([]*CollectionDeclaration, 0)
  }
// Create a slice of pointers to the object type
func CollectionRoundSlice() []*CollectionRound {
  return make([]*CollectionRound, 0)
  }
// Create a slice of pointers to the object type
func CollectionStatusSlice() []*CollectionStatus {
  return make([]*CollectionStatus, 0)
  }
// Create a slice of pointers to the object type
func DebtorSlice() []*Debtor {
  return make([]*Debtor, 0)
  }
// Create a slice of pointers to the object type
func EquipmentInfoSlice() []*EquipmentInfo {
  return make([]*EquipmentInfo, 0)
  }
// Create a slice of pointers to the object type
func FinancialAccountSlice() []*FinancialAccount {
  return make([]*FinancialAccount, 0)
  }
// Create a slice of pointers to the object type
func FinancialQuestionnaireCollectionSlice() []*FinancialQuestionnaireCollection {
  return make([]*FinancialQuestionnaireCollection, 0)
  }
// Create a slice of pointers to the object type
func GradingAssignmentSlice() []*GradingAssignment {
  return make([]*GradingAssignment, 0)
  }
// Create a slice of pointers to the object type
func GradingAssignmentScoreSlice() []*GradingAssignmentScore {
  return make([]*GradingAssignmentScore, 0)
  }
// Create a slice of pointers to the object type
func IdentitySlice() []*Identity {
  return make([]*Identity, 0)
  }
// Create a slice of pointers to the object type
func InvoiceSlice() []*Invoice {
  return make([]*Invoice, 0)
  }
// Create a slice of pointers to the object type
func JournalSlice() []*Journal {
  return make([]*Journal, 0)
  }
// Create a slice of pointers to the object type
func LEAInfoSlice() []*LEAInfo {
  return make([]*LEAInfo, 0)
  }
// Create a slice of pointers to the object type
func LearningResourceSlice() []*LearningResource {
  return make([]*LearningResource, 0)
  }
// Create a slice of pointers to the object type
func LearningResourcePackageSlice() []*LearningResourcePackage {
  return make([]*LearningResourcePackage, 0)
  }
// Create a slice of pointers to the object type
func LearningStandardDocumentSlice() []*LearningStandardDocument {
  return make([]*LearningStandardDocument, 0)
  }
// Create a slice of pointers to the object type
func LearningStandardItemSlice() []*LearningStandardItem {
  return make([]*LearningStandardItem, 0)
  }
// Create a slice of pointers to the object type
func LibraryPatronStatusSlice() []*LibraryPatronStatus {
  return make([]*LibraryPatronStatus, 0)
  }
// Create a slice of pointers to the object type
func MarkValueInfoSlice() []*MarkValueInfo {
  return make([]*MarkValueInfo, 0)
  }
// Create a slice of pointers to the object type
func NAPCodeFrameSlice() []*NAPCodeFrame {
  return make([]*NAPCodeFrame, 0)
  }
// Create a slice of pointers to the object type
func NAPEventStudentLinkSlice() []*NAPEventStudentLink {
  return make([]*NAPEventStudentLink, 0)
  }
// Create a slice of pointers to the object type
func NAPStudentResponseSetSlice() []*NAPStudentResponseSet {
  return make([]*NAPStudentResponseSet, 0)
  }
// Create a slice of pointers to the object type
func NAPTestSlice() []*NAPTest {
  return make([]*NAPTest, 0)
  }
// Create a slice of pointers to the object type
func NAPTestItemSlice() []*NAPTestItem {
  return make([]*NAPTestItem, 0)
  }
// Create a slice of pointers to the object type
func NAPTestScoreSummarySlice() []*NAPTestScoreSummary {
  return make([]*NAPTestScoreSummary, 0)
  }
// Create a slice of pointers to the object type
func NAPTestletSlice() []*NAPTestlet {
  return make([]*NAPTestlet, 0)
  }
// Create a slice of pointers to the object type
func PaymentReceiptSlice() []*PaymentReceipt {
  return make([]*PaymentReceipt, 0)
  }
// Create a slice of pointers to the object type
func PersonPictureSlice() []*PersonPicture {
  return make([]*PersonPicture, 0)
  }
// Create a slice of pointers to the object type
func PersonPrivacyObligationDocumentSlice() []*PersonPrivacyObligationDocument {
  return make([]*PersonPrivacyObligationDocument, 0)
  }
// Create a slice of pointers to the object type
func PersonalisedPlanSlice() []*PersonalisedPlan {
  return make([]*PersonalisedPlan, 0)
  }
// Create a slice of pointers to the object type
func PurchaseOrderSlice() []*PurchaseOrder {
  return make([]*PurchaseOrder, 0)
  }
// Create a slice of pointers to the object type
func ResourceBookingSlice() []*ResourceBooking {
  return make([]*ResourceBooking, 0)
  }
// Create a slice of pointers to the object type
func RoomInfoSlice() []*RoomInfo {
  return make([]*RoomInfo, 0)
  }
// Create a slice of pointers to the object type
func ScheduledActivitySlice() []*ScheduledActivity {
  return make([]*ScheduledActivity, 0)
  }
// Create a slice of pointers to the object type
func SchoolCourseInfoSlice() []*SchoolCourseInfo {
  return make([]*SchoolCourseInfo, 0)
  }
// Create a slice of pointers to the object type
func SchoolInfoSlice() []*SchoolInfo {
  return make([]*SchoolInfo, 0)
  }
// Create a slice of pointers to the object type
func SchoolProgramsSlice() []*SchoolPrograms {
  return make([]*SchoolPrograms, 0)
  }
// Create a slice of pointers to the object type
func SectionInfoSlice() []*SectionInfo {
  return make([]*SectionInfo, 0)
  }
// Create a slice of pointers to the object type
func SessionInfoSlice() []*SessionInfo {
  return make([]*SessionInfo, 0)
  }
// Create a slice of pointers to the object type
func StaffAssignmentSlice() []*StaffAssignment {
  return make([]*StaffAssignment, 0)
  }
// Create a slice of pointers to the object type
func StaffPersonalSlice() []*StaffPersonal {
  return make([]*StaffPersonal, 0)
  }
// Create a slice of pointers to the object type
func StudentActivityInfoSlice() []*StudentActivityInfo {
  return make([]*StudentActivityInfo, 0)
  }
// Create a slice of pointers to the object type
func StudentActivityParticipationSlice() []*StudentActivityParticipation {
  return make([]*StudentActivityParticipation, 0)
  }
// Create a slice of pointers to the object type
func StudentAttendanceCollectionSlice() []*StudentAttendanceCollection {
  return make([]*StudentAttendanceCollection, 0)
  }
// Create a slice of pointers to the object type
func StudentAttendanceSummarySlice() []*StudentAttendanceSummary {
  return make([]*StudentAttendanceSummary, 0)
  }
// Create a slice of pointers to the object type
func StudentAttendanceTimeListSlice() []*StudentAttendanceTimeList {
  return make([]*StudentAttendanceTimeList, 0)
  }
// Create a slice of pointers to the object type
func StudentContactPersonalSlice() []*StudentContactPersonal {
  return make([]*StudentContactPersonal, 0)
  }
// Create a slice of pointers to the object type
func StudentContactRelationshipSlice() []*StudentContactRelationship {
  return make([]*StudentContactRelationship, 0)
  }
// Create a slice of pointers to the object type
func StudentDailyAttendanceSlice() []*StudentDailyAttendance {
  return make([]*StudentDailyAttendance, 0)
  }
// Create a slice of pointers to the object type
func StudentDataTransferNoteSlice() []*StudentDataTransferNote {
  return make([]*StudentDataTransferNote, 0)
  }
// Create a slice of pointers to the object type
func StudentGradeSlice() []*StudentGrade {
  return make([]*StudentGrade, 0)
  }
// Create a slice of pointers to the object type
func StudentParticipationSlice() []*StudentParticipation {
  return make([]*StudentParticipation, 0)
  }
// Create a slice of pointers to the object type
func StudentPeriodAttendanceSlice() []*StudentPeriodAttendance {
  return make([]*StudentPeriodAttendance, 0)
  }
// Create a slice of pointers to the object type
func StudentPersonalSlice() []*StudentPersonal {
  return make([]*StudentPersonal, 0)
  }
// Create a slice of pointers to the object type
func StudentSchoolEnrollmentSlice() []*StudentSchoolEnrollment {
  return make([]*StudentSchoolEnrollment, 0)
  }
// Create a slice of pointers to the object type
func StudentScoreJudgementAgainstStandardSlice() []*StudentScoreJudgementAgainstStandard {
  return make([]*StudentScoreJudgementAgainstStandard, 0)
  }
// Create a slice of pointers to the object type
func StudentSectionEnrollmentSlice() []*StudentSectionEnrollment {
  return make([]*StudentSectionEnrollment, 0)
  }
// Create a slice of pointers to the object type
func TeachingGroupSlice() []*TeachingGroup {
  return make([]*TeachingGroup, 0)
  }
// Create a slice of pointers to the object type
func TermInfoSlice() []*TermInfo {
  return make([]*TermInfo, 0)
  }
// Create a slice of pointers to the object type
func TimeTableSlice() []*TimeTable {
  return make([]*TimeTable, 0)
  }
// Create a slice of pointers to the object type
func TimeTableCellSlice() []*TimeTableCell {
  return make([]*TimeTableCell, 0)
  }
// Create a slice of pointers to the object type
func TimeTableContainerSlice() []*TimeTableContainer {
  return make([]*TimeTableContainer, 0)
  }
// Create a slice of pointers to the object type
func TimeTableSubjectSlice() []*TimeTableSubject {
  return make([]*TimeTableSubject, 0)
  }
// Create a slice of pointers to the object type
func VendorInfoSlice() []*VendorInfo {
  return make([]*VendorInfo, 0)
  }
// Create a slice of pointers to the object type
func WellbeingAlertSlice() []*WellbeingAlert {
  return make([]*WellbeingAlert, 0)
  }
// Create a slice of pointers to the object type
func WellbeingAppealSlice() []*WellbeingAppeal {
  return make([]*WellbeingAppeal, 0)
  }
// Create a slice of pointers to the object type
func WellbeingCharacteristicSlice() []*WellbeingCharacteristic {
  return make([]*WellbeingCharacteristic, 0)
  }
// Create a slice of pointers to the object type
func WellbeingEventSlice() []*WellbeingEvent {
  return make([]*WellbeingEvent, 0)
  }
// Create a slice of pointers to the object type
func WellbeingPersonLinkSlice() []*WellbeingPersonLink {
  return make([]*WellbeingPersonLink, 0)
  }
// Create a slice of pointers to the object type
func WellbeingResponseSlice() []*WellbeingResponse {
  return make([]*WellbeingResponse, 0)
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ACStrandAreaListType) Clone() (*ACStrandAreaListType) {
return reprint.This(t).(*ACStrandAreaListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ACStrandAreaListTypePointer(value interface{}) (*ACStrandAreaListType, bool) {
switch t := value.(type) {
        case *ACStrandAreaListType:
                return value.(*ACStrandAreaListType), true
        case ACStrandAreaListType:
                v, _ := value.(ACStrandAreaListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ACStrandAreaListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewACStrandAreaListType() *ACStrandAreaListType {
  if out, ok := ACStrandAreaListTypePointer(ACStrandAreaListType{}); !ok {
                log.Fatalf("Could not create pointer to ACStrandAreaListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ACStrandSubjectAreaType) Clone() (*ACStrandSubjectAreaType) {
return reprint.This(t).(*ACStrandSubjectAreaType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ACStrandSubjectAreaTypePointer(value interface{}) (*ACStrandSubjectAreaType, bool) {
switch t := value.(type) {
        case *ACStrandSubjectAreaType:
                return value.(*ACStrandSubjectAreaType), true
        case ACStrandSubjectAreaType:
                v, _ := value.(ACStrandSubjectAreaType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ACStrandSubjectAreaType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewACStrandSubjectAreaType() *ACStrandSubjectAreaType {
  if out, ok := ACStrandSubjectAreaTypePointer(ACStrandSubjectAreaType{}); !ok {
                log.Fatalf("Could not create pointer to ACStrandSubjectAreaType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AGContextualQuestionListType) Clone() (*AGContextualQuestionListType) {
return reprint.This(t).(*AGContextualQuestionListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AGContextualQuestionListTypePointer(value interface{}) (*AGContextualQuestionListType, bool) {
switch t := value.(type) {
        case *AGContextualQuestionListType:
                return value.(*AGContextualQuestionListType), true
        case AGContextualQuestionListType:
                v, _ := value.(AGContextualQuestionListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AGContextualQuestionListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAGContextualQuestionListType() *AGContextualQuestionListType {
  if out, ok := AGContextualQuestionListTypePointer(AGContextualQuestionListType{}); !ok {
                log.Fatalf("Could not create pointer to AGContextualQuestionListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AGContextualQuestionType) Clone() (*AGContextualQuestionType) {
return reprint.This(t).(*AGContextualQuestionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AGContextualQuestionTypePointer(value interface{}) (*AGContextualQuestionType, bool) {
switch t := value.(type) {
        case *AGContextualQuestionType:
                return value.(*AGContextualQuestionType), true
        case AGContextualQuestionType:
                v, _ := value.(AGContextualQuestionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AGContextualQuestionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAGContextualQuestionType() *AGContextualQuestionType {
  if out, ok := AGContextualQuestionTypePointer(AGContextualQuestionType{}); !ok {
                log.Fatalf("Could not create pointer to AGContextualQuestionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AGParentType) Clone() (*AGParentType) {
return reprint.This(t).(*AGParentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AGParentTypePointer(value interface{}) (*AGParentType, bool) {
switch t := value.(type) {
        case *AGParentType:
                return value.(*AGParentType), true
        case AGParentType:
                v, _ := value.(AGParentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AGParentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAGParentType() *AGParentType {
  if out, ok := AGParentTypePointer(AGParentType{}); !ok {
                log.Fatalf("Could not create pointer to AGParentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AGReportingObjectResponseListType) Clone() (*AGReportingObjectResponseListType) {
return reprint.This(t).(*AGReportingObjectResponseListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AGReportingObjectResponseListTypePointer(value interface{}) (*AGReportingObjectResponseListType, bool) {
switch t := value.(type) {
        case *AGReportingObjectResponseListType:
                return value.(*AGReportingObjectResponseListType), true
        case AGReportingObjectResponseListType:
                v, _ := value.(AGReportingObjectResponseListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AGReportingObjectResponseListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAGReportingObjectResponseListType() *AGReportingObjectResponseListType {
  if out, ok := AGReportingObjectResponseListTypePointer(AGReportingObjectResponseListType{}); !ok {
                log.Fatalf("Could not create pointer to AGReportingObjectResponseListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AGReportingObjectResponseType) Clone() (*AGReportingObjectResponseType) {
return reprint.This(t).(*AGReportingObjectResponseType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AGReportingObjectResponseTypePointer(value interface{}) (*AGReportingObjectResponseType, bool) {
switch t := value.(type) {
        case *AGReportingObjectResponseType:
                return value.(*AGReportingObjectResponseType), true
        case AGReportingObjectResponseType:
                v, _ := value.(AGReportingObjectResponseType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AGReportingObjectResponseType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAGReportingObjectResponseType() *AGReportingObjectResponseType {
  if out, ok := AGReportingObjectResponseTypePointer(AGReportingObjectResponseType{}); !ok {
                log.Fatalf("Could not create pointer to AGReportingObjectResponseType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AGRoundListType) Clone() (*AGRoundListType) {
return reprint.This(t).(*AGRoundListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AGRoundListTypePointer(value interface{}) (*AGRoundListType, bool) {
switch t := value.(type) {
        case *AGRoundListType:
                return value.(*AGRoundListType), true
        case AGRoundListType:
                v, _ := value.(AGRoundListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AGRoundListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAGRoundListType() *AGRoundListType {
  if out, ok := AGRoundListTypePointer(AGRoundListType{}); !ok {
                log.Fatalf("Could not create pointer to AGRoundListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AGRoundType) Clone() (*AGRoundType) {
return reprint.This(t).(*AGRoundType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AGRoundTypePointer(value interface{}) (*AGRoundType, bool) {
switch t := value.(type) {
        case *AGRoundType:
                return value.(*AGRoundType), true
        case AGRoundType:
                v, _ := value.(AGRoundType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AGRoundType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAGRoundType() *AGRoundType {
  if out, ok := AGRoundTypePointer(AGRoundType{}); !ok {
                log.Fatalf("Could not create pointer to AGRoundType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AGRuleListType) Clone() (*AGRuleListType) {
return reprint.This(t).(*AGRuleListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AGRuleListTypePointer(value interface{}) (*AGRuleListType, bool) {
switch t := value.(type) {
        case *AGRuleListType:
                return value.(*AGRuleListType), true
        case AGRuleListType:
                v, _ := value.(AGRuleListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AGRuleListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAGRuleListType() *AGRuleListType {
  if out, ok := AGRuleListTypePointer(AGRuleListType{}); !ok {
                log.Fatalf("Could not create pointer to AGRuleListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AGRuleType) Clone() (*AGRuleType) {
return reprint.This(t).(*AGRuleType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AGRuleTypePointer(value interface{}) (*AGRuleType, bool) {
switch t := value.(type) {
        case *AGRuleType:
                return value.(*AGRuleType), true
        case AGRuleType:
                v, _ := value.(AGRuleType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AGRuleType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAGRuleType() *AGRuleType {
  if out, ok := AGRuleTypePointer(AGRuleType{}); !ok {
                log.Fatalf("Could not create pointer to AGRuleType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AbstractContentElementType) Clone() (*AbstractContentElementType) {
return reprint.This(t).(*AbstractContentElementType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AbstractContentElementTypePointer(value interface{}) (*AbstractContentElementType, bool) {
switch t := value.(type) {
        case *AbstractContentElementType:
                return value.(*AbstractContentElementType), true
        case AbstractContentElementType:
                v, _ := value.(AbstractContentElementType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AbstractContentElementType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAbstractContentElementType() *AbstractContentElementType {
  if out, ok := AbstractContentElementTypePointer(AbstractContentElementType{}); !ok {
                log.Fatalf("Could not create pointer to AbstractContentElementType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AccountCodeListType) Clone() (*AccountCodeListType) {
return reprint.This(t).(*AccountCodeListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AccountCodeListTypePointer(value interface{}) (*AccountCodeListType, bool) {
switch t := value.(type) {
        case *AccountCodeListType:
                return value.(*AccountCodeListType), true
        case AccountCodeListType:
                v, _ := value.(AccountCodeListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AccountCodeListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAccountCodeListType() *AccountCodeListType {
  if out, ok := AccountCodeListTypePointer(AccountCodeListType{}); !ok {
                log.Fatalf("Could not create pointer to AccountCodeListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Activity) Clone() (*Activity) {
return reprint.This(t).(*Activity)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ActivityPointer(value interface{}) (*Activity, bool) {
switch t := value.(type) {
        case *Activity:
                return value.(*Activity), true
        case Activity:
                v, _ := value.(Activity)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Activity\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewActivity() *Activity {
  if out, ok := ActivityPointer(Activity{}); !ok {
                log.Fatalf("Could not create pointer to Activity\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ActivityEvaluationType) Clone() (*ActivityEvaluationType) {
return reprint.This(t).(*ActivityEvaluationType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ActivityEvaluationTypePointer(value interface{}) (*ActivityEvaluationType, bool) {
switch t := value.(type) {
        case *ActivityEvaluationType:
                return value.(*ActivityEvaluationType), true
        case ActivityEvaluationType:
                v, _ := value.(ActivityEvaluationType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ActivityEvaluationType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewActivityEvaluationType() *ActivityEvaluationType {
  if out, ok := ActivityEvaluationTypePointer(ActivityEvaluationType{}); !ok {
                log.Fatalf("Could not create pointer to ActivityEvaluationType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ActivityTimeType) Clone() (*ActivityTimeType) {
return reprint.This(t).(*ActivityTimeType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ActivityTimeTypePointer(value interface{}) (*ActivityTimeType, bool) {
switch t := value.(type) {
        case *ActivityTimeType:
                return value.(*ActivityTimeType), true
        case ActivityTimeType:
                v, _ := value.(ActivityTimeType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ActivityTimeType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewActivityTimeType() *ActivityTimeType {
  if out, ok := ActivityTimeTypePointer(ActivityTimeType{}); !ok {
                log.Fatalf("Could not create pointer to ActivityTimeType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Activitys) Clone() (*Activitys) {
return reprint.This(t).(*Activitys)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ActivitysPointer(value interface{}) (*Activitys, bool) {
switch t := value.(type) {
        case *Activitys:
                return value.(*Activitys), true
        case Activitys:
                v, _ := value.(Activitys)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Activitys\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AddressCollection) Clone() (*AddressCollection) {
return reprint.This(t).(*AddressCollection)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AddressCollectionPointer(value interface{}) (*AddressCollection, bool) {
switch t := value.(type) {
        case *AddressCollection:
                return value.(*AddressCollection), true
        case AddressCollection:
                v, _ := value.(AddressCollection)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AddressCollection\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAddressCollection() *AddressCollection {
  if out, ok := AddressCollectionPointer(AddressCollection{}); !ok {
                log.Fatalf("Could not create pointer to AddressCollection\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AddressCollectionReportingListType) Clone() (*AddressCollectionReportingListType) {
return reprint.This(t).(*AddressCollectionReportingListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AddressCollectionReportingListTypePointer(value interface{}) (*AddressCollectionReportingListType, bool) {
switch t := value.(type) {
        case *AddressCollectionReportingListType:
                return value.(*AddressCollectionReportingListType), true
        case AddressCollectionReportingListType:
                v, _ := value.(AddressCollectionReportingListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AddressCollectionReportingListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAddressCollectionReportingListType() *AddressCollectionReportingListType {
  if out, ok := AddressCollectionReportingListTypePointer(AddressCollectionReportingListType{}); !ok {
                log.Fatalf("Could not create pointer to AddressCollectionReportingListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AddressCollectionReportingType) Clone() (*AddressCollectionReportingType) {
return reprint.This(t).(*AddressCollectionReportingType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AddressCollectionReportingTypePointer(value interface{}) (*AddressCollectionReportingType, bool) {
switch t := value.(type) {
        case *AddressCollectionReportingType:
                return value.(*AddressCollectionReportingType), true
        case AddressCollectionReportingType:
                v, _ := value.(AddressCollectionReportingType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AddressCollectionReportingType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAddressCollectionReportingType() *AddressCollectionReportingType {
  if out, ok := AddressCollectionReportingTypePointer(AddressCollectionReportingType{}); !ok {
                log.Fatalf("Could not create pointer to AddressCollectionReportingType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AddressCollectionStudentListType) Clone() (*AddressCollectionStudentListType) {
return reprint.This(t).(*AddressCollectionStudentListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AddressCollectionStudentListTypePointer(value interface{}) (*AddressCollectionStudentListType, bool) {
switch t := value.(type) {
        case *AddressCollectionStudentListType:
                return value.(*AddressCollectionStudentListType), true
        case AddressCollectionStudentListType:
                v, _ := value.(AddressCollectionStudentListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AddressCollectionStudentListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAddressCollectionStudentListType() *AddressCollectionStudentListType {
  if out, ok := AddressCollectionStudentListTypePointer(AddressCollectionStudentListType{}); !ok {
                log.Fatalf("Could not create pointer to AddressCollectionStudentListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AddressCollectionStudentType) Clone() (*AddressCollectionStudentType) {
return reprint.This(t).(*AddressCollectionStudentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AddressCollectionStudentTypePointer(value interface{}) (*AddressCollectionStudentType, bool) {
switch t := value.(type) {
        case *AddressCollectionStudentType:
                return value.(*AddressCollectionStudentType), true
        case AddressCollectionStudentType:
                v, _ := value.(AddressCollectionStudentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AddressCollectionStudentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAddressCollectionStudentType() *AddressCollectionStudentType {
  if out, ok := AddressCollectionStudentTypePointer(AddressCollectionStudentType{}); !ok {
                log.Fatalf("Could not create pointer to AddressCollectionStudentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AddressCollections) Clone() (*AddressCollections) {
return reprint.This(t).(*AddressCollections)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AddressCollectionsPointer(value interface{}) (*AddressCollections, bool) {
switch t := value.(type) {
        case *AddressCollections:
                return value.(*AddressCollections), true
        case AddressCollections:
                v, _ := value.(AddressCollections)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AddressCollections\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AddressListType) Clone() (*AddressListType) {
return reprint.This(t).(*AddressListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AddressListTypePointer(value interface{}) (*AddressListType, bool) {
switch t := value.(type) {
        case *AddressListType:
                return value.(*AddressListType), true
        case AddressListType:
                v, _ := value.(AddressListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AddressListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAddressListType() *AddressListType {
  if out, ok := AddressListTypePointer(AddressListType{}); !ok {
                log.Fatalf("Could not create pointer to AddressListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AddressStreetType) Clone() (*AddressStreetType) {
return reprint.This(t).(*AddressStreetType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AddressStreetTypePointer(value interface{}) (*AddressStreetType, bool) {
switch t := value.(type) {
        case *AddressStreetType:
                return value.(*AddressStreetType), true
        case AddressStreetType:
                v, _ := value.(AddressStreetType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AddressStreetType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAddressStreetType() *AddressStreetType {
  if out, ok := AddressStreetTypePointer(AddressStreetType{}); !ok {
                log.Fatalf("Could not create pointer to AddressStreetType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AddressType) Clone() (*AddressType) {
return reprint.This(t).(*AddressType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AddressTypePointer(value interface{}) (*AddressType, bool) {
switch t := value.(type) {
        case *AddressType:
                return value.(*AddressType), true
        case AddressType:
                v, _ := value.(AddressType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AddressType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAddressType() *AddressType {
  if out, ok := AddressTypePointer(AddressType{}); !ok {
                log.Fatalf("Could not create pointer to AddressType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AdjustmentContainerType) Clone() (*AdjustmentContainerType) {
return reprint.This(t).(*AdjustmentContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AdjustmentContainerTypePointer(value interface{}) (*AdjustmentContainerType, bool) {
switch t := value.(type) {
        case *AdjustmentContainerType:
                return value.(*AdjustmentContainerType), true
        case AdjustmentContainerType:
                v, _ := value.(AdjustmentContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AdjustmentContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAdjustmentContainerType() *AdjustmentContainerType {
  if out, ok := AdjustmentContainerTypePointer(AdjustmentContainerType{}); !ok {
                log.Fatalf("Could not create pointer to AdjustmentContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AgencyType) Clone() (*AgencyType) {
return reprint.This(t).(*AgencyType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AgencyTypePointer(value interface{}) (*AgencyType, bool) {
switch t := value.(type) {
        case *AgencyType:
                return value.(*AgencyType), true
        case AgencyType:
                v, _ := value.(AgencyType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AgencyType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAgencyType() *AgencyType {
  if out, ok := AgencyTypePointer(AgencyType{}); !ok {
                log.Fatalf("Could not create pointer to AgencyType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AggregateCharacteristicInfo) Clone() (*AggregateCharacteristicInfo) {
return reprint.This(t).(*AggregateCharacteristicInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AggregateCharacteristicInfoPointer(value interface{}) (*AggregateCharacteristicInfo, bool) {
switch t := value.(type) {
        case *AggregateCharacteristicInfo:
                return value.(*AggregateCharacteristicInfo), true
        case AggregateCharacteristicInfo:
                v, _ := value.(AggregateCharacteristicInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AggregateCharacteristicInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAggregateCharacteristicInfo() *AggregateCharacteristicInfo {
  if out, ok := AggregateCharacteristicInfoPointer(AggregateCharacteristicInfo{}); !ok {
                log.Fatalf("Could not create pointer to AggregateCharacteristicInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AggregateCharacteristicInfos) Clone() (*AggregateCharacteristicInfos) {
return reprint.This(t).(*AggregateCharacteristicInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AggregateCharacteristicInfosPointer(value interface{}) (*AggregateCharacteristicInfos, bool) {
switch t := value.(type) {
        case *AggregateCharacteristicInfos:
                return value.(*AggregateCharacteristicInfos), true
        case AggregateCharacteristicInfos:
                v, _ := value.(AggregateCharacteristicInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AggregateCharacteristicInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AggregateStatisticFact) Clone() (*AggregateStatisticFact) {
return reprint.This(t).(*AggregateStatisticFact)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AggregateStatisticFactPointer(value interface{}) (*AggregateStatisticFact, bool) {
switch t := value.(type) {
        case *AggregateStatisticFact:
                return value.(*AggregateStatisticFact), true
        case AggregateStatisticFact:
                v, _ := value.(AggregateStatisticFact)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AggregateStatisticFact\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAggregateStatisticFact() *AggregateStatisticFact {
  if out, ok := AggregateStatisticFactPointer(AggregateStatisticFact{}); !ok {
                log.Fatalf("Could not create pointer to AggregateStatisticFact\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AggregateStatisticFacts) Clone() (*AggregateStatisticFacts) {
return reprint.This(t).(*AggregateStatisticFacts)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AggregateStatisticFactsPointer(value interface{}) (*AggregateStatisticFacts, bool) {
switch t := value.(type) {
        case *AggregateStatisticFacts:
                return value.(*AggregateStatisticFacts), true
        case AggregateStatisticFacts:
                v, _ := value.(AggregateStatisticFacts)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AggregateStatisticFacts\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AggregateStatisticInfo) Clone() (*AggregateStatisticInfo) {
return reprint.This(t).(*AggregateStatisticInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AggregateStatisticInfoPointer(value interface{}) (*AggregateStatisticInfo, bool) {
switch t := value.(type) {
        case *AggregateStatisticInfo:
                return value.(*AggregateStatisticInfo), true
        case AggregateStatisticInfo:
                v, _ := value.(AggregateStatisticInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AggregateStatisticInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAggregateStatisticInfo() *AggregateStatisticInfo {
  if out, ok := AggregateStatisticInfoPointer(AggregateStatisticInfo{}); !ok {
                log.Fatalf("Could not create pointer to AggregateStatisticInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AggregateStatisticInfos) Clone() (*AggregateStatisticInfos) {
return reprint.This(t).(*AggregateStatisticInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AggregateStatisticInfosPointer(value interface{}) (*AggregateStatisticInfos, bool) {
switch t := value.(type) {
        case *AggregateStatisticInfos:
                return value.(*AggregateStatisticInfos), true
        case AggregateStatisticInfos:
                v, _ := value.(AggregateStatisticInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AggregateStatisticInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AlertMessageType) Clone() (*AlertMessageType) {
return reprint.This(t).(*AlertMessageType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AlertMessageTypePointer(value interface{}) (*AlertMessageType, bool) {
switch t := value.(type) {
        case *AlertMessageType:
                return value.(*AlertMessageType), true
        case AlertMessageType:
                v, _ := value.(AlertMessageType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AlertMessageType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAlertMessageType() *AlertMessageType {
  if out, ok := AlertMessageTypePointer(AlertMessageType{}); !ok {
                log.Fatalf("Could not create pointer to AlertMessageType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AlertMessagesType) Clone() (*AlertMessagesType) {
return reprint.This(t).(*AlertMessagesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AlertMessagesTypePointer(value interface{}) (*AlertMessagesType, bool) {
switch t := value.(type) {
        case *AlertMessagesType:
                return value.(*AlertMessagesType), true
        case AlertMessagesType:
                v, _ := value.(AlertMessagesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AlertMessagesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAlertMessagesType() *AlertMessagesType {
  if out, ok := AlertMessagesTypePointer(AlertMessagesType{}); !ok {
                log.Fatalf("Could not create pointer to AlertMessagesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AlternateIdentificationCodeListType) Clone() (*AlternateIdentificationCodeListType) {
return reprint.This(t).(*AlternateIdentificationCodeListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AlternateIdentificationCodeListTypePointer(value interface{}) (*AlternateIdentificationCodeListType, bool) {
switch t := value.(type) {
        case *AlternateIdentificationCodeListType:
                return value.(*AlternateIdentificationCodeListType), true
        case AlternateIdentificationCodeListType:
                v, _ := value.(AlternateIdentificationCodeListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AlternateIdentificationCodeListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAlternateIdentificationCodeListType() *AlternateIdentificationCodeListType {
  if out, ok := AlternateIdentificationCodeListTypePointer(AlternateIdentificationCodeListType{}); !ok {
                log.Fatalf("Could not create pointer to AlternateIdentificationCodeListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ApplicableLawListType) Clone() (*ApplicableLawListType) {
return reprint.This(t).(*ApplicableLawListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ApplicableLawListTypePointer(value interface{}) (*ApplicableLawListType, bool) {
switch t := value.(type) {
        case *ApplicableLawListType:
                return value.(*ApplicableLawListType), true
        case ApplicableLawListType:
                v, _ := value.(ApplicableLawListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ApplicableLawListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewApplicableLawListType() *ApplicableLawListType {
  if out, ok := ApplicableLawListTypePointer(ApplicableLawListType{}); !ok {
                log.Fatalf("Could not create pointer to ApplicableLawListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ApplicableLawType) Clone() (*ApplicableLawType) {
return reprint.This(t).(*ApplicableLawType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ApplicableLawTypePointer(value interface{}) (*ApplicableLawType, bool) {
switch t := value.(type) {
        case *ApplicableLawType:
                return value.(*ApplicableLawType), true
        case ApplicableLawType:
                v, _ := value.(ApplicableLawType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ApplicableLawType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewApplicableLawType() *ApplicableLawType {
  if out, ok := ApplicableLawTypePointer(ApplicableLawType{}); !ok {
                log.Fatalf("Could not create pointer to ApplicableLawType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ApprovalType) Clone() (*ApprovalType) {
return reprint.This(t).(*ApprovalType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ApprovalTypePointer(value interface{}) (*ApprovalType, bool) {
switch t := value.(type) {
        case *ApprovalType:
                return value.(*ApprovalType), true
        case ApprovalType:
                v, _ := value.(ApprovalType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ApprovalType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewApprovalType() *ApprovalType {
  if out, ok := ApprovalTypePointer(ApprovalType{}); !ok {
                log.Fatalf("Could not create pointer to ApprovalType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ApprovalsType) Clone() (*ApprovalsType) {
return reprint.This(t).(*ApprovalsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ApprovalsTypePointer(value interface{}) (*ApprovalsType, bool) {
switch t := value.(type) {
        case *ApprovalsType:
                return value.(*ApprovalsType), true
        case ApprovalsType:
                v, _ := value.(ApprovalsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ApprovalsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewApprovalsType() *ApprovalsType {
  if out, ok := ApprovalsTypePointer(ApprovalsType{}); !ok {
                log.Fatalf("Could not create pointer to ApprovalsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ArrivalSchoolType) Clone() (*ArrivalSchoolType) {
return reprint.This(t).(*ArrivalSchoolType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ArrivalSchoolTypePointer(value interface{}) (*ArrivalSchoolType, bool) {
switch t := value.(type) {
        case *ArrivalSchoolType:
                return value.(*ArrivalSchoolType), true
        case ArrivalSchoolType:
                v, _ := value.(ArrivalSchoolType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ArrivalSchoolType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewArrivalSchoolType() *ArrivalSchoolType {
  if out, ok := ArrivalSchoolTypePointer(ArrivalSchoolType{}); !ok {
                log.Fatalf("Could not create pointer to ArrivalSchoolType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AssignmentListType) Clone() (*AssignmentListType) {
return reprint.This(t).(*AssignmentListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AssignmentListTypePointer(value interface{}) (*AssignmentListType, bool) {
switch t := value.(type) {
        case *AssignmentListType:
                return value.(*AssignmentListType), true
        case AssignmentListType:
                v, _ := value.(AssignmentListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AssignmentListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAssignmentListType() *AssignmentListType {
  if out, ok := AssignmentListTypePointer(AssignmentListType{}); !ok {
                log.Fatalf("Could not create pointer to AssignmentListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AssignmentScoreType) Clone() (*AssignmentScoreType) {
return reprint.This(t).(*AssignmentScoreType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AssignmentScoreTypePointer(value interface{}) (*AssignmentScoreType, bool) {
switch t := value.(type) {
        case *AssignmentScoreType:
                return value.(*AssignmentScoreType), true
        case AssignmentScoreType:
                v, _ := value.(AssignmentScoreType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AssignmentScoreType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAssignmentScoreType() *AssignmentScoreType {
  if out, ok := AssignmentScoreTypePointer(AssignmentScoreType{}); !ok {
                log.Fatalf("Could not create pointer to AssignmentScoreType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AssociatedObjectsType) Clone() (*AssociatedObjectsType) {
return reprint.This(t).(*AssociatedObjectsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AssociatedObjectsTypePointer(value interface{}) (*AssociatedObjectsType, bool) {
switch t := value.(type) {
        case *AssociatedObjectsType:
                return value.(*AssociatedObjectsType), true
        case AssociatedObjectsType:
                v, _ := value.(AssociatedObjectsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AssociatedObjectsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAssociatedObjectsType() *AssociatedObjectsType {
  if out, ok := AssociatedObjectsTypePointer(AssociatedObjectsType{}); !ok {
                log.Fatalf("Could not create pointer to AssociatedObjectsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AssociatedObjectsType_AssociatedObject) Clone() (*AssociatedObjectsType_AssociatedObject) {
return reprint.This(t).(*AssociatedObjectsType_AssociatedObject)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AssociatedObjectsType_AssociatedObjectPointer(value interface{}) (*AssociatedObjectsType_AssociatedObject, bool) {
switch t := value.(type) {
        case *AssociatedObjectsType_AssociatedObject:
                return value.(*AssociatedObjectsType_AssociatedObject), true
        case AssociatedObjectsType_AssociatedObject:
                v, _ := value.(AssociatedObjectsType_AssociatedObject)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AssociatedObjectsType_AssociatedObject\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAssociatedObjectsType_AssociatedObject() *AssociatedObjectsType_AssociatedObject {
  if out, ok := AssociatedObjectsType_AssociatedObjectPointer(AssociatedObjectsType_AssociatedObject{}); !ok {
                log.Fatalf("Could not create pointer to AssociatedObjectsType_AssociatedObject\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AttendanceCodeType) Clone() (*AttendanceCodeType) {
return reprint.This(t).(*AttendanceCodeType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AttendanceCodeTypePointer(value interface{}) (*AttendanceCodeType, bool) {
switch t := value.(type) {
        case *AttendanceCodeType:
                return value.(*AttendanceCodeType), true
        case AttendanceCodeType:
                v, _ := value.(AttendanceCodeType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AttendanceCodeType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAttendanceCodeType() *AttendanceCodeType {
  if out, ok := AttendanceCodeTypePointer(AttendanceCodeType{}); !ok {
                log.Fatalf("Could not create pointer to AttendanceCodeType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AttendanceInfoType) Clone() (*AttendanceInfoType) {
return reprint.This(t).(*AttendanceInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AttendanceInfoTypePointer(value interface{}) (*AttendanceInfoType, bool) {
switch t := value.(type) {
        case *AttendanceInfoType:
                return value.(*AttendanceInfoType), true
        case AttendanceInfoType:
                v, _ := value.(AttendanceInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AttendanceInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAttendanceInfoType() *AttendanceInfoType {
  if out, ok := AttendanceInfoTypePointer(AttendanceInfoType{}); !ok {
                log.Fatalf("Could not create pointer to AttendanceInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AttendanceTimeType) Clone() (*AttendanceTimeType) {
return reprint.This(t).(*AttendanceTimeType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AttendanceTimeTypePointer(value interface{}) (*AttendanceTimeType, bool) {
switch t := value.(type) {
        case *AttendanceTimeType:
                return value.(*AttendanceTimeType), true
        case AttendanceTimeType:
                v, _ := value.(AttendanceTimeType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AttendanceTimeType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAttendanceTimeType() *AttendanceTimeType {
  if out, ok := AttendanceTimeTypePointer(AttendanceTimeType{}); !ok {
                log.Fatalf("Could not create pointer to AttendanceTimeType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AttendanceTimesType) Clone() (*AttendanceTimesType) {
return reprint.This(t).(*AttendanceTimesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AttendanceTimesTypePointer(value interface{}) (*AttendanceTimesType, bool) {
switch t := value.(type) {
        case *AttendanceTimesType:
                return value.(*AttendanceTimesType), true
        case AttendanceTimesType:
                v, _ := value.(AttendanceTimesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AttendanceTimesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAttendanceTimesType() *AttendanceTimesType {
  if out, ok := AttendanceTimesTypePointer(AttendanceTimesType{}); !ok {
                log.Fatalf("Could not create pointer to AttendanceTimesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AuditInfoType) Clone() (*AuditInfoType) {
return reprint.This(t).(*AuditInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AuditInfoTypePointer(value interface{}) (*AuditInfoType, bool) {
switch t := value.(type) {
        case *AuditInfoType:
                return value.(*AuditInfoType), true
        case AuditInfoType:
                v, _ := value.(AuditInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AuditInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAuditInfoType() *AuditInfoType {
  if out, ok := AuditInfoTypePointer(AuditInfoType{}); !ok {
                log.Fatalf("Could not create pointer to AuditInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AuthorsType) Clone() (*AuthorsType) {
return reprint.This(t).(*AuthorsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AuthorsTypePointer(value interface{}) (*AuthorsType, bool) {
switch t := value.(type) {
        case *AuthorsType:
                return value.(*AuthorsType), true
        case AuthorsType:
                v, _ := value.(AuthorsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AuthorsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAuthorsType() *AuthorsType {
  if out, ok := AuthorsTypePointer(AuthorsType{}); !ok {
                log.Fatalf("Could not create pointer to AuthorsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *AwardContainerType) Clone() (*AwardContainerType) {
return reprint.This(t).(*AwardContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func AwardContainerTypePointer(value interface{}) (*AwardContainerType, bool) {
switch t := value.(type) {
        case *AwardContainerType:
                return value.(*AwardContainerType), true
        case AwardContainerType:
                v, _ := value.(AwardContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to AwardContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewAwardContainerType() *AwardContainerType {
  if out, ok := AwardContainerTypePointer(AwardContainerType{}); !ok {
                log.Fatalf("Could not create pointer to AwardContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *BaseNameType) Clone() (*BaseNameType) {
return reprint.This(t).(*BaseNameType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func BaseNameTypePointer(value interface{}) (*BaseNameType, bool) {
switch t := value.(type) {
        case *BaseNameType:
                return value.(*BaseNameType), true
        case BaseNameType:
                v, _ := value.(BaseNameType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to BaseNameType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewBaseNameType() *BaseNameType {
  if out, ok := BaseNameTypePointer(BaseNameType{}); !ok {
                log.Fatalf("Could not create pointer to BaseNameType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *BinaryDataType) Clone() (*BinaryDataType) {
return reprint.This(t).(*BinaryDataType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func BinaryDataTypePointer(value interface{}) (*BinaryDataType, bool) {
switch t := value.(type) {
        case *BinaryDataType:
                return value.(*BinaryDataType), true
        case BinaryDataType:
                v, _ := value.(BinaryDataType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to BinaryDataType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewBinaryDataType() *BinaryDataType {
  if out, ok := BinaryDataTypePointer(BinaryDataType{}); !ok {
                log.Fatalf("Could not create pointer to BinaryDataType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CalculationRuleType) Clone() (*CalculationRuleType) {
return reprint.This(t).(*CalculationRuleType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CalculationRuleTypePointer(value interface{}) (*CalculationRuleType, bool) {
switch t := value.(type) {
        case *CalculationRuleType:
                return value.(*CalculationRuleType), true
        case CalculationRuleType:
                v, _ := value.(CalculationRuleType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CalculationRuleType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCalculationRuleType() *CalculationRuleType {
  if out, ok := CalculationRuleTypePointer(CalculationRuleType{}); !ok {
                log.Fatalf("Could not create pointer to CalculationRuleType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CalendarDate) Clone() (*CalendarDate) {
return reprint.This(t).(*CalendarDate)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CalendarDatePointer(value interface{}) (*CalendarDate, bool) {
switch t := value.(type) {
        case *CalendarDate:
                return value.(*CalendarDate), true
        case CalendarDate:
                v, _ := value.(CalendarDate)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CalendarDate\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCalendarDate() *CalendarDate {
  if out, ok := CalendarDatePointer(CalendarDate{}); !ok {
                log.Fatalf("Could not create pointer to CalendarDate\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CalendarDateInfoType) Clone() (*CalendarDateInfoType) {
return reprint.This(t).(*CalendarDateInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CalendarDateInfoTypePointer(value interface{}) (*CalendarDateInfoType, bool) {
switch t := value.(type) {
        case *CalendarDateInfoType:
                return value.(*CalendarDateInfoType), true
        case CalendarDateInfoType:
                v, _ := value.(CalendarDateInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CalendarDateInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCalendarDateInfoType() *CalendarDateInfoType {
  if out, ok := CalendarDateInfoTypePointer(CalendarDateInfoType{}); !ok {
                log.Fatalf("Could not create pointer to CalendarDateInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CalendarDates) Clone() (*CalendarDates) {
return reprint.This(t).(*CalendarDates)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CalendarDatesPointer(value interface{}) (*CalendarDates, bool) {
switch t := value.(type) {
        case *CalendarDates:
                return value.(*CalendarDates), true
        case CalendarDates:
                v, _ := value.(CalendarDates)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CalendarDates\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CalendarSummary) Clone() (*CalendarSummary) {
return reprint.This(t).(*CalendarSummary)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CalendarSummaryPointer(value interface{}) (*CalendarSummary, bool) {
switch t := value.(type) {
        case *CalendarSummary:
                return value.(*CalendarSummary), true
        case CalendarSummary:
                v, _ := value.(CalendarSummary)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CalendarSummary\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCalendarSummary() *CalendarSummary {
  if out, ok := CalendarSummaryPointer(CalendarSummary{}); !ok {
                log.Fatalf("Could not create pointer to CalendarSummary\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CalendarSummaryListType) Clone() (*CalendarSummaryListType) {
return reprint.This(t).(*CalendarSummaryListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CalendarSummaryListTypePointer(value interface{}) (*CalendarSummaryListType, bool) {
switch t := value.(type) {
        case *CalendarSummaryListType:
                return value.(*CalendarSummaryListType), true
        case CalendarSummaryListType:
                v, _ := value.(CalendarSummaryListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CalendarSummaryListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCalendarSummaryListType() *CalendarSummaryListType {
  if out, ok := CalendarSummaryListTypePointer(CalendarSummaryListType{}); !ok {
                log.Fatalf("Could not create pointer to CalendarSummaryListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CalendarSummarys) Clone() (*CalendarSummarys) {
return reprint.This(t).(*CalendarSummarys)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CalendarSummarysPointer(value interface{}) (*CalendarSummarys, bool) {
switch t := value.(type) {
        case *CalendarSummarys:
                return value.(*CalendarSummarys), true
        case CalendarSummarys:
                v, _ := value.(CalendarSummarys)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CalendarSummarys\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CampusContainerType) Clone() (*CampusContainerType) {
return reprint.This(t).(*CampusContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CampusContainerTypePointer(value interface{}) (*CampusContainerType, bool) {
switch t := value.(type) {
        case *CampusContainerType:
                return value.(*CampusContainerType), true
        case CampusContainerType:
                v, _ := value.(CampusContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CampusContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCampusContainerType() *CampusContainerType {
  if out, ok := CampusContainerTypePointer(CampusContainerType{}); !ok {
                log.Fatalf("Could not create pointer to CampusContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CatchmentStatusContainerType) Clone() (*CatchmentStatusContainerType) {
return reprint.This(t).(*CatchmentStatusContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CatchmentStatusContainerTypePointer(value interface{}) (*CatchmentStatusContainerType, bool) {
switch t := value.(type) {
        case *CatchmentStatusContainerType:
                return value.(*CatchmentStatusContainerType), true
        case CatchmentStatusContainerType:
                v, _ := value.(CatchmentStatusContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CatchmentStatusContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCatchmentStatusContainerType() *CatchmentStatusContainerType {
  if out, ok := CatchmentStatusContainerTypePointer(CatchmentStatusContainerType{}); !ok {
                log.Fatalf("Could not create pointer to CatchmentStatusContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CensusCollection) Clone() (*CensusCollection) {
return reprint.This(t).(*CensusCollection)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CensusCollectionPointer(value interface{}) (*CensusCollection, bool) {
switch t := value.(type) {
        case *CensusCollection:
                return value.(*CensusCollection), true
        case CensusCollection:
                v, _ := value.(CensusCollection)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CensusCollection\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCensusCollection() *CensusCollection {
  if out, ok := CensusCollectionPointer(CensusCollection{}); !ok {
                log.Fatalf("Could not create pointer to CensusCollection\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CensusCollections) Clone() (*CensusCollections) {
return reprint.This(t).(*CensusCollections)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CensusCollectionsPointer(value interface{}) (*CensusCollections, bool) {
switch t := value.(type) {
        case *CensusCollections:
                return value.(*CensusCollections), true
        case CensusCollections:
                v, _ := value.(CensusCollections)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CensusCollections\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CensusReportingListType) Clone() (*CensusReportingListType) {
return reprint.This(t).(*CensusReportingListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CensusReportingListTypePointer(value interface{}) (*CensusReportingListType, bool) {
switch t := value.(type) {
        case *CensusReportingListType:
                return value.(*CensusReportingListType), true
        case CensusReportingListType:
                v, _ := value.(CensusReportingListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CensusReportingListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCensusReportingListType() *CensusReportingListType {
  if out, ok := CensusReportingListTypePointer(CensusReportingListType{}); !ok {
                log.Fatalf("Could not create pointer to CensusReportingListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CensusReportingType) Clone() (*CensusReportingType) {
return reprint.This(t).(*CensusReportingType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CensusReportingTypePointer(value interface{}) (*CensusReportingType, bool) {
switch t := value.(type) {
        case *CensusReportingType:
                return value.(*CensusReportingType), true
        case CensusReportingType:
                v, _ := value.(CensusReportingType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CensusReportingType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCensusReportingType() *CensusReportingType {
  if out, ok := CensusReportingTypePointer(CensusReportingType{}); !ok {
                log.Fatalf("Could not create pointer to CensusReportingType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CensusStaffListType) Clone() (*CensusStaffListType) {
return reprint.This(t).(*CensusStaffListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CensusStaffListTypePointer(value interface{}) (*CensusStaffListType, bool) {
switch t := value.(type) {
        case *CensusStaffListType:
                return value.(*CensusStaffListType), true
        case CensusStaffListType:
                v, _ := value.(CensusStaffListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CensusStaffListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCensusStaffListType() *CensusStaffListType {
  if out, ok := CensusStaffListTypePointer(CensusStaffListType{}); !ok {
                log.Fatalf("Could not create pointer to CensusStaffListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CensusStaffType) Clone() (*CensusStaffType) {
return reprint.This(t).(*CensusStaffType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CensusStaffTypePointer(value interface{}) (*CensusStaffType, bool) {
switch t := value.(type) {
        case *CensusStaffType:
                return value.(*CensusStaffType), true
        case CensusStaffType:
                v, _ := value.(CensusStaffType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CensusStaffType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCensusStaffType() *CensusStaffType {
  if out, ok := CensusStaffTypePointer(CensusStaffType{}); !ok {
                log.Fatalf("Could not create pointer to CensusStaffType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CensusStudentListType) Clone() (*CensusStudentListType) {
return reprint.This(t).(*CensusStudentListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CensusStudentListTypePointer(value interface{}) (*CensusStudentListType, bool) {
switch t := value.(type) {
        case *CensusStudentListType:
                return value.(*CensusStudentListType), true
        case CensusStudentListType:
                v, _ := value.(CensusStudentListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CensusStudentListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCensusStudentListType() *CensusStudentListType {
  if out, ok := CensusStudentListTypePointer(CensusStudentListType{}); !ok {
                log.Fatalf("Could not create pointer to CensusStudentListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CensusStudentType) Clone() (*CensusStudentType) {
return reprint.This(t).(*CensusStudentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CensusStudentTypePointer(value interface{}) (*CensusStudentType, bool) {
switch t := value.(type) {
        case *CensusStudentType:
                return value.(*CensusStudentType), true
        case CensusStudentType:
                v, _ := value.(CensusStudentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CensusStudentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCensusStudentType() *CensusStudentType {
  if out, ok := CensusStudentTypePointer(CensusStudentType{}); !ok {
                log.Fatalf("Could not create pointer to CensusStudentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CharacteristicsType) Clone() (*CharacteristicsType) {
return reprint.This(t).(*CharacteristicsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CharacteristicsTypePointer(value interface{}) (*CharacteristicsType, bool) {
switch t := value.(type) {
        case *CharacteristicsType:
                return value.(*CharacteristicsType), true
        case CharacteristicsType:
                v, _ := value.(CharacteristicsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CharacteristicsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCharacteristicsType() *CharacteristicsType {
  if out, ok := CharacteristicsTypePointer(CharacteristicsType{}); !ok {
                log.Fatalf("Could not create pointer to CharacteristicsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ChargedLocationInfo) Clone() (*ChargedLocationInfo) {
return reprint.This(t).(*ChargedLocationInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ChargedLocationInfoPointer(value interface{}) (*ChargedLocationInfo, bool) {
switch t := value.(type) {
        case *ChargedLocationInfo:
                return value.(*ChargedLocationInfo), true
        case ChargedLocationInfo:
                v, _ := value.(ChargedLocationInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ChargedLocationInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewChargedLocationInfo() *ChargedLocationInfo {
  if out, ok := ChargedLocationInfoPointer(ChargedLocationInfo{}); !ok {
                log.Fatalf("Could not create pointer to ChargedLocationInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ChargedLocationInfos) Clone() (*ChargedLocationInfos) {
return reprint.This(t).(*ChargedLocationInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ChargedLocationInfosPointer(value interface{}) (*ChargedLocationInfos, bool) {
switch t := value.(type) {
        case *ChargedLocationInfos:
                return value.(*ChargedLocationInfos), true
        case ChargedLocationInfos:
                v, _ := value.(ChargedLocationInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ChargedLocationInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CheckoutInfoType) Clone() (*CheckoutInfoType) {
return reprint.This(t).(*CheckoutInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CheckoutInfoTypePointer(value interface{}) (*CheckoutInfoType, bool) {
switch t := value.(type) {
        case *CheckoutInfoType:
                return value.(*CheckoutInfoType), true
        case CheckoutInfoType:
                v, _ := value.(CheckoutInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CheckoutInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCheckoutInfoType() *CheckoutInfoType {
  if out, ok := CheckoutInfoTypePointer(CheckoutInfoType{}); !ok {
                log.Fatalf("Could not create pointer to CheckoutInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CodeFrameTestItemListType) Clone() (*CodeFrameTestItemListType) {
return reprint.This(t).(*CodeFrameTestItemListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CodeFrameTestItemListTypePointer(value interface{}) (*CodeFrameTestItemListType, bool) {
switch t := value.(type) {
        case *CodeFrameTestItemListType:
                return value.(*CodeFrameTestItemListType), true
        case CodeFrameTestItemListType:
                v, _ := value.(CodeFrameTestItemListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CodeFrameTestItemListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCodeFrameTestItemListType() *CodeFrameTestItemListType {
  if out, ok := CodeFrameTestItemListTypePointer(CodeFrameTestItemListType{}); !ok {
                log.Fatalf("Could not create pointer to CodeFrameTestItemListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CodeFrameTestItemType) Clone() (*CodeFrameTestItemType) {
return reprint.This(t).(*CodeFrameTestItemType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CodeFrameTestItemTypePointer(value interface{}) (*CodeFrameTestItemType, bool) {
switch t := value.(type) {
        case *CodeFrameTestItemType:
                return value.(*CodeFrameTestItemType), true
        case CodeFrameTestItemType:
                v, _ := value.(CodeFrameTestItemType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CodeFrameTestItemType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCodeFrameTestItemType() *CodeFrameTestItemType {
  if out, ok := CodeFrameTestItemTypePointer(CodeFrameTestItemType{}); !ok {
                log.Fatalf("Could not create pointer to CodeFrameTestItemType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CollectionAcquittal) Clone() (*CollectionAcquittal) {
return reprint.This(t).(*CollectionAcquittal)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CollectionAcquittalPointer(value interface{}) (*CollectionAcquittal, bool) {
switch t := value.(type) {
        case *CollectionAcquittal:
                return value.(*CollectionAcquittal), true
        case CollectionAcquittal:
                v, _ := value.(CollectionAcquittal)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CollectionAcquittal\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCollectionAcquittal() *CollectionAcquittal {
  if out, ok := CollectionAcquittalPointer(CollectionAcquittal{}); !ok {
                log.Fatalf("Could not create pointer to CollectionAcquittal\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CollectionAcquittals) Clone() (*CollectionAcquittals) {
return reprint.This(t).(*CollectionAcquittals)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CollectionAcquittalsPointer(value interface{}) (*CollectionAcquittals, bool) {
switch t := value.(type) {
        case *CollectionAcquittals:
                return value.(*CollectionAcquittals), true
        case CollectionAcquittals:
                v, _ := value.(CollectionAcquittals)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CollectionAcquittals\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CollectionDeclaration) Clone() (*CollectionDeclaration) {
return reprint.This(t).(*CollectionDeclaration)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CollectionDeclarationPointer(value interface{}) (*CollectionDeclaration, bool) {
switch t := value.(type) {
        case *CollectionDeclaration:
                return value.(*CollectionDeclaration), true
        case CollectionDeclaration:
                v, _ := value.(CollectionDeclaration)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CollectionDeclaration\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCollectionDeclaration() *CollectionDeclaration {
  if out, ok := CollectionDeclarationPointer(CollectionDeclaration{}); !ok {
                log.Fatalf("Could not create pointer to CollectionDeclaration\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CollectionDeclarations) Clone() (*CollectionDeclarations) {
return reprint.This(t).(*CollectionDeclarations)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CollectionDeclarationsPointer(value interface{}) (*CollectionDeclarations, bool) {
switch t := value.(type) {
        case *CollectionDeclarations:
                return value.(*CollectionDeclarations), true
        case CollectionDeclarations:
                v, _ := value.(CollectionDeclarations)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CollectionDeclarations\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CollectionRound) Clone() (*CollectionRound) {
return reprint.This(t).(*CollectionRound)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CollectionRoundPointer(value interface{}) (*CollectionRound, bool) {
switch t := value.(type) {
        case *CollectionRound:
                return value.(*CollectionRound), true
        case CollectionRound:
                v, _ := value.(CollectionRound)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CollectionRound\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCollectionRound() *CollectionRound {
  if out, ok := CollectionRoundPointer(CollectionRound{}); !ok {
                log.Fatalf("Could not create pointer to CollectionRound\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CollectionRounds) Clone() (*CollectionRounds) {
return reprint.This(t).(*CollectionRounds)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CollectionRoundsPointer(value interface{}) (*CollectionRounds, bool) {
switch t := value.(type) {
        case *CollectionRounds:
                return value.(*CollectionRounds), true
        case CollectionRounds:
                v, _ := value.(CollectionRounds)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CollectionRounds\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CollectionStatus) Clone() (*CollectionStatus) {
return reprint.This(t).(*CollectionStatus)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CollectionStatusPointer(value interface{}) (*CollectionStatus, bool) {
switch t := value.(type) {
        case *CollectionStatus:
                return value.(*CollectionStatus), true
        case CollectionStatus:
                v, _ := value.(CollectionStatus)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CollectionStatus\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCollectionStatus() *CollectionStatus {
  if out, ok := CollectionStatusPointer(CollectionStatus{}); !ok {
                log.Fatalf("Could not create pointer to CollectionStatus\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CollectionStatuss) Clone() (*CollectionStatuss) {
return reprint.This(t).(*CollectionStatuss)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CollectionStatussPointer(value interface{}) (*CollectionStatuss, bool) {
switch t := value.(type) {
        case *CollectionStatuss:
                return value.(*CollectionStatuss), true
        case CollectionStatuss:
                v, _ := value.(CollectionStatuss)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CollectionStatuss\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ComponentType) Clone() (*ComponentType) {
return reprint.This(t).(*ComponentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ComponentTypePointer(value interface{}) (*ComponentType, bool) {
switch t := value.(type) {
        case *ComponentType:
                return value.(*ComponentType), true
        case ComponentType:
                v, _ := value.(ComponentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ComponentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewComponentType() *ComponentType {
  if out, ok := ComponentTypePointer(ComponentType{}); !ok {
                log.Fatalf("Could not create pointer to ComponentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ComponentsType) Clone() (*ComponentsType) {
return reprint.This(t).(*ComponentsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ComponentsTypePointer(value interface{}) (*ComponentsType, bool) {
switch t := value.(type) {
        case *ComponentsType:
                return value.(*ComponentsType), true
        case ComponentsType:
                v, _ := value.(ComponentsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ComponentsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewComponentsType() *ComponentsType {
  if out, ok := ComponentsTypePointer(ComponentsType{}); !ok {
                log.Fatalf("Could not create pointer to ComponentsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ConsentToSharingOfDataContainerType) Clone() (*ConsentToSharingOfDataContainerType) {
return reprint.This(t).(*ConsentToSharingOfDataContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ConsentToSharingOfDataContainerTypePointer(value interface{}) (*ConsentToSharingOfDataContainerType, bool) {
switch t := value.(type) {
        case *ConsentToSharingOfDataContainerType:
                return value.(*ConsentToSharingOfDataContainerType), true
        case ConsentToSharingOfDataContainerType:
                v, _ := value.(ConsentToSharingOfDataContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ConsentToSharingOfDataContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewConsentToSharingOfDataContainerType() *ConsentToSharingOfDataContainerType {
  if out, ok := ConsentToSharingOfDataContainerTypePointer(ConsentToSharingOfDataContainerType{}); !ok {
                log.Fatalf("Could not create pointer to ConsentToSharingOfDataContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ContactFlagsType) Clone() (*ContactFlagsType) {
return reprint.This(t).(*ContactFlagsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ContactFlagsTypePointer(value interface{}) (*ContactFlagsType, bool) {
switch t := value.(type) {
        case *ContactFlagsType:
                return value.(*ContactFlagsType), true
        case ContactFlagsType:
                v, _ := value.(ContactFlagsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ContactFlagsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewContactFlagsType() *ContactFlagsType {
  if out, ok := ContactFlagsTypePointer(ContactFlagsType{}); !ok {
                log.Fatalf("Could not create pointer to ContactFlagsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ContactInfoType) Clone() (*ContactInfoType) {
return reprint.This(t).(*ContactInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ContactInfoTypePointer(value interface{}) (*ContactInfoType, bool) {
switch t := value.(type) {
        case *ContactInfoType:
                return value.(*ContactInfoType), true
        case ContactInfoType:
                v, _ := value.(ContactInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ContactInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewContactInfoType() *ContactInfoType {
  if out, ok := ContactInfoTypePointer(ContactInfoType{}); !ok {
                log.Fatalf("Could not create pointer to ContactInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ContactType) Clone() (*ContactType) {
return reprint.This(t).(*ContactType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ContactTypePointer(value interface{}) (*ContactType, bool) {
switch t := value.(type) {
        case *ContactType:
                return value.(*ContactType), true
        case ContactType:
                v, _ := value.(ContactType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ContactType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewContactType() *ContactType {
  if out, ok := ContactTypePointer(ContactType{}); !ok {
                log.Fatalf("Could not create pointer to ContactType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ContactsType) Clone() (*ContactsType) {
return reprint.This(t).(*ContactsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ContactsTypePointer(value interface{}) (*ContactsType, bool) {
switch t := value.(type) {
        case *ContactsType:
                return value.(*ContactsType), true
        case ContactsType:
                v, _ := value.(ContactsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ContactsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewContactsType() *ContactsType {
  if out, ok := ContactsTypePointer(ContactsType{}); !ok {
                log.Fatalf("Could not create pointer to ContactsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ContentDescriptionListType) Clone() (*ContentDescriptionListType) {
return reprint.This(t).(*ContentDescriptionListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ContentDescriptionListTypePointer(value interface{}) (*ContentDescriptionListType, bool) {
switch t := value.(type) {
        case *ContentDescriptionListType:
                return value.(*ContentDescriptionListType), true
        case ContentDescriptionListType:
                v, _ := value.(ContentDescriptionListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ContentDescriptionListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewContentDescriptionListType() *ContentDescriptionListType {
  if out, ok := ContentDescriptionListTypePointer(ContentDescriptionListType{}); !ok {
                log.Fatalf("Could not create pointer to ContentDescriptionListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CopyRightContainerType) Clone() (*CopyRightContainerType) {
return reprint.This(t).(*CopyRightContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CopyRightContainerTypePointer(value interface{}) (*CopyRightContainerType, bool) {
switch t := value.(type) {
        case *CopyRightContainerType:
                return value.(*CopyRightContainerType), true
        case CopyRightContainerType:
                v, _ := value.(CopyRightContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CopyRightContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCopyRightContainerType() *CopyRightContainerType {
  if out, ok := CopyRightContainerTypePointer(CopyRightContainerType{}); !ok {
                log.Fatalf("Could not create pointer to CopyRightContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CountryList2Type) Clone() (*CountryList2Type) {
return reprint.This(t).(*CountryList2Type)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CountryList2TypePointer(value interface{}) (*CountryList2Type, bool) {
switch t := value.(type) {
        case *CountryList2Type:
                return value.(*CountryList2Type), true
        case CountryList2Type:
                v, _ := value.(CountryList2Type)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CountryList2Type\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCountryList2Type() *CountryList2Type {
  if out, ok := CountryList2TypePointer(CountryList2Type{}); !ok {
                log.Fatalf("Could not create pointer to CountryList2Type\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CountryListType) Clone() (*CountryListType) {
return reprint.This(t).(*CountryListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CountryListTypePointer(value interface{}) (*CountryListType, bool) {
switch t := value.(type) {
        case *CountryListType:
                return value.(*CountryListType), true
        case CountryListType:
                v, _ := value.(CountryListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CountryListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCountryListType() *CountryListType {
  if out, ok := CountryListTypePointer(CountryListType{}); !ok {
                log.Fatalf("Could not create pointer to CountryListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CreatedType) Clone() (*CreatedType) {
return reprint.This(t).(*CreatedType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CreatedTypePointer(value interface{}) (*CreatedType, bool) {
switch t := value.(type) {
        case *CreatedType:
                return value.(*CreatedType), true
        case CreatedType:
                v, _ := value.(CreatedType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CreatedType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCreatedType() *CreatedType {
  if out, ok := CreatedTypePointer(CreatedType{}); !ok {
                log.Fatalf("Could not create pointer to CreatedType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CreationUserType) Clone() (*CreationUserType) {
return reprint.This(t).(*CreationUserType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CreationUserTypePointer(value interface{}) (*CreationUserType, bool) {
switch t := value.(type) {
        case *CreationUserType:
                return value.(*CreationUserType), true
        case CreationUserType:
                v, _ := value.(CreationUserType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CreationUserType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCreationUserType() *CreationUserType {
  if out, ok := CreationUserTypePointer(CreationUserType{}); !ok {
                log.Fatalf("Could not create pointer to CreationUserType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *CreatorListType) Clone() (*CreatorListType) {
return reprint.This(t).(*CreatorListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func CreatorListTypePointer(value interface{}) (*CreatorListType, bool) {
switch t := value.(type) {
        case *CreatorListType:
                return value.(*CreatorListType), true
        case CreatorListType:
                v, _ := value.(CreatorListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to CreatorListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewCreatorListType() *CreatorListType {
  if out, ok := CreatorListTypePointer(CreatorListType{}); !ok {
                log.Fatalf("Could not create pointer to CreatorListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DataDomainObligationListType) Clone() (*DataDomainObligationListType) {
return reprint.This(t).(*DataDomainObligationListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DataDomainObligationListTypePointer(value interface{}) (*DataDomainObligationListType, bool) {
switch t := value.(type) {
        case *DataDomainObligationListType:
                return value.(*DataDomainObligationListType), true
        case DataDomainObligationListType:
                v, _ := value.(DataDomainObligationListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DataDomainObligationListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDataDomainObligationListType() *DataDomainObligationListType {
  if out, ok := DataDomainObligationListTypePointer(DataDomainObligationListType{}); !ok {
                log.Fatalf("Could not create pointer to DataDomainObligationListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DataDomainObligationType) Clone() (*DataDomainObligationType) {
return reprint.This(t).(*DataDomainObligationType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DataDomainObligationTypePointer(value interface{}) (*DataDomainObligationType, bool) {
switch t := value.(type) {
        case *DataDomainObligationType:
                return value.(*DataDomainObligationType), true
        case DataDomainObligationType:
                v, _ := value.(DataDomainObligationType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DataDomainObligationType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDataDomainObligationType() *DataDomainObligationType {
  if out, ok := DataDomainObligationTypePointer(DataDomainObligationType{}); !ok {
                log.Fatalf("Could not create pointer to DataDomainObligationType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DebitOrCreditAmountType) Clone() (*DebitOrCreditAmountType) {
return reprint.This(t).(*DebitOrCreditAmountType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DebitOrCreditAmountTypePointer(value interface{}) (*DebitOrCreditAmountType, bool) {
switch t := value.(type) {
        case *DebitOrCreditAmountType:
                return value.(*DebitOrCreditAmountType), true
        case DebitOrCreditAmountType:
                v, _ := value.(DebitOrCreditAmountType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DebitOrCreditAmountType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDebitOrCreditAmountType() *DebitOrCreditAmountType {
  if out, ok := DebitOrCreditAmountTypePointer(DebitOrCreditAmountType{}); !ok {
                log.Fatalf("Could not create pointer to DebitOrCreditAmountType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Debtor) Clone() (*Debtor) {
return reprint.This(t).(*Debtor)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DebtorPointer(value interface{}) (*Debtor, bool) {
switch t := value.(type) {
        case *Debtor:
                return value.(*Debtor), true
        case Debtor:
                v, _ := value.(Debtor)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Debtor\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDebtor() *Debtor {
  if out, ok := DebtorPointer(Debtor{}); !ok {
                log.Fatalf("Could not create pointer to Debtor\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Debtor_BilledEntity) Clone() (*Debtor_BilledEntity) {
return reprint.This(t).(*Debtor_BilledEntity)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func Debtor_BilledEntityPointer(value interface{}) (*Debtor_BilledEntity, bool) {
switch t := value.(type) {
        case *Debtor_BilledEntity:
                return value.(*Debtor_BilledEntity), true
        case Debtor_BilledEntity:
                v, _ := value.(Debtor_BilledEntity)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Debtor_BilledEntity\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDebtor_BilledEntity() *Debtor_BilledEntity {
  if out, ok := Debtor_BilledEntityPointer(Debtor_BilledEntity{}); !ok {
                log.Fatalf("Could not create pointer to Debtor_BilledEntity\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Debtors) Clone() (*Debtors) {
return reprint.This(t).(*Debtors)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DebtorsPointer(value interface{}) (*Debtors, bool) {
switch t := value.(type) {
        case *Debtors:
                return value.(*Debtors), true
        case Debtors:
                v, _ := value.(Debtors)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Debtors\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DemographicsType) Clone() (*DemographicsType) {
return reprint.This(t).(*DemographicsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DemographicsTypePointer(value interface{}) (*DemographicsType, bool) {
switch t := value.(type) {
        case *DemographicsType:
                return value.(*DemographicsType), true
        case DemographicsType:
                v, _ := value.(DemographicsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DemographicsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDemographicsType() *DemographicsType {
  if out, ok := DemographicsTypePointer(DemographicsType{}); !ok {
                log.Fatalf("Could not create pointer to DemographicsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DepartureSchoolType) Clone() (*DepartureSchoolType) {
return reprint.This(t).(*DepartureSchoolType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DepartureSchoolTypePointer(value interface{}) (*DepartureSchoolType, bool) {
switch t := value.(type) {
        case *DepartureSchoolType:
                return value.(*DepartureSchoolType), true
        case DepartureSchoolType:
                v, _ := value.(DepartureSchoolType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DepartureSchoolType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDepartureSchoolType() *DepartureSchoolType {
  if out, ok := DepartureSchoolTypePointer(DepartureSchoolType{}); !ok {
                log.Fatalf("Could not create pointer to DepartureSchoolType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DetentionContainerType) Clone() (*DetentionContainerType) {
return reprint.This(t).(*DetentionContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DetentionContainerTypePointer(value interface{}) (*DetentionContainerType, bool) {
switch t := value.(type) {
        case *DetentionContainerType:
                return value.(*DetentionContainerType), true
        case DetentionContainerType:
                v, _ := value.(DetentionContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DetentionContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDetentionContainerType() *DetentionContainerType {
  if out, ok := DetentionContainerTypePointer(DetentionContainerType{}); !ok {
                log.Fatalf("Could not create pointer to DetentionContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DisabilityCategoryListType) Clone() (*DisabilityCategoryListType) {
return reprint.This(t).(*DisabilityCategoryListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DisabilityCategoryListTypePointer(value interface{}) (*DisabilityCategoryListType, bool) {
switch t := value.(type) {
        case *DisabilityCategoryListType:
                return value.(*DisabilityCategoryListType), true
        case DisabilityCategoryListType:
                v, _ := value.(DisabilityCategoryListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DisabilityCategoryListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDisabilityCategoryListType() *DisabilityCategoryListType {
  if out, ok := DisabilityCategoryListTypePointer(DisabilityCategoryListType{}); !ok {
                log.Fatalf("Could not create pointer to DisabilityCategoryListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DoNotShareWithListType) Clone() (*DoNotShareWithListType) {
return reprint.This(t).(*DoNotShareWithListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DoNotShareWithListTypePointer(value interface{}) (*DoNotShareWithListType, bool) {
switch t := value.(type) {
        case *DoNotShareWithListType:
                return value.(*DoNotShareWithListType), true
        case DoNotShareWithListType:
                v, _ := value.(DoNotShareWithListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DoNotShareWithListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDoNotShareWithListType() *DoNotShareWithListType {
  if out, ok := DoNotShareWithListTypePointer(DoNotShareWithListType{}); !ok {
                log.Fatalf("Could not create pointer to DoNotShareWithListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DoNotShareWithType) Clone() (*DoNotShareWithType) {
return reprint.This(t).(*DoNotShareWithType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DoNotShareWithTypePointer(value interface{}) (*DoNotShareWithType, bool) {
switch t := value.(type) {
        case *DoNotShareWithType:
                return value.(*DoNotShareWithType), true
        case DoNotShareWithType:
                v, _ := value.(DoNotShareWithType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DoNotShareWithType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDoNotShareWithType() *DoNotShareWithType {
  if out, ok := DoNotShareWithTypePointer(DoNotShareWithType{}); !ok {
                log.Fatalf("Could not create pointer to DoNotShareWithType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DomainBandsContainerType) Clone() (*DomainBandsContainerType) {
return reprint.This(t).(*DomainBandsContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DomainBandsContainerTypePointer(value interface{}) (*DomainBandsContainerType, bool) {
switch t := value.(type) {
        case *DomainBandsContainerType:
                return value.(*DomainBandsContainerType), true
        case DomainBandsContainerType:
                v, _ := value.(DomainBandsContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DomainBandsContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDomainBandsContainerType() *DomainBandsContainerType {
  if out, ok := DomainBandsContainerTypePointer(DomainBandsContainerType{}); !ok {
                log.Fatalf("Could not create pointer to DomainBandsContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DomainProficiencyContainerType) Clone() (*DomainProficiencyContainerType) {
return reprint.This(t).(*DomainProficiencyContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DomainProficiencyContainerTypePointer(value interface{}) (*DomainProficiencyContainerType, bool) {
switch t := value.(type) {
        case *DomainProficiencyContainerType:
                return value.(*DomainProficiencyContainerType), true
        case DomainProficiencyContainerType:
                v, _ := value.(DomainProficiencyContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DomainProficiencyContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDomainProficiencyContainerType() *DomainProficiencyContainerType {
  if out, ok := DomainProficiencyContainerTypePointer(DomainProficiencyContainerType{}); !ok {
                log.Fatalf("Could not create pointer to DomainProficiencyContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DomainScoreSDTNType) Clone() (*DomainScoreSDTNType) {
return reprint.This(t).(*DomainScoreSDTNType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DomainScoreSDTNTypePointer(value interface{}) (*DomainScoreSDTNType, bool) {
switch t := value.(type) {
        case *DomainScoreSDTNType:
                return value.(*DomainScoreSDTNType), true
        case DomainScoreSDTNType:
                v, _ := value.(DomainScoreSDTNType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DomainScoreSDTNType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDomainScoreSDTNType() *DomainScoreSDTNType {
  if out, ok := DomainScoreSDTNTypePointer(DomainScoreSDTNType{}); !ok {
                log.Fatalf("Could not create pointer to DomainScoreSDTNType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DomainScoreType) Clone() (*DomainScoreType) {
return reprint.This(t).(*DomainScoreType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DomainScoreTypePointer(value interface{}) (*DomainScoreType, bool) {
switch t := value.(type) {
        case *DomainScoreType:
                return value.(*DomainScoreType), true
        case DomainScoreType:
                v, _ := value.(DomainScoreType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DomainScoreType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDomainScoreType() *DomainScoreType {
  if out, ok := DomainScoreTypePointer(DomainScoreType{}); !ok {
                log.Fatalf("Could not create pointer to DomainScoreType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DurationType) Clone() (*DurationType) {
return reprint.This(t).(*DurationType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DurationTypePointer(value interface{}) (*DurationType, bool) {
switch t := value.(type) {
        case *DurationType:
                return value.(*DurationType), true
        case DurationType:
                v, _ := value.(DurationType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DurationType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDurationType() *DurationType {
  if out, ok := DurationTypePointer(DurationType{}); !ok {
                log.Fatalf("Could not create pointer to DurationType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *DwellingArrangementType) Clone() (*DwellingArrangementType) {
return reprint.This(t).(*DwellingArrangementType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func DwellingArrangementTypePointer(value interface{}) (*DwellingArrangementType, bool) {
switch t := value.(type) {
        case *DwellingArrangementType:
                return value.(*DwellingArrangementType), true
        case DwellingArrangementType:
                v, _ := value.(DwellingArrangementType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to DwellingArrangementType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewDwellingArrangementType() *DwellingArrangementType {
  if out, ok := DwellingArrangementTypePointer(DwellingArrangementType{}); !ok {
                log.Fatalf("Could not create pointer to DwellingArrangementType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EducationalAssessmentListType) Clone() (*EducationalAssessmentListType) {
return reprint.This(t).(*EducationalAssessmentListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EducationalAssessmentListTypePointer(value interface{}) (*EducationalAssessmentListType, bool) {
switch t := value.(type) {
        case *EducationalAssessmentListType:
                return value.(*EducationalAssessmentListType), true
        case EducationalAssessmentListType:
                v, _ := value.(EducationalAssessmentListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EducationalAssessmentListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEducationalAssessmentListType() *EducationalAssessmentListType {
  if out, ok := EducationalAssessmentListTypePointer(EducationalAssessmentListType{}); !ok {
                log.Fatalf("Could not create pointer to EducationalAssessmentListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EducationalAssessmentType) Clone() (*EducationalAssessmentType) {
return reprint.This(t).(*EducationalAssessmentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EducationalAssessmentTypePointer(value interface{}) (*EducationalAssessmentType, bool) {
switch t := value.(type) {
        case *EducationalAssessmentType:
                return value.(*EducationalAssessmentType), true
        case EducationalAssessmentType:
                v, _ := value.(EducationalAssessmentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EducationalAssessmentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEducationalAssessmentType() *EducationalAssessmentType {
  if out, ok := EducationalAssessmentTypePointer(EducationalAssessmentType{}); !ok {
                log.Fatalf("Could not create pointer to EducationalAssessmentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ElectronicIdListType) Clone() (*ElectronicIdListType) {
return reprint.This(t).(*ElectronicIdListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ElectronicIdListTypePointer(value interface{}) (*ElectronicIdListType, bool) {
switch t := value.(type) {
        case *ElectronicIdListType:
                return value.(*ElectronicIdListType), true
        case ElectronicIdListType:
                v, _ := value.(ElectronicIdListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ElectronicIdListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewElectronicIdListType() *ElectronicIdListType {
  if out, ok := ElectronicIdListTypePointer(ElectronicIdListType{}); !ok {
                log.Fatalf("Could not create pointer to ElectronicIdListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ElectronicIdType) Clone() (*ElectronicIdType) {
return reprint.This(t).(*ElectronicIdType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ElectronicIdTypePointer(value interface{}) (*ElectronicIdType, bool) {
switch t := value.(type) {
        case *ElectronicIdType:
                return value.(*ElectronicIdType), true
        case ElectronicIdType:
                v, _ := value.(ElectronicIdType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ElectronicIdType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewElectronicIdType() *ElectronicIdType {
  if out, ok := ElectronicIdTypePointer(ElectronicIdType{}); !ok {
                log.Fatalf("Could not create pointer to ElectronicIdType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EmailListType) Clone() (*EmailListType) {
return reprint.This(t).(*EmailListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EmailListTypePointer(value interface{}) (*EmailListType, bool) {
switch t := value.(type) {
        case *EmailListType:
                return value.(*EmailListType), true
        case EmailListType:
                v, _ := value.(EmailListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EmailListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEmailListType() *EmailListType {
  if out, ok := EmailListTypePointer(EmailListType{}); !ok {
                log.Fatalf("Could not create pointer to EmailListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EmailType) Clone() (*EmailType) {
return reprint.This(t).(*EmailType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EmailTypePointer(value interface{}) (*EmailType, bool) {
switch t := value.(type) {
        case *EmailType:
                return value.(*EmailType), true
        case EmailType:
                v, _ := value.(EmailType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EmailType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEmailType() *EmailType {
  if out, ok := EmailTypePointer(EmailType{}); !ok {
                log.Fatalf("Could not create pointer to EmailType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EnglishProficiencyType) Clone() (*EnglishProficiencyType) {
return reprint.This(t).(*EnglishProficiencyType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EnglishProficiencyTypePointer(value interface{}) (*EnglishProficiencyType, bool) {
switch t := value.(type) {
        case *EnglishProficiencyType:
                return value.(*EnglishProficiencyType), true
        case EnglishProficiencyType:
                v, _ := value.(EnglishProficiencyType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EnglishProficiencyType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEnglishProficiencyType() *EnglishProficiencyType {
  if out, ok := EnglishProficiencyTypePointer(EnglishProficiencyType{}); !ok {
                log.Fatalf("Could not create pointer to EnglishProficiencyType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EntityContactInfoType) Clone() (*EntityContactInfoType) {
return reprint.This(t).(*EntityContactInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EntityContactInfoTypePointer(value interface{}) (*EntityContactInfoType, bool) {
switch t := value.(type) {
        case *EntityContactInfoType:
                return value.(*EntityContactInfoType), true
        case EntityContactInfoType:
                v, _ := value.(EntityContactInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EntityContactInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEntityContactInfoType() *EntityContactInfoType {
  if out, ok := EntityContactInfoTypePointer(EntityContactInfoType{}); !ok {
                log.Fatalf("Could not create pointer to EntityContactInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EquipmentInfo) Clone() (*EquipmentInfo) {
return reprint.This(t).(*EquipmentInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EquipmentInfoPointer(value interface{}) (*EquipmentInfo, bool) {
switch t := value.(type) {
        case *EquipmentInfo:
                return value.(*EquipmentInfo), true
        case EquipmentInfo:
                v, _ := value.(EquipmentInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EquipmentInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEquipmentInfo() *EquipmentInfo {
  if out, ok := EquipmentInfoPointer(EquipmentInfo{}); !ok {
                log.Fatalf("Could not create pointer to EquipmentInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EquipmentInfo_SIF_RefId) Clone() (*EquipmentInfo_SIF_RefId) {
return reprint.This(t).(*EquipmentInfo_SIF_RefId)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EquipmentInfo_SIF_RefIdPointer(value interface{}) (*EquipmentInfo_SIF_RefId, bool) {
switch t := value.(type) {
        case *EquipmentInfo_SIF_RefId:
                return value.(*EquipmentInfo_SIF_RefId), true
        case EquipmentInfo_SIF_RefId:
                v, _ := value.(EquipmentInfo_SIF_RefId)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EquipmentInfo_SIF_RefId\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEquipmentInfo_SIF_RefId() *EquipmentInfo_SIF_RefId {
  if out, ok := EquipmentInfo_SIF_RefIdPointer(EquipmentInfo_SIF_RefId{}); !ok {
                log.Fatalf("Could not create pointer to EquipmentInfo_SIF_RefId\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EquipmentInfos) Clone() (*EquipmentInfos) {
return reprint.This(t).(*EquipmentInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EquipmentInfosPointer(value interface{}) (*EquipmentInfos, bool) {
switch t := value.(type) {
        case *EquipmentInfos:
                return value.(*EquipmentInfos), true
        case EquipmentInfos:
                v, _ := value.(EquipmentInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EquipmentInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EssentialMaterialsType) Clone() (*EssentialMaterialsType) {
return reprint.This(t).(*EssentialMaterialsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EssentialMaterialsTypePointer(value interface{}) (*EssentialMaterialsType, bool) {
switch t := value.(type) {
        case *EssentialMaterialsType:
                return value.(*EssentialMaterialsType), true
        case EssentialMaterialsType:
                v, _ := value.(EssentialMaterialsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EssentialMaterialsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEssentialMaterialsType() *EssentialMaterialsType {
  if out, ok := EssentialMaterialsTypePointer(EssentialMaterialsType{}); !ok {
                log.Fatalf("Could not create pointer to EssentialMaterialsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EvaluationType) Clone() (*EvaluationType) {
return reprint.This(t).(*EvaluationType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EvaluationTypePointer(value interface{}) (*EvaluationType, bool) {
switch t := value.(type) {
        case *EvaluationType:
                return value.(*EvaluationType), true
        case EvaluationType:
                v, _ := value.(EvaluationType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EvaluationType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEvaluationType() *EvaluationType {
  if out, ok := EvaluationTypePointer(EvaluationType{}); !ok {
                log.Fatalf("Could not create pointer to EvaluationType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *EvaluationsType) Clone() (*EvaluationsType) {
return reprint.This(t).(*EvaluationsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func EvaluationsTypePointer(value interface{}) (*EvaluationsType, bool) {
switch t := value.(type) {
        case *EvaluationsType:
                return value.(*EvaluationsType), true
        case EvaluationsType:
                v, _ := value.(EvaluationsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to EvaluationsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewEvaluationsType() *EvaluationsType {
  if out, ok := EvaluationsTypePointer(EvaluationsType{}); !ok {
                log.Fatalf("Could not create pointer to EvaluationsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ExclusionRuleType) Clone() (*ExclusionRuleType) {
return reprint.This(t).(*ExclusionRuleType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ExclusionRuleTypePointer(value interface{}) (*ExclusionRuleType, bool) {
switch t := value.(type) {
        case *ExclusionRuleType:
                return value.(*ExclusionRuleType), true
        case ExclusionRuleType:
                v, _ := value.(ExclusionRuleType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ExclusionRuleType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewExclusionRuleType() *ExclusionRuleType {
  if out, ok := ExclusionRuleTypePointer(ExclusionRuleType{}); !ok {
                log.Fatalf("Could not create pointer to ExclusionRuleType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ExclusionRulesType) Clone() (*ExclusionRulesType) {
return reprint.This(t).(*ExclusionRulesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ExclusionRulesTypePointer(value interface{}) (*ExclusionRulesType, bool) {
switch t := value.(type) {
        case *ExclusionRulesType:
                return value.(*ExclusionRulesType), true
        case ExclusionRulesType:
                v, _ := value.(ExclusionRulesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ExclusionRulesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewExclusionRulesType() *ExclusionRulesType {
  if out, ok := ExclusionRulesTypePointer(ExclusionRulesType{}); !ok {
                log.Fatalf("Could not create pointer to ExclusionRulesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ExpenseAccountType) Clone() (*ExpenseAccountType) {
return reprint.This(t).(*ExpenseAccountType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ExpenseAccountTypePointer(value interface{}) (*ExpenseAccountType, bool) {
switch t := value.(type) {
        case *ExpenseAccountType:
                return value.(*ExpenseAccountType), true
        case ExpenseAccountType:
                v, _ := value.(ExpenseAccountType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ExpenseAccountType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewExpenseAccountType() *ExpenseAccountType {
  if out, ok := ExpenseAccountTypePointer(ExpenseAccountType{}); !ok {
                log.Fatalf("Could not create pointer to ExpenseAccountType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ExpenseAccountsType) Clone() (*ExpenseAccountsType) {
return reprint.This(t).(*ExpenseAccountsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ExpenseAccountsTypePointer(value interface{}) (*ExpenseAccountsType, bool) {
switch t := value.(type) {
        case *ExpenseAccountsType:
                return value.(*ExpenseAccountsType), true
        case ExpenseAccountsType:
                v, _ := value.(ExpenseAccountsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ExpenseAccountsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewExpenseAccountsType() *ExpenseAccountsType {
  if out, ok := ExpenseAccountsTypePointer(ExpenseAccountsType{}); !ok {
                log.Fatalf("Could not create pointer to ExpenseAccountsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FQContextualQuestionListType) Clone() (*FQContextualQuestionListType) {
return reprint.This(t).(*FQContextualQuestionListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FQContextualQuestionListTypePointer(value interface{}) (*FQContextualQuestionListType, bool) {
switch t := value.(type) {
        case *FQContextualQuestionListType:
                return value.(*FQContextualQuestionListType), true
        case FQContextualQuestionListType:
                v, _ := value.(FQContextualQuestionListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FQContextualQuestionListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFQContextualQuestionListType() *FQContextualQuestionListType {
  if out, ok := FQContextualQuestionListTypePointer(FQContextualQuestionListType{}); !ok {
                log.Fatalf("Could not create pointer to FQContextualQuestionListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FQContextualQuestionType) Clone() (*FQContextualQuestionType) {
return reprint.This(t).(*FQContextualQuestionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FQContextualQuestionTypePointer(value interface{}) (*FQContextualQuestionType, bool) {
switch t := value.(type) {
        case *FQContextualQuestionType:
                return value.(*FQContextualQuestionType), true
        case FQContextualQuestionType:
                v, _ := value.(FQContextualQuestionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FQContextualQuestionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFQContextualQuestionType() *FQContextualQuestionType {
  if out, ok := FQContextualQuestionTypePointer(FQContextualQuestionType{}); !ok {
                log.Fatalf("Could not create pointer to FQContextualQuestionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FQItemListType) Clone() (*FQItemListType) {
return reprint.This(t).(*FQItemListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FQItemListTypePointer(value interface{}) (*FQItemListType, bool) {
switch t := value.(type) {
        case *FQItemListType:
                return value.(*FQItemListType), true
        case FQItemListType:
                v, _ := value.(FQItemListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FQItemListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFQItemListType() *FQItemListType {
  if out, ok := FQItemListTypePointer(FQItemListType{}); !ok {
                log.Fatalf("Could not create pointer to FQItemListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FQItemType) Clone() (*FQItemType) {
return reprint.This(t).(*FQItemType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FQItemTypePointer(value interface{}) (*FQItemType, bool) {
switch t := value.(type) {
        case *FQItemType:
                return value.(*FQItemType), true
        case FQItemType:
                v, _ := value.(FQItemType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FQItemType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFQItemType() *FQItemType {
  if out, ok := FQItemTypePointer(FQItemType{}); !ok {
                log.Fatalf("Could not create pointer to FQItemType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FQReportingListType) Clone() (*FQReportingListType) {
return reprint.This(t).(*FQReportingListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FQReportingListTypePointer(value interface{}) (*FQReportingListType, bool) {
switch t := value.(type) {
        case *FQReportingListType:
                return value.(*FQReportingListType), true
        case FQReportingListType:
                v, _ := value.(FQReportingListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FQReportingListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFQReportingListType() *FQReportingListType {
  if out, ok := FQReportingListTypePointer(FQReportingListType{}); !ok {
                log.Fatalf("Could not create pointer to FQReportingListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FQReportingType) Clone() (*FQReportingType) {
return reprint.This(t).(*FQReportingType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FQReportingTypePointer(value interface{}) (*FQReportingType, bool) {
switch t := value.(type) {
        case *FQReportingType:
                return value.(*FQReportingType), true
        case FQReportingType:
                v, _ := value.(FQReportingType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FQReportingType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFQReportingType() *FQReportingType {
  if out, ok := FQReportingTypePointer(FQReportingType{}); !ok {
                log.Fatalf("Could not create pointer to FQReportingType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FinancialAccount) Clone() (*FinancialAccount) {
return reprint.This(t).(*FinancialAccount)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FinancialAccountPointer(value interface{}) (*FinancialAccount, bool) {
switch t := value.(type) {
        case *FinancialAccount:
                return value.(*FinancialAccount), true
        case FinancialAccount:
                v, _ := value.(FinancialAccount)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FinancialAccount\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFinancialAccount() *FinancialAccount {
  if out, ok := FinancialAccountPointer(FinancialAccount{}); !ok {
                log.Fatalf("Could not create pointer to FinancialAccount\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FinancialAccountRefIdListType) Clone() (*FinancialAccountRefIdListType) {
return reprint.This(t).(*FinancialAccountRefIdListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FinancialAccountRefIdListTypePointer(value interface{}) (*FinancialAccountRefIdListType, bool) {
switch t := value.(type) {
        case *FinancialAccountRefIdListType:
                return value.(*FinancialAccountRefIdListType), true
        case FinancialAccountRefIdListType:
                v, _ := value.(FinancialAccountRefIdListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FinancialAccountRefIdListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFinancialAccountRefIdListType() *FinancialAccountRefIdListType {
  if out, ok := FinancialAccountRefIdListTypePointer(FinancialAccountRefIdListType{}); !ok {
                log.Fatalf("Could not create pointer to FinancialAccountRefIdListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FinancialAccounts) Clone() (*FinancialAccounts) {
return reprint.This(t).(*FinancialAccounts)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FinancialAccountsPointer(value interface{}) (*FinancialAccounts, bool) {
switch t := value.(type) {
        case *FinancialAccounts:
                return value.(*FinancialAccounts), true
        case FinancialAccounts:
                v, _ := value.(FinancialAccounts)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FinancialAccounts\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FinancialQuestionnaireCollection) Clone() (*FinancialQuestionnaireCollection) {
return reprint.This(t).(*FinancialQuestionnaireCollection)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FinancialQuestionnaireCollectionPointer(value interface{}) (*FinancialQuestionnaireCollection, bool) {
switch t := value.(type) {
        case *FinancialQuestionnaireCollection:
                return value.(*FinancialQuestionnaireCollection), true
        case FinancialQuestionnaireCollection:
                v, _ := value.(FinancialQuestionnaireCollection)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FinancialQuestionnaireCollection\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFinancialQuestionnaireCollection() *FinancialQuestionnaireCollection {
  if out, ok := FinancialQuestionnaireCollectionPointer(FinancialQuestionnaireCollection{}); !ok {
                log.Fatalf("Could not create pointer to FinancialQuestionnaireCollection\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FinancialQuestionnaireCollections) Clone() (*FinancialQuestionnaireCollections) {
return reprint.This(t).(*FinancialQuestionnaireCollections)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FinancialQuestionnaireCollectionsPointer(value interface{}) (*FinancialQuestionnaireCollections, bool) {
switch t := value.(type) {
        case *FinancialQuestionnaireCollections:
                return value.(*FinancialQuestionnaireCollections), true
        case FinancialQuestionnaireCollections:
                v, _ := value.(FinancialQuestionnaireCollections)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FinancialQuestionnaireCollections\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FineInfoListType) Clone() (*FineInfoListType) {
return reprint.This(t).(*FineInfoListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FineInfoListTypePointer(value interface{}) (*FineInfoListType, bool) {
switch t := value.(type) {
        case *FineInfoListType:
                return value.(*FineInfoListType), true
        case FineInfoListType:
                v, _ := value.(FineInfoListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FineInfoListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFineInfoListType() *FineInfoListType {
  if out, ok := FineInfoListTypePointer(FineInfoListType{}); !ok {
                log.Fatalf("Could not create pointer to FineInfoListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FineInfoType) Clone() (*FineInfoType) {
return reprint.This(t).(*FineInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FineInfoTypePointer(value interface{}) (*FineInfoType, bool) {
switch t := value.(type) {
        case *FineInfoType:
                return value.(*FineInfoType), true
        case FineInfoType:
                v, _ := value.(FineInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FineInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFineInfoType() *FineInfoType {
  if out, ok := FineInfoTypePointer(FineInfoType{}); !ok {
                log.Fatalf("Could not create pointer to FineInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FollowUpActionListType) Clone() (*FollowUpActionListType) {
return reprint.This(t).(*FollowUpActionListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FollowUpActionListTypePointer(value interface{}) (*FollowUpActionListType, bool) {
switch t := value.(type) {
        case *FollowUpActionListType:
                return value.(*FollowUpActionListType), true
        case FollowUpActionListType:
                v, _ := value.(FollowUpActionListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FollowUpActionListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFollowUpActionListType() *FollowUpActionListType {
  if out, ok := FollowUpActionListTypePointer(FollowUpActionListType{}); !ok {
                log.Fatalf("Could not create pointer to FollowUpActionListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *FollowUpActionType) Clone() (*FollowUpActionType) {
return reprint.This(t).(*FollowUpActionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func FollowUpActionTypePointer(value interface{}) (*FollowUpActionType, bool) {
switch t := value.(type) {
        case *FollowUpActionType:
                return value.(*FollowUpActionType), true
        case FollowUpActionType:
                v, _ := value.(FollowUpActionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to FollowUpActionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewFollowUpActionType() *FollowUpActionType {
  if out, ok := FollowUpActionTypePointer(FollowUpActionType{}); !ok {
                log.Fatalf("Could not create pointer to FollowUpActionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *GenericRubricType) Clone() (*GenericRubricType) {
return reprint.This(t).(*GenericRubricType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func GenericRubricTypePointer(value interface{}) (*GenericRubricType, bool) {
switch t := value.(type) {
        case *GenericRubricType:
                return value.(*GenericRubricType), true
        case GenericRubricType:
                v, _ := value.(GenericRubricType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to GenericRubricType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewGenericRubricType() *GenericRubricType {
  if out, ok := GenericRubricTypePointer(GenericRubricType{}); !ok {
                log.Fatalf("Could not create pointer to GenericRubricType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *GradeType) Clone() (*GradeType) {
return reprint.This(t).(*GradeType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func GradeTypePointer(value interface{}) (*GradeType, bool) {
switch t := value.(type) {
        case *GradeType:
                return value.(*GradeType), true
        case GradeType:
                v, _ := value.(GradeType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to GradeType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewGradeType() *GradeType {
  if out, ok := GradeTypePointer(GradeType{}); !ok {
                log.Fatalf("Could not create pointer to GradeType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *GradingAssignment) Clone() (*GradingAssignment) {
return reprint.This(t).(*GradingAssignment)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func GradingAssignmentPointer(value interface{}) (*GradingAssignment, bool) {
switch t := value.(type) {
        case *GradingAssignment:
                return value.(*GradingAssignment), true
        case GradingAssignment:
                v, _ := value.(GradingAssignment)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to GradingAssignment\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewGradingAssignment() *GradingAssignment {
  if out, ok := GradingAssignmentPointer(GradingAssignment{}); !ok {
                log.Fatalf("Could not create pointer to GradingAssignment\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *GradingAssignmentScore) Clone() (*GradingAssignmentScore) {
return reprint.This(t).(*GradingAssignmentScore)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func GradingAssignmentScorePointer(value interface{}) (*GradingAssignmentScore, bool) {
switch t := value.(type) {
        case *GradingAssignmentScore:
                return value.(*GradingAssignmentScore), true
        case GradingAssignmentScore:
                v, _ := value.(GradingAssignmentScore)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to GradingAssignmentScore\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewGradingAssignmentScore() *GradingAssignmentScore {
  if out, ok := GradingAssignmentScorePointer(GradingAssignmentScore{}); !ok {
                log.Fatalf("Could not create pointer to GradingAssignmentScore\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *GradingAssignmentScores) Clone() (*GradingAssignmentScores) {
return reprint.This(t).(*GradingAssignmentScores)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func GradingAssignmentScoresPointer(value interface{}) (*GradingAssignmentScores, bool) {
switch t := value.(type) {
        case *GradingAssignmentScores:
                return value.(*GradingAssignmentScores), true
        case GradingAssignmentScores:
                v, _ := value.(GradingAssignmentScores)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to GradingAssignmentScores\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *GradingAssignments) Clone() (*GradingAssignments) {
return reprint.This(t).(*GradingAssignments)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func GradingAssignmentsPointer(value interface{}) (*GradingAssignments, bool) {
switch t := value.(type) {
        case *GradingAssignments:
                return value.(*GradingAssignments), true
        case GradingAssignments:
                v, _ := value.(GradingAssignments)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to GradingAssignments\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *GradingScoreListType) Clone() (*GradingScoreListType) {
return reprint.This(t).(*GradingScoreListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func GradingScoreListTypePointer(value interface{}) (*GradingScoreListType, bool) {
switch t := value.(type) {
        case *GradingScoreListType:
                return value.(*GradingScoreListType), true
        case GradingScoreListType:
                v, _ := value.(GradingScoreListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to GradingScoreListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewGradingScoreListType() *GradingScoreListType {
  if out, ok := GradingScoreListTypePointer(GradingScoreListType{}); !ok {
                log.Fatalf("Could not create pointer to GradingScoreListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *GridLocationType) Clone() (*GridLocationType) {
return reprint.This(t).(*GridLocationType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func GridLocationTypePointer(value interface{}) (*GridLocationType, bool) {
switch t := value.(type) {
        case *GridLocationType:
                return value.(*GridLocationType), true
        case GridLocationType:
                v, _ := value.(GridLocationType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to GridLocationType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewGridLocationType() *GridLocationType {
  if out, ok := GridLocationTypePointer(GridLocationType{}); !ok {
                log.Fatalf("Could not create pointer to GridLocationType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *HoldInfoListType) Clone() (*HoldInfoListType) {
return reprint.This(t).(*HoldInfoListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func HoldInfoListTypePointer(value interface{}) (*HoldInfoListType, bool) {
switch t := value.(type) {
        case *HoldInfoListType:
                return value.(*HoldInfoListType), true
        case HoldInfoListType:
                v, _ := value.(HoldInfoListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to HoldInfoListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewHoldInfoListType() *HoldInfoListType {
  if out, ok := HoldInfoListTypePointer(HoldInfoListType{}); !ok {
                log.Fatalf("Could not create pointer to HoldInfoListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *HoldInfoType) Clone() (*HoldInfoType) {
return reprint.This(t).(*HoldInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func HoldInfoTypePointer(value interface{}) (*HoldInfoType, bool) {
switch t := value.(type) {
        case *HoldInfoType:
                return value.(*HoldInfoType), true
        case HoldInfoType:
                v, _ := value.(HoldInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to HoldInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewHoldInfoType() *HoldInfoType {
  if out, ok := HoldInfoTypePointer(HoldInfoType{}); !ok {
                log.Fatalf("Could not create pointer to HoldInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *HomeroomType) Clone() (*HomeroomType) {
return reprint.This(t).(*HomeroomType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func HomeroomTypePointer(value interface{}) (*HomeroomType, bool) {
switch t := value.(type) {
        case *HomeroomType:
                return value.(*HomeroomType), true
        case HomeroomType:
                v, _ := value.(HomeroomType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to HomeroomType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewHomeroomType() *HomeroomType {
  if out, ok := HomeroomTypePointer(HomeroomType{}); !ok {
                log.Fatalf("Could not create pointer to HomeroomType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *HouseholdContactInfoListType) Clone() (*HouseholdContactInfoListType) {
return reprint.This(t).(*HouseholdContactInfoListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func HouseholdContactInfoListTypePointer(value interface{}) (*HouseholdContactInfoListType, bool) {
switch t := value.(type) {
        case *HouseholdContactInfoListType:
                return value.(*HouseholdContactInfoListType), true
        case HouseholdContactInfoListType:
                v, _ := value.(HouseholdContactInfoListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to HouseholdContactInfoListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewHouseholdContactInfoListType() *HouseholdContactInfoListType {
  if out, ok := HouseholdContactInfoListTypePointer(HouseholdContactInfoListType{}); !ok {
                log.Fatalf("Could not create pointer to HouseholdContactInfoListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *HouseholdContactInfoType) Clone() (*HouseholdContactInfoType) {
return reprint.This(t).(*HouseholdContactInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func HouseholdContactInfoTypePointer(value interface{}) (*HouseholdContactInfoType, bool) {
switch t := value.(type) {
        case *HouseholdContactInfoType:
                return value.(*HouseholdContactInfoType), true
        case HouseholdContactInfoType:
                v, _ := value.(HouseholdContactInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to HouseholdContactInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewHouseholdContactInfoType() *HouseholdContactInfoType {
  if out, ok := HouseholdContactInfoTypePointer(HouseholdContactInfoType{}); !ok {
                log.Fatalf("Could not create pointer to HouseholdContactInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *HouseholdListType) Clone() (*HouseholdListType) {
return reprint.This(t).(*HouseholdListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func HouseholdListTypePointer(value interface{}) (*HouseholdListType, bool) {
switch t := value.(type) {
        case *HouseholdListType:
                return value.(*HouseholdListType), true
        case HouseholdListType:
                v, _ := value.(HouseholdListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to HouseholdListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewHouseholdListType() *HouseholdListType {
  if out, ok := HouseholdListTypePointer(HouseholdListType{}); !ok {
                log.Fatalf("Could not create pointer to HouseholdListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Identity) Clone() (*Identity) {
return reprint.This(t).(*Identity)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func IdentityPointer(value interface{}) (*Identity, bool) {
switch t := value.(type) {
        case *Identity:
                return value.(*Identity), true
        case Identity:
                v, _ := value.(Identity)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Identity\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewIdentity() *Identity {
  if out, ok := IdentityPointer(Identity{}); !ok {
                log.Fatalf("Could not create pointer to Identity\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *IdentityAssertionType) Clone() (*IdentityAssertionType) {
return reprint.This(t).(*IdentityAssertionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func IdentityAssertionTypePointer(value interface{}) (*IdentityAssertionType, bool) {
switch t := value.(type) {
        case *IdentityAssertionType:
                return value.(*IdentityAssertionType), true
        case IdentityAssertionType:
                v, _ := value.(IdentityAssertionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to IdentityAssertionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewIdentityAssertionType() *IdentityAssertionType {
  if out, ok := IdentityAssertionTypePointer(IdentityAssertionType{}); !ok {
                log.Fatalf("Could not create pointer to IdentityAssertionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *IdentityAssertionsType) Clone() (*IdentityAssertionsType) {
return reprint.This(t).(*IdentityAssertionsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func IdentityAssertionsTypePointer(value interface{}) (*IdentityAssertionsType, bool) {
switch t := value.(type) {
        case *IdentityAssertionsType:
                return value.(*IdentityAssertionsType), true
        case IdentityAssertionsType:
                v, _ := value.(IdentityAssertionsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to IdentityAssertionsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewIdentityAssertionsType() *IdentityAssertionsType {
  if out, ok := IdentityAssertionsTypePointer(IdentityAssertionsType{}); !ok {
                log.Fatalf("Could not create pointer to IdentityAssertionsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Identity_SIF_RefId) Clone() (*Identity_SIF_RefId) {
return reprint.This(t).(*Identity_SIF_RefId)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func Identity_SIF_RefIdPointer(value interface{}) (*Identity_SIF_RefId, bool) {
switch t := value.(type) {
        case *Identity_SIF_RefId:
                return value.(*Identity_SIF_RefId), true
        case Identity_SIF_RefId:
                v, _ := value.(Identity_SIF_RefId)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Identity_SIF_RefId\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewIdentity_SIF_RefId() *Identity_SIF_RefId {
  if out, ok := Identity_SIF_RefIdPointer(Identity_SIF_RefId{}); !ok {
                log.Fatalf("Could not create pointer to Identity_SIF_RefId\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Identitys) Clone() (*Identitys) {
return reprint.This(t).(*Identitys)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func IdentitysPointer(value interface{}) (*Identitys, bool) {
switch t := value.(type) {
        case *Identitys:
                return value.(*Identitys), true
        case Identitys:
                v, _ := value.(Identitys)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Identitys\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Invoice) Clone() (*Invoice) {
return reprint.This(t).(*Invoice)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func InvoicePointer(value interface{}) (*Invoice, bool) {
switch t := value.(type) {
        case *Invoice:
                return value.(*Invoice), true
        case Invoice:
                v, _ := value.(Invoice)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Invoice\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewInvoice() *Invoice {
  if out, ok := InvoicePointer(Invoice{}); !ok {
                log.Fatalf("Could not create pointer to Invoice\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Invoice_InvoicedEntity) Clone() (*Invoice_InvoicedEntity) {
return reprint.This(t).(*Invoice_InvoicedEntity)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func Invoice_InvoicedEntityPointer(value interface{}) (*Invoice_InvoicedEntity, bool) {
switch t := value.(type) {
        case *Invoice_InvoicedEntity:
                return value.(*Invoice_InvoicedEntity), true
        case Invoice_InvoicedEntity:
                v, _ := value.(Invoice_InvoicedEntity)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Invoice_InvoicedEntity\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewInvoice_InvoicedEntity() *Invoice_InvoicedEntity {
  if out, ok := Invoice_InvoicedEntityPointer(Invoice_InvoicedEntity{}); !ok {
                log.Fatalf("Could not create pointer to Invoice_InvoicedEntity\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Invoices) Clone() (*Invoices) {
return reprint.This(t).(*Invoices)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func InvoicesPointer(value interface{}) (*Invoices, bool) {
switch t := value.(type) {
        case *Invoices:
                return value.(*Invoices), true
        case Invoices:
                v, _ := value.(Invoices)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Invoices\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Journal) Clone() (*Journal) {
return reprint.This(t).(*Journal)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func JournalPointer(value interface{}) (*Journal, bool) {
switch t := value.(type) {
        case *Journal:
                return value.(*Journal), true
        case Journal:
                v, _ := value.(Journal)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Journal\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewJournal() *Journal {
  if out, ok := JournalPointer(Journal{}); !ok {
                log.Fatalf("Could not create pointer to Journal\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *JournalAdjustmentListType) Clone() (*JournalAdjustmentListType) {
return reprint.This(t).(*JournalAdjustmentListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func JournalAdjustmentListTypePointer(value interface{}) (*JournalAdjustmentListType, bool) {
switch t := value.(type) {
        case *JournalAdjustmentListType:
                return value.(*JournalAdjustmentListType), true
        case JournalAdjustmentListType:
                v, _ := value.(JournalAdjustmentListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to JournalAdjustmentListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewJournalAdjustmentListType() *JournalAdjustmentListType {
  if out, ok := JournalAdjustmentListTypePointer(JournalAdjustmentListType{}); !ok {
                log.Fatalf("Could not create pointer to JournalAdjustmentListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *JournalAdjustmentType) Clone() (*JournalAdjustmentType) {
return reprint.This(t).(*JournalAdjustmentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func JournalAdjustmentTypePointer(value interface{}) (*JournalAdjustmentType, bool) {
switch t := value.(type) {
        case *JournalAdjustmentType:
                return value.(*JournalAdjustmentType), true
        case JournalAdjustmentType:
                v, _ := value.(JournalAdjustmentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to JournalAdjustmentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewJournalAdjustmentType() *JournalAdjustmentType {
  if out, ok := JournalAdjustmentTypePointer(JournalAdjustmentType{}); !ok {
                log.Fatalf("Could not create pointer to JournalAdjustmentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Journal_OriginatingTransactionRefId) Clone() (*Journal_OriginatingTransactionRefId) {
return reprint.This(t).(*Journal_OriginatingTransactionRefId)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func Journal_OriginatingTransactionRefIdPointer(value interface{}) (*Journal_OriginatingTransactionRefId, bool) {
switch t := value.(type) {
        case *Journal_OriginatingTransactionRefId:
                return value.(*Journal_OriginatingTransactionRefId), true
        case Journal_OriginatingTransactionRefId:
                v, _ := value.(Journal_OriginatingTransactionRefId)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Journal_OriginatingTransactionRefId\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewJournal_OriginatingTransactionRefId() *Journal_OriginatingTransactionRefId {
  if out, ok := Journal_OriginatingTransactionRefIdPointer(Journal_OriginatingTransactionRefId{}); !ok {
                log.Fatalf("Could not create pointer to Journal_OriginatingTransactionRefId\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *Journals) Clone() (*Journals) {
return reprint.This(t).(*Journals)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func JournalsPointer(value interface{}) (*Journals, bool) {
switch t := value.(type) {
        case *Journals:
                return value.(*Journals), true
        case Journals:
                v, _ := value.(Journals)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Journals\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LEAContactListType) Clone() (*LEAContactListType) {
return reprint.This(t).(*LEAContactListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LEAContactListTypePointer(value interface{}) (*LEAContactListType, bool) {
switch t := value.(type) {
        case *LEAContactListType:
                return value.(*LEAContactListType), true
        case LEAContactListType:
                v, _ := value.(LEAContactListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LEAContactListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLEAContactListType() *LEAContactListType {
  if out, ok := LEAContactListTypePointer(LEAContactListType{}); !ok {
                log.Fatalf("Could not create pointer to LEAContactListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LEAContactType) Clone() (*LEAContactType) {
return reprint.This(t).(*LEAContactType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LEAContactTypePointer(value interface{}) (*LEAContactType, bool) {
switch t := value.(type) {
        case *LEAContactType:
                return value.(*LEAContactType), true
        case LEAContactType:
                v, _ := value.(LEAContactType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LEAContactType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLEAContactType() *LEAContactType {
  if out, ok := LEAContactTypePointer(LEAContactType{}); !ok {
                log.Fatalf("Could not create pointer to LEAContactType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LEAInfo) Clone() (*LEAInfo) {
return reprint.This(t).(*LEAInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LEAInfoPointer(value interface{}) (*LEAInfo, bool) {
switch t := value.(type) {
        case *LEAInfo:
                return value.(*LEAInfo), true
        case LEAInfo:
                v, _ := value.(LEAInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LEAInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLEAInfo() *LEAInfo {
  if out, ok := LEAInfoPointer(LEAInfo{}); !ok {
                log.Fatalf("Could not create pointer to LEAInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LEAInfos) Clone() (*LEAInfos) {
return reprint.This(t).(*LEAInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LEAInfosPointer(value interface{}) (*LEAInfos, bool) {
switch t := value.(type) {
        case *LEAInfos:
                return value.(*LEAInfos), true
        case LEAInfos:
                v, _ := value.(LEAInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LEAInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LResourcesType) Clone() (*LResourcesType) {
return reprint.This(t).(*LResourcesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LResourcesTypePointer(value interface{}) (*LResourcesType, bool) {
switch t := value.(type) {
        case *LResourcesType:
                return value.(*LResourcesType), true
        case LResourcesType:
                v, _ := value.(LResourcesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LResourcesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLResourcesType() *LResourcesType {
  if out, ok := LResourcesTypePointer(LResourcesType{}); !ok {
                log.Fatalf("Could not create pointer to LResourcesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LanguageBaseType) Clone() (*LanguageBaseType) {
return reprint.This(t).(*LanguageBaseType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LanguageBaseTypePointer(value interface{}) (*LanguageBaseType, bool) {
switch t := value.(type) {
        case *LanguageBaseType:
                return value.(*LanguageBaseType), true
        case LanguageBaseType:
                v, _ := value.(LanguageBaseType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LanguageBaseType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLanguageBaseType() *LanguageBaseType {
  if out, ok := LanguageBaseTypePointer(LanguageBaseType{}); !ok {
                log.Fatalf("Could not create pointer to LanguageBaseType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LanguageListType) Clone() (*LanguageListType) {
return reprint.This(t).(*LanguageListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LanguageListTypePointer(value interface{}) (*LanguageListType, bool) {
switch t := value.(type) {
        case *LanguageListType:
                return value.(*LanguageListType), true
        case LanguageListType:
                v, _ := value.(LanguageListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LanguageListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLanguageListType() *LanguageListType {
  if out, ok := LanguageListTypePointer(LanguageListType{}); !ok {
                log.Fatalf("Could not create pointer to LanguageListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LanguageOfInstructionType) Clone() (*LanguageOfInstructionType) {
return reprint.This(t).(*LanguageOfInstructionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LanguageOfInstructionTypePointer(value interface{}) (*LanguageOfInstructionType, bool) {
switch t := value.(type) {
        case *LanguageOfInstructionType:
                return value.(*LanguageOfInstructionType), true
        case LanguageOfInstructionType:
                v, _ := value.(LanguageOfInstructionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LanguageOfInstructionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLanguageOfInstructionType() *LanguageOfInstructionType {
  if out, ok := LanguageOfInstructionTypePointer(LanguageOfInstructionType{}); !ok {
                log.Fatalf("Could not create pointer to LanguageOfInstructionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningObjectivesType) Clone() (*LearningObjectivesType) {
return reprint.This(t).(*LearningObjectivesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningObjectivesTypePointer(value interface{}) (*LearningObjectivesType, bool) {
switch t := value.(type) {
        case *LearningObjectivesType:
                return value.(*LearningObjectivesType), true
        case LearningObjectivesType:
                v, _ := value.(LearningObjectivesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningObjectivesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningObjectivesType() *LearningObjectivesType {
  if out, ok := LearningObjectivesTypePointer(LearningObjectivesType{}); !ok {
                log.Fatalf("Could not create pointer to LearningObjectivesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningResource) Clone() (*LearningResource) {
return reprint.This(t).(*LearningResource)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningResourcePointer(value interface{}) (*LearningResource, bool) {
switch t := value.(type) {
        case *LearningResource:
                return value.(*LearningResource), true
        case LearningResource:
                v, _ := value.(LearningResource)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningResource\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningResource() *LearningResource {
  if out, ok := LearningResourcePointer(LearningResource{}); !ok {
                log.Fatalf("Could not create pointer to LearningResource\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningResourceLocationType) Clone() (*LearningResourceLocationType) {
return reprint.This(t).(*LearningResourceLocationType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningResourceLocationTypePointer(value interface{}) (*LearningResourceLocationType, bool) {
switch t := value.(type) {
        case *LearningResourceLocationType:
                return value.(*LearningResourceLocationType), true
        case LearningResourceLocationType:
                v, _ := value.(LearningResourceLocationType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningResourceLocationType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningResourceLocationType() *LearningResourceLocationType {
  if out, ok := LearningResourceLocationTypePointer(LearningResourceLocationType{}); !ok {
                log.Fatalf("Could not create pointer to LearningResourceLocationType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningResourcePackages) Clone() (*LearningResourcePackages) {
return reprint.This(t).(*LearningResourcePackages)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningResourcePackagesPointer(value interface{}) (*LearningResourcePackages, bool) {
switch t := value.(type) {
        case *LearningResourcePackages:
                return value.(*LearningResourcePackages), true
        case LearningResourcePackages:
                v, _ := value.(LearningResourcePackages)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningResourcePackages\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningResources) Clone() (*LearningResources) {
return reprint.This(t).(*LearningResources)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningResourcesPointer(value interface{}) (*LearningResources, bool) {
switch t := value.(type) {
        case *LearningResources:
                return value.(*LearningResources), true
        case LearningResources:
                v, _ := value.(LearningResources)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningResources\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningResourcesType) Clone() (*LearningResourcesType) {
return reprint.This(t).(*LearningResourcesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningResourcesTypePointer(value interface{}) (*LearningResourcesType, bool) {
switch t := value.(type) {
        case *LearningResourcesType:
                return value.(*LearningResourcesType), true
        case LearningResourcesType:
                v, _ := value.(LearningResourcesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningResourcesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningResourcesType() *LearningResourcesType {
  if out, ok := LearningResourcesTypePointer(LearningResourcesType{}); !ok {
                log.Fatalf("Could not create pointer to LearningResourcesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningStandardDocument) Clone() (*LearningStandardDocument) {
return reprint.This(t).(*LearningStandardDocument)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningStandardDocumentPointer(value interface{}) (*LearningStandardDocument, bool) {
switch t := value.(type) {
        case *LearningStandardDocument:
                return value.(*LearningStandardDocument), true
        case LearningStandardDocument:
                v, _ := value.(LearningStandardDocument)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningStandardDocument\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningStandardDocument() *LearningStandardDocument {
  if out, ok := LearningStandardDocumentPointer(LearningStandardDocument{}); !ok {
                log.Fatalf("Could not create pointer to LearningStandardDocument\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningStandardDocuments) Clone() (*LearningStandardDocuments) {
return reprint.This(t).(*LearningStandardDocuments)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningStandardDocumentsPointer(value interface{}) (*LearningStandardDocuments, bool) {
switch t := value.(type) {
        case *LearningStandardDocuments:
                return value.(*LearningStandardDocuments), true
        case LearningStandardDocuments:
                v, _ := value.(LearningStandardDocuments)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningStandardDocuments\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningStandardItem) Clone() (*LearningStandardItem) {
return reprint.This(t).(*LearningStandardItem)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningStandardItemPointer(value interface{}) (*LearningStandardItem, bool) {
switch t := value.(type) {
        case *LearningStandardItem:
                return value.(*LearningStandardItem), true
        case LearningStandardItem:
                v, _ := value.(LearningStandardItem)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningStandardItem\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningStandardItem() *LearningStandardItem {
  if out, ok := LearningStandardItemPointer(LearningStandardItem{}); !ok {
                log.Fatalf("Could not create pointer to LearningStandardItem\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningStandardItems) Clone() (*LearningStandardItems) {
return reprint.This(t).(*LearningStandardItems)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningStandardItemsPointer(value interface{}) (*LearningStandardItems, bool) {
switch t := value.(type) {
        case *LearningStandardItems:
                return value.(*LearningStandardItems), true
        case LearningStandardItems:
                v, _ := value.(LearningStandardItems)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningStandardItems\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningStandardListType) Clone() (*LearningStandardListType) {
return reprint.This(t).(*LearningStandardListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningStandardListTypePointer(value interface{}) (*LearningStandardListType, bool) {
switch t := value.(type) {
        case *LearningStandardListType:
                return value.(*LearningStandardListType), true
        case LearningStandardListType:
                v, _ := value.(LearningStandardListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningStandardListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningStandardListType() *LearningStandardListType {
  if out, ok := LearningStandardListTypePointer(LearningStandardListType{}); !ok {
                log.Fatalf("Could not create pointer to LearningStandardListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningStandardType) Clone() (*LearningStandardType) {
return reprint.This(t).(*LearningStandardType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningStandardTypePointer(value interface{}) (*LearningStandardType, bool) {
switch t := value.(type) {
        case *LearningStandardType:
                return value.(*LearningStandardType), true
        case LearningStandardType:
                v, _ := value.(LearningStandardType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningStandardType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningStandardType() *LearningStandardType {
  if out, ok := LearningStandardTypePointer(LearningStandardType{}); !ok {
                log.Fatalf("Could not create pointer to LearningStandardType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningStandardsDocumentType) Clone() (*LearningStandardsDocumentType) {
return reprint.This(t).(*LearningStandardsDocumentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningStandardsDocumentTypePointer(value interface{}) (*LearningStandardsDocumentType, bool) {
switch t := value.(type) {
        case *LearningStandardsDocumentType:
                return value.(*LearningStandardsDocumentType), true
        case LearningStandardsDocumentType:
                v, _ := value.(LearningStandardsDocumentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningStandardsDocumentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningStandardsDocumentType() *LearningStandardsDocumentType {
  if out, ok := LearningStandardsDocumentTypePointer(LearningStandardsDocumentType{}); !ok {
                log.Fatalf("Could not create pointer to LearningStandardsDocumentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LearningStandardsType) Clone() (*LearningStandardsType) {
return reprint.This(t).(*LearningStandardsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LearningStandardsTypePointer(value interface{}) (*LearningStandardsType, bool) {
switch t := value.(type) {
        case *LearningStandardsType:
                return value.(*LearningStandardsType), true
        case LearningStandardsType:
                v, _ := value.(LearningStandardsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LearningStandardsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLearningStandardsType() *LearningStandardsType {
  if out, ok := LearningStandardsTypePointer(LearningStandardsType{}); !ok {
                log.Fatalf("Could not create pointer to LearningStandardsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LibraryItemInfoType) Clone() (*LibraryItemInfoType) {
return reprint.This(t).(*LibraryItemInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LibraryItemInfoTypePointer(value interface{}) (*LibraryItemInfoType, bool) {
switch t := value.(type) {
        case *LibraryItemInfoType:
                return value.(*LibraryItemInfoType), true
        case LibraryItemInfoType:
                v, _ := value.(LibraryItemInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LibraryItemInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLibraryItemInfoType() *LibraryItemInfoType {
  if out, ok := LibraryItemInfoTypePointer(LibraryItemInfoType{}); !ok {
                log.Fatalf("Could not create pointer to LibraryItemInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LibraryMessageListType) Clone() (*LibraryMessageListType) {
return reprint.This(t).(*LibraryMessageListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LibraryMessageListTypePointer(value interface{}) (*LibraryMessageListType, bool) {
switch t := value.(type) {
        case *LibraryMessageListType:
                return value.(*LibraryMessageListType), true
        case LibraryMessageListType:
                v, _ := value.(LibraryMessageListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LibraryMessageListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLibraryMessageListType() *LibraryMessageListType {
  if out, ok := LibraryMessageListTypePointer(LibraryMessageListType{}); !ok {
                log.Fatalf("Could not create pointer to LibraryMessageListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LibraryMessageType) Clone() (*LibraryMessageType) {
return reprint.This(t).(*LibraryMessageType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LibraryMessageTypePointer(value interface{}) (*LibraryMessageType, bool) {
switch t := value.(type) {
        case *LibraryMessageType:
                return value.(*LibraryMessageType), true
        case LibraryMessageType:
                v, _ := value.(LibraryMessageType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LibraryMessageType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLibraryMessageType() *LibraryMessageType {
  if out, ok := LibraryMessageTypePointer(LibraryMessageType{}); !ok {
                log.Fatalf("Could not create pointer to LibraryMessageType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LibraryPatronStatus) Clone() (*LibraryPatronStatus) {
return reprint.This(t).(*LibraryPatronStatus)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LibraryPatronStatusPointer(value interface{}) (*LibraryPatronStatus, bool) {
switch t := value.(type) {
        case *LibraryPatronStatus:
                return value.(*LibraryPatronStatus), true
        case LibraryPatronStatus:
                v, _ := value.(LibraryPatronStatus)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LibraryPatronStatus\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLibraryPatronStatus() *LibraryPatronStatus {
  if out, ok := LibraryPatronStatusPointer(LibraryPatronStatus{}); !ok {
                log.Fatalf("Could not create pointer to LibraryPatronStatus\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LibraryPatronStatuss) Clone() (*LibraryPatronStatuss) {
return reprint.This(t).(*LibraryPatronStatuss)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LibraryPatronStatussPointer(value interface{}) (*LibraryPatronStatuss, bool) {
switch t := value.(type) {
        case *LibraryPatronStatuss:
                return value.(*LibraryPatronStatuss), true
        case LibraryPatronStatuss:
                v, _ := value.(LibraryPatronStatuss)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LibraryPatronStatuss\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LibraryTransactionListType) Clone() (*LibraryTransactionListType) {
return reprint.This(t).(*LibraryTransactionListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LibraryTransactionListTypePointer(value interface{}) (*LibraryTransactionListType, bool) {
switch t := value.(type) {
        case *LibraryTransactionListType:
                return value.(*LibraryTransactionListType), true
        case LibraryTransactionListType:
                v, _ := value.(LibraryTransactionListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LibraryTransactionListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLibraryTransactionListType() *LibraryTransactionListType {
  if out, ok := LibraryTransactionListTypePointer(LibraryTransactionListType{}); !ok {
                log.Fatalf("Could not create pointer to LibraryTransactionListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LibraryTransactionType) Clone() (*LibraryTransactionType) {
return reprint.This(t).(*LibraryTransactionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LibraryTransactionTypePointer(value interface{}) (*LibraryTransactionType, bool) {
switch t := value.(type) {
        case *LibraryTransactionType:
                return value.(*LibraryTransactionType), true
        case LibraryTransactionType:
                v, _ := value.(LibraryTransactionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LibraryTransactionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLibraryTransactionType() *LibraryTransactionType {
  if out, ok := LibraryTransactionTypePointer(LibraryTransactionType{}); !ok {
                log.Fatalf("Could not create pointer to LibraryTransactionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LifeCycleCreatorType) Clone() (*LifeCycleCreatorType) {
return reprint.This(t).(*LifeCycleCreatorType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LifeCycleCreatorTypePointer(value interface{}) (*LifeCycleCreatorType, bool) {
switch t := value.(type) {
        case *LifeCycleCreatorType:
                return value.(*LifeCycleCreatorType), true
        case LifeCycleCreatorType:
                v, _ := value.(LifeCycleCreatorType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LifeCycleCreatorType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLifeCycleCreatorType() *LifeCycleCreatorType {
  if out, ok := LifeCycleCreatorTypePointer(LifeCycleCreatorType{}); !ok {
                log.Fatalf("Could not create pointer to LifeCycleCreatorType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LifeCycleType) Clone() (*LifeCycleType) {
return reprint.This(t).(*LifeCycleType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LifeCycleTypePointer(value interface{}) (*LifeCycleType, bool) {
switch t := value.(type) {
        case *LifeCycleType:
                return value.(*LifeCycleType), true
        case LifeCycleType:
                v, _ := value.(LifeCycleType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LifeCycleType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLifeCycleType() *LifeCycleType {
  if out, ok := LifeCycleTypePointer(LifeCycleType{}); !ok {
                log.Fatalf("Could not create pointer to LifeCycleType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LocalCodeListType) Clone() (*LocalCodeListType) {
return reprint.This(t).(*LocalCodeListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LocalCodeListTypePointer(value interface{}) (*LocalCodeListType, bool) {
switch t := value.(type) {
        case *LocalCodeListType:
                return value.(*LocalCodeListType), true
        case LocalCodeListType:
                v, _ := value.(LocalCodeListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LocalCodeListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLocalCodeListType() *LocalCodeListType {
  if out, ok := LocalCodeListTypePointer(LocalCodeListType{}); !ok {
                log.Fatalf("Could not create pointer to LocalCodeListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LocalCodeType) Clone() (*LocalCodeType) {
return reprint.This(t).(*LocalCodeType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LocalCodeTypePointer(value interface{}) (*LocalCodeType, bool) {
switch t := value.(type) {
        case *LocalCodeType:
                return value.(*LocalCodeType), true
        case LocalCodeType:
                v, _ := value.(LocalCodeType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LocalCodeType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLocalCodeType() *LocalCodeType {
  if out, ok := LocalCodeTypePointer(LocalCodeType{}); !ok {
                log.Fatalf("Could not create pointer to LocalCodeType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LocationOfInstructionType) Clone() (*LocationOfInstructionType) {
return reprint.This(t).(*LocationOfInstructionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LocationOfInstructionTypePointer(value interface{}) (*LocationOfInstructionType, bool) {
switch t := value.(type) {
        case *LocationOfInstructionType:
                return value.(*LocationOfInstructionType), true
        case LocationOfInstructionType:
                v, _ := value.(LocationOfInstructionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LocationOfInstructionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLocationOfInstructionType() *LocationOfInstructionType {
  if out, ok := LocationOfInstructionTypePointer(LocationOfInstructionType{}); !ok {
                log.Fatalf("Could not create pointer to LocationOfInstructionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LocationType) Clone() (*LocationType) {
return reprint.This(t).(*LocationType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LocationTypePointer(value interface{}) (*LocationType, bool) {
switch t := value.(type) {
        case *LocationType:
                return value.(*LocationType), true
        case LocationType:
                v, _ := value.(LocationType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LocationType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLocationType() *LocationType {
  if out, ok := LocationTypePointer(LocationType{}); !ok {
                log.Fatalf("Could not create pointer to LocationType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *LocationType_LocationRefId) Clone() (*LocationType_LocationRefId) {
return reprint.This(t).(*LocationType_LocationRefId)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func LocationType_LocationRefIdPointer(value interface{}) (*LocationType_LocationRefId, bool) {
switch t := value.(type) {
        case *LocationType_LocationRefId:
                return value.(*LocationType_LocationRefId), true
        case LocationType_LocationRefId:
                v, _ := value.(LocationType_LocationRefId)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to LocationType_LocationRefId\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewLocationType_LocationRefId() *LocationType_LocationRefId {
  if out, ok := LocationType_LocationRefIdPointer(LocationType_LocationRefId{}); !ok {
                log.Fatalf("Could not create pointer to LocationType_LocationRefId\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MapReferenceType) Clone() (*MapReferenceType) {
return reprint.This(t).(*MapReferenceType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MapReferenceTypePointer(value interface{}) (*MapReferenceType, bool) {
switch t := value.(type) {
        case *MapReferenceType:
                return value.(*MapReferenceType), true
        case MapReferenceType:
                v, _ := value.(MapReferenceType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MapReferenceType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMapReferenceType() *MapReferenceType {
  if out, ok := MapReferenceTypePointer(MapReferenceType{}); !ok {
                log.Fatalf("Could not create pointer to MapReferenceType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MarkValueInfo) Clone() (*MarkValueInfo) {
return reprint.This(t).(*MarkValueInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MarkValueInfoPointer(value interface{}) (*MarkValueInfo, bool) {
switch t := value.(type) {
        case *MarkValueInfo:
                return value.(*MarkValueInfo), true
        case MarkValueInfo:
                v, _ := value.(MarkValueInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MarkValueInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMarkValueInfo() *MarkValueInfo {
  if out, ok := MarkValueInfoPointer(MarkValueInfo{}); !ok {
                log.Fatalf("Could not create pointer to MarkValueInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MarkValueInfos) Clone() (*MarkValueInfos) {
return reprint.This(t).(*MarkValueInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MarkValueInfosPointer(value interface{}) (*MarkValueInfos, bool) {
switch t := value.(type) {
        case *MarkValueInfos:
                return value.(*MarkValueInfos), true
        case MarkValueInfos:
                v, _ := value.(MarkValueInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MarkValueInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MarkerType) Clone() (*MarkerType) {
return reprint.This(t).(*MarkerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MarkerTypePointer(value interface{}) (*MarkerType, bool) {
switch t := value.(type) {
        case *MarkerType:
                return value.(*MarkerType), true
        case MarkerType:
                v, _ := value.(MarkerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MarkerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMarkerType() *MarkerType {
  if out, ok := MarkerTypePointer(MarkerType{}); !ok {
                log.Fatalf("Could not create pointer to MarkerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MediaTypesType) Clone() (*MediaTypesType) {
return reprint.This(t).(*MediaTypesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MediaTypesTypePointer(value interface{}) (*MediaTypesType, bool) {
switch t := value.(type) {
        case *MediaTypesType:
                return value.(*MediaTypesType), true
        case MediaTypesType:
                v, _ := value.(MediaTypesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MediaTypesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMediaTypesType() *MediaTypesType {
  if out, ok := MediaTypesTypePointer(MediaTypesType{}); !ok {
                log.Fatalf("Could not create pointer to MediaTypesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MedicalAlertMessageType) Clone() (*MedicalAlertMessageType) {
return reprint.This(t).(*MedicalAlertMessageType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MedicalAlertMessageTypePointer(value interface{}) (*MedicalAlertMessageType, bool) {
switch t := value.(type) {
        case *MedicalAlertMessageType:
                return value.(*MedicalAlertMessageType), true
        case MedicalAlertMessageType:
                v, _ := value.(MedicalAlertMessageType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MedicalAlertMessageType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMedicalAlertMessageType() *MedicalAlertMessageType {
  if out, ok := MedicalAlertMessageTypePointer(MedicalAlertMessageType{}); !ok {
                log.Fatalf("Could not create pointer to MedicalAlertMessageType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MedicalAlertMessagesType) Clone() (*MedicalAlertMessagesType) {
return reprint.This(t).(*MedicalAlertMessagesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MedicalAlertMessagesTypePointer(value interface{}) (*MedicalAlertMessagesType, bool) {
switch t := value.(type) {
        case *MedicalAlertMessagesType:
                return value.(*MedicalAlertMessagesType), true
        case MedicalAlertMessagesType:
                v, _ := value.(MedicalAlertMessagesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MedicalAlertMessagesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMedicalAlertMessagesType() *MedicalAlertMessagesType {
  if out, ok := MedicalAlertMessagesTypePointer(MedicalAlertMessagesType{}); !ok {
                log.Fatalf("Could not create pointer to MedicalAlertMessagesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MedicationListType) Clone() (*MedicationListType) {
return reprint.This(t).(*MedicationListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MedicationListTypePointer(value interface{}) (*MedicationListType, bool) {
switch t := value.(type) {
        case *MedicationListType:
                return value.(*MedicationListType), true
        case MedicationListType:
                v, _ := value.(MedicationListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MedicationListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMedicationListType() *MedicationListType {
  if out, ok := MedicationListTypePointer(MedicationListType{}); !ok {
                log.Fatalf("Could not create pointer to MedicationListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MedicationType) Clone() (*MedicationType) {
return reprint.This(t).(*MedicationType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MedicationTypePointer(value interface{}) (*MedicationType, bool) {
switch t := value.(type) {
        case *MedicationType:
                return value.(*MedicationType), true
        case MedicationType:
                v, _ := value.(MedicationType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MedicationType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMedicationType() *MedicationType {
  if out, ok := MedicationTypePointer(MedicationType{}); !ok {
                log.Fatalf("Could not create pointer to MedicationType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MediumOfInstructionType) Clone() (*MediumOfInstructionType) {
return reprint.This(t).(*MediumOfInstructionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MediumOfInstructionTypePointer(value interface{}) (*MediumOfInstructionType, bool) {
switch t := value.(type) {
        case *MediumOfInstructionType:
                return value.(*MediumOfInstructionType), true
        case MediumOfInstructionType:
                v, _ := value.(MediumOfInstructionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MediumOfInstructionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMediumOfInstructionType() *MediumOfInstructionType {
  if out, ok := MediumOfInstructionTypePointer(MediumOfInstructionType{}); !ok {
                log.Fatalf("Could not create pointer to MediumOfInstructionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ModifiedListType) Clone() (*ModifiedListType) {
return reprint.This(t).(*ModifiedListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ModifiedListTypePointer(value interface{}) (*ModifiedListType, bool) {
switch t := value.(type) {
        case *ModifiedListType:
                return value.(*ModifiedListType), true
        case ModifiedListType:
                v, _ := value.(ModifiedListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ModifiedListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewModifiedListType() *ModifiedListType {
  if out, ok := ModifiedListTypePointer(ModifiedListType{}); !ok {
                log.Fatalf("Could not create pointer to ModifiedListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ModifiedType) Clone() (*ModifiedType) {
return reprint.This(t).(*ModifiedType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ModifiedTypePointer(value interface{}) (*ModifiedType, bool) {
switch t := value.(type) {
        case *ModifiedType:
                return value.(*ModifiedType), true
        case ModifiedType:
                v, _ := value.(ModifiedType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ModifiedType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewModifiedType() *ModifiedType {
  if out, ok := ModifiedTypePointer(ModifiedType{}); !ok {
                log.Fatalf("Could not create pointer to ModifiedType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *MonetaryAmountType) Clone() (*MonetaryAmountType) {
return reprint.This(t).(*MonetaryAmountType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func MonetaryAmountTypePointer(value interface{}) (*MonetaryAmountType, bool) {
switch t := value.(type) {
        case *MonetaryAmountType:
                return value.(*MonetaryAmountType), true
        case MonetaryAmountType:
                v, _ := value.(MonetaryAmountType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to MonetaryAmountType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewMonetaryAmountType() *MonetaryAmountType {
  if out, ok := MonetaryAmountTypePointer(MonetaryAmountType{}); !ok {
                log.Fatalf("Could not create pointer to MonetaryAmountType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPCodeFrame) Clone() (*NAPCodeFrame) {
return reprint.This(t).(*NAPCodeFrame)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPCodeFramePointer(value interface{}) (*NAPCodeFrame, bool) {
switch t := value.(type) {
        case *NAPCodeFrame:
                return value.(*NAPCodeFrame), true
        case NAPCodeFrame:
                v, _ := value.(NAPCodeFrame)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPCodeFrame\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPCodeFrame() *NAPCodeFrame {
  if out, ok := NAPCodeFramePointer(NAPCodeFrame{}); !ok {
                log.Fatalf("Could not create pointer to NAPCodeFrame\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPCodeFrameTestletListType) Clone() (*NAPCodeFrameTestletListType) {
return reprint.This(t).(*NAPCodeFrameTestletListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPCodeFrameTestletListTypePointer(value interface{}) (*NAPCodeFrameTestletListType, bool) {
switch t := value.(type) {
        case *NAPCodeFrameTestletListType:
                return value.(*NAPCodeFrameTestletListType), true
        case NAPCodeFrameTestletListType:
                v, _ := value.(NAPCodeFrameTestletListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPCodeFrameTestletListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPCodeFrameTestletListType() *NAPCodeFrameTestletListType {
  if out, ok := NAPCodeFrameTestletListTypePointer(NAPCodeFrameTestletListType{}); !ok {
                log.Fatalf("Could not create pointer to NAPCodeFrameTestletListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPCodeFrames) Clone() (*NAPCodeFrames) {
return reprint.This(t).(*NAPCodeFrames)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPCodeFramesPointer(value interface{}) (*NAPCodeFrames, bool) {
switch t := value.(type) {
        case *NAPCodeFrames:
                return value.(*NAPCodeFrames), true
        case NAPCodeFrames:
                v, _ := value.(NAPCodeFrames)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPCodeFrames\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPEventStudentLink) Clone() (*NAPEventStudentLink) {
return reprint.This(t).(*NAPEventStudentLink)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPEventStudentLinkPointer(value interface{}) (*NAPEventStudentLink, bool) {
switch t := value.(type) {
        case *NAPEventStudentLink:
                return value.(*NAPEventStudentLink), true
        case NAPEventStudentLink:
                v, _ := value.(NAPEventStudentLink)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPEventStudentLink\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPEventStudentLink() *NAPEventStudentLink {
  if out, ok := NAPEventStudentLinkPointer(NAPEventStudentLink{}); !ok {
                log.Fatalf("Could not create pointer to NAPEventStudentLink\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPEventStudentLinks) Clone() (*NAPEventStudentLinks) {
return reprint.This(t).(*NAPEventStudentLinks)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPEventStudentLinksPointer(value interface{}) (*NAPEventStudentLinks, bool) {
switch t := value.(type) {
        case *NAPEventStudentLinks:
                return value.(*NAPEventStudentLinks), true
        case NAPEventStudentLinks:
                v, _ := value.(NAPEventStudentLinks)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPEventStudentLinks\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPLANClassListType) Clone() (*NAPLANClassListType) {
return reprint.This(t).(*NAPLANClassListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPLANClassListTypePointer(value interface{}) (*NAPLANClassListType, bool) {
switch t := value.(type) {
        case *NAPLANClassListType:
                return value.(*NAPLANClassListType), true
        case NAPLANClassListType:
                v, _ := value.(NAPLANClassListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPLANClassListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPLANClassListType() *NAPLANClassListType {
  if out, ok := NAPLANClassListTypePointer(NAPLANClassListType{}); !ok {
                log.Fatalf("Could not create pointer to NAPLANClassListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPLANScoreListType) Clone() (*NAPLANScoreListType) {
return reprint.This(t).(*NAPLANScoreListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPLANScoreListTypePointer(value interface{}) (*NAPLANScoreListType, bool) {
switch t := value.(type) {
        case *NAPLANScoreListType:
                return value.(*NAPLANScoreListType), true
        case NAPLANScoreListType:
                v, _ := value.(NAPLANScoreListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPLANScoreListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPLANScoreListType() *NAPLANScoreListType {
  if out, ok := NAPLANScoreListTypePointer(NAPLANScoreListType{}); !ok {
                log.Fatalf("Could not create pointer to NAPLANScoreListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPLANScoreType) Clone() (*NAPLANScoreType) {
return reprint.This(t).(*NAPLANScoreType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPLANScoreTypePointer(value interface{}) (*NAPLANScoreType, bool) {
switch t := value.(type) {
        case *NAPLANScoreType:
                return value.(*NAPLANScoreType), true
        case NAPLANScoreType:
                v, _ := value.(NAPLANScoreType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPLANScoreType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPLANScoreType() *NAPLANScoreType {
  if out, ok := NAPLANScoreTypePointer(NAPLANScoreType{}); !ok {
                log.Fatalf("Could not create pointer to NAPLANScoreType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPLANScoreWithYearsListType) Clone() (*NAPLANScoreWithYearsListType) {
return reprint.This(t).(*NAPLANScoreWithYearsListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPLANScoreWithYearsListTypePointer(value interface{}) (*NAPLANScoreWithYearsListType, bool) {
switch t := value.(type) {
        case *NAPLANScoreWithYearsListType:
                return value.(*NAPLANScoreWithYearsListType), true
        case NAPLANScoreWithYearsListType:
                v, _ := value.(NAPLANScoreWithYearsListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPLANScoreWithYearsListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPLANScoreWithYearsListType() *NAPLANScoreWithYearsListType {
  if out, ok := NAPLANScoreWithYearsListTypePointer(NAPLANScoreWithYearsListType{}); !ok {
                log.Fatalf("Could not create pointer to NAPLANScoreWithYearsListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPLANScoreWithYearsType) Clone() (*NAPLANScoreWithYearsType) {
return reprint.This(t).(*NAPLANScoreWithYearsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPLANScoreWithYearsTypePointer(value interface{}) (*NAPLANScoreWithYearsType, bool) {
switch t := value.(type) {
        case *NAPLANScoreWithYearsType:
                return value.(*NAPLANScoreWithYearsType), true
        case NAPLANScoreWithYearsType:
                v, _ := value.(NAPLANScoreWithYearsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPLANScoreWithYearsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPLANScoreWithYearsType() *NAPLANScoreWithYearsType {
  if out, ok := NAPLANScoreWithYearsTypePointer(NAPLANScoreWithYearsType{}); !ok {
                log.Fatalf("Could not create pointer to NAPLANScoreWithYearsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPStudentResponseSet) Clone() (*NAPStudentResponseSet) {
return reprint.This(t).(*NAPStudentResponseSet)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPStudentResponseSetPointer(value interface{}) (*NAPStudentResponseSet, bool) {
switch t := value.(type) {
        case *NAPStudentResponseSet:
                return value.(*NAPStudentResponseSet), true
        case NAPStudentResponseSet:
                v, _ := value.(NAPStudentResponseSet)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPStudentResponseSet\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPStudentResponseSet() *NAPStudentResponseSet {
  if out, ok := NAPStudentResponseSetPointer(NAPStudentResponseSet{}); !ok {
                log.Fatalf("Could not create pointer to NAPStudentResponseSet\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPStudentResponseSets) Clone() (*NAPStudentResponseSets) {
return reprint.This(t).(*NAPStudentResponseSets)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPStudentResponseSetsPointer(value interface{}) (*NAPStudentResponseSets, bool) {
switch t := value.(type) {
        case *NAPStudentResponseSets:
                return value.(*NAPStudentResponseSets), true
        case NAPStudentResponseSets:
                v, _ := value.(NAPStudentResponseSets)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPStudentResponseSets\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPStudentResponseTestletListType) Clone() (*NAPStudentResponseTestletListType) {
return reprint.This(t).(*NAPStudentResponseTestletListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPStudentResponseTestletListTypePointer(value interface{}) (*NAPStudentResponseTestletListType, bool) {
switch t := value.(type) {
        case *NAPStudentResponseTestletListType:
                return value.(*NAPStudentResponseTestletListType), true
        case NAPStudentResponseTestletListType:
                v, _ := value.(NAPStudentResponseTestletListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPStudentResponseTestletListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPStudentResponseTestletListType() *NAPStudentResponseTestletListType {
  if out, ok := NAPStudentResponseTestletListTypePointer(NAPStudentResponseTestletListType{}); !ok {
                log.Fatalf("Could not create pointer to NAPStudentResponseTestletListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPSubscoreListType) Clone() (*NAPSubscoreListType) {
return reprint.This(t).(*NAPSubscoreListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPSubscoreListTypePointer(value interface{}) (*NAPSubscoreListType, bool) {
switch t := value.(type) {
        case *NAPSubscoreListType:
                return value.(*NAPSubscoreListType), true
        case NAPSubscoreListType:
                v, _ := value.(NAPSubscoreListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPSubscoreListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPSubscoreListType() *NAPSubscoreListType {
  if out, ok := NAPSubscoreListTypePointer(NAPSubscoreListType{}); !ok {
                log.Fatalf("Could not create pointer to NAPSubscoreListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPSubscoreType) Clone() (*NAPSubscoreType) {
return reprint.This(t).(*NAPSubscoreType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPSubscoreTypePointer(value interface{}) (*NAPSubscoreType, bool) {
switch t := value.(type) {
        case *NAPSubscoreType:
                return value.(*NAPSubscoreType), true
        case NAPSubscoreType:
                v, _ := value.(NAPSubscoreType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPSubscoreType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPSubscoreType() *NAPSubscoreType {
  if out, ok := NAPSubscoreTypePointer(NAPSubscoreType{}); !ok {
                log.Fatalf("Could not create pointer to NAPSubscoreType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTest) Clone() (*NAPTest) {
return reprint.This(t).(*NAPTest)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestPointer(value interface{}) (*NAPTest, bool) {
switch t := value.(type) {
        case *NAPTest:
                return value.(*NAPTest), true
        case NAPTest:
                v, _ := value.(NAPTest)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTest\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTest() *NAPTest {
  if out, ok := NAPTestPointer(NAPTest{}); !ok {
                log.Fatalf("Could not create pointer to NAPTest\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestContentType) Clone() (*NAPTestContentType) {
return reprint.This(t).(*NAPTestContentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestContentTypePointer(value interface{}) (*NAPTestContentType, bool) {
switch t := value.(type) {
        case *NAPTestContentType:
                return value.(*NAPTestContentType), true
        case NAPTestContentType:
                v, _ := value.(NAPTestContentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestContentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestContentType() *NAPTestContentType {
  if out, ok := NAPTestContentTypePointer(NAPTestContentType{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestContentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestItem) Clone() (*NAPTestItem) {
return reprint.This(t).(*NAPTestItem)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestItemPointer(value interface{}) (*NAPTestItem, bool) {
switch t := value.(type) {
        case *NAPTestItem:
                return value.(*NAPTestItem), true
        case NAPTestItem:
                v, _ := value.(NAPTestItem)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestItem\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestItem() *NAPTestItem {
  if out, ok := NAPTestItemPointer(NAPTestItem{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestItem\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestItem2Type) Clone() (*NAPTestItem2Type) {
return reprint.This(t).(*NAPTestItem2Type)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestItem2TypePointer(value interface{}) (*NAPTestItem2Type, bool) {
switch t := value.(type) {
        case *NAPTestItem2Type:
                return value.(*NAPTestItem2Type), true
        case NAPTestItem2Type:
                v, _ := value.(NAPTestItem2Type)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestItem2Type\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestItem2Type() *NAPTestItem2Type {
  if out, ok := NAPTestItem2TypePointer(NAPTestItem2Type{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestItem2Type\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestItemContentType) Clone() (*NAPTestItemContentType) {
return reprint.This(t).(*NAPTestItemContentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestItemContentTypePointer(value interface{}) (*NAPTestItemContentType, bool) {
switch t := value.(type) {
        case *NAPTestItemContentType:
                return value.(*NAPTestItemContentType), true
        case NAPTestItemContentType:
                v, _ := value.(NAPTestItemContentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestItemContentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestItemContentType() *NAPTestItemContentType {
  if out, ok := NAPTestItemContentTypePointer(NAPTestItemContentType{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestItemContentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestItemListType) Clone() (*NAPTestItemListType) {
return reprint.This(t).(*NAPTestItemListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestItemListTypePointer(value interface{}) (*NAPTestItemListType, bool) {
switch t := value.(type) {
        case *NAPTestItemListType:
                return value.(*NAPTestItemListType), true
        case NAPTestItemListType:
                v, _ := value.(NAPTestItemListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestItemListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestItemListType() *NAPTestItemListType {
  if out, ok := NAPTestItemListTypePointer(NAPTestItemListType{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestItemListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestItems) Clone() (*NAPTestItems) {
return reprint.This(t).(*NAPTestItems)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestItemsPointer(value interface{}) (*NAPTestItems, bool) {
switch t := value.(type) {
        case *NAPTestItems:
                return value.(*NAPTestItems), true
        case NAPTestItems:
                v, _ := value.(NAPTestItems)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestItems\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestScoreSummary) Clone() (*NAPTestScoreSummary) {
return reprint.This(t).(*NAPTestScoreSummary)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestScoreSummaryPointer(value interface{}) (*NAPTestScoreSummary, bool) {
switch t := value.(type) {
        case *NAPTestScoreSummary:
                return value.(*NAPTestScoreSummary), true
        case NAPTestScoreSummary:
                v, _ := value.(NAPTestScoreSummary)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestScoreSummary\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestScoreSummary() *NAPTestScoreSummary {
  if out, ok := NAPTestScoreSummaryPointer(NAPTestScoreSummary{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestScoreSummary\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestScoreSummarys) Clone() (*NAPTestScoreSummarys) {
return reprint.This(t).(*NAPTestScoreSummarys)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestScoreSummarysPointer(value interface{}) (*NAPTestScoreSummarys, bool) {
switch t := value.(type) {
        case *NAPTestScoreSummarys:
                return value.(*NAPTestScoreSummarys), true
        case NAPTestScoreSummarys:
                v, _ := value.(NAPTestScoreSummarys)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestScoreSummarys\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestlet) Clone() (*NAPTestlet) {
return reprint.This(t).(*NAPTestlet)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestletPointer(value interface{}) (*NAPTestlet, bool) {
switch t := value.(type) {
        case *NAPTestlet:
                return value.(*NAPTestlet), true
        case NAPTestlet:
                v, _ := value.(NAPTestlet)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestlet\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestlet() *NAPTestlet {
  if out, ok := NAPTestletPointer(NAPTestlet{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestlet\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestletCodeFrameType) Clone() (*NAPTestletCodeFrameType) {
return reprint.This(t).(*NAPTestletCodeFrameType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestletCodeFrameTypePointer(value interface{}) (*NAPTestletCodeFrameType, bool) {
switch t := value.(type) {
        case *NAPTestletCodeFrameType:
                return value.(*NAPTestletCodeFrameType), true
        case NAPTestletCodeFrameType:
                v, _ := value.(NAPTestletCodeFrameType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestletCodeFrameType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestletCodeFrameType() *NAPTestletCodeFrameType {
  if out, ok := NAPTestletCodeFrameTypePointer(NAPTestletCodeFrameType{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestletCodeFrameType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestletContentType) Clone() (*NAPTestletContentType) {
return reprint.This(t).(*NAPTestletContentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestletContentTypePointer(value interface{}) (*NAPTestletContentType, bool) {
switch t := value.(type) {
        case *NAPTestletContentType:
                return value.(*NAPTestletContentType), true
        case NAPTestletContentType:
                v, _ := value.(NAPTestletContentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestletContentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestletContentType() *NAPTestletContentType {
  if out, ok := NAPTestletContentTypePointer(NAPTestletContentType{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestletContentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestletItemResponseListType) Clone() (*NAPTestletItemResponseListType) {
return reprint.This(t).(*NAPTestletItemResponseListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestletItemResponseListTypePointer(value interface{}) (*NAPTestletItemResponseListType, bool) {
switch t := value.(type) {
        case *NAPTestletItemResponseListType:
                return value.(*NAPTestletItemResponseListType), true
        case NAPTestletItemResponseListType:
                v, _ := value.(NAPTestletItemResponseListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestletItemResponseListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestletItemResponseListType() *NAPTestletItemResponseListType {
  if out, ok := NAPTestletItemResponseListTypePointer(NAPTestletItemResponseListType{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestletItemResponseListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestletResponseItemType) Clone() (*NAPTestletResponseItemType) {
return reprint.This(t).(*NAPTestletResponseItemType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestletResponseItemTypePointer(value interface{}) (*NAPTestletResponseItemType, bool) {
switch t := value.(type) {
        case *NAPTestletResponseItemType:
                return value.(*NAPTestletResponseItemType), true
        case NAPTestletResponseItemType:
                v, _ := value.(NAPTestletResponseItemType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestletResponseItemType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestletResponseItemType() *NAPTestletResponseItemType {
  if out, ok := NAPTestletResponseItemTypePointer(NAPTestletResponseItemType{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestletResponseItemType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestletResponseType) Clone() (*NAPTestletResponseType) {
return reprint.This(t).(*NAPTestletResponseType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestletResponseTypePointer(value interface{}) (*NAPTestletResponseType, bool) {
switch t := value.(type) {
        case *NAPTestletResponseType:
                return value.(*NAPTestletResponseType), true
        case NAPTestletResponseType:
                v, _ := value.(NAPTestletResponseType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestletResponseType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPTestletResponseType() *NAPTestletResponseType {
  if out, ok := NAPTestletResponseTypePointer(NAPTestletResponseType{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestletResponseType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTestlets) Clone() (*NAPTestlets) {
return reprint.This(t).(*NAPTestlets)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestletsPointer(value interface{}) (*NAPTestlets, bool) {
switch t := value.(type) {
        case *NAPTestlets:
                return value.(*NAPTestlets), true
        case NAPTestlets:
                v, _ := value.(NAPTestlets)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTestlets\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPTests) Clone() (*NAPTests) {
return reprint.This(t).(*NAPTests)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPTestsPointer(value interface{}) (*NAPTests, bool) {
switch t := value.(type) {
        case *NAPTests:
                return value.(*NAPTests), true
        case NAPTests:
                v, _ := value.(NAPTests)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPTests\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPWritingRubricListType) Clone() (*NAPWritingRubricListType) {
return reprint.This(t).(*NAPWritingRubricListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPWritingRubricListTypePointer(value interface{}) (*NAPWritingRubricListType, bool) {
switch t := value.(type) {
        case *NAPWritingRubricListType:
                return value.(*NAPWritingRubricListType), true
        case NAPWritingRubricListType:
                v, _ := value.(NAPWritingRubricListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPWritingRubricListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPWritingRubricListType() *NAPWritingRubricListType {
  if out, ok := NAPWritingRubricListTypePointer(NAPWritingRubricListType{}); !ok {
                log.Fatalf("Could not create pointer to NAPWritingRubricListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NAPWritingRubricType) Clone() (*NAPWritingRubricType) {
return reprint.This(t).(*NAPWritingRubricType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NAPWritingRubricTypePointer(value interface{}) (*NAPWritingRubricType, bool) {
switch t := value.(type) {
        case *NAPWritingRubricType:
                return value.(*NAPWritingRubricType), true
        case NAPWritingRubricType:
                v, _ := value.(NAPWritingRubricType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NAPWritingRubricType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNAPWritingRubricType() *NAPWritingRubricType {
  if out, ok := NAPWritingRubricTypePointer(NAPWritingRubricType{}); !ok {
                log.Fatalf("Could not create pointer to NAPWritingRubricType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NCCDListType) Clone() (*NCCDListType) {
return reprint.This(t).(*NCCDListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NCCDListTypePointer(value interface{}) (*NCCDListType, bool) {
switch t := value.(type) {
        case *NCCDListType:
                return value.(*NCCDListType), true
        case NCCDListType:
                v, _ := value.(NCCDListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NCCDListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNCCDListType() *NCCDListType {
  if out, ok := NCCDListTypePointer(NCCDListType{}); !ok {
                log.Fatalf("Could not create pointer to NCCDListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NCCDType) Clone() (*NCCDType) {
return reprint.This(t).(*NCCDType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NCCDTypePointer(value interface{}) (*NCCDType, bool) {
switch t := value.(type) {
        case *NCCDType:
                return value.(*NCCDType), true
        case NCCDType:
                v, _ := value.(NCCDType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NCCDType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNCCDType() *NCCDType {
  if out, ok := NCCDTypePointer(NCCDType{}); !ok {
                log.Fatalf("Could not create pointer to NCCDType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NameOfRecordType) Clone() (*NameOfRecordType) {
return reprint.This(t).(*NameOfRecordType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NameOfRecordTypePointer(value interface{}) (*NameOfRecordType, bool) {
switch t := value.(type) {
        case *NameOfRecordType:
                return value.(*NameOfRecordType), true
        case NameOfRecordType:
                v, _ := value.(NameOfRecordType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NameOfRecordType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNameOfRecordType() *NameOfRecordType {
  if out, ok := NameOfRecordTypePointer(NameOfRecordType{}); !ok {
                log.Fatalf("Could not create pointer to NameOfRecordType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NameType) Clone() (*NameType) {
return reprint.This(t).(*NameType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NameTypePointer(value interface{}) (*NameType, bool) {
switch t := value.(type) {
        case *NameType:
                return value.(*NameType), true
        case NameType:
                v, _ := value.(NameType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NameType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNameType() *NameType {
  if out, ok := NameTypePointer(NameType{}); !ok {
                log.Fatalf("Could not create pointer to NameType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NeverShareWithListType) Clone() (*NeverShareWithListType) {
return reprint.This(t).(*NeverShareWithListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NeverShareWithListTypePointer(value interface{}) (*NeverShareWithListType, bool) {
switch t := value.(type) {
        case *NeverShareWithListType:
                return value.(*NeverShareWithListType), true
        case NeverShareWithListType:
                v, _ := value.(NeverShareWithListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NeverShareWithListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNeverShareWithListType() *NeverShareWithListType {
  if out, ok := NeverShareWithListTypePointer(NeverShareWithListType{}); !ok {
                log.Fatalf("Could not create pointer to NeverShareWithListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *NeverShareWithType) Clone() (*NeverShareWithType) {
return reprint.This(t).(*NeverShareWithType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func NeverShareWithTypePointer(value interface{}) (*NeverShareWithType, bool) {
switch t := value.(type) {
        case *NeverShareWithType:
                return value.(*NeverShareWithType), true
        case NeverShareWithType:
                v, _ := value.(NeverShareWithType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to NeverShareWithType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewNeverShareWithType() *NeverShareWithType {
  if out, ok := NeverShareWithTypePointer(NeverShareWithType{}); !ok {
                log.Fatalf("Could not create pointer to NeverShareWithType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *OrganizationsType) Clone() (*OrganizationsType) {
return reprint.This(t).(*OrganizationsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func OrganizationsTypePointer(value interface{}) (*OrganizationsType, bool) {
switch t := value.(type) {
        case *OrganizationsType:
                return value.(*OrganizationsType), true
        case OrganizationsType:
                v, _ := value.(OrganizationsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to OrganizationsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewOrganizationsType() *OrganizationsType {
  if out, ok := OrganizationsTypePointer(OrganizationsType{}); !ok {
                log.Fatalf("Could not create pointer to OrganizationsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *OtherCodeListType) Clone() (*OtherCodeListType) {
return reprint.This(t).(*OtherCodeListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func OtherCodeListTypePointer(value interface{}) (*OtherCodeListType, bool) {
switch t := value.(type) {
        case *OtherCodeListType:
                return value.(*OtherCodeListType), true
        case OtherCodeListType:
                v, _ := value.(OtherCodeListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to OtherCodeListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewOtherCodeListType() *OtherCodeListType {
  if out, ok := OtherCodeListTypePointer(OtherCodeListType{}); !ok {
                log.Fatalf("Could not create pointer to OtherCodeListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *OtherCodeListType_OtherCode) Clone() (*OtherCodeListType_OtherCode) {
return reprint.This(t).(*OtherCodeListType_OtherCode)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func OtherCodeListType_OtherCodePointer(value interface{}) (*OtherCodeListType_OtherCode, bool) {
switch t := value.(type) {
        case *OtherCodeListType_OtherCode:
                return value.(*OtherCodeListType_OtherCode), true
        case OtherCodeListType_OtherCode:
                v, _ := value.(OtherCodeListType_OtherCode)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to OtherCodeListType_OtherCode\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewOtherCodeListType_OtherCode() *OtherCodeListType_OtherCode {
  if out, ok := OtherCodeListType_OtherCodePointer(OtherCodeListType_OtherCode{}); !ok {
                log.Fatalf("Could not create pointer to OtherCodeListType_OtherCode\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *OtherIdListType) Clone() (*OtherIdListType) {
return reprint.This(t).(*OtherIdListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func OtherIdListTypePointer(value interface{}) (*OtherIdListType, bool) {
switch t := value.(type) {
        case *OtherIdListType:
                return value.(*OtherIdListType), true
        case OtherIdListType:
                v, _ := value.(OtherIdListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to OtherIdListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewOtherIdListType() *OtherIdListType {
  if out, ok := OtherIdListTypePointer(OtherIdListType{}); !ok {
                log.Fatalf("Could not create pointer to OtherIdListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *OtherIdType) Clone() (*OtherIdType) {
return reprint.This(t).(*OtherIdType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func OtherIdTypePointer(value interface{}) (*OtherIdType, bool) {
switch t := value.(type) {
        case *OtherIdType:
                return value.(*OtherIdType), true
        case OtherIdType:
                v, _ := value.(OtherIdType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to OtherIdType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewOtherIdType() *OtherIdType {
  if out, ok := OtherIdTypePointer(OtherIdType{}); !ok {
                log.Fatalf("Could not create pointer to OtherIdType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *OtherNameType) Clone() (*OtherNameType) {
return reprint.This(t).(*OtherNameType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func OtherNameTypePointer(value interface{}) (*OtherNameType, bool) {
switch t := value.(type) {
        case *OtherNameType:
                return value.(*OtherNameType), true
        case OtherNameType:
                v, _ := value.(OtherNameType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to OtherNameType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewOtherNameType() *OtherNameType {
  if out, ok := OtherNameTypePointer(OtherNameType{}); !ok {
                log.Fatalf("Could not create pointer to OtherNameType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *OtherNamesType) Clone() (*OtherNamesType) {
return reprint.This(t).(*OtherNamesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func OtherNamesTypePointer(value interface{}) (*OtherNamesType, bool) {
switch t := value.(type) {
        case *OtherNamesType:
                return value.(*OtherNamesType), true
        case OtherNamesType:
                v, _ := value.(OtherNamesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to OtherNamesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewOtherNamesType() *OtherNamesType {
  if out, ok := OtherNamesTypePointer(OtherNamesType{}); !ok {
                log.Fatalf("Could not create pointer to OtherNamesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *OtherWellbeingResponseContainerType) Clone() (*OtherWellbeingResponseContainerType) {
return reprint.This(t).(*OtherWellbeingResponseContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func OtherWellbeingResponseContainerTypePointer(value interface{}) (*OtherWellbeingResponseContainerType, bool) {
switch t := value.(type) {
        case *OtherWellbeingResponseContainerType:
                return value.(*OtherWellbeingResponseContainerType), true
        case OtherWellbeingResponseContainerType:
                v, _ := value.(OtherWellbeingResponseContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to OtherWellbeingResponseContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewOtherWellbeingResponseContainerType() *OtherWellbeingResponseContainerType {
  if out, ok := OtherWellbeingResponseContainerTypePointer(OtherWellbeingResponseContainerType{}); !ok {
                log.Fatalf("Could not create pointer to OtherWellbeingResponseContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PNPCodeListType) Clone() (*PNPCodeListType) {
return reprint.This(t).(*PNPCodeListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PNPCodeListTypePointer(value interface{}) (*PNPCodeListType, bool) {
switch t := value.(type) {
        case *PNPCodeListType:
                return value.(*PNPCodeListType), true
        case PNPCodeListType:
                v, _ := value.(PNPCodeListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PNPCodeListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPNPCodeListType() *PNPCodeListType {
  if out, ok := PNPCodeListTypePointer(PNPCodeListType{}); !ok {
                log.Fatalf("Could not create pointer to PNPCodeListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PassportType) Clone() (*PassportType) {
return reprint.This(t).(*PassportType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PassportTypePointer(value interface{}) (*PassportType, bool) {
switch t := value.(type) {
        case *PassportType:
                return value.(*PassportType), true
        case PassportType:
                v, _ := value.(PassportType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PassportType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPassportType() *PassportType {
  if out, ok := PassportTypePointer(PassportType{}); !ok {
                log.Fatalf("Could not create pointer to PassportType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PasswordListType) Clone() (*PasswordListType) {
return reprint.This(t).(*PasswordListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PasswordListTypePointer(value interface{}) (*PasswordListType, bool) {
switch t := value.(type) {
        case *PasswordListType:
                return value.(*PasswordListType), true
        case PasswordListType:
                v, _ := value.(PasswordListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PasswordListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPasswordListType() *PasswordListType {
  if out, ok := PasswordListTypePointer(PasswordListType{}); !ok {
                log.Fatalf("Could not create pointer to PasswordListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PasswordListType_Password) Clone() (*PasswordListType_Password) {
return reprint.This(t).(*PasswordListType_Password)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PasswordListType_PasswordPointer(value interface{}) (*PasswordListType_Password, bool) {
switch t := value.(type) {
        case *PasswordListType_Password:
                return value.(*PasswordListType_Password), true
        case PasswordListType_Password:
                v, _ := value.(PasswordListType_Password)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PasswordListType_Password\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPasswordListType_Password() *PasswordListType_Password {
  if out, ok := PasswordListType_PasswordPointer(PasswordListType_Password{}); !ok {
                log.Fatalf("Could not create pointer to PasswordListType_Password\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PaymentReceipt) Clone() (*PaymentReceipt) {
return reprint.This(t).(*PaymentReceipt)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PaymentReceiptPointer(value interface{}) (*PaymentReceipt, bool) {
switch t := value.(type) {
        case *PaymentReceipt:
                return value.(*PaymentReceipt), true
        case PaymentReceipt:
                v, _ := value.(PaymentReceipt)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PaymentReceipt\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPaymentReceipt() *PaymentReceipt {
  if out, ok := PaymentReceiptPointer(PaymentReceipt{}); !ok {
                log.Fatalf("Could not create pointer to PaymentReceipt\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PaymentReceiptLineListType) Clone() (*PaymentReceiptLineListType) {
return reprint.This(t).(*PaymentReceiptLineListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PaymentReceiptLineListTypePointer(value interface{}) (*PaymentReceiptLineListType, bool) {
switch t := value.(type) {
        case *PaymentReceiptLineListType:
                return value.(*PaymentReceiptLineListType), true
        case PaymentReceiptLineListType:
                v, _ := value.(PaymentReceiptLineListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PaymentReceiptLineListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPaymentReceiptLineListType() *PaymentReceiptLineListType {
  if out, ok := PaymentReceiptLineListTypePointer(PaymentReceiptLineListType{}); !ok {
                log.Fatalf("Could not create pointer to PaymentReceiptLineListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PaymentReceiptLineType) Clone() (*PaymentReceiptLineType) {
return reprint.This(t).(*PaymentReceiptLineType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PaymentReceiptLineTypePointer(value interface{}) (*PaymentReceiptLineType, bool) {
switch t := value.(type) {
        case *PaymentReceiptLineType:
                return value.(*PaymentReceiptLineType), true
        case PaymentReceiptLineType:
                v, _ := value.(PaymentReceiptLineType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PaymentReceiptLineType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPaymentReceiptLineType() *PaymentReceiptLineType {
  if out, ok := PaymentReceiptLineTypePointer(PaymentReceiptLineType{}); !ok {
                log.Fatalf("Could not create pointer to PaymentReceiptLineType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PaymentReceipts) Clone() (*PaymentReceipts) {
return reprint.This(t).(*PaymentReceipts)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PaymentReceiptsPointer(value interface{}) (*PaymentReceipts, bool) {
switch t := value.(type) {
        case *PaymentReceipts:
                return value.(*PaymentReceipts), true
        case PaymentReceipts:
                v, _ := value.(PaymentReceipts)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PaymentReceipts\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PeriodAttendanceType) Clone() (*PeriodAttendanceType) {
return reprint.This(t).(*PeriodAttendanceType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PeriodAttendanceTypePointer(value interface{}) (*PeriodAttendanceType, bool) {
switch t := value.(type) {
        case *PeriodAttendanceType:
                return value.(*PeriodAttendanceType), true
        case PeriodAttendanceType:
                v, _ := value.(PeriodAttendanceType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PeriodAttendanceType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPeriodAttendanceType() *PeriodAttendanceType {
  if out, ok := PeriodAttendanceTypePointer(PeriodAttendanceType{}); !ok {
                log.Fatalf("Could not create pointer to PeriodAttendanceType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PeriodAttendancesType) Clone() (*PeriodAttendancesType) {
return reprint.This(t).(*PeriodAttendancesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PeriodAttendancesTypePointer(value interface{}) (*PeriodAttendancesType, bool) {
switch t := value.(type) {
        case *PeriodAttendancesType:
                return value.(*PeriodAttendancesType), true
        case PeriodAttendancesType:
                v, _ := value.(PeriodAttendancesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PeriodAttendancesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPeriodAttendancesType() *PeriodAttendancesType {
  if out, ok := PeriodAttendancesTypePointer(PeriodAttendancesType{}); !ok {
                log.Fatalf("Could not create pointer to PeriodAttendancesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PermissionToParticipateListType) Clone() (*PermissionToParticipateListType) {
return reprint.This(t).(*PermissionToParticipateListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PermissionToParticipateListTypePointer(value interface{}) (*PermissionToParticipateListType, bool) {
switch t := value.(type) {
        case *PermissionToParticipateListType:
                return value.(*PermissionToParticipateListType), true
        case PermissionToParticipateListType:
                v, _ := value.(PermissionToParticipateListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PermissionToParticipateListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPermissionToParticipateListType() *PermissionToParticipateListType {
  if out, ok := PermissionToParticipateListTypePointer(PermissionToParticipateListType{}); !ok {
                log.Fatalf("Could not create pointer to PermissionToParticipateListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PermissionToParticipateType) Clone() (*PermissionToParticipateType) {
return reprint.This(t).(*PermissionToParticipateType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PermissionToParticipateTypePointer(value interface{}) (*PermissionToParticipateType, bool) {
switch t := value.(type) {
        case *PermissionToParticipateType:
                return value.(*PermissionToParticipateType), true
        case PermissionToParticipateType:
                v, _ := value.(PermissionToParticipateType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PermissionToParticipateType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPermissionToParticipateType() *PermissionToParticipateType {
  if out, ok := PermissionToParticipateTypePointer(PermissionToParticipateType{}); !ok {
                log.Fatalf("Could not create pointer to PermissionToParticipateType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonInfoType) Clone() (*PersonInfoType) {
return reprint.This(t).(*PersonInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonInfoTypePointer(value interface{}) (*PersonInfoType, bool) {
switch t := value.(type) {
        case *PersonInfoType:
                return value.(*PersonInfoType), true
        case PersonInfoType:
                v, _ := value.(PersonInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPersonInfoType() *PersonInfoType {
  if out, ok := PersonInfoTypePointer(PersonInfoType{}); !ok {
                log.Fatalf("Could not create pointer to PersonInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonInvolvementListType) Clone() (*PersonInvolvementListType) {
return reprint.This(t).(*PersonInvolvementListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonInvolvementListTypePointer(value interface{}) (*PersonInvolvementListType, bool) {
switch t := value.(type) {
        case *PersonInvolvementListType:
                return value.(*PersonInvolvementListType), true
        case PersonInvolvementListType:
                v, _ := value.(PersonInvolvementListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonInvolvementListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPersonInvolvementListType() *PersonInvolvementListType {
  if out, ok := PersonInvolvementListTypePointer(PersonInvolvementListType{}); !ok {
                log.Fatalf("Could not create pointer to PersonInvolvementListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonInvolvementType) Clone() (*PersonInvolvementType) {
return reprint.This(t).(*PersonInvolvementType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonInvolvementTypePointer(value interface{}) (*PersonInvolvementType, bool) {
switch t := value.(type) {
        case *PersonInvolvementType:
                return value.(*PersonInvolvementType), true
        case PersonInvolvementType:
                v, _ := value.(PersonInvolvementType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonInvolvementType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPersonInvolvementType() *PersonInvolvementType {
  if out, ok := PersonInvolvementTypePointer(PersonInvolvementType{}); !ok {
                log.Fatalf("Could not create pointer to PersonInvolvementType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonInvolvementType_PersonRefId) Clone() (*PersonInvolvementType_PersonRefId) {
return reprint.This(t).(*PersonInvolvementType_PersonRefId)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonInvolvementType_PersonRefIdPointer(value interface{}) (*PersonInvolvementType_PersonRefId, bool) {
switch t := value.(type) {
        case *PersonInvolvementType_PersonRefId:
                return value.(*PersonInvolvementType_PersonRefId), true
        case PersonInvolvementType_PersonRefId:
                v, _ := value.(PersonInvolvementType_PersonRefId)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonInvolvementType_PersonRefId\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPersonInvolvementType_PersonRefId() *PersonInvolvementType_PersonRefId {
  if out, ok := PersonInvolvementType_PersonRefIdPointer(PersonInvolvementType_PersonRefId{}); !ok {
                log.Fatalf("Could not create pointer to PersonInvolvementType_PersonRefId\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonPicture) Clone() (*PersonPicture) {
return reprint.This(t).(*PersonPicture)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonPicturePointer(value interface{}) (*PersonPicture, bool) {
switch t := value.(type) {
        case *PersonPicture:
                return value.(*PersonPicture), true
        case PersonPicture:
                v, _ := value.(PersonPicture)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonPicture\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPersonPicture() *PersonPicture {
  if out, ok := PersonPicturePointer(PersonPicture{}); !ok {
                log.Fatalf("Could not create pointer to PersonPicture\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonPicture_ParentObjectRefId) Clone() (*PersonPicture_ParentObjectRefId) {
return reprint.This(t).(*PersonPicture_ParentObjectRefId)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonPicture_ParentObjectRefIdPointer(value interface{}) (*PersonPicture_ParentObjectRefId, bool) {
switch t := value.(type) {
        case *PersonPicture_ParentObjectRefId:
                return value.(*PersonPicture_ParentObjectRefId), true
        case PersonPicture_ParentObjectRefId:
                v, _ := value.(PersonPicture_ParentObjectRefId)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonPicture_ParentObjectRefId\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPersonPicture_ParentObjectRefId() *PersonPicture_ParentObjectRefId {
  if out, ok := PersonPicture_ParentObjectRefIdPointer(PersonPicture_ParentObjectRefId{}); !ok {
                log.Fatalf("Could not create pointer to PersonPicture_ParentObjectRefId\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonPictures) Clone() (*PersonPictures) {
return reprint.This(t).(*PersonPictures)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonPicturesPointer(value interface{}) (*PersonPictures, bool) {
switch t := value.(type) {
        case *PersonPictures:
                return value.(*PersonPictures), true
        case PersonPictures:
                v, _ := value.(PersonPictures)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonPictures\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonPrivacyObligationDocument) Clone() (*PersonPrivacyObligationDocument) {
return reprint.This(t).(*PersonPrivacyObligationDocument)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonPrivacyObligationDocumentPointer(value interface{}) (*PersonPrivacyObligationDocument, bool) {
switch t := value.(type) {
        case *PersonPrivacyObligationDocument:
                return value.(*PersonPrivacyObligationDocument), true
        case PersonPrivacyObligationDocument:
                v, _ := value.(PersonPrivacyObligationDocument)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonPrivacyObligationDocument\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPersonPrivacyObligationDocument() *PersonPrivacyObligationDocument {
  if out, ok := PersonPrivacyObligationDocumentPointer(PersonPrivacyObligationDocument{}); !ok {
                log.Fatalf("Could not create pointer to PersonPrivacyObligationDocument\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonPrivacyObligationDocuments) Clone() (*PersonPrivacyObligationDocuments) {
return reprint.This(t).(*PersonPrivacyObligationDocuments)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonPrivacyObligationDocumentsPointer(value interface{}) (*PersonPrivacyObligationDocuments, bool) {
switch t := value.(type) {
        case *PersonPrivacyObligationDocuments:
                return value.(*PersonPrivacyObligationDocuments), true
        case PersonPrivacyObligationDocuments:
                v, _ := value.(PersonPrivacyObligationDocuments)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonPrivacyObligationDocuments\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonalisedPlan) Clone() (*PersonalisedPlan) {
return reprint.This(t).(*PersonalisedPlan)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonalisedPlanPointer(value interface{}) (*PersonalisedPlan, bool) {
switch t := value.(type) {
        case *PersonalisedPlan:
                return value.(*PersonalisedPlan), true
        case PersonalisedPlan:
                v, _ := value.(PersonalisedPlan)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonalisedPlan\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPersonalisedPlan() *PersonalisedPlan {
  if out, ok := PersonalisedPlanPointer(PersonalisedPlan{}); !ok {
                log.Fatalf("Could not create pointer to PersonalisedPlan\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PersonalisedPlans) Clone() (*PersonalisedPlans) {
return reprint.This(t).(*PersonalisedPlans)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PersonalisedPlansPointer(value interface{}) (*PersonalisedPlans, bool) {
switch t := value.(type) {
        case *PersonalisedPlans:
                return value.(*PersonalisedPlans), true
        case PersonalisedPlans:
                v, _ := value.(PersonalisedPlans)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PersonalisedPlans\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PhoneNumberListType) Clone() (*PhoneNumberListType) {
return reprint.This(t).(*PhoneNumberListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PhoneNumberListTypePointer(value interface{}) (*PhoneNumberListType, bool) {
switch t := value.(type) {
        case *PhoneNumberListType:
                return value.(*PhoneNumberListType), true
        case PhoneNumberListType:
                v, _ := value.(PhoneNumberListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PhoneNumberListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPhoneNumberListType() *PhoneNumberListType {
  if out, ok := PhoneNumberListTypePointer(PhoneNumberListType{}); !ok {
                log.Fatalf("Could not create pointer to PhoneNumberListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PhoneNumberType) Clone() (*PhoneNumberType) {
return reprint.This(t).(*PhoneNumberType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PhoneNumberTypePointer(value interface{}) (*PhoneNumberType, bool) {
switch t := value.(type) {
        case *PhoneNumberType:
                return value.(*PhoneNumberType), true
        case PhoneNumberType:
                v, _ := value.(PhoneNumberType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PhoneNumberType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPhoneNumberType() *PhoneNumberType {
  if out, ok := PhoneNumberTypePointer(PhoneNumberType{}); !ok {
                log.Fatalf("Could not create pointer to PhoneNumberType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PictureSourceType) Clone() (*PictureSourceType) {
return reprint.This(t).(*PictureSourceType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PictureSourceTypePointer(value interface{}) (*PictureSourceType, bool) {
switch t := value.(type) {
        case *PictureSourceType:
                return value.(*PictureSourceType), true
        case PictureSourceType:
                v, _ := value.(PictureSourceType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PictureSourceType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPictureSourceType() *PictureSourceType {
  if out, ok := PictureSourceTypePointer(PictureSourceType{}); !ok {
                log.Fatalf("Could not create pointer to PictureSourceType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PlanRequiredContainerType) Clone() (*PlanRequiredContainerType) {
return reprint.This(t).(*PlanRequiredContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PlanRequiredContainerTypePointer(value interface{}) (*PlanRequiredContainerType, bool) {
switch t := value.(type) {
        case *PlanRequiredContainerType:
                return value.(*PlanRequiredContainerType), true
        case PlanRequiredContainerType:
                v, _ := value.(PlanRequiredContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PlanRequiredContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPlanRequiredContainerType() *PlanRequiredContainerType {
  if out, ok := PlanRequiredContainerTypePointer(PlanRequiredContainerType{}); !ok {
                log.Fatalf("Could not create pointer to PlanRequiredContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PlanRequiredListType) Clone() (*PlanRequiredListType) {
return reprint.This(t).(*PlanRequiredListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PlanRequiredListTypePointer(value interface{}) (*PlanRequiredListType, bool) {
switch t := value.(type) {
        case *PlanRequiredListType:
                return value.(*PlanRequiredListType), true
        case PlanRequiredListType:
                v, _ := value.(PlanRequiredListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PlanRequiredListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPlanRequiredListType() *PlanRequiredListType {
  if out, ok := PlanRequiredListTypePointer(PlanRequiredListType{}); !ok {
                log.Fatalf("Could not create pointer to PlanRequiredListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PlausibleScaledValueListType) Clone() (*PlausibleScaledValueListType) {
return reprint.This(t).(*PlausibleScaledValueListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PlausibleScaledValueListTypePointer(value interface{}) (*PlausibleScaledValueListType, bool) {
switch t := value.(type) {
        case *PlausibleScaledValueListType:
                return value.(*PlausibleScaledValueListType), true
        case PlausibleScaledValueListType:
                v, _ := value.(PlausibleScaledValueListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PlausibleScaledValueListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPlausibleScaledValueListType() *PlausibleScaledValueListType {
  if out, ok := PlausibleScaledValueListTypePointer(PlausibleScaledValueListType{}); !ok {
                log.Fatalf("Could not create pointer to PlausibleScaledValueListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PrerequisitesType) Clone() (*PrerequisitesType) {
return reprint.This(t).(*PrerequisitesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PrerequisitesTypePointer(value interface{}) (*PrerequisitesType, bool) {
switch t := value.(type) {
        case *PrerequisitesType:
                return value.(*PrerequisitesType), true
        case PrerequisitesType:
                v, _ := value.(PrerequisitesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PrerequisitesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPrerequisitesType() *PrerequisitesType {
  if out, ok := PrerequisitesTypePointer(PrerequisitesType{}); !ok {
                log.Fatalf("Could not create pointer to PrerequisitesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PreviousSchoolListType) Clone() (*PreviousSchoolListType) {
return reprint.This(t).(*PreviousSchoolListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PreviousSchoolListTypePointer(value interface{}) (*PreviousSchoolListType, bool) {
switch t := value.(type) {
        case *PreviousSchoolListType:
                return value.(*PreviousSchoolListType), true
        case PreviousSchoolListType:
                v, _ := value.(PreviousSchoolListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PreviousSchoolListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPreviousSchoolListType() *PreviousSchoolListType {
  if out, ok := PreviousSchoolListTypePointer(PreviousSchoolListType{}); !ok {
                log.Fatalf("Could not create pointer to PreviousSchoolListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PreviousSchoolType) Clone() (*PreviousSchoolType) {
return reprint.This(t).(*PreviousSchoolType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PreviousSchoolTypePointer(value interface{}) (*PreviousSchoolType, bool) {
switch t := value.(type) {
        case *PreviousSchoolType:
                return value.(*PreviousSchoolType), true
        case PreviousSchoolType:
                v, _ := value.(PreviousSchoolType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PreviousSchoolType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPreviousSchoolType() *PreviousSchoolType {
  if out, ok := PreviousSchoolTypePointer(PreviousSchoolType{}); !ok {
                log.Fatalf("Could not create pointer to PreviousSchoolType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PrincipalInfoType) Clone() (*PrincipalInfoType) {
return reprint.This(t).(*PrincipalInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PrincipalInfoTypePointer(value interface{}) (*PrincipalInfoType, bool) {
switch t := value.(type) {
        case *PrincipalInfoType:
                return value.(*PrincipalInfoType), true
        case PrincipalInfoType:
                v, _ := value.(PrincipalInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PrincipalInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPrincipalInfoType() *PrincipalInfoType {
  if out, ok := PrincipalInfoTypePointer(PrincipalInfoType{}); !ok {
                log.Fatalf("Could not create pointer to PrincipalInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PrivateHealthInsuranceType) Clone() (*PrivateHealthInsuranceType) {
return reprint.This(t).(*PrivateHealthInsuranceType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PrivateHealthInsuranceTypePointer(value interface{}) (*PrivateHealthInsuranceType, bool) {
switch t := value.(type) {
        case *PrivateHealthInsuranceType:
                return value.(*PrivateHealthInsuranceType), true
        case PrivateHealthInsuranceType:
                v, _ := value.(PrivateHealthInsuranceType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PrivateHealthInsuranceType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPrivateHealthInsuranceType() *PrivateHealthInsuranceType {
  if out, ok := PrivateHealthInsuranceTypePointer(PrivateHealthInsuranceType{}); !ok {
                log.Fatalf("Could not create pointer to PrivateHealthInsuranceType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ProgramAvailabilityType) Clone() (*ProgramAvailabilityType) {
return reprint.This(t).(*ProgramAvailabilityType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ProgramAvailabilityTypePointer(value interface{}) (*ProgramAvailabilityType, bool) {
switch t := value.(type) {
        case *ProgramAvailabilityType:
                return value.(*ProgramAvailabilityType), true
        case ProgramAvailabilityType:
                v, _ := value.(ProgramAvailabilityType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ProgramAvailabilityType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewProgramAvailabilityType() *ProgramAvailabilityType {
  if out, ok := ProgramAvailabilityTypePointer(ProgramAvailabilityType{}); !ok {
                log.Fatalf("Could not create pointer to ProgramAvailabilityType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ProgramFundingSourceType) Clone() (*ProgramFundingSourceType) {
return reprint.This(t).(*ProgramFundingSourceType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ProgramFundingSourceTypePointer(value interface{}) (*ProgramFundingSourceType, bool) {
switch t := value.(type) {
        case *ProgramFundingSourceType:
                return value.(*ProgramFundingSourceType), true
        case ProgramFundingSourceType:
                v, _ := value.(ProgramFundingSourceType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ProgramFundingSourceType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewProgramFundingSourceType() *ProgramFundingSourceType {
  if out, ok := ProgramFundingSourceTypePointer(ProgramFundingSourceType{}); !ok {
                log.Fatalf("Could not create pointer to ProgramFundingSourceType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ProgramFundingSourcesType) Clone() (*ProgramFundingSourcesType) {
return reprint.This(t).(*ProgramFundingSourcesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ProgramFundingSourcesTypePointer(value interface{}) (*ProgramFundingSourcesType, bool) {
switch t := value.(type) {
        case *ProgramFundingSourcesType:
                return value.(*ProgramFundingSourcesType), true
        case ProgramFundingSourcesType:
                v, _ := value.(ProgramFundingSourcesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ProgramFundingSourcesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewProgramFundingSourcesType() *ProgramFundingSourcesType {
  if out, ok := ProgramFundingSourcesTypePointer(ProgramFundingSourcesType{}); !ok {
                log.Fatalf("Could not create pointer to ProgramFundingSourcesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ProgramStatusType) Clone() (*ProgramStatusType) {
return reprint.This(t).(*ProgramStatusType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ProgramStatusTypePointer(value interface{}) (*ProgramStatusType, bool) {
switch t := value.(type) {
        case *ProgramStatusType:
                return value.(*ProgramStatusType), true
        case ProgramStatusType:
                v, _ := value.(ProgramStatusType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ProgramStatusType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewProgramStatusType() *ProgramStatusType {
  if out, ok := ProgramStatusTypePointer(ProgramStatusType{}); !ok {
                log.Fatalf("Could not create pointer to ProgramStatusType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PromotionInfoType) Clone() (*PromotionInfoType) {
return reprint.This(t).(*PromotionInfoType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PromotionInfoTypePointer(value interface{}) (*PromotionInfoType, bool) {
switch t := value.(type) {
        case *PromotionInfoType:
                return value.(*PromotionInfoType), true
        case PromotionInfoType:
                v, _ := value.(PromotionInfoType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PromotionInfoType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPromotionInfoType() *PromotionInfoType {
  if out, ok := PromotionInfoTypePointer(PromotionInfoType{}); !ok {
                log.Fatalf("Could not create pointer to PromotionInfoType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PublishingPermissionListType) Clone() (*PublishingPermissionListType) {
return reprint.This(t).(*PublishingPermissionListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PublishingPermissionListTypePointer(value interface{}) (*PublishingPermissionListType, bool) {
switch t := value.(type) {
        case *PublishingPermissionListType:
                return value.(*PublishingPermissionListType), true
        case PublishingPermissionListType:
                v, _ := value.(PublishingPermissionListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PublishingPermissionListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPublishingPermissionListType() *PublishingPermissionListType {
  if out, ok := PublishingPermissionListTypePointer(PublishingPermissionListType{}); !ok {
                log.Fatalf("Could not create pointer to PublishingPermissionListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PublishingPermissionType) Clone() (*PublishingPermissionType) {
return reprint.This(t).(*PublishingPermissionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PublishingPermissionTypePointer(value interface{}) (*PublishingPermissionType, bool) {
switch t := value.(type) {
        case *PublishingPermissionType:
                return value.(*PublishingPermissionType), true
        case PublishingPermissionType:
                v, _ := value.(PublishingPermissionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PublishingPermissionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPublishingPermissionType() *PublishingPermissionType {
  if out, ok := PublishingPermissionTypePointer(PublishingPermissionType{}); !ok {
                log.Fatalf("Could not create pointer to PublishingPermissionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PurchaseOrder) Clone() (*PurchaseOrder) {
return reprint.This(t).(*PurchaseOrder)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PurchaseOrderPointer(value interface{}) (*PurchaseOrder, bool) {
switch t := value.(type) {
        case *PurchaseOrder:
                return value.(*PurchaseOrder), true
        case PurchaseOrder:
                v, _ := value.(PurchaseOrder)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PurchaseOrder\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPurchaseOrder() *PurchaseOrder {
  if out, ok := PurchaseOrderPointer(PurchaseOrder{}); !ok {
                log.Fatalf("Could not create pointer to PurchaseOrder\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PurchaseOrders) Clone() (*PurchaseOrders) {
return reprint.This(t).(*PurchaseOrders)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PurchaseOrdersPointer(value interface{}) (*PurchaseOrders, bool) {
switch t := value.(type) {
        case *PurchaseOrders:
                return value.(*PurchaseOrders), true
        case PurchaseOrders:
                v, _ := value.(PurchaseOrders)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PurchaseOrders\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PurchasingItemType) Clone() (*PurchasingItemType) {
return reprint.This(t).(*PurchasingItemType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PurchasingItemTypePointer(value interface{}) (*PurchasingItemType, bool) {
switch t := value.(type) {
        case *PurchasingItemType:
                return value.(*PurchasingItemType), true
        case PurchasingItemType:
                v, _ := value.(PurchasingItemType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PurchasingItemType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPurchasingItemType() *PurchasingItemType {
  if out, ok := PurchasingItemTypePointer(PurchasingItemType{}); !ok {
                log.Fatalf("Could not create pointer to PurchasingItemType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *PurchasingItemsType) Clone() (*PurchasingItemsType) {
return reprint.This(t).(*PurchasingItemsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func PurchasingItemsTypePointer(value interface{}) (*PurchasingItemsType, bool) {
switch t := value.(type) {
        case *PurchasingItemsType:
                return value.(*PurchasingItemsType), true
        case PurchasingItemsType:
                v, _ := value.(PurchasingItemsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to PurchasingItemsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewPurchasingItemsType() *PurchasingItemsType {
  if out, ok := PurchasingItemsTypePointer(PurchasingItemsType{}); !ok {
                log.Fatalf("Could not create pointer to PurchasingItemsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *RecognitionListType) Clone() (*RecognitionListType) {
return reprint.This(t).(*RecognitionListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func RecognitionListTypePointer(value interface{}) (*RecognitionListType, bool) {
switch t := value.(type) {
        case *RecognitionListType:
                return value.(*RecognitionListType), true
        case RecognitionListType:
                v, _ := value.(RecognitionListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to RecognitionListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewRecognitionListType() *RecognitionListType {
  if out, ok := RecognitionListTypePointer(RecognitionListType{}); !ok {
                log.Fatalf("Could not create pointer to RecognitionListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ReferenceDataType) Clone() (*ReferenceDataType) {
return reprint.This(t).(*ReferenceDataType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ReferenceDataTypePointer(value interface{}) (*ReferenceDataType, bool) {
switch t := value.(type) {
        case *ReferenceDataType:
                return value.(*ReferenceDataType), true
        case ReferenceDataType:
                v, _ := value.(ReferenceDataType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ReferenceDataType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewReferenceDataType() *ReferenceDataType {
  if out, ok := ReferenceDataTypePointer(ReferenceDataType{}); !ok {
                log.Fatalf("Could not create pointer to ReferenceDataType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ReferralSourceType) Clone() (*ReferralSourceType) {
return reprint.This(t).(*ReferralSourceType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ReferralSourceTypePointer(value interface{}) (*ReferralSourceType, bool) {
switch t := value.(type) {
        case *ReferralSourceType:
                return value.(*ReferralSourceType), true
        case ReferralSourceType:
                v, _ := value.(ReferralSourceType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ReferralSourceType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewReferralSourceType() *ReferralSourceType {
  if out, ok := ReferralSourceTypePointer(ReferralSourceType{}); !ok {
                log.Fatalf("Could not create pointer to ReferralSourceType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *RelatedLearningStandardItemRefIdListType) Clone() (*RelatedLearningStandardItemRefIdListType) {
return reprint.This(t).(*RelatedLearningStandardItemRefIdListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func RelatedLearningStandardItemRefIdListTypePointer(value interface{}) (*RelatedLearningStandardItemRefIdListType, bool) {
switch t := value.(type) {
        case *RelatedLearningStandardItemRefIdListType:
                return value.(*RelatedLearningStandardItemRefIdListType), true
        case RelatedLearningStandardItemRefIdListType:
                v, _ := value.(RelatedLearningStandardItemRefIdListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to RelatedLearningStandardItemRefIdListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewRelatedLearningStandardItemRefIdListType() *RelatedLearningStandardItemRefIdListType {
  if out, ok := RelatedLearningStandardItemRefIdListTypePointer(RelatedLearningStandardItemRefIdListType{}); !ok {
                log.Fatalf("Could not create pointer to RelatedLearningStandardItemRefIdListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *RelatedLearningStandardItemRefIdType) Clone() (*RelatedLearningStandardItemRefIdType) {
return reprint.This(t).(*RelatedLearningStandardItemRefIdType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func RelatedLearningStandardItemRefIdTypePointer(value interface{}) (*RelatedLearningStandardItemRefIdType, bool) {
switch t := value.(type) {
        case *RelatedLearningStandardItemRefIdType:
                return value.(*RelatedLearningStandardItemRefIdType), true
        case RelatedLearningStandardItemRefIdType:
                v, _ := value.(RelatedLearningStandardItemRefIdType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to RelatedLearningStandardItemRefIdType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewRelatedLearningStandardItemRefIdType() *RelatedLearningStandardItemRefIdType {
  if out, ok := RelatedLearningStandardItemRefIdTypePointer(RelatedLearningStandardItemRefIdType{}); !ok {
                log.Fatalf("Could not create pointer to RelatedLearningStandardItemRefIdType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *RelationshipType) Clone() (*RelationshipType) {
return reprint.This(t).(*RelationshipType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func RelationshipTypePointer(value interface{}) (*RelationshipType, bool) {
switch t := value.(type) {
        case *RelationshipType:
                return value.(*RelationshipType), true
        case RelationshipType:
                v, _ := value.(RelationshipType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to RelationshipType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewRelationshipType() *RelationshipType {
  if out, ok := RelationshipTypePointer(RelationshipType{}); !ok {
                log.Fatalf("Could not create pointer to RelationshipType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ReligionType) Clone() (*ReligionType) {
return reprint.This(t).(*ReligionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ReligionTypePointer(value interface{}) (*ReligionType, bool) {
switch t := value.(type) {
        case *ReligionType:
                return value.(*ReligionType), true
        case ReligionType:
                v, _ := value.(ReligionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ReligionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewReligionType() *ReligionType {
  if out, ok := ReligionTypePointer(ReligionType{}); !ok {
                log.Fatalf("Could not create pointer to ReligionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ReligiousEventListType) Clone() (*ReligiousEventListType) {
return reprint.This(t).(*ReligiousEventListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ReligiousEventListTypePointer(value interface{}) (*ReligiousEventListType, bool) {
switch t := value.(type) {
        case *ReligiousEventListType:
                return value.(*ReligiousEventListType), true
        case ReligiousEventListType:
                v, _ := value.(ReligiousEventListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ReligiousEventListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewReligiousEventListType() *ReligiousEventListType {
  if out, ok := ReligiousEventListTypePointer(ReligiousEventListType{}); !ok {
                log.Fatalf("Could not create pointer to ReligiousEventListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ReligiousEventType) Clone() (*ReligiousEventType) {
return reprint.This(t).(*ReligiousEventType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ReligiousEventTypePointer(value interface{}) (*ReligiousEventType, bool) {
switch t := value.(type) {
        case *ReligiousEventType:
                return value.(*ReligiousEventType), true
        case ReligiousEventType:
                v, _ := value.(ReligiousEventType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ReligiousEventType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewReligiousEventType() *ReligiousEventType {
  if out, ok := ReligiousEventTypePointer(ReligiousEventType{}); !ok {
                log.Fatalf("Could not create pointer to ReligiousEventType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ReportingAuthorityListType) Clone() (*ReportingAuthorityListType) {
return reprint.This(t).(*ReportingAuthorityListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ReportingAuthorityListTypePointer(value interface{}) (*ReportingAuthorityListType, bool) {
switch t := value.(type) {
        case *ReportingAuthorityListType:
                return value.(*ReportingAuthorityListType), true
        case ReportingAuthorityListType:
                v, _ := value.(ReportingAuthorityListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ReportingAuthorityListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewReportingAuthorityListType() *ReportingAuthorityListType {
  if out, ok := ReportingAuthorityListTypePointer(ReportingAuthorityListType{}); !ok {
                log.Fatalf("Could not create pointer to ReportingAuthorityListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ReportingAuthorityType) Clone() (*ReportingAuthorityType) {
return reprint.This(t).(*ReportingAuthorityType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ReportingAuthorityTypePointer(value interface{}) (*ReportingAuthorityType, bool) {
switch t := value.(type) {
        case *ReportingAuthorityType:
                return value.(*ReportingAuthorityType), true
        case ReportingAuthorityType:
                v, _ := value.(ReportingAuthorityType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ReportingAuthorityType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewReportingAuthorityType() *ReportingAuthorityType {
  if out, ok := ReportingAuthorityTypePointer(ReportingAuthorityType{}); !ok {
                log.Fatalf("Could not create pointer to ReportingAuthorityType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ResourceBooking) Clone() (*ResourceBooking) {
return reprint.This(t).(*ResourceBooking)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ResourceBookingPointer(value interface{}) (*ResourceBooking, bool) {
switch t := value.(type) {
        case *ResourceBooking:
                return value.(*ResourceBooking), true
        case ResourceBooking:
                v, _ := value.(ResourceBooking)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ResourceBooking\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewResourceBooking() *ResourceBooking {
  if out, ok := ResourceBookingPointer(ResourceBooking{}); !ok {
                log.Fatalf("Could not create pointer to ResourceBooking\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ResourceBooking_ResourceRefId) Clone() (*ResourceBooking_ResourceRefId) {
return reprint.This(t).(*ResourceBooking_ResourceRefId)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ResourceBooking_ResourceRefIdPointer(value interface{}) (*ResourceBooking_ResourceRefId, bool) {
switch t := value.(type) {
        case *ResourceBooking_ResourceRefId:
                return value.(*ResourceBooking_ResourceRefId), true
        case ResourceBooking_ResourceRefId:
                v, _ := value.(ResourceBooking_ResourceRefId)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ResourceBooking_ResourceRefId\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewResourceBooking_ResourceRefId() *ResourceBooking_ResourceRefId {
  if out, ok := ResourceBooking_ResourceRefIdPointer(ResourceBooking_ResourceRefId{}); !ok {
                log.Fatalf("Could not create pointer to ResourceBooking_ResourceRefId\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ResourceBookings) Clone() (*ResourceBookings) {
return reprint.This(t).(*ResourceBookings)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ResourceBookingsPointer(value interface{}) (*ResourceBookings, bool) {
switch t := value.(type) {
        case *ResourceBookings:
                return value.(*ResourceBookings), true
        case ResourceBookings:
                v, _ := value.(ResourceBookings)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ResourceBookings\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ResourcesType) Clone() (*ResourcesType) {
return reprint.This(t).(*ResourcesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ResourcesTypePointer(value interface{}) (*ResourcesType, bool) {
switch t := value.(type) {
        case *ResourcesType:
                return value.(*ResourcesType), true
        case ResourcesType:
                v, _ := value.(ResourcesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ResourcesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewResourcesType() *ResourcesType {
  if out, ok := ResourcesTypePointer(ResourcesType{}); !ok {
                log.Fatalf("Could not create pointer to ResourcesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *RoomInfo) Clone() (*RoomInfo) {
return reprint.This(t).(*RoomInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func RoomInfoPointer(value interface{}) (*RoomInfo, bool) {
switch t := value.(type) {
        case *RoomInfo:
                return value.(*RoomInfo), true
        case RoomInfo:
                v, _ := value.(RoomInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to RoomInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewRoomInfo() *RoomInfo {
  if out, ok := RoomInfoPointer(RoomInfo{}); !ok {
                log.Fatalf("Could not create pointer to RoomInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *RoomInfos) Clone() (*RoomInfos) {
return reprint.This(t).(*RoomInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func RoomInfosPointer(value interface{}) (*RoomInfos, bool) {
switch t := value.(type) {
        case *RoomInfos:
                return value.(*RoomInfos), true
        case RoomInfos:
                v, _ := value.(RoomInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to RoomInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *RoomListType) Clone() (*RoomListType) {
return reprint.This(t).(*RoomListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func RoomListTypePointer(value interface{}) (*RoomListType, bool) {
switch t := value.(type) {
        case *RoomListType:
                return value.(*RoomListType), true
        case RoomListType:
                v, _ := value.(RoomListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to RoomListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewRoomListType() *RoomListType {
  if out, ok := RoomListTypePointer(RoomListType{}); !ok {
                log.Fatalf("Could not create pointer to RoomListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SIF_ExtendedElementsType) Clone() (*SIF_ExtendedElementsType) {
return reprint.This(t).(*SIF_ExtendedElementsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SIF_ExtendedElementsTypePointer(value interface{}) (*SIF_ExtendedElementsType, bool) {
switch t := value.(type) {
        case *SIF_ExtendedElementsType:
                return value.(*SIF_ExtendedElementsType), true
        case SIF_ExtendedElementsType:
                v, _ := value.(SIF_ExtendedElementsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SIF_ExtendedElementsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSIF_ExtendedElementsType() *SIF_ExtendedElementsType {
  if out, ok := SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); !ok {
                log.Fatalf("Could not create pointer to SIF_ExtendedElementsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SIF_ExtendedElementsType_SIF_ExtendedElement) Clone() (*SIF_ExtendedElementsType_SIF_ExtendedElement) {
return reprint.This(t).(*SIF_ExtendedElementsType_SIF_ExtendedElement)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SIF_ExtendedElementsType_SIF_ExtendedElementPointer(value interface{}) (*SIF_ExtendedElementsType_SIF_ExtendedElement, bool) {
switch t := value.(type) {
        case *SIF_ExtendedElementsType_SIF_ExtendedElement:
                return value.(*SIF_ExtendedElementsType_SIF_ExtendedElement), true
        case SIF_ExtendedElementsType_SIF_ExtendedElement:
                v, _ := value.(SIF_ExtendedElementsType_SIF_ExtendedElement)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SIF_ExtendedElementsType_SIF_ExtendedElement\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSIF_ExtendedElementsType_SIF_ExtendedElement() *SIF_ExtendedElementsType_SIF_ExtendedElement {
  if out, ok := SIF_ExtendedElementsType_SIF_ExtendedElementPointer(SIF_ExtendedElementsType_SIF_ExtendedElement{}); !ok {
                log.Fatalf("Could not create pointer to SIF_ExtendedElementsType_SIF_ExtendedElement\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SIF_MetadataType) Clone() (*SIF_MetadataType) {
return reprint.This(t).(*SIF_MetadataType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SIF_MetadataTypePointer(value interface{}) (*SIF_MetadataType, bool) {
switch t := value.(type) {
        case *SIF_MetadataType:
                return value.(*SIF_MetadataType), true
        case SIF_MetadataType:
                v, _ := value.(SIF_MetadataType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SIF_MetadataType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSIF_MetadataType() *SIF_MetadataType {
  if out, ok := SIF_MetadataTypePointer(SIF_MetadataType{}); !ok {
                log.Fatalf("Could not create pointer to SIF_MetadataType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *STDNAttachmentListType) Clone() (*STDNAttachmentListType) {
return reprint.This(t).(*STDNAttachmentListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func STDNAttachmentListTypePointer(value interface{}) (*STDNAttachmentListType, bool) {
switch t := value.(type) {
        case *STDNAttachmentListType:
                return value.(*STDNAttachmentListType), true
        case STDNAttachmentListType:
                v, _ := value.(STDNAttachmentListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to STDNAttachmentListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSTDNAttachmentListType() *STDNAttachmentListType {
  if out, ok := STDNAttachmentListTypePointer(STDNAttachmentListType{}); !ok {
                log.Fatalf("Could not create pointer to STDNAttachmentListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *STDNAttachmentType) Clone() (*STDNAttachmentType) {
return reprint.This(t).(*STDNAttachmentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func STDNAttachmentTypePointer(value interface{}) (*STDNAttachmentType, bool) {
switch t := value.(type) {
        case *STDNAttachmentType:
                return value.(*STDNAttachmentType), true
        case STDNAttachmentType:
                v, _ := value.(STDNAttachmentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to STDNAttachmentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSTDNAttachmentType() *STDNAttachmentType {
  if out, ok := STDNAttachmentTypePointer(STDNAttachmentType{}); !ok {
                log.Fatalf("Could not create pointer to STDNAttachmentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *STDNGradeListType) Clone() (*STDNGradeListType) {
return reprint.This(t).(*STDNGradeListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func STDNGradeListTypePointer(value interface{}) (*STDNGradeListType, bool) {
switch t := value.(type) {
        case *STDNGradeListType:
                return value.(*STDNGradeListType), true
        case STDNGradeListType:
                v, _ := value.(STDNGradeListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to STDNGradeListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSTDNGradeListType() *STDNGradeListType {
  if out, ok := STDNGradeListTypePointer(STDNGradeListType{}); !ok {
                log.Fatalf("Could not create pointer to STDNGradeListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *STDNGradeType) Clone() (*STDNGradeType) {
return reprint.This(t).(*STDNGradeType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func STDNGradeTypePointer(value interface{}) (*STDNGradeType, bool) {
switch t := value.(type) {
        case *STDNGradeType:
                return value.(*STDNGradeType), true
        case STDNGradeType:
                v, _ := value.(STDNGradeType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to STDNGradeType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSTDNGradeType() *STDNGradeType {
  if out, ok := STDNGradeTypePointer(STDNGradeType{}); !ok {
                log.Fatalf("Could not create pointer to STDNGradeType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *STDNSupportNeedsType) Clone() (*STDNSupportNeedsType) {
return reprint.This(t).(*STDNSupportNeedsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func STDNSupportNeedsTypePointer(value interface{}) (*STDNSupportNeedsType, bool) {
switch t := value.(type) {
        case *STDNSupportNeedsType:
                return value.(*STDNSupportNeedsType), true
        case STDNSupportNeedsType:
                v, _ := value.(STDNSupportNeedsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to STDNSupportNeedsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSTDNSupportNeedsType() *STDNSupportNeedsType {
  if out, ok := STDNSupportNeedsTypePointer(STDNSupportNeedsType{}); !ok {
                log.Fatalf("Could not create pointer to STDNSupportNeedsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ScheduledActivity) Clone() (*ScheduledActivity) {
return reprint.This(t).(*ScheduledActivity)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ScheduledActivityPointer(value interface{}) (*ScheduledActivity, bool) {
switch t := value.(type) {
        case *ScheduledActivity:
                return value.(*ScheduledActivity), true
        case ScheduledActivity:
                v, _ := value.(ScheduledActivity)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ScheduledActivity\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewScheduledActivity() *ScheduledActivity {
  if out, ok := ScheduledActivityPointer(ScheduledActivity{}); !ok {
                log.Fatalf("Could not create pointer to ScheduledActivity\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ScheduledActivityOverrideType) Clone() (*ScheduledActivityOverrideType) {
return reprint.This(t).(*ScheduledActivityOverrideType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ScheduledActivityOverrideTypePointer(value interface{}) (*ScheduledActivityOverrideType, bool) {
switch t := value.(type) {
        case *ScheduledActivityOverrideType:
                return value.(*ScheduledActivityOverrideType), true
        case ScheduledActivityOverrideType:
                v, _ := value.(ScheduledActivityOverrideType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ScheduledActivityOverrideType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewScheduledActivityOverrideType() *ScheduledActivityOverrideType {
  if out, ok := ScheduledActivityOverrideTypePointer(ScheduledActivityOverrideType{}); !ok {
                log.Fatalf("Could not create pointer to ScheduledActivityOverrideType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ScheduledActivitys) Clone() (*ScheduledActivitys) {
return reprint.This(t).(*ScheduledActivitys)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ScheduledActivitysPointer(value interface{}) (*ScheduledActivitys, bool) {
switch t := value.(type) {
        case *ScheduledActivitys:
                return value.(*ScheduledActivitys), true
        case ScheduledActivitys:
                v, _ := value.(ScheduledActivitys)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ScheduledActivitys\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ScheduledTeacherListType) Clone() (*ScheduledTeacherListType) {
return reprint.This(t).(*ScheduledTeacherListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ScheduledTeacherListTypePointer(value interface{}) (*ScheduledTeacherListType, bool) {
switch t := value.(type) {
        case *ScheduledTeacherListType:
                return value.(*ScheduledTeacherListType), true
        case ScheduledTeacherListType:
                v, _ := value.(ScheduledTeacherListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ScheduledTeacherListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewScheduledTeacherListType() *ScheduledTeacherListType {
  if out, ok := ScheduledTeacherListTypePointer(ScheduledTeacherListType{}); !ok {
                log.Fatalf("Could not create pointer to ScheduledTeacherListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolContactListType) Clone() (*SchoolContactListType) {
return reprint.This(t).(*SchoolContactListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolContactListTypePointer(value interface{}) (*SchoolContactListType, bool) {
switch t := value.(type) {
        case *SchoolContactListType:
                return value.(*SchoolContactListType), true
        case SchoolContactListType:
                v, _ := value.(SchoolContactListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolContactListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolContactListType() *SchoolContactListType {
  if out, ok := SchoolContactListTypePointer(SchoolContactListType{}); !ok {
                log.Fatalf("Could not create pointer to SchoolContactListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolContactType) Clone() (*SchoolContactType) {
return reprint.This(t).(*SchoolContactType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolContactTypePointer(value interface{}) (*SchoolContactType, bool) {
switch t := value.(type) {
        case *SchoolContactType:
                return value.(*SchoolContactType), true
        case SchoolContactType:
                v, _ := value.(SchoolContactType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolContactType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolContactType() *SchoolContactType {
  if out, ok := SchoolContactTypePointer(SchoolContactType{}); !ok {
                log.Fatalf("Could not create pointer to SchoolContactType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolCourseInfo) Clone() (*SchoolCourseInfo) {
return reprint.This(t).(*SchoolCourseInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolCourseInfoPointer(value interface{}) (*SchoolCourseInfo, bool) {
switch t := value.(type) {
        case *SchoolCourseInfo:
                return value.(*SchoolCourseInfo), true
        case SchoolCourseInfo:
                v, _ := value.(SchoolCourseInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolCourseInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolCourseInfo() *SchoolCourseInfo {
  if out, ok := SchoolCourseInfoPointer(SchoolCourseInfo{}); !ok {
                log.Fatalf("Could not create pointer to SchoolCourseInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolCourseInfoOverrideType) Clone() (*SchoolCourseInfoOverrideType) {
return reprint.This(t).(*SchoolCourseInfoOverrideType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolCourseInfoOverrideTypePointer(value interface{}) (*SchoolCourseInfoOverrideType, bool) {
switch t := value.(type) {
        case *SchoolCourseInfoOverrideType:
                return value.(*SchoolCourseInfoOverrideType), true
        case SchoolCourseInfoOverrideType:
                v, _ := value.(SchoolCourseInfoOverrideType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolCourseInfoOverrideType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolCourseInfoOverrideType() *SchoolCourseInfoOverrideType {
  if out, ok := SchoolCourseInfoOverrideTypePointer(SchoolCourseInfoOverrideType{}); !ok {
                log.Fatalf("Could not create pointer to SchoolCourseInfoOverrideType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolCourseInfos) Clone() (*SchoolCourseInfos) {
return reprint.This(t).(*SchoolCourseInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolCourseInfosPointer(value interface{}) (*SchoolCourseInfos, bool) {
switch t := value.(type) {
        case *SchoolCourseInfos:
                return value.(*SchoolCourseInfos), true
        case SchoolCourseInfos:
                v, _ := value.(SchoolCourseInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolCourseInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolFocusListType) Clone() (*SchoolFocusListType) {
return reprint.This(t).(*SchoolFocusListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolFocusListTypePointer(value interface{}) (*SchoolFocusListType, bool) {
switch t := value.(type) {
        case *SchoolFocusListType:
                return value.(*SchoolFocusListType), true
        case SchoolFocusListType:
                v, _ := value.(SchoolFocusListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolFocusListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolFocusListType() *SchoolFocusListType {
  if out, ok := SchoolFocusListTypePointer(SchoolFocusListType{}); !ok {
                log.Fatalf("Could not create pointer to SchoolFocusListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolGroupListType) Clone() (*SchoolGroupListType) {
return reprint.This(t).(*SchoolGroupListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolGroupListTypePointer(value interface{}) (*SchoolGroupListType, bool) {
switch t := value.(type) {
        case *SchoolGroupListType:
                return value.(*SchoolGroupListType), true
        case SchoolGroupListType:
                v, _ := value.(SchoolGroupListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolGroupListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolGroupListType() *SchoolGroupListType {
  if out, ok := SchoolGroupListTypePointer(SchoolGroupListType{}); !ok {
                log.Fatalf("Could not create pointer to SchoolGroupListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolInfo) Clone() (*SchoolInfo) {
return reprint.This(t).(*SchoolInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolInfoPointer(value interface{}) (*SchoolInfo, bool) {
switch t := value.(type) {
        case *SchoolInfo:
                return value.(*SchoolInfo), true
        case SchoolInfo:
                v, _ := value.(SchoolInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolInfo() *SchoolInfo {
  if out, ok := SchoolInfoPointer(SchoolInfo{}); !ok {
                log.Fatalf("Could not create pointer to SchoolInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolInfo_OtherLEA) Clone() (*SchoolInfo_OtherLEA) {
return reprint.This(t).(*SchoolInfo_OtherLEA)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolInfo_OtherLEAPointer(value interface{}) (*SchoolInfo_OtherLEA, bool) {
switch t := value.(type) {
        case *SchoolInfo_OtherLEA:
                return value.(*SchoolInfo_OtherLEA), true
        case SchoolInfo_OtherLEA:
                v, _ := value.(SchoolInfo_OtherLEA)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolInfo_OtherLEA\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolInfo_OtherLEA() *SchoolInfo_OtherLEA {
  if out, ok := SchoolInfo_OtherLEAPointer(SchoolInfo_OtherLEA{}); !ok {
                log.Fatalf("Could not create pointer to SchoolInfo_OtherLEA\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolInfos) Clone() (*SchoolInfos) {
return reprint.This(t).(*SchoolInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolInfosPointer(value interface{}) (*SchoolInfos, bool) {
switch t := value.(type) {
        case *SchoolInfos:
                return value.(*SchoolInfos), true
        case SchoolInfos:
                v, _ := value.(SchoolInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolProgramListType) Clone() (*SchoolProgramListType) {
return reprint.This(t).(*SchoolProgramListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolProgramListTypePointer(value interface{}) (*SchoolProgramListType, bool) {
switch t := value.(type) {
        case *SchoolProgramListType:
                return value.(*SchoolProgramListType), true
        case SchoolProgramListType:
                v, _ := value.(SchoolProgramListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolProgramListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolProgramListType() *SchoolProgramListType {
  if out, ok := SchoolProgramListTypePointer(SchoolProgramListType{}); !ok {
                log.Fatalf("Could not create pointer to SchoolProgramListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolProgramType) Clone() (*SchoolProgramType) {
return reprint.This(t).(*SchoolProgramType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolProgramTypePointer(value interface{}) (*SchoolProgramType, bool) {
switch t := value.(type) {
        case *SchoolProgramType:
                return value.(*SchoolProgramType), true
        case SchoolProgramType:
                v, _ := value.(SchoolProgramType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolProgramType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolProgramType() *SchoolProgramType {
  if out, ok := SchoolProgramTypePointer(SchoolProgramType{}); !ok {
                log.Fatalf("Could not create pointer to SchoolProgramType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolPrograms) Clone() (*SchoolPrograms) {
return reprint.This(t).(*SchoolPrograms)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolProgramsPointer(value interface{}) (*SchoolPrograms, bool) {
switch t := value.(type) {
        case *SchoolPrograms:
                return value.(*SchoolPrograms), true
        case SchoolPrograms:
                v, _ := value.(SchoolPrograms)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolPrograms\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolPrograms() *SchoolPrograms {
  if out, ok := SchoolProgramsPointer(SchoolPrograms{}); !ok {
                log.Fatalf("Could not create pointer to SchoolPrograms\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolProgramss) Clone() (*SchoolProgramss) {
return reprint.This(t).(*SchoolProgramss)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolProgramssPointer(value interface{}) (*SchoolProgramss, bool) {
switch t := value.(type) {
        case *SchoolProgramss:
                return value.(*SchoolProgramss), true
        case SchoolProgramss:
                v, _ := value.(SchoolProgramss)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolProgramss\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SchoolTravelType) Clone() (*SchoolTravelType) {
return reprint.This(t).(*SchoolTravelType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SchoolTravelTypePointer(value interface{}) (*SchoolTravelType, bool) {
switch t := value.(type) {
        case *SchoolTravelType:
                return value.(*SchoolTravelType), true
        case SchoolTravelType:
                v, _ := value.(SchoolTravelType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SchoolTravelType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSchoolTravelType() *SchoolTravelType {
  if out, ok := SchoolTravelTypePointer(SchoolTravelType{}); !ok {
                log.Fatalf("Could not create pointer to SchoolTravelType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ScoreDescriptionListType) Clone() (*ScoreDescriptionListType) {
return reprint.This(t).(*ScoreDescriptionListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ScoreDescriptionListTypePointer(value interface{}) (*ScoreDescriptionListType, bool) {
switch t := value.(type) {
        case *ScoreDescriptionListType:
                return value.(*ScoreDescriptionListType), true
        case ScoreDescriptionListType:
                v, _ := value.(ScoreDescriptionListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ScoreDescriptionListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewScoreDescriptionListType() *ScoreDescriptionListType {
  if out, ok := ScoreDescriptionListTypePointer(ScoreDescriptionListType{}); !ok {
                log.Fatalf("Could not create pointer to ScoreDescriptionListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ScoreDescriptionType) Clone() (*ScoreDescriptionType) {
return reprint.This(t).(*ScoreDescriptionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ScoreDescriptionTypePointer(value interface{}) (*ScoreDescriptionType, bool) {
switch t := value.(type) {
        case *ScoreDescriptionType:
                return value.(*ScoreDescriptionType), true
        case ScoreDescriptionType:
                v, _ := value.(ScoreDescriptionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ScoreDescriptionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewScoreDescriptionType() *ScoreDescriptionType {
  if out, ok := ScoreDescriptionTypePointer(ScoreDescriptionType{}); !ok {
                log.Fatalf("Could not create pointer to ScoreDescriptionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ScoreListType) Clone() (*ScoreListType) {
return reprint.This(t).(*ScoreListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ScoreListTypePointer(value interface{}) (*ScoreListType, bool) {
switch t := value.(type) {
        case *ScoreListType:
                return value.(*ScoreListType), true
        case ScoreListType:
                v, _ := value.(ScoreListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ScoreListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewScoreListType() *ScoreListType {
  if out, ok := ScoreListTypePointer(ScoreListType{}); !ok {
                log.Fatalf("Could not create pointer to ScoreListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ScoreType) Clone() (*ScoreType) {
return reprint.This(t).(*ScoreType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ScoreTypePointer(value interface{}) (*ScoreType, bool) {
switch t := value.(type) {
        case *ScoreType:
                return value.(*ScoreType), true
        case ScoreType:
                v, _ := value.(ScoreType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ScoreType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewScoreType() *ScoreType {
  if out, ok := ScoreTypePointer(ScoreType{}); !ok {
                log.Fatalf("Could not create pointer to ScoreType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SectionInfo) Clone() (*SectionInfo) {
return reprint.This(t).(*SectionInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SectionInfoPointer(value interface{}) (*SectionInfo, bool) {
switch t := value.(type) {
        case *SectionInfo:
                return value.(*SectionInfo), true
        case SectionInfo:
                v, _ := value.(SectionInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SectionInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSectionInfo() *SectionInfo {
  if out, ok := SectionInfoPointer(SectionInfo{}); !ok {
                log.Fatalf("Could not create pointer to SectionInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SectionInfos) Clone() (*SectionInfos) {
return reprint.This(t).(*SectionInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SectionInfosPointer(value interface{}) (*SectionInfos, bool) {
switch t := value.(type) {
        case *SectionInfos:
                return value.(*SectionInfos), true
        case SectionInfos:
                v, _ := value.(SectionInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SectionInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SessionInfo) Clone() (*SessionInfo) {
return reprint.This(t).(*SessionInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SessionInfoPointer(value interface{}) (*SessionInfo, bool) {
switch t := value.(type) {
        case *SessionInfo:
                return value.(*SessionInfo), true
        case SessionInfo:
                v, _ := value.(SessionInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SessionInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSessionInfo() *SessionInfo {
  if out, ok := SessionInfoPointer(SessionInfo{}); !ok {
                log.Fatalf("Could not create pointer to SessionInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SessionInfos) Clone() (*SessionInfos) {
return reprint.This(t).(*SessionInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SessionInfosPointer(value interface{}) (*SessionInfos, bool) {
switch t := value.(type) {
        case *SessionInfos:
                return value.(*SessionInfos), true
        case SessionInfos:
                v, _ := value.(SessionInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SessionInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SettingLocationListType) Clone() (*SettingLocationListType) {
return reprint.This(t).(*SettingLocationListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SettingLocationListTypePointer(value interface{}) (*SettingLocationListType, bool) {
switch t := value.(type) {
        case *SettingLocationListType:
                return value.(*SettingLocationListType), true
        case SettingLocationListType:
                v, _ := value.(SettingLocationListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SettingLocationListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSettingLocationListType() *SettingLocationListType {
  if out, ok := SettingLocationListTypePointer(SettingLocationListType{}); !ok {
                log.Fatalf("Could not create pointer to SettingLocationListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SettingLocationType) Clone() (*SettingLocationType) {
return reprint.This(t).(*SettingLocationType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SettingLocationTypePointer(value interface{}) (*SettingLocationType, bool) {
switch t := value.(type) {
        case *SettingLocationType:
                return value.(*SettingLocationType), true
        case SettingLocationType:
                v, _ := value.(SettingLocationType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SettingLocationType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSettingLocationType() *SettingLocationType {
  if out, ok := SettingLocationTypePointer(SettingLocationType{}); !ok {
                log.Fatalf("Could not create pointer to SettingLocationType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ShareWithListType) Clone() (*ShareWithListType) {
return reprint.This(t).(*ShareWithListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ShareWithListTypePointer(value interface{}) (*ShareWithListType, bool) {
switch t := value.(type) {
        case *ShareWithListType:
                return value.(*ShareWithListType), true
        case ShareWithListType:
                v, _ := value.(ShareWithListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ShareWithListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewShareWithListType() *ShareWithListType {
  if out, ok := ShareWithListTypePointer(ShareWithListType{}); !ok {
                log.Fatalf("Could not create pointer to ShareWithListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ShareWithType) Clone() (*ShareWithType) {
return reprint.This(t).(*ShareWithType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ShareWithTypePointer(value interface{}) (*ShareWithType, bool) {
switch t := value.(type) {
        case *ShareWithType:
                return value.(*ShareWithType), true
        case ShareWithType:
                v, _ := value.(ShareWithType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ShareWithType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewShareWithType() *ShareWithType {
  if out, ok := ShareWithTypePointer(ShareWithType{}); !ok {
                log.Fatalf("Could not create pointer to ShareWithType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SignatoryType) Clone() (*SignatoryType) {
return reprint.This(t).(*SignatoryType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SignatoryTypePointer(value interface{}) (*SignatoryType, bool) {
switch t := value.(type) {
        case *SignatoryType:
                return value.(*SignatoryType), true
        case SignatoryType:
                v, _ := value.(SignatoryType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SignatoryType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSignatoryType() *SignatoryType {
  if out, ok := SignatoryTypePointer(SignatoryType{}); !ok {
                log.Fatalf("Could not create pointer to SignatoryType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SoftwareRequirementListType) Clone() (*SoftwareRequirementListType) {
return reprint.This(t).(*SoftwareRequirementListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SoftwareRequirementListTypePointer(value interface{}) (*SoftwareRequirementListType, bool) {
switch t := value.(type) {
        case *SoftwareRequirementListType:
                return value.(*SoftwareRequirementListType), true
        case SoftwareRequirementListType:
                v, _ := value.(SoftwareRequirementListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SoftwareRequirementListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSoftwareRequirementListType() *SoftwareRequirementListType {
  if out, ok := SoftwareRequirementListTypePointer(SoftwareRequirementListType{}); !ok {
                log.Fatalf("Could not create pointer to SoftwareRequirementListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SoftwareRequirementType) Clone() (*SoftwareRequirementType) {
return reprint.This(t).(*SoftwareRequirementType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SoftwareRequirementTypePointer(value interface{}) (*SoftwareRequirementType, bool) {
switch t := value.(type) {
        case *SoftwareRequirementType:
                return value.(*SoftwareRequirementType), true
        case SoftwareRequirementType:
                v, _ := value.(SoftwareRequirementType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SoftwareRequirementType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSoftwareRequirementType() *SoftwareRequirementType {
  if out, ok := SoftwareRequirementTypePointer(SoftwareRequirementType{}); !ok {
                log.Fatalf("Could not create pointer to SoftwareRequirementType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SoftwareVendorInfoContainerType) Clone() (*SoftwareVendorInfoContainerType) {
return reprint.This(t).(*SoftwareVendorInfoContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SoftwareVendorInfoContainerTypePointer(value interface{}) (*SoftwareVendorInfoContainerType, bool) {
switch t := value.(type) {
        case *SoftwareVendorInfoContainerType:
                return value.(*SoftwareVendorInfoContainerType), true
        case SoftwareVendorInfoContainerType:
                v, _ := value.(SoftwareVendorInfoContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SoftwareVendorInfoContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSoftwareVendorInfoContainerType() *SoftwareVendorInfoContainerType {
  if out, ok := SoftwareVendorInfoContainerTypePointer(SoftwareVendorInfoContainerType{}); !ok {
                log.Fatalf("Could not create pointer to SoftwareVendorInfoContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SourceObjectsType) Clone() (*SourceObjectsType) {
return reprint.This(t).(*SourceObjectsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SourceObjectsTypePointer(value interface{}) (*SourceObjectsType, bool) {
switch t := value.(type) {
        case *SourceObjectsType:
                return value.(*SourceObjectsType), true
        case SourceObjectsType:
                v, _ := value.(SourceObjectsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SourceObjectsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSourceObjectsType() *SourceObjectsType {
  if out, ok := SourceObjectsTypePointer(SourceObjectsType{}); !ok {
                log.Fatalf("Could not create pointer to SourceObjectsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SourceObjectsType_SourceObject) Clone() (*SourceObjectsType_SourceObject) {
return reprint.This(t).(*SourceObjectsType_SourceObject)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SourceObjectsType_SourceObjectPointer(value interface{}) (*SourceObjectsType_SourceObject, bool) {
switch t := value.(type) {
        case *SourceObjectsType_SourceObject:
                return value.(*SourceObjectsType_SourceObject), true
        case SourceObjectsType_SourceObject:
                v, _ := value.(SourceObjectsType_SourceObject)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SourceObjectsType_SourceObject\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSourceObjectsType_SourceObject() *SourceObjectsType_SourceObject {
  if out, ok := SourceObjectsType_SourceObjectPointer(SourceObjectsType_SourceObject{}); !ok {
                log.Fatalf("Could not create pointer to SourceObjectsType_SourceObject\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SpanGapListType) Clone() (*SpanGapListType) {
return reprint.This(t).(*SpanGapListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SpanGapListTypePointer(value interface{}) (*SpanGapListType, bool) {
switch t := value.(type) {
        case *SpanGapListType:
                return value.(*SpanGapListType), true
        case SpanGapListType:
                v, _ := value.(SpanGapListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SpanGapListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSpanGapListType() *SpanGapListType {
  if out, ok := SpanGapListTypePointer(SpanGapListType{}); !ok {
                log.Fatalf("Could not create pointer to SpanGapListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SpanGapType) Clone() (*SpanGapType) {
return reprint.This(t).(*SpanGapType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SpanGapTypePointer(value interface{}) (*SpanGapType, bool) {
switch t := value.(type) {
        case *SpanGapType:
                return value.(*SpanGapType), true
        case SpanGapType:
                v, _ := value.(SpanGapType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SpanGapType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSpanGapType() *SpanGapType {
  if out, ok := SpanGapTypePointer(SpanGapType{}); !ok {
                log.Fatalf("Could not create pointer to SpanGapType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffActivityExtensionType) Clone() (*StaffActivityExtensionType) {
return reprint.This(t).(*StaffActivityExtensionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffActivityExtensionTypePointer(value interface{}) (*StaffActivityExtensionType, bool) {
switch t := value.(type) {
        case *StaffActivityExtensionType:
                return value.(*StaffActivityExtensionType), true
        case StaffActivityExtensionType:
                v, _ := value.(StaffActivityExtensionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffActivityExtensionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStaffActivityExtensionType() *StaffActivityExtensionType {
  if out, ok := StaffActivityExtensionTypePointer(StaffActivityExtensionType{}); !ok {
                log.Fatalf("Could not create pointer to StaffActivityExtensionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffAssignment) Clone() (*StaffAssignment) {
return reprint.This(t).(*StaffAssignment)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffAssignmentPointer(value interface{}) (*StaffAssignment, bool) {
switch t := value.(type) {
        case *StaffAssignment:
                return value.(*StaffAssignment), true
        case StaffAssignment:
                v, _ := value.(StaffAssignment)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffAssignment\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStaffAssignment() *StaffAssignment {
  if out, ok := StaffAssignmentPointer(StaffAssignment{}); !ok {
                log.Fatalf("Could not create pointer to StaffAssignment\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffAssignmentMostRecentContainerType) Clone() (*StaffAssignmentMostRecentContainerType) {
return reprint.This(t).(*StaffAssignmentMostRecentContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffAssignmentMostRecentContainerTypePointer(value interface{}) (*StaffAssignmentMostRecentContainerType, bool) {
switch t := value.(type) {
        case *StaffAssignmentMostRecentContainerType:
                return value.(*StaffAssignmentMostRecentContainerType), true
        case StaffAssignmentMostRecentContainerType:
                v, _ := value.(StaffAssignmentMostRecentContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffAssignmentMostRecentContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStaffAssignmentMostRecentContainerType() *StaffAssignmentMostRecentContainerType {
  if out, ok := StaffAssignmentMostRecentContainerTypePointer(StaffAssignmentMostRecentContainerType{}); !ok {
                log.Fatalf("Could not create pointer to StaffAssignmentMostRecentContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffAssignments) Clone() (*StaffAssignments) {
return reprint.This(t).(*StaffAssignments)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffAssignmentsPointer(value interface{}) (*StaffAssignments, bool) {
switch t := value.(type) {
        case *StaffAssignments:
                return value.(*StaffAssignments), true
        case StaffAssignments:
                v, _ := value.(StaffAssignments)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffAssignments\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffListType) Clone() (*StaffListType) {
return reprint.This(t).(*StaffListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffListTypePointer(value interface{}) (*StaffListType, bool) {
switch t := value.(type) {
        case *StaffListType:
                return value.(*StaffListType), true
        case StaffListType:
                v, _ := value.(StaffListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStaffListType() *StaffListType {
  if out, ok := StaffListTypePointer(StaffListType{}); !ok {
                log.Fatalf("Could not create pointer to StaffListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffMostRecentContainerType) Clone() (*StaffMostRecentContainerType) {
return reprint.This(t).(*StaffMostRecentContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffMostRecentContainerTypePointer(value interface{}) (*StaffMostRecentContainerType, bool) {
switch t := value.(type) {
        case *StaffMostRecentContainerType:
                return value.(*StaffMostRecentContainerType), true
        case StaffMostRecentContainerType:
                v, _ := value.(StaffMostRecentContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffMostRecentContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStaffMostRecentContainerType() *StaffMostRecentContainerType {
  if out, ok := StaffMostRecentContainerTypePointer(StaffMostRecentContainerType{}); !ok {
                log.Fatalf("Could not create pointer to StaffMostRecentContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffPersonal) Clone() (*StaffPersonal) {
return reprint.This(t).(*StaffPersonal)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffPersonalPointer(value interface{}) (*StaffPersonal, bool) {
switch t := value.(type) {
        case *StaffPersonal:
                return value.(*StaffPersonal), true
        case StaffPersonal:
                v, _ := value.(StaffPersonal)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffPersonal\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStaffPersonal() *StaffPersonal {
  if out, ok := StaffPersonalPointer(StaffPersonal{}); !ok {
                log.Fatalf("Could not create pointer to StaffPersonal\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffPersonals) Clone() (*StaffPersonals) {
return reprint.This(t).(*StaffPersonals)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffPersonalsPointer(value interface{}) (*StaffPersonals, bool) {
switch t := value.(type) {
        case *StaffPersonals:
                return value.(*StaffPersonals), true
        case StaffPersonals:
                v, _ := value.(StaffPersonals)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffPersonals\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffRefIdType) Clone() (*StaffRefIdType) {
return reprint.This(t).(*StaffRefIdType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffRefIdTypePointer(value interface{}) (*StaffRefIdType, bool) {
switch t := value.(type) {
        case *StaffRefIdType:
                return value.(*StaffRefIdType), true
        case StaffRefIdType:
                v, _ := value.(StaffRefIdType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffRefIdType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStaffRefIdType() *StaffRefIdType {
  if out, ok := StaffRefIdTypePointer(StaffRefIdType{}); !ok {
                log.Fatalf("Could not create pointer to StaffRefIdType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffSubjectListType) Clone() (*StaffSubjectListType) {
return reprint.This(t).(*StaffSubjectListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffSubjectListTypePointer(value interface{}) (*StaffSubjectListType, bool) {
switch t := value.(type) {
        case *StaffSubjectListType:
                return value.(*StaffSubjectListType), true
        case StaffSubjectListType:
                v, _ := value.(StaffSubjectListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffSubjectListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStaffSubjectListType() *StaffSubjectListType {
  if out, ok := StaffSubjectListTypePointer(StaffSubjectListType{}); !ok {
                log.Fatalf("Could not create pointer to StaffSubjectListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StaffSubjectType) Clone() (*StaffSubjectType) {
return reprint.This(t).(*StaffSubjectType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StaffSubjectTypePointer(value interface{}) (*StaffSubjectType, bool) {
switch t := value.(type) {
        case *StaffSubjectType:
                return value.(*StaffSubjectType), true
        case StaffSubjectType:
                v, _ := value.(StaffSubjectType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StaffSubjectType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStaffSubjectType() *StaffSubjectType {
  if out, ok := StaffSubjectTypePointer(StaffSubjectType{}); !ok {
                log.Fatalf("Could not create pointer to StaffSubjectType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StandardHierarchyLevelType) Clone() (*StandardHierarchyLevelType) {
return reprint.This(t).(*StandardHierarchyLevelType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StandardHierarchyLevelTypePointer(value interface{}) (*StandardHierarchyLevelType, bool) {
switch t := value.(type) {
        case *StandardHierarchyLevelType:
                return value.(*StandardHierarchyLevelType), true
        case StandardHierarchyLevelType:
                v, _ := value.(StandardHierarchyLevelType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StandardHierarchyLevelType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStandardHierarchyLevelType() *StandardHierarchyLevelType {
  if out, ok := StandardHierarchyLevelTypePointer(StandardHierarchyLevelType{}); !ok {
                log.Fatalf("Could not create pointer to StandardHierarchyLevelType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StandardIdentifierType) Clone() (*StandardIdentifierType) {
return reprint.This(t).(*StandardIdentifierType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StandardIdentifierTypePointer(value interface{}) (*StandardIdentifierType, bool) {
switch t := value.(type) {
        case *StandardIdentifierType:
                return value.(*StandardIdentifierType), true
        case StandardIdentifierType:
                v, _ := value.(StandardIdentifierType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StandardIdentifierType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStandardIdentifierType() *StandardIdentifierType {
  if out, ok := StandardIdentifierTypePointer(StandardIdentifierType{}); !ok {
                log.Fatalf("Could not create pointer to StandardIdentifierType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StandardsSettingBodyType) Clone() (*StandardsSettingBodyType) {
return reprint.This(t).(*StandardsSettingBodyType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StandardsSettingBodyTypePointer(value interface{}) (*StandardsSettingBodyType, bool) {
switch t := value.(type) {
        case *StandardsSettingBodyType:
                return value.(*StandardsSettingBodyType), true
        case StandardsSettingBodyType:
                v, _ := value.(StandardsSettingBodyType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StandardsSettingBodyType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStandardsSettingBodyType() *StandardsSettingBodyType {
  if out, ok := StandardsSettingBodyTypePointer(StandardsSettingBodyType{}); !ok {
                log.Fatalf("Could not create pointer to StandardsSettingBodyType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StatementCodesType) Clone() (*StatementCodesType) {
return reprint.This(t).(*StatementCodesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StatementCodesTypePointer(value interface{}) (*StatementCodesType, bool) {
switch t := value.(type) {
        case *StatementCodesType:
                return value.(*StatementCodesType), true
        case StatementCodesType:
                v, _ := value.(StatementCodesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StatementCodesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStatementCodesType() *StatementCodesType {
  if out, ok := StatementCodesTypePointer(StatementCodesType{}); !ok {
                log.Fatalf("Could not create pointer to StatementCodesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StatementsType) Clone() (*StatementsType) {
return reprint.This(t).(*StatementsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StatementsTypePointer(value interface{}) (*StatementsType, bool) {
switch t := value.(type) {
        case *StatementsType:
                return value.(*StatementsType), true
        case StatementsType:
                v, _ := value.(StatementsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StatementsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStatementsType() *StatementsType {
  if out, ok := StatementsTypePointer(StatementsType{}); !ok {
                log.Fatalf("Could not create pointer to StatementsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StatisticalAreaType) Clone() (*StatisticalAreaType) {
return reprint.This(t).(*StatisticalAreaType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StatisticalAreaTypePointer(value interface{}) (*StatisticalAreaType, bool) {
switch t := value.(type) {
        case *StatisticalAreaType:
                return value.(*StatisticalAreaType), true
        case StatisticalAreaType:
                v, _ := value.(StatisticalAreaType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StatisticalAreaType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStatisticalAreaType() *StatisticalAreaType {
  if out, ok := StatisticalAreaTypePointer(StatisticalAreaType{}); !ok {
                log.Fatalf("Could not create pointer to StatisticalAreaType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StatisticalAreasType) Clone() (*StatisticalAreasType) {
return reprint.This(t).(*StatisticalAreasType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StatisticalAreasTypePointer(value interface{}) (*StatisticalAreasType, bool) {
switch t := value.(type) {
        case *StatisticalAreasType:
                return value.(*StatisticalAreasType), true
        case StatisticalAreasType:
                v, _ := value.(StatisticalAreasType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StatisticalAreasType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStatisticalAreasType() *StatisticalAreasType {
  if out, ok := StatisticalAreasTypePointer(StatisticalAreasType{}); !ok {
                log.Fatalf("Could not create pointer to StatisticalAreasType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StatsCohortListType) Clone() (*StatsCohortListType) {
return reprint.This(t).(*StatsCohortListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StatsCohortListTypePointer(value interface{}) (*StatsCohortListType, bool) {
switch t := value.(type) {
        case *StatsCohortListType:
                return value.(*StatsCohortListType), true
        case StatsCohortListType:
                v, _ := value.(StatsCohortListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StatsCohortListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStatsCohortListType() *StatsCohortListType {
  if out, ok := StatsCohortListTypePointer(StatsCohortListType{}); !ok {
                log.Fatalf("Could not create pointer to StatsCohortListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StatsCohortType) Clone() (*StatsCohortType) {
return reprint.This(t).(*StatsCohortType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StatsCohortTypePointer(value interface{}) (*StatsCohortType, bool) {
switch t := value.(type) {
        case *StatsCohortType:
                return value.(*StatsCohortType), true
        case StatsCohortType:
                v, _ := value.(StatsCohortType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StatsCohortType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStatsCohortType() *StatsCohortType {
  if out, ok := StatsCohortTypePointer(StatsCohortType{}); !ok {
                log.Fatalf("Could not create pointer to StatsCohortType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StatsCohortYearLevelListType) Clone() (*StatsCohortYearLevelListType) {
return reprint.This(t).(*StatsCohortYearLevelListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StatsCohortYearLevelListTypePointer(value interface{}) (*StatsCohortYearLevelListType, bool) {
switch t := value.(type) {
        case *StatsCohortYearLevelListType:
                return value.(*StatsCohortYearLevelListType), true
        case StatsCohortYearLevelListType:
                v, _ := value.(StatsCohortYearLevelListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StatsCohortYearLevelListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStatsCohortYearLevelListType() *StatsCohortYearLevelListType {
  if out, ok := StatsCohortYearLevelListTypePointer(StatsCohortYearLevelListType{}); !ok {
                log.Fatalf("Could not create pointer to StatsCohortYearLevelListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StatsCohortYearLevelType) Clone() (*StatsCohortYearLevelType) {
return reprint.This(t).(*StatsCohortYearLevelType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StatsCohortYearLevelTypePointer(value interface{}) (*StatsCohortYearLevelType, bool) {
switch t := value.(type) {
        case *StatsCohortYearLevelType:
                return value.(*StatsCohortYearLevelType), true
        case StatsCohortYearLevelType:
                v, _ := value.(StatsCohortYearLevelType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StatsCohortYearLevelType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStatsCohortYearLevelType() *StatsCohortYearLevelType {
  if out, ok := StatsCohortYearLevelTypePointer(StatsCohortYearLevelType{}); !ok {
                log.Fatalf("Could not create pointer to StatsCohortYearLevelType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StimulusListType) Clone() (*StimulusListType) {
return reprint.This(t).(*StimulusListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StimulusListTypePointer(value interface{}) (*StimulusListType, bool) {
switch t := value.(type) {
        case *StimulusListType:
                return value.(*StimulusListType), true
        case StimulusListType:
                v, _ := value.(StimulusListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StimulusListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStimulusListType() *StimulusListType {
  if out, ok := StimulusListTypePointer(StimulusListType{}); !ok {
                log.Fatalf("Could not create pointer to StimulusListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StimulusLocalIdListType) Clone() (*StimulusLocalIdListType) {
return reprint.This(t).(*StimulusLocalIdListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StimulusLocalIdListTypePointer(value interface{}) (*StimulusLocalIdListType, bool) {
switch t := value.(type) {
        case *StimulusLocalIdListType:
                return value.(*StimulusLocalIdListType), true
        case StimulusLocalIdListType:
                v, _ := value.(StimulusLocalIdListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StimulusLocalIdListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStimulusLocalIdListType() *StimulusLocalIdListType {
  if out, ok := StimulusLocalIdListTypePointer(StimulusLocalIdListType{}); !ok {
                log.Fatalf("Could not create pointer to StimulusLocalIdListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StimulusType) Clone() (*StimulusType) {
return reprint.This(t).(*StimulusType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StimulusTypePointer(value interface{}) (*StimulusType, bool) {
switch t := value.(type) {
        case *StimulusType:
                return value.(*StimulusType), true
        case StimulusType:
                v, _ := value.(StimulusType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StimulusType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStimulusType() *StimulusType {
  if out, ok := StimulusTypePointer(StimulusType{}); !ok {
                log.Fatalf("Could not create pointer to StimulusType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StrategiesType) Clone() (*StrategiesType) {
return reprint.This(t).(*StrategiesType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StrategiesTypePointer(value interface{}) (*StrategiesType, bool) {
switch t := value.(type) {
        case *StrategiesType:
                return value.(*StrategiesType), true
        case StrategiesType:
                v, _ := value.(StrategiesType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StrategiesType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStrategiesType() *StrategiesType {
  if out, ok := StrategiesTypePointer(StrategiesType{}); !ok {
                log.Fatalf("Could not create pointer to StrategiesType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentActivityInfo) Clone() (*StudentActivityInfo) {
return reprint.This(t).(*StudentActivityInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentActivityInfoPointer(value interface{}) (*StudentActivityInfo, bool) {
switch t := value.(type) {
        case *StudentActivityInfo:
                return value.(*StudentActivityInfo), true
        case StudentActivityInfo:
                v, _ := value.(StudentActivityInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentActivityInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentActivityInfo() *StudentActivityInfo {
  if out, ok := StudentActivityInfoPointer(StudentActivityInfo{}); !ok {
                log.Fatalf("Could not create pointer to StudentActivityInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentActivityInfos) Clone() (*StudentActivityInfos) {
return reprint.This(t).(*StudentActivityInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentActivityInfosPointer(value interface{}) (*StudentActivityInfos, bool) {
switch t := value.(type) {
        case *StudentActivityInfos:
                return value.(*StudentActivityInfos), true
        case StudentActivityInfos:
                v, _ := value.(StudentActivityInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentActivityInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentActivityParticipation) Clone() (*StudentActivityParticipation) {
return reprint.This(t).(*StudentActivityParticipation)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentActivityParticipationPointer(value interface{}) (*StudentActivityParticipation, bool) {
switch t := value.(type) {
        case *StudentActivityParticipation:
                return value.(*StudentActivityParticipation), true
        case StudentActivityParticipation:
                v, _ := value.(StudentActivityParticipation)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentActivityParticipation\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentActivityParticipation() *StudentActivityParticipation {
  if out, ok := StudentActivityParticipationPointer(StudentActivityParticipation{}); !ok {
                log.Fatalf("Could not create pointer to StudentActivityParticipation\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentActivityParticipations) Clone() (*StudentActivityParticipations) {
return reprint.This(t).(*StudentActivityParticipations)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentActivityParticipationsPointer(value interface{}) (*StudentActivityParticipations, bool) {
switch t := value.(type) {
        case *StudentActivityParticipations:
                return value.(*StudentActivityParticipations), true
        case StudentActivityParticipations:
                v, _ := value.(StudentActivityParticipations)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentActivityParticipations\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentActivityType) Clone() (*StudentActivityType) {
return reprint.This(t).(*StudentActivityType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentActivityTypePointer(value interface{}) (*StudentActivityType, bool) {
switch t := value.(type) {
        case *StudentActivityType:
                return value.(*StudentActivityType), true
        case StudentActivityType:
                v, _ := value.(StudentActivityType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentActivityType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentActivityType() *StudentActivityType {
  if out, ok := StudentActivityTypePointer(StudentActivityType{}); !ok {
                log.Fatalf("Could not create pointer to StudentActivityType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentAttendanceCollection) Clone() (*StudentAttendanceCollection) {
return reprint.This(t).(*StudentAttendanceCollection)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentAttendanceCollectionPointer(value interface{}) (*StudentAttendanceCollection, bool) {
switch t := value.(type) {
        case *StudentAttendanceCollection:
                return value.(*StudentAttendanceCollection), true
        case StudentAttendanceCollection:
                v, _ := value.(StudentAttendanceCollection)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentAttendanceCollection\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentAttendanceCollection() *StudentAttendanceCollection {
  if out, ok := StudentAttendanceCollectionPointer(StudentAttendanceCollection{}); !ok {
                log.Fatalf("Could not create pointer to StudentAttendanceCollection\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentAttendanceCollectionReportingListType) Clone() (*StudentAttendanceCollectionReportingListType) {
return reprint.This(t).(*StudentAttendanceCollectionReportingListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentAttendanceCollectionReportingListTypePointer(value interface{}) (*StudentAttendanceCollectionReportingListType, bool) {
switch t := value.(type) {
        case *StudentAttendanceCollectionReportingListType:
                return value.(*StudentAttendanceCollectionReportingListType), true
        case StudentAttendanceCollectionReportingListType:
                v, _ := value.(StudentAttendanceCollectionReportingListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentAttendanceCollectionReportingListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentAttendanceCollectionReportingListType() *StudentAttendanceCollectionReportingListType {
  if out, ok := StudentAttendanceCollectionReportingListTypePointer(StudentAttendanceCollectionReportingListType{}); !ok {
                log.Fatalf("Could not create pointer to StudentAttendanceCollectionReportingListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentAttendanceCollectionReportingType) Clone() (*StudentAttendanceCollectionReportingType) {
return reprint.This(t).(*StudentAttendanceCollectionReportingType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentAttendanceCollectionReportingTypePointer(value interface{}) (*StudentAttendanceCollectionReportingType, bool) {
switch t := value.(type) {
        case *StudentAttendanceCollectionReportingType:
                return value.(*StudentAttendanceCollectionReportingType), true
        case StudentAttendanceCollectionReportingType:
                v, _ := value.(StudentAttendanceCollectionReportingType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentAttendanceCollectionReportingType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentAttendanceCollectionReportingType() *StudentAttendanceCollectionReportingType {
  if out, ok := StudentAttendanceCollectionReportingTypePointer(StudentAttendanceCollectionReportingType{}); !ok {
                log.Fatalf("Could not create pointer to StudentAttendanceCollectionReportingType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentAttendanceCollections) Clone() (*StudentAttendanceCollections) {
return reprint.This(t).(*StudentAttendanceCollections)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentAttendanceCollectionsPointer(value interface{}) (*StudentAttendanceCollections, bool) {
switch t := value.(type) {
        case *StudentAttendanceCollections:
                return value.(*StudentAttendanceCollections), true
        case StudentAttendanceCollections:
                v, _ := value.(StudentAttendanceCollections)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentAttendanceCollections\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentAttendanceSummary) Clone() (*StudentAttendanceSummary) {
return reprint.This(t).(*StudentAttendanceSummary)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentAttendanceSummaryPointer(value interface{}) (*StudentAttendanceSummary, bool) {
switch t := value.(type) {
        case *StudentAttendanceSummary:
                return value.(*StudentAttendanceSummary), true
        case StudentAttendanceSummary:
                v, _ := value.(StudentAttendanceSummary)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentAttendanceSummary\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentAttendanceSummary() *StudentAttendanceSummary {
  if out, ok := StudentAttendanceSummaryPointer(StudentAttendanceSummary{}); !ok {
                log.Fatalf("Could not create pointer to StudentAttendanceSummary\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentAttendanceSummarys) Clone() (*StudentAttendanceSummarys) {
return reprint.This(t).(*StudentAttendanceSummarys)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentAttendanceSummarysPointer(value interface{}) (*StudentAttendanceSummarys, bool) {
switch t := value.(type) {
        case *StudentAttendanceSummarys:
                return value.(*StudentAttendanceSummarys), true
        case StudentAttendanceSummarys:
                v, _ := value.(StudentAttendanceSummarys)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentAttendanceSummarys\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentAttendanceTimeList) Clone() (*StudentAttendanceTimeList) {
return reprint.This(t).(*StudentAttendanceTimeList)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentAttendanceTimeListPointer(value interface{}) (*StudentAttendanceTimeList, bool) {
switch t := value.(type) {
        case *StudentAttendanceTimeList:
                return value.(*StudentAttendanceTimeList), true
        case StudentAttendanceTimeList:
                v, _ := value.(StudentAttendanceTimeList)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentAttendanceTimeList\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentAttendanceTimeList() *StudentAttendanceTimeList {
  if out, ok := StudentAttendanceTimeListPointer(StudentAttendanceTimeList{}); !ok {
                log.Fatalf("Could not create pointer to StudentAttendanceTimeList\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentAttendanceTimeLists) Clone() (*StudentAttendanceTimeLists) {
return reprint.This(t).(*StudentAttendanceTimeLists)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentAttendanceTimeListsPointer(value interface{}) (*StudentAttendanceTimeLists, bool) {
switch t := value.(type) {
        case *StudentAttendanceTimeLists:
                return value.(*StudentAttendanceTimeLists), true
        case StudentAttendanceTimeLists:
                v, _ := value.(StudentAttendanceTimeLists)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentAttendanceTimeLists\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentContactFeePercentageType) Clone() (*StudentContactFeePercentageType) {
return reprint.This(t).(*StudentContactFeePercentageType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentContactFeePercentageTypePointer(value interface{}) (*StudentContactFeePercentageType, bool) {
switch t := value.(type) {
        case *StudentContactFeePercentageType:
                return value.(*StudentContactFeePercentageType), true
        case StudentContactFeePercentageType:
                v, _ := value.(StudentContactFeePercentageType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentContactFeePercentageType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentContactFeePercentageType() *StudentContactFeePercentageType {
  if out, ok := StudentContactFeePercentageTypePointer(StudentContactFeePercentageType{}); !ok {
                log.Fatalf("Could not create pointer to StudentContactFeePercentageType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentContactPersonal) Clone() (*StudentContactPersonal) {
return reprint.This(t).(*StudentContactPersonal)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentContactPersonalPointer(value interface{}) (*StudentContactPersonal, bool) {
switch t := value.(type) {
        case *StudentContactPersonal:
                return value.(*StudentContactPersonal), true
        case StudentContactPersonal:
                v, _ := value.(StudentContactPersonal)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentContactPersonal\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentContactPersonal() *StudentContactPersonal {
  if out, ok := StudentContactPersonalPointer(StudentContactPersonal{}); !ok {
                log.Fatalf("Could not create pointer to StudentContactPersonal\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentContactPersonals) Clone() (*StudentContactPersonals) {
return reprint.This(t).(*StudentContactPersonals)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentContactPersonalsPointer(value interface{}) (*StudentContactPersonals, bool) {
switch t := value.(type) {
        case *StudentContactPersonals:
                return value.(*StudentContactPersonals), true
        case StudentContactPersonals:
                v, _ := value.(StudentContactPersonals)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentContactPersonals\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentContactRelationship) Clone() (*StudentContactRelationship) {
return reprint.This(t).(*StudentContactRelationship)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentContactRelationshipPointer(value interface{}) (*StudentContactRelationship, bool) {
switch t := value.(type) {
        case *StudentContactRelationship:
                return value.(*StudentContactRelationship), true
        case StudentContactRelationship:
                v, _ := value.(StudentContactRelationship)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentContactRelationship\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentContactRelationship() *StudentContactRelationship {
  if out, ok := StudentContactRelationshipPointer(StudentContactRelationship{}); !ok {
                log.Fatalf("Could not create pointer to StudentContactRelationship\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentContactRelationships) Clone() (*StudentContactRelationships) {
return reprint.This(t).(*StudentContactRelationships)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentContactRelationshipsPointer(value interface{}) (*StudentContactRelationships, bool) {
switch t := value.(type) {
        case *StudentContactRelationships:
                return value.(*StudentContactRelationships), true
        case StudentContactRelationships:
                v, _ := value.(StudentContactRelationships)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentContactRelationships\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentDailyAttendance) Clone() (*StudentDailyAttendance) {
return reprint.This(t).(*StudentDailyAttendance)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentDailyAttendancePointer(value interface{}) (*StudentDailyAttendance, bool) {
switch t := value.(type) {
        case *StudentDailyAttendance:
                return value.(*StudentDailyAttendance), true
        case StudentDailyAttendance:
                v, _ := value.(StudentDailyAttendance)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentDailyAttendance\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentDailyAttendance() *StudentDailyAttendance {
  if out, ok := StudentDailyAttendancePointer(StudentDailyAttendance{}); !ok {
                log.Fatalf("Could not create pointer to StudentDailyAttendance\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentDailyAttendances) Clone() (*StudentDailyAttendances) {
return reprint.This(t).(*StudentDailyAttendances)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentDailyAttendancesPointer(value interface{}) (*StudentDailyAttendances, bool) {
switch t := value.(type) {
        case *StudentDailyAttendances:
                return value.(*StudentDailyAttendances), true
        case StudentDailyAttendances:
                v, _ := value.(StudentDailyAttendances)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentDailyAttendances\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentDataTransferNote) Clone() (*StudentDataTransferNote) {
return reprint.This(t).(*StudentDataTransferNote)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentDataTransferNotePointer(value interface{}) (*StudentDataTransferNote, bool) {
switch t := value.(type) {
        case *StudentDataTransferNote:
                return value.(*StudentDataTransferNote), true
        case StudentDataTransferNote:
                v, _ := value.(StudentDataTransferNote)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentDataTransferNote\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentDataTransferNote() *StudentDataTransferNote {
  if out, ok := StudentDataTransferNotePointer(StudentDataTransferNote{}); !ok {
                log.Fatalf("Could not create pointer to StudentDataTransferNote\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentDataTransferNotes) Clone() (*StudentDataTransferNotes) {
return reprint.This(t).(*StudentDataTransferNotes)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentDataTransferNotesPointer(value interface{}) (*StudentDataTransferNotes, bool) {
switch t := value.(type) {
        case *StudentDataTransferNotes:
                return value.(*StudentDataTransferNotes), true
        case StudentDataTransferNotes:
                v, _ := value.(StudentDataTransferNotes)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentDataTransferNotes\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentEntryContainerType) Clone() (*StudentEntryContainerType) {
return reprint.This(t).(*StudentEntryContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentEntryContainerTypePointer(value interface{}) (*StudentEntryContainerType, bool) {
switch t := value.(type) {
        case *StudentEntryContainerType:
                return value.(*StudentEntryContainerType), true
        case StudentEntryContainerType:
                v, _ := value.(StudentEntryContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentEntryContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentEntryContainerType() *StudentEntryContainerType {
  if out, ok := StudentEntryContainerTypePointer(StudentEntryContainerType{}); !ok {
                log.Fatalf("Could not create pointer to StudentEntryContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentExitContainerType) Clone() (*StudentExitContainerType) {
return reprint.This(t).(*StudentExitContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentExitContainerTypePointer(value interface{}) (*StudentExitContainerType, bool) {
switch t := value.(type) {
        case *StudentExitContainerType:
                return value.(*StudentExitContainerType), true
        case StudentExitContainerType:
                v, _ := value.(StudentExitContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentExitContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentExitContainerType() *StudentExitContainerType {
  if out, ok := StudentExitContainerTypePointer(StudentExitContainerType{}); !ok {
                log.Fatalf("Could not create pointer to StudentExitContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentExitStatusContainerType) Clone() (*StudentExitStatusContainerType) {
return reprint.This(t).(*StudentExitStatusContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentExitStatusContainerTypePointer(value interface{}) (*StudentExitStatusContainerType, bool) {
switch t := value.(type) {
        case *StudentExitStatusContainerType:
                return value.(*StudentExitStatusContainerType), true
        case StudentExitStatusContainerType:
                v, _ := value.(StudentExitStatusContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentExitStatusContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentExitStatusContainerType() *StudentExitStatusContainerType {
  if out, ok := StudentExitStatusContainerTypePointer(StudentExitStatusContainerType{}); !ok {
                log.Fatalf("Could not create pointer to StudentExitStatusContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentGrade) Clone() (*StudentGrade) {
return reprint.This(t).(*StudentGrade)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentGradePointer(value interface{}) (*StudentGrade, bool) {
switch t := value.(type) {
        case *StudentGrade:
                return value.(*StudentGrade), true
        case StudentGrade:
                v, _ := value.(StudentGrade)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentGrade\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentGrade() *StudentGrade {
  if out, ok := StudentGradePointer(StudentGrade{}); !ok {
                log.Fatalf("Could not create pointer to StudentGrade\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentGradeMarkersListType) Clone() (*StudentGradeMarkersListType) {
return reprint.This(t).(*StudentGradeMarkersListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentGradeMarkersListTypePointer(value interface{}) (*StudentGradeMarkersListType, bool) {
switch t := value.(type) {
        case *StudentGradeMarkersListType:
                return value.(*StudentGradeMarkersListType), true
        case StudentGradeMarkersListType:
                v, _ := value.(StudentGradeMarkersListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentGradeMarkersListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentGradeMarkersListType() *StudentGradeMarkersListType {
  if out, ok := StudentGradeMarkersListTypePointer(StudentGradeMarkersListType{}); !ok {
                log.Fatalf("Could not create pointer to StudentGradeMarkersListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentGrades) Clone() (*StudentGrades) {
return reprint.This(t).(*StudentGrades)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentGradesPointer(value interface{}) (*StudentGrades, bool) {
switch t := value.(type) {
        case *StudentGrades:
                return value.(*StudentGrades), true
        case StudentGrades:
                v, _ := value.(StudentGrades)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentGrades\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentGroupListType) Clone() (*StudentGroupListType) {
return reprint.This(t).(*StudentGroupListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentGroupListTypePointer(value interface{}) (*StudentGroupListType, bool) {
switch t := value.(type) {
        case *StudentGroupListType:
                return value.(*StudentGroupListType), true
        case StudentGroupListType:
                v, _ := value.(StudentGroupListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentGroupListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentGroupListType() *StudentGroupListType {
  if out, ok := StudentGroupListTypePointer(StudentGroupListType{}); !ok {
                log.Fatalf("Could not create pointer to StudentGroupListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentGroupType) Clone() (*StudentGroupType) {
return reprint.This(t).(*StudentGroupType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentGroupTypePointer(value interface{}) (*StudentGroupType, bool) {
switch t := value.(type) {
        case *StudentGroupType:
                return value.(*StudentGroupType), true
        case StudentGroupType:
                v, _ := value.(StudentGroupType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentGroupType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentGroupType() *StudentGroupType {
  if out, ok := StudentGroupTypePointer(StudentGroupType{}); !ok {
                log.Fatalf("Could not create pointer to StudentGroupType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentListType) Clone() (*StudentListType) {
return reprint.This(t).(*StudentListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentListTypePointer(value interface{}) (*StudentListType, bool) {
switch t := value.(type) {
        case *StudentListType:
                return value.(*StudentListType), true
        case StudentListType:
                v, _ := value.(StudentListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentListType() *StudentListType {
  if out, ok := StudentListTypePointer(StudentListType{}); !ok {
                log.Fatalf("Could not create pointer to StudentListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentMostRecentContainerType) Clone() (*StudentMostRecentContainerType) {
return reprint.This(t).(*StudentMostRecentContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentMostRecentContainerTypePointer(value interface{}) (*StudentMostRecentContainerType, bool) {
switch t := value.(type) {
        case *StudentMostRecentContainerType:
                return value.(*StudentMostRecentContainerType), true
        case StudentMostRecentContainerType:
                v, _ := value.(StudentMostRecentContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentMostRecentContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentMostRecentContainerType() *StudentMostRecentContainerType {
  if out, ok := StudentMostRecentContainerTypePointer(StudentMostRecentContainerType{}); !ok {
                log.Fatalf("Could not create pointer to StudentMostRecentContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentParticipation) Clone() (*StudentParticipation) {
return reprint.This(t).(*StudentParticipation)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentParticipationPointer(value interface{}) (*StudentParticipation, bool) {
switch t := value.(type) {
        case *StudentParticipation:
                return value.(*StudentParticipation), true
        case StudentParticipation:
                v, _ := value.(StudentParticipation)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentParticipation\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentParticipation() *StudentParticipation {
  if out, ok := StudentParticipationPointer(StudentParticipation{}); !ok {
                log.Fatalf("Could not create pointer to StudentParticipation\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentParticipation_ManagingSchool) Clone() (*StudentParticipation_ManagingSchool) {
return reprint.This(t).(*StudentParticipation_ManagingSchool)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentParticipation_ManagingSchoolPointer(value interface{}) (*StudentParticipation_ManagingSchool, bool) {
switch t := value.(type) {
        case *StudentParticipation_ManagingSchool:
                return value.(*StudentParticipation_ManagingSchool), true
        case StudentParticipation_ManagingSchool:
                v, _ := value.(StudentParticipation_ManagingSchool)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentParticipation_ManagingSchool\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentParticipation_ManagingSchool() *StudentParticipation_ManagingSchool {
  if out, ok := StudentParticipation_ManagingSchoolPointer(StudentParticipation_ManagingSchool{}); !ok {
                log.Fatalf("Could not create pointer to StudentParticipation_ManagingSchool\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentParticipations) Clone() (*StudentParticipations) {
return reprint.This(t).(*StudentParticipations)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentParticipationsPointer(value interface{}) (*StudentParticipations, bool) {
switch t := value.(type) {
        case *StudentParticipations:
                return value.(*StudentParticipations), true
        case StudentParticipations:
                v, _ := value.(StudentParticipations)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentParticipations\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentPeriodAttendance) Clone() (*StudentPeriodAttendance) {
return reprint.This(t).(*StudentPeriodAttendance)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentPeriodAttendancePointer(value interface{}) (*StudentPeriodAttendance, bool) {
switch t := value.(type) {
        case *StudentPeriodAttendance:
                return value.(*StudentPeriodAttendance), true
        case StudentPeriodAttendance:
                v, _ := value.(StudentPeriodAttendance)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentPeriodAttendance\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentPeriodAttendance() *StudentPeriodAttendance {
  if out, ok := StudentPeriodAttendancePointer(StudentPeriodAttendance{}); !ok {
                log.Fatalf("Could not create pointer to StudentPeriodAttendance\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentPeriodAttendances) Clone() (*StudentPeriodAttendances) {
return reprint.This(t).(*StudentPeriodAttendances)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentPeriodAttendancesPointer(value interface{}) (*StudentPeriodAttendances, bool) {
switch t := value.(type) {
        case *StudentPeriodAttendances:
                return value.(*StudentPeriodAttendances), true
        case StudentPeriodAttendances:
                v, _ := value.(StudentPeriodAttendances)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentPeriodAttendances\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentPersonal) Clone() (*StudentPersonal) {
return reprint.This(t).(*StudentPersonal)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentPersonalPointer(value interface{}) (*StudentPersonal, bool) {
switch t := value.(type) {
        case *StudentPersonal:
                return value.(*StudentPersonal), true
        case StudentPersonal:
                v, _ := value.(StudentPersonal)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentPersonal\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentPersonal() *StudentPersonal {
  if out, ok := StudentPersonalPointer(StudentPersonal{}); !ok {
                log.Fatalf("Could not create pointer to StudentPersonal\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentPersonals) Clone() (*StudentPersonals) {
return reprint.This(t).(*StudentPersonals)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentPersonalsPointer(value interface{}) (*StudentPersonals, bool) {
switch t := value.(type) {
        case *StudentPersonals:
                return value.(*StudentPersonals), true
        case StudentPersonals:
                v, _ := value.(StudentPersonals)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentPersonals\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentSchoolEnrollment) Clone() (*StudentSchoolEnrollment) {
return reprint.This(t).(*StudentSchoolEnrollment)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentSchoolEnrollmentPointer(value interface{}) (*StudentSchoolEnrollment, bool) {
switch t := value.(type) {
        case *StudentSchoolEnrollment:
                return value.(*StudentSchoolEnrollment), true
        case StudentSchoolEnrollment:
                v, _ := value.(StudentSchoolEnrollment)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentSchoolEnrollment\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentSchoolEnrollment() *StudentSchoolEnrollment {
  if out, ok := StudentSchoolEnrollmentPointer(StudentSchoolEnrollment{}); !ok {
                log.Fatalf("Could not create pointer to StudentSchoolEnrollment\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentSchoolEnrollment_Calendar) Clone() (*StudentSchoolEnrollment_Calendar) {
return reprint.This(t).(*StudentSchoolEnrollment_Calendar)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentSchoolEnrollment_CalendarPointer(value interface{}) (*StudentSchoolEnrollment_Calendar, bool) {
switch t := value.(type) {
        case *StudentSchoolEnrollment_Calendar:
                return value.(*StudentSchoolEnrollment_Calendar), true
        case StudentSchoolEnrollment_Calendar:
                v, _ := value.(StudentSchoolEnrollment_Calendar)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentSchoolEnrollment_Calendar\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentSchoolEnrollment_Calendar() *StudentSchoolEnrollment_Calendar {
  if out, ok := StudentSchoolEnrollment_CalendarPointer(StudentSchoolEnrollment_Calendar{}); !ok {
                log.Fatalf("Could not create pointer to StudentSchoolEnrollment_Calendar\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentSchoolEnrollments) Clone() (*StudentSchoolEnrollments) {
return reprint.This(t).(*StudentSchoolEnrollments)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentSchoolEnrollmentsPointer(value interface{}) (*StudentSchoolEnrollments, bool) {
switch t := value.(type) {
        case *StudentSchoolEnrollments:
                return value.(*StudentSchoolEnrollments), true
        case StudentSchoolEnrollments:
                v, _ := value.(StudentSchoolEnrollments)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentSchoolEnrollments\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentScoreJudgementAgainstStandard) Clone() (*StudentScoreJudgementAgainstStandard) {
return reprint.This(t).(*StudentScoreJudgementAgainstStandard)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentScoreJudgementAgainstStandardPointer(value interface{}) (*StudentScoreJudgementAgainstStandard, bool) {
switch t := value.(type) {
        case *StudentScoreJudgementAgainstStandard:
                return value.(*StudentScoreJudgementAgainstStandard), true
        case StudentScoreJudgementAgainstStandard:
                v, _ := value.(StudentScoreJudgementAgainstStandard)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentScoreJudgementAgainstStandard\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentScoreJudgementAgainstStandard() *StudentScoreJudgementAgainstStandard {
  if out, ok := StudentScoreJudgementAgainstStandardPointer(StudentScoreJudgementAgainstStandard{}); !ok {
                log.Fatalf("Could not create pointer to StudentScoreJudgementAgainstStandard\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentScoreJudgementAgainstStandards) Clone() (*StudentScoreJudgementAgainstStandards) {
return reprint.This(t).(*StudentScoreJudgementAgainstStandards)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentScoreJudgementAgainstStandardsPointer(value interface{}) (*StudentScoreJudgementAgainstStandards, bool) {
switch t := value.(type) {
        case *StudentScoreJudgementAgainstStandards:
                return value.(*StudentScoreJudgementAgainstStandards), true
        case StudentScoreJudgementAgainstStandards:
                v, _ := value.(StudentScoreJudgementAgainstStandards)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentScoreJudgementAgainstStandards\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentSectionEnrollment) Clone() (*StudentSectionEnrollment) {
return reprint.This(t).(*StudentSectionEnrollment)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentSectionEnrollmentPointer(value interface{}) (*StudentSectionEnrollment, bool) {
switch t := value.(type) {
        case *StudentSectionEnrollment:
                return value.(*StudentSectionEnrollment), true
        case StudentSectionEnrollment:
                v, _ := value.(StudentSectionEnrollment)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentSectionEnrollment\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentSectionEnrollment() *StudentSectionEnrollment {
  if out, ok := StudentSectionEnrollmentPointer(StudentSectionEnrollment{}); !ok {
                log.Fatalf("Could not create pointer to StudentSectionEnrollment\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentSectionEnrollments) Clone() (*StudentSectionEnrollments) {
return reprint.This(t).(*StudentSectionEnrollments)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentSectionEnrollmentsPointer(value interface{}) (*StudentSectionEnrollments, bool) {
switch t := value.(type) {
        case *StudentSectionEnrollments:
                return value.(*StudentSectionEnrollments), true
        case StudentSectionEnrollments:
                v, _ := value.(StudentSectionEnrollments)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentSectionEnrollments\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentSubjectChoiceListType) Clone() (*StudentSubjectChoiceListType) {
return reprint.This(t).(*StudentSubjectChoiceListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentSubjectChoiceListTypePointer(value interface{}) (*StudentSubjectChoiceListType, bool) {
switch t := value.(type) {
        case *StudentSubjectChoiceListType:
                return value.(*StudentSubjectChoiceListType), true
        case StudentSubjectChoiceListType:
                v, _ := value.(StudentSubjectChoiceListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentSubjectChoiceListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentSubjectChoiceListType() *StudentSubjectChoiceListType {
  if out, ok := StudentSubjectChoiceListTypePointer(StudentSubjectChoiceListType{}); !ok {
                log.Fatalf("Could not create pointer to StudentSubjectChoiceListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentSubjectChoiceType) Clone() (*StudentSubjectChoiceType) {
return reprint.This(t).(*StudentSubjectChoiceType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentSubjectChoiceTypePointer(value interface{}) (*StudentSubjectChoiceType, bool) {
switch t := value.(type) {
        case *StudentSubjectChoiceType:
                return value.(*StudentSubjectChoiceType), true
        case StudentSubjectChoiceType:
                v, _ := value.(StudentSubjectChoiceType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentSubjectChoiceType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentSubjectChoiceType() *StudentSubjectChoiceType {
  if out, ok := StudentSubjectChoiceTypePointer(StudentSubjectChoiceType{}); !ok {
                log.Fatalf("Could not create pointer to StudentSubjectChoiceType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *StudentsType) Clone() (*StudentsType) {
return reprint.This(t).(*StudentsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func StudentsTypePointer(value interface{}) (*StudentsType, bool) {
switch t := value.(type) {
        case *StudentsType:
                return value.(*StudentsType), true
        case StudentsType:
                v, _ := value.(StudentsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to StudentsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewStudentsType() *StudentsType {
  if out, ok := StudentsTypePointer(StudentsType{}); !ok {
                log.Fatalf("Could not create pointer to StudentsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SubjectAreaListType) Clone() (*SubjectAreaListType) {
return reprint.This(t).(*SubjectAreaListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SubjectAreaListTypePointer(value interface{}) (*SubjectAreaListType, bool) {
switch t := value.(type) {
        case *SubjectAreaListType:
                return value.(*SubjectAreaListType), true
        case SubjectAreaListType:
                v, _ := value.(SubjectAreaListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SubjectAreaListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSubjectAreaListType() *SubjectAreaListType {
  if out, ok := SubjectAreaListTypePointer(SubjectAreaListType{}); !ok {
                log.Fatalf("Could not create pointer to SubjectAreaListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SubjectAreaType) Clone() (*SubjectAreaType) {
return reprint.This(t).(*SubjectAreaType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SubjectAreaTypePointer(value interface{}) (*SubjectAreaType, bool) {
switch t := value.(type) {
        case *SubjectAreaType:
                return value.(*SubjectAreaType), true
        case SubjectAreaType:
                v, _ := value.(SubjectAreaType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SubjectAreaType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSubjectAreaType() *SubjectAreaType {
  if out, ok := SubjectAreaTypePointer(SubjectAreaType{}); !ok {
                log.Fatalf("Could not create pointer to SubjectAreaType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SubstituteItemListType) Clone() (*SubstituteItemListType) {
return reprint.This(t).(*SubstituteItemListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SubstituteItemListTypePointer(value interface{}) (*SubstituteItemListType, bool) {
switch t := value.(type) {
        case *SubstituteItemListType:
                return value.(*SubstituteItemListType), true
        case SubstituteItemListType:
                v, _ := value.(SubstituteItemListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SubstituteItemListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSubstituteItemListType() *SubstituteItemListType {
  if out, ok := SubstituteItemListTypePointer(SubstituteItemListType{}); !ok {
                log.Fatalf("Could not create pointer to SubstituteItemListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SubstituteItemType) Clone() (*SubstituteItemType) {
return reprint.This(t).(*SubstituteItemType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SubstituteItemTypePointer(value interface{}) (*SubstituteItemType, bool) {
switch t := value.(type) {
        case *SubstituteItemType:
                return value.(*SubstituteItemType), true
        case SubstituteItemType:
                v, _ := value.(SubstituteItemType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SubstituteItemType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSubstituteItemType() *SubstituteItemType {
  if out, ok := SubstituteItemTypePointer(SubstituteItemType{}); !ok {
                log.Fatalf("Could not create pointer to SubstituteItemType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SuspensionContainerType) Clone() (*SuspensionContainerType) {
return reprint.This(t).(*SuspensionContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SuspensionContainerTypePointer(value interface{}) (*SuspensionContainerType, bool) {
switch t := value.(type) {
        case *SuspensionContainerType:
                return value.(*SuspensionContainerType), true
        case SuspensionContainerType:
                v, _ := value.(SuspensionContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SuspensionContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSuspensionContainerType() *SuspensionContainerType {
  if out, ok := SuspensionContainerTypePointer(SuspensionContainerType{}); !ok {
                log.Fatalf("Could not create pointer to SuspensionContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *SymptomListType) Clone() (*SymptomListType) {
return reprint.This(t).(*SymptomListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func SymptomListTypePointer(value interface{}) (*SymptomListType, bool) {
switch t := value.(type) {
        case *SymptomListType:
                return value.(*SymptomListType), true
        case SymptomListType:
                v, _ := value.(SymptomListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to SymptomListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewSymptomListType() *SymptomListType {
  if out, ok := SymptomListTypePointer(SymptomListType{}); !ok {
                log.Fatalf("Could not create pointer to SymptomListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeacherCoverType) Clone() (*TeacherCoverType) {
return reprint.This(t).(*TeacherCoverType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeacherCoverTypePointer(value interface{}) (*TeacherCoverType, bool) {
switch t := value.(type) {
        case *TeacherCoverType:
                return value.(*TeacherCoverType), true
        case TeacherCoverType:
                v, _ := value.(TeacherCoverType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeacherCoverType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeacherCoverType() *TeacherCoverType {
  if out, ok := TeacherCoverTypePointer(TeacherCoverType{}); !ok {
                log.Fatalf("Could not create pointer to TeacherCoverType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeacherListType) Clone() (*TeacherListType) {
return reprint.This(t).(*TeacherListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeacherListTypePointer(value interface{}) (*TeacherListType, bool) {
switch t := value.(type) {
        case *TeacherListType:
                return value.(*TeacherListType), true
        case TeacherListType:
                v, _ := value.(TeacherListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeacherListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeacherListType() *TeacherListType {
  if out, ok := TeacherListTypePointer(TeacherListType{}); !ok {
                log.Fatalf("Could not create pointer to TeacherListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeachingGroup) Clone() (*TeachingGroup) {
return reprint.This(t).(*TeachingGroup)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeachingGroupPointer(value interface{}) (*TeachingGroup, bool) {
switch t := value.(type) {
        case *TeachingGroup:
                return value.(*TeachingGroup), true
        case TeachingGroup:
                v, _ := value.(TeachingGroup)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeachingGroup\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeachingGroup() *TeachingGroup {
  if out, ok := TeachingGroupPointer(TeachingGroup{}); !ok {
                log.Fatalf("Could not create pointer to TeachingGroup\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeachingGroupListType) Clone() (*TeachingGroupListType) {
return reprint.This(t).(*TeachingGroupListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeachingGroupListTypePointer(value interface{}) (*TeachingGroupListType, bool) {
switch t := value.(type) {
        case *TeachingGroupListType:
                return value.(*TeachingGroupListType), true
        case TeachingGroupListType:
                v, _ := value.(TeachingGroupListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeachingGroupListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeachingGroupListType() *TeachingGroupListType {
  if out, ok := TeachingGroupListTypePointer(TeachingGroupListType{}); !ok {
                log.Fatalf("Could not create pointer to TeachingGroupListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeachingGroupPeriodListType) Clone() (*TeachingGroupPeriodListType) {
return reprint.This(t).(*TeachingGroupPeriodListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeachingGroupPeriodListTypePointer(value interface{}) (*TeachingGroupPeriodListType, bool) {
switch t := value.(type) {
        case *TeachingGroupPeriodListType:
                return value.(*TeachingGroupPeriodListType), true
        case TeachingGroupPeriodListType:
                v, _ := value.(TeachingGroupPeriodListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeachingGroupPeriodListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeachingGroupPeriodListType() *TeachingGroupPeriodListType {
  if out, ok := TeachingGroupPeriodListTypePointer(TeachingGroupPeriodListType{}); !ok {
                log.Fatalf("Could not create pointer to TeachingGroupPeriodListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeachingGroupPeriodType) Clone() (*TeachingGroupPeriodType) {
return reprint.This(t).(*TeachingGroupPeriodType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeachingGroupPeriodTypePointer(value interface{}) (*TeachingGroupPeriodType, bool) {
switch t := value.(type) {
        case *TeachingGroupPeriodType:
                return value.(*TeachingGroupPeriodType), true
        case TeachingGroupPeriodType:
                v, _ := value.(TeachingGroupPeriodType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeachingGroupPeriodType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeachingGroupPeriodType() *TeachingGroupPeriodType {
  if out, ok := TeachingGroupPeriodTypePointer(TeachingGroupPeriodType{}); !ok {
                log.Fatalf("Could not create pointer to TeachingGroupPeriodType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeachingGroupScheduleListType) Clone() (*TeachingGroupScheduleListType) {
return reprint.This(t).(*TeachingGroupScheduleListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeachingGroupScheduleListTypePointer(value interface{}) (*TeachingGroupScheduleListType, bool) {
switch t := value.(type) {
        case *TeachingGroupScheduleListType:
                return value.(*TeachingGroupScheduleListType), true
        case TeachingGroupScheduleListType:
                v, _ := value.(TeachingGroupScheduleListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeachingGroupScheduleListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeachingGroupScheduleListType() *TeachingGroupScheduleListType {
  if out, ok := TeachingGroupScheduleListTypePointer(TeachingGroupScheduleListType{}); !ok {
                log.Fatalf("Could not create pointer to TeachingGroupScheduleListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeachingGroupScheduleType) Clone() (*TeachingGroupScheduleType) {
return reprint.This(t).(*TeachingGroupScheduleType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeachingGroupScheduleTypePointer(value interface{}) (*TeachingGroupScheduleType, bool) {
switch t := value.(type) {
        case *TeachingGroupScheduleType:
                return value.(*TeachingGroupScheduleType), true
        case TeachingGroupScheduleType:
                v, _ := value.(TeachingGroupScheduleType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeachingGroupScheduleType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeachingGroupScheduleType() *TeachingGroupScheduleType {
  if out, ok := TeachingGroupScheduleTypePointer(TeachingGroupScheduleType{}); !ok {
                log.Fatalf("Could not create pointer to TeachingGroupScheduleType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeachingGroupStudentType) Clone() (*TeachingGroupStudentType) {
return reprint.This(t).(*TeachingGroupStudentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeachingGroupStudentTypePointer(value interface{}) (*TeachingGroupStudentType, bool) {
switch t := value.(type) {
        case *TeachingGroupStudentType:
                return value.(*TeachingGroupStudentType), true
        case TeachingGroupStudentType:
                v, _ := value.(TeachingGroupStudentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeachingGroupStudentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeachingGroupStudentType() *TeachingGroupStudentType {
  if out, ok := TeachingGroupStudentTypePointer(TeachingGroupStudentType{}); !ok {
                log.Fatalf("Could not create pointer to TeachingGroupStudentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeachingGroupTeacherType) Clone() (*TeachingGroupTeacherType) {
return reprint.This(t).(*TeachingGroupTeacherType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeachingGroupTeacherTypePointer(value interface{}) (*TeachingGroupTeacherType, bool) {
switch t := value.(type) {
        case *TeachingGroupTeacherType:
                return value.(*TeachingGroupTeacherType), true
        case TeachingGroupTeacherType:
                v, _ := value.(TeachingGroupTeacherType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeachingGroupTeacherType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTeachingGroupTeacherType() *TeachingGroupTeacherType {
  if out, ok := TeachingGroupTeacherTypePointer(TeachingGroupTeacherType{}); !ok {
                log.Fatalf("Could not create pointer to TeachingGroupTeacherType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TeachingGroups) Clone() (*TeachingGroups) {
return reprint.This(t).(*TeachingGroups)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TeachingGroupsPointer(value interface{}) (*TeachingGroups, bool) {
switch t := value.(type) {
        case *TeachingGroups:
                return value.(*TeachingGroups), true
        case TeachingGroups:
                v, _ := value.(TeachingGroups)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TeachingGroups\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TechnicalRequirementsType) Clone() (*TechnicalRequirementsType) {
return reprint.This(t).(*TechnicalRequirementsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TechnicalRequirementsTypePointer(value interface{}) (*TechnicalRequirementsType, bool) {
switch t := value.(type) {
        case *TechnicalRequirementsType:
                return value.(*TechnicalRequirementsType), true
        case TechnicalRequirementsType:
                v, _ := value.(TechnicalRequirementsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TechnicalRequirementsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTechnicalRequirementsType() *TechnicalRequirementsType {
  if out, ok := TechnicalRequirementsTypePointer(TechnicalRequirementsType{}); !ok {
                log.Fatalf("Could not create pointer to TechnicalRequirementsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TermInfo) Clone() (*TermInfo) {
return reprint.This(t).(*TermInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TermInfoPointer(value interface{}) (*TermInfo, bool) {
switch t := value.(type) {
        case *TermInfo:
                return value.(*TermInfo), true
        case TermInfo:
                v, _ := value.(TermInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TermInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTermInfo() *TermInfo {
  if out, ok := TermInfoPointer(TermInfo{}); !ok {
                log.Fatalf("Could not create pointer to TermInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TermInfos) Clone() (*TermInfos) {
return reprint.This(t).(*TermInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TermInfosPointer(value interface{}) (*TermInfos, bool) {
switch t := value.(type) {
        case *TermInfos:
                return value.(*TermInfos), true
        case TermInfos:
                v, _ := value.(TermInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TermInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TestDisruptionListType) Clone() (*TestDisruptionListType) {
return reprint.This(t).(*TestDisruptionListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TestDisruptionListTypePointer(value interface{}) (*TestDisruptionListType, bool) {
switch t := value.(type) {
        case *TestDisruptionListType:
                return value.(*TestDisruptionListType), true
        case TestDisruptionListType:
                v, _ := value.(TestDisruptionListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TestDisruptionListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTestDisruptionListType() *TestDisruptionListType {
  if out, ok := TestDisruptionListTypePointer(TestDisruptionListType{}); !ok {
                log.Fatalf("Could not create pointer to TestDisruptionListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TestDisruptionType) Clone() (*TestDisruptionType) {
return reprint.This(t).(*TestDisruptionType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TestDisruptionTypePointer(value interface{}) (*TestDisruptionType, bool) {
switch t := value.(type) {
        case *TestDisruptionType:
                return value.(*TestDisruptionType), true
        case TestDisruptionType:
                v, _ := value.(TestDisruptionType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TestDisruptionType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTestDisruptionType() *TestDisruptionType {
  if out, ok := TestDisruptionTypePointer(TestDisruptionType{}); !ok {
                log.Fatalf("Could not create pointer to TestDisruptionType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TextDataType) Clone() (*TextDataType) {
return reprint.This(t).(*TextDataType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TextDataTypePointer(value interface{}) (*TextDataType, bool) {
switch t := value.(type) {
        case *TextDataType:
                return value.(*TextDataType), true
        case TextDataType:
                v, _ := value.(TextDataType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TextDataType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTextDataType() *TextDataType {
  if out, ok := TextDataTypePointer(TextDataType{}); !ok {
                log.Fatalf("Could not create pointer to TextDataType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeElementListType) Clone() (*TimeElementListType) {
return reprint.This(t).(*TimeElementListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeElementListTypePointer(value interface{}) (*TimeElementListType, bool) {
switch t := value.(type) {
        case *TimeElementListType:
                return value.(*TimeElementListType), true
        case TimeElementListType:
                v, _ := value.(TimeElementListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeElementListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeElementListType() *TimeElementListType {
  if out, ok := TimeElementListTypePointer(TimeElementListType{}); !ok {
                log.Fatalf("Could not create pointer to TimeElementListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeElementType) Clone() (*TimeElementType) {
return reprint.This(t).(*TimeElementType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeElementTypePointer(value interface{}) (*TimeElementType, bool) {
switch t := value.(type) {
        case *TimeElementType:
                return value.(*TimeElementType), true
        case TimeElementType:
                v, _ := value.(TimeElementType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeElementType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeElementType() *TimeElementType {
  if out, ok := TimeElementTypePointer(TimeElementType{}); !ok {
                log.Fatalf("Could not create pointer to TimeElementType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTable) Clone() (*TimeTable) {
return reprint.This(t).(*TimeTable)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTablePointer(value interface{}) (*TimeTable, bool) {
switch t := value.(type) {
        case *TimeTable:
                return value.(*TimeTable), true
        case TimeTable:
                v, _ := value.(TimeTable)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTable\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTable() *TimeTable {
  if out, ok := TimeTablePointer(TimeTable{}); !ok {
                log.Fatalf("Could not create pointer to TimeTable\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableCell) Clone() (*TimeTableCell) {
return reprint.This(t).(*TimeTableCell)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableCellPointer(value interface{}) (*TimeTableCell, bool) {
switch t := value.(type) {
        case *TimeTableCell:
                return value.(*TimeTableCell), true
        case TimeTableCell:
                v, _ := value.(TimeTableCell)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableCell\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableCell() *TimeTableCell {
  if out, ok := TimeTableCellPointer(TimeTableCell{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableCell\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableCells) Clone() (*TimeTableCells) {
return reprint.This(t).(*TimeTableCells)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableCellsPointer(value interface{}) (*TimeTableCells, bool) {
switch t := value.(type) {
        case *TimeTableCells:
                return value.(*TimeTableCells), true
        case TimeTableCells:
                v, _ := value.(TimeTableCells)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableCells\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableChangeReasonListType) Clone() (*TimeTableChangeReasonListType) {
return reprint.This(t).(*TimeTableChangeReasonListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableChangeReasonListTypePointer(value interface{}) (*TimeTableChangeReasonListType, bool) {
switch t := value.(type) {
        case *TimeTableChangeReasonListType:
                return value.(*TimeTableChangeReasonListType), true
        case TimeTableChangeReasonListType:
                v, _ := value.(TimeTableChangeReasonListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableChangeReasonListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableChangeReasonListType() *TimeTableChangeReasonListType {
  if out, ok := TimeTableChangeReasonListTypePointer(TimeTableChangeReasonListType{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableChangeReasonListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableChangeReasonType) Clone() (*TimeTableChangeReasonType) {
return reprint.This(t).(*TimeTableChangeReasonType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableChangeReasonTypePointer(value interface{}) (*TimeTableChangeReasonType, bool) {
switch t := value.(type) {
        case *TimeTableChangeReasonType:
                return value.(*TimeTableChangeReasonType), true
        case TimeTableChangeReasonType:
                v, _ := value.(TimeTableChangeReasonType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableChangeReasonType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableChangeReasonType() *TimeTableChangeReasonType {
  if out, ok := TimeTableChangeReasonTypePointer(TimeTableChangeReasonType{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableChangeReasonType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableContainer) Clone() (*TimeTableContainer) {
return reprint.This(t).(*TimeTableContainer)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableContainerPointer(value interface{}) (*TimeTableContainer, bool) {
switch t := value.(type) {
        case *TimeTableContainer:
                return value.(*TimeTableContainer), true
        case TimeTableContainer:
                v, _ := value.(TimeTableContainer)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableContainer\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableContainer() *TimeTableContainer {
  if out, ok := TimeTableContainerPointer(TimeTableContainer{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableContainer\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableContainers) Clone() (*TimeTableContainers) {
return reprint.This(t).(*TimeTableContainers)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableContainersPointer(value interface{}) (*TimeTableContainers, bool) {
switch t := value.(type) {
        case *TimeTableContainers:
                return value.(*TimeTableContainers), true
        case TimeTableContainers:
                v, _ := value.(TimeTableContainers)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableContainers\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableDayListType) Clone() (*TimeTableDayListType) {
return reprint.This(t).(*TimeTableDayListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableDayListTypePointer(value interface{}) (*TimeTableDayListType, bool) {
switch t := value.(type) {
        case *TimeTableDayListType:
                return value.(*TimeTableDayListType), true
        case TimeTableDayListType:
                v, _ := value.(TimeTableDayListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableDayListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableDayListType() *TimeTableDayListType {
  if out, ok := TimeTableDayListTypePointer(TimeTableDayListType{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableDayListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableDayType) Clone() (*TimeTableDayType) {
return reprint.This(t).(*TimeTableDayType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableDayTypePointer(value interface{}) (*TimeTableDayType, bool) {
switch t := value.(type) {
        case *TimeTableDayType:
                return value.(*TimeTableDayType), true
        case TimeTableDayType:
                v, _ := value.(TimeTableDayType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableDayType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableDayType() *TimeTableDayType {
  if out, ok := TimeTableDayTypePointer(TimeTableDayType{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableDayType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTablePeriodListType) Clone() (*TimeTablePeriodListType) {
return reprint.This(t).(*TimeTablePeriodListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTablePeriodListTypePointer(value interface{}) (*TimeTablePeriodListType, bool) {
switch t := value.(type) {
        case *TimeTablePeriodListType:
                return value.(*TimeTablePeriodListType), true
        case TimeTablePeriodListType:
                v, _ := value.(TimeTablePeriodListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTablePeriodListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTablePeriodListType() *TimeTablePeriodListType {
  if out, ok := TimeTablePeriodListTypePointer(TimeTablePeriodListType{}); !ok {
                log.Fatalf("Could not create pointer to TimeTablePeriodListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTablePeriodType) Clone() (*TimeTablePeriodType) {
return reprint.This(t).(*TimeTablePeriodType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTablePeriodTypePointer(value interface{}) (*TimeTablePeriodType, bool) {
switch t := value.(type) {
        case *TimeTablePeriodType:
                return value.(*TimeTablePeriodType), true
        case TimeTablePeriodType:
                v, _ := value.(TimeTablePeriodType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTablePeriodType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTablePeriodType() *TimeTablePeriodType {
  if out, ok := TimeTablePeriodTypePointer(TimeTablePeriodType{}); !ok {
                log.Fatalf("Could not create pointer to TimeTablePeriodType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableScheduleCellListType) Clone() (*TimeTableScheduleCellListType) {
return reprint.This(t).(*TimeTableScheduleCellListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableScheduleCellListTypePointer(value interface{}) (*TimeTableScheduleCellListType, bool) {
switch t := value.(type) {
        case *TimeTableScheduleCellListType:
                return value.(*TimeTableScheduleCellListType), true
        case TimeTableScheduleCellListType:
                v, _ := value.(TimeTableScheduleCellListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableScheduleCellListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableScheduleCellListType() *TimeTableScheduleCellListType {
  if out, ok := TimeTableScheduleCellListTypePointer(TimeTableScheduleCellListType{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableScheduleCellListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableScheduleCellType) Clone() (*TimeTableScheduleCellType) {
return reprint.This(t).(*TimeTableScheduleCellType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableScheduleCellTypePointer(value interface{}) (*TimeTableScheduleCellType, bool) {
switch t := value.(type) {
        case *TimeTableScheduleCellType:
                return value.(*TimeTableScheduleCellType), true
        case TimeTableScheduleCellType:
                v, _ := value.(TimeTableScheduleCellType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableScheduleCellType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableScheduleCellType() *TimeTableScheduleCellType {
  if out, ok := TimeTableScheduleCellTypePointer(TimeTableScheduleCellType{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableScheduleCellType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableScheduleType) Clone() (*TimeTableScheduleType) {
return reprint.This(t).(*TimeTableScheduleType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableScheduleTypePointer(value interface{}) (*TimeTableScheduleType, bool) {
switch t := value.(type) {
        case *TimeTableScheduleType:
                return value.(*TimeTableScheduleType), true
        case TimeTableScheduleType:
                v, _ := value.(TimeTableScheduleType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableScheduleType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableScheduleType() *TimeTableScheduleType {
  if out, ok := TimeTableScheduleTypePointer(TimeTableScheduleType{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableScheduleType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableSubject) Clone() (*TimeTableSubject) {
return reprint.This(t).(*TimeTableSubject)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableSubjectPointer(value interface{}) (*TimeTableSubject, bool) {
switch t := value.(type) {
        case *TimeTableSubject:
                return value.(*TimeTableSubject), true
        case TimeTableSubject:
                v, _ := value.(TimeTableSubject)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableSubject\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTimeTableSubject() *TimeTableSubject {
  if out, ok := TimeTableSubjectPointer(TimeTableSubject{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableSubject\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTableSubjects) Clone() (*TimeTableSubjects) {
return reprint.This(t).(*TimeTableSubjects)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTableSubjectsPointer(value interface{}) (*TimeTableSubjects, bool) {
switch t := value.(type) {
        case *TimeTableSubjects:
                return value.(*TimeTableSubjects), true
        case TimeTableSubjects:
                v, _ := value.(TimeTableSubjects)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTableSubjects\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TimeTables) Clone() (*TimeTables) {
return reprint.This(t).(*TimeTables)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TimeTablesPointer(value interface{}) (*TimeTables, bool) {
switch t := value.(type) {
        case *TimeTables:
                return value.(*TimeTables), true
        case TimeTables:
                v, _ := value.(TimeTables)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TimeTables\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TotalEnrollmentsType) Clone() (*TotalEnrollmentsType) {
return reprint.This(t).(*TotalEnrollmentsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TotalEnrollmentsTypePointer(value interface{}) (*TotalEnrollmentsType, bool) {
switch t := value.(type) {
        case *TotalEnrollmentsType:
                return value.(*TotalEnrollmentsType), true
        case TotalEnrollmentsType:
                v, _ := value.(TotalEnrollmentsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TotalEnrollmentsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTotalEnrollmentsType() *TotalEnrollmentsType {
  if out, ok := TotalEnrollmentsTypePointer(TotalEnrollmentsType{}); !ok {
                log.Fatalf("Could not create pointer to TotalEnrollmentsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TravelDetailsContainerType) Clone() (*TravelDetailsContainerType) {
return reprint.This(t).(*TravelDetailsContainerType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TravelDetailsContainerTypePointer(value interface{}) (*TravelDetailsContainerType, bool) {
switch t := value.(type) {
        case *TravelDetailsContainerType:
                return value.(*TravelDetailsContainerType), true
        case TravelDetailsContainerType:
                v, _ := value.(TravelDetailsContainerType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TravelDetailsContainerType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTravelDetailsContainerType() *TravelDetailsContainerType {
  if out, ok := TravelDetailsContainerTypePointer(TravelDetailsContainerType{}); !ok {
                log.Fatalf("Could not create pointer to TravelDetailsContainerType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *TypedIdRefType) Clone() (*TypedIdRefType) {
return reprint.This(t).(*TypedIdRefType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func TypedIdRefTypePointer(value interface{}) (*TypedIdRefType, bool) {
switch t := value.(type) {
        case *TypedIdRefType:
                return value.(*TypedIdRefType), true
        case TypedIdRefType:
                v, _ := value.(TypedIdRefType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to TypedIdRefType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewTypedIdRefType() *TypedIdRefType {
  if out, ok := TypedIdRefTypePointer(TypedIdRefType{}); !ok {
                log.Fatalf("Could not create pointer to TypedIdRefType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ValidLetterMarkListType) Clone() (*ValidLetterMarkListType) {
return reprint.This(t).(*ValidLetterMarkListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ValidLetterMarkListTypePointer(value interface{}) (*ValidLetterMarkListType, bool) {
switch t := value.(type) {
        case *ValidLetterMarkListType:
                return value.(*ValidLetterMarkListType), true
        case ValidLetterMarkListType:
                v, _ := value.(ValidLetterMarkListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ValidLetterMarkListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewValidLetterMarkListType() *ValidLetterMarkListType {
  if out, ok := ValidLetterMarkListTypePointer(ValidLetterMarkListType{}); !ok {
                log.Fatalf("Could not create pointer to ValidLetterMarkListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *ValidLetterMarkType) Clone() (*ValidLetterMarkType) {
return reprint.This(t).(*ValidLetterMarkType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func ValidLetterMarkTypePointer(value interface{}) (*ValidLetterMarkType, bool) {
switch t := value.(type) {
        case *ValidLetterMarkType:
                return value.(*ValidLetterMarkType), true
        case ValidLetterMarkType:
                v, _ := value.(ValidLetterMarkType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to ValidLetterMarkType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewValidLetterMarkType() *ValidLetterMarkType {
  if out, ok := ValidLetterMarkTypePointer(ValidLetterMarkType{}); !ok {
                log.Fatalf("Could not create pointer to ValidLetterMarkType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *VendorInfo) Clone() (*VendorInfo) {
return reprint.This(t).(*VendorInfo)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func VendorInfoPointer(value interface{}) (*VendorInfo, bool) {
switch t := value.(type) {
        case *VendorInfo:
                return value.(*VendorInfo), true
        case VendorInfo:
                v, _ := value.(VendorInfo)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to VendorInfo\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewVendorInfo() *VendorInfo {
  if out, ok := VendorInfoPointer(VendorInfo{}); !ok {
                log.Fatalf("Could not create pointer to VendorInfo\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *VendorInfos) Clone() (*VendorInfos) {
return reprint.This(t).(*VendorInfos)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func VendorInfosPointer(value interface{}) (*VendorInfos, bool) {
switch t := value.(type) {
        case *VendorInfos:
                return value.(*VendorInfos), true
        case VendorInfos:
                v, _ := value.(VendorInfos)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to VendorInfos\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *VisaSubClassListType) Clone() (*VisaSubClassListType) {
return reprint.This(t).(*VisaSubClassListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func VisaSubClassListTypePointer(value interface{}) (*VisaSubClassListType, bool) {
switch t := value.(type) {
        case *VisaSubClassListType:
                return value.(*VisaSubClassListType), true
        case VisaSubClassListType:
                v, _ := value.(VisaSubClassListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to VisaSubClassListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewVisaSubClassListType() *VisaSubClassListType {
  if out, ok := VisaSubClassListTypePointer(VisaSubClassListType{}); !ok {
                log.Fatalf("Could not create pointer to VisaSubClassListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *VisaSubClassType) Clone() (*VisaSubClassType) {
return reprint.This(t).(*VisaSubClassType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func VisaSubClassTypePointer(value interface{}) (*VisaSubClassType, bool) {
switch t := value.(type) {
        case *VisaSubClassType:
                return value.(*VisaSubClassType), true
        case VisaSubClassType:
                v, _ := value.(VisaSubClassType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to VisaSubClassType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewVisaSubClassType() *VisaSubClassType {
  if out, ok := VisaSubClassTypePointer(VisaSubClassType{}); !ok {
                log.Fatalf("Could not create pointer to VisaSubClassType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingAlert) Clone() (*WellbeingAlert) {
return reprint.This(t).(*WellbeingAlert)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingAlertPointer(value interface{}) (*WellbeingAlert, bool) {
switch t := value.(type) {
        case *WellbeingAlert:
                return value.(*WellbeingAlert), true
        case WellbeingAlert:
                v, _ := value.(WellbeingAlert)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingAlert\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingAlert() *WellbeingAlert {
  if out, ok := WellbeingAlertPointer(WellbeingAlert{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingAlert\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingAlerts) Clone() (*WellbeingAlerts) {
return reprint.This(t).(*WellbeingAlerts)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingAlertsPointer(value interface{}) (*WellbeingAlerts, bool) {
switch t := value.(type) {
        case *WellbeingAlerts:
                return value.(*WellbeingAlerts), true
        case WellbeingAlerts:
                v, _ := value.(WellbeingAlerts)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingAlerts\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingAppeal) Clone() (*WellbeingAppeal) {
return reprint.This(t).(*WellbeingAppeal)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingAppealPointer(value interface{}) (*WellbeingAppeal, bool) {
switch t := value.(type) {
        case *WellbeingAppeal:
                return value.(*WellbeingAppeal), true
        case WellbeingAppeal:
                v, _ := value.(WellbeingAppeal)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingAppeal\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingAppeal() *WellbeingAppeal {
  if out, ok := WellbeingAppealPointer(WellbeingAppeal{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingAppeal\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingAppeals) Clone() (*WellbeingAppeals) {
return reprint.This(t).(*WellbeingAppeals)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingAppealsPointer(value interface{}) (*WellbeingAppeals, bool) {
switch t := value.(type) {
        case *WellbeingAppeals:
                return value.(*WellbeingAppeals), true
        case WellbeingAppeals:
                v, _ := value.(WellbeingAppeals)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingAppeals\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingCharacteristic) Clone() (*WellbeingCharacteristic) {
return reprint.This(t).(*WellbeingCharacteristic)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingCharacteristicPointer(value interface{}) (*WellbeingCharacteristic, bool) {
switch t := value.(type) {
        case *WellbeingCharacteristic:
                return value.(*WellbeingCharacteristic), true
        case WellbeingCharacteristic:
                v, _ := value.(WellbeingCharacteristic)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingCharacteristic\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingCharacteristic() *WellbeingCharacteristic {
  if out, ok := WellbeingCharacteristicPointer(WellbeingCharacteristic{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingCharacteristic\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingCharacteristics) Clone() (*WellbeingCharacteristics) {
return reprint.This(t).(*WellbeingCharacteristics)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingCharacteristicsPointer(value interface{}) (*WellbeingCharacteristics, bool) {
switch t := value.(type) {
        case *WellbeingCharacteristics:
                return value.(*WellbeingCharacteristics), true
        case WellbeingCharacteristics:
                v, _ := value.(WellbeingCharacteristics)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingCharacteristics\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingDocumentListType) Clone() (*WellbeingDocumentListType) {
return reprint.This(t).(*WellbeingDocumentListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingDocumentListTypePointer(value interface{}) (*WellbeingDocumentListType, bool) {
switch t := value.(type) {
        case *WellbeingDocumentListType:
                return value.(*WellbeingDocumentListType), true
        case WellbeingDocumentListType:
                v, _ := value.(WellbeingDocumentListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingDocumentListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingDocumentListType() *WellbeingDocumentListType {
  if out, ok := WellbeingDocumentListTypePointer(WellbeingDocumentListType{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingDocumentListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingDocumentType) Clone() (*WellbeingDocumentType) {
return reprint.This(t).(*WellbeingDocumentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingDocumentTypePointer(value interface{}) (*WellbeingDocumentType, bool) {
switch t := value.(type) {
        case *WellbeingDocumentType:
                return value.(*WellbeingDocumentType), true
        case WellbeingDocumentType:
                v, _ := value.(WellbeingDocumentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingDocumentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingDocumentType() *WellbeingDocumentType {
  if out, ok := WellbeingDocumentTypePointer(WellbeingDocumentType{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingDocumentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingEvent) Clone() (*WellbeingEvent) {
return reprint.This(t).(*WellbeingEvent)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingEventPointer(value interface{}) (*WellbeingEvent, bool) {
switch t := value.(type) {
        case *WellbeingEvent:
                return value.(*WellbeingEvent), true
        case WellbeingEvent:
                v, _ := value.(WellbeingEvent)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingEvent\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingEvent() *WellbeingEvent {
  if out, ok := WellbeingEventPointer(WellbeingEvent{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingEvent\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingEventCategoryListType) Clone() (*WellbeingEventCategoryListType) {
return reprint.This(t).(*WellbeingEventCategoryListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingEventCategoryListTypePointer(value interface{}) (*WellbeingEventCategoryListType, bool) {
switch t := value.(type) {
        case *WellbeingEventCategoryListType:
                return value.(*WellbeingEventCategoryListType), true
        case WellbeingEventCategoryListType:
                v, _ := value.(WellbeingEventCategoryListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingEventCategoryListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingEventCategoryListType() *WellbeingEventCategoryListType {
  if out, ok := WellbeingEventCategoryListTypePointer(WellbeingEventCategoryListType{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingEventCategoryListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingEventCategoryType) Clone() (*WellbeingEventCategoryType) {
return reprint.This(t).(*WellbeingEventCategoryType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingEventCategoryTypePointer(value interface{}) (*WellbeingEventCategoryType, bool) {
switch t := value.(type) {
        case *WellbeingEventCategoryType:
                return value.(*WellbeingEventCategoryType), true
        case WellbeingEventCategoryType:
                v, _ := value.(WellbeingEventCategoryType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingEventCategoryType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingEventCategoryType() *WellbeingEventCategoryType {
  if out, ok := WellbeingEventCategoryTypePointer(WellbeingEventCategoryType{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingEventCategoryType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingEventLocationDetailsType) Clone() (*WellbeingEventLocationDetailsType) {
return reprint.This(t).(*WellbeingEventLocationDetailsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingEventLocationDetailsTypePointer(value interface{}) (*WellbeingEventLocationDetailsType, bool) {
switch t := value.(type) {
        case *WellbeingEventLocationDetailsType:
                return value.(*WellbeingEventLocationDetailsType), true
        case WellbeingEventLocationDetailsType:
                v, _ := value.(WellbeingEventLocationDetailsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingEventLocationDetailsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingEventLocationDetailsType() *WellbeingEventLocationDetailsType {
  if out, ok := WellbeingEventLocationDetailsTypePointer(WellbeingEventLocationDetailsType{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingEventLocationDetailsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingEventSubCategoryListType) Clone() (*WellbeingEventSubCategoryListType) {
return reprint.This(t).(*WellbeingEventSubCategoryListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingEventSubCategoryListTypePointer(value interface{}) (*WellbeingEventSubCategoryListType, bool) {
switch t := value.(type) {
        case *WellbeingEventSubCategoryListType:
                return value.(*WellbeingEventSubCategoryListType), true
        case WellbeingEventSubCategoryListType:
                v, _ := value.(WellbeingEventSubCategoryListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingEventSubCategoryListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingEventSubCategoryListType() *WellbeingEventSubCategoryListType {
  if out, ok := WellbeingEventSubCategoryListTypePointer(WellbeingEventSubCategoryListType{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingEventSubCategoryListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingEvents) Clone() (*WellbeingEvents) {
return reprint.This(t).(*WellbeingEvents)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingEventsPointer(value interface{}) (*WellbeingEvents, bool) {
switch t := value.(type) {
        case *WellbeingEvents:
                return value.(*WellbeingEvents), true
        case WellbeingEvents:
                v, _ := value.(WellbeingEvents)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingEvents\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingPersonLink) Clone() (*WellbeingPersonLink) {
return reprint.This(t).(*WellbeingPersonLink)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingPersonLinkPointer(value interface{}) (*WellbeingPersonLink, bool) {
switch t := value.(type) {
        case *WellbeingPersonLink:
                return value.(*WellbeingPersonLink), true
        case WellbeingPersonLink:
                v, _ := value.(WellbeingPersonLink)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingPersonLink\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingPersonLink() *WellbeingPersonLink {
  if out, ok := WellbeingPersonLinkPointer(WellbeingPersonLink{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingPersonLink\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingPersonLink_PersonRefId) Clone() (*WellbeingPersonLink_PersonRefId) {
return reprint.This(t).(*WellbeingPersonLink_PersonRefId)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingPersonLink_PersonRefIdPointer(value interface{}) (*WellbeingPersonLink_PersonRefId, bool) {
switch t := value.(type) {
        case *WellbeingPersonLink_PersonRefId:
                return value.(*WellbeingPersonLink_PersonRefId), true
        case WellbeingPersonLink_PersonRefId:
                v, _ := value.(WellbeingPersonLink_PersonRefId)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingPersonLink_PersonRefId\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingPersonLink_PersonRefId() *WellbeingPersonLink_PersonRefId {
  if out, ok := WellbeingPersonLink_PersonRefIdPointer(WellbeingPersonLink_PersonRefId{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingPersonLink_PersonRefId\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingPersonLinks) Clone() (*WellbeingPersonLinks) {
return reprint.This(t).(*WellbeingPersonLinks)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingPersonLinksPointer(value interface{}) (*WellbeingPersonLinks, bool) {
switch t := value.(type) {
        case *WellbeingPersonLinks:
                return value.(*WellbeingPersonLinks), true
        case WellbeingPersonLinks:
                v, _ := value.(WellbeingPersonLinks)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingPersonLinks\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingPlanType) Clone() (*WellbeingPlanType) {
return reprint.This(t).(*WellbeingPlanType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingPlanTypePointer(value interface{}) (*WellbeingPlanType, bool) {
switch t := value.(type) {
        case *WellbeingPlanType:
                return value.(*WellbeingPlanType), true
        case WellbeingPlanType:
                v, _ := value.(WellbeingPlanType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingPlanType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingPlanType() *WellbeingPlanType {
  if out, ok := WellbeingPlanTypePointer(WellbeingPlanType{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingPlanType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingResponse) Clone() (*WellbeingResponse) {
return reprint.This(t).(*WellbeingResponse)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingResponsePointer(value interface{}) (*WellbeingResponse, bool) {
switch t := value.(type) {
        case *WellbeingResponse:
                return value.(*WellbeingResponse), true
        case WellbeingResponse:
                v, _ := value.(WellbeingResponse)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingResponse\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWellbeingResponse() *WellbeingResponse {
  if out, ok := WellbeingResponsePointer(WellbeingResponse{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingResponse\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WellbeingResponses) Clone() (*WellbeingResponses) {
return reprint.This(t).(*WellbeingResponses)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WellbeingResponsesPointer(value interface{}) (*WellbeingResponses, bool) {
switch t := value.(type) {
        case *WellbeingResponses:
                return value.(*WellbeingResponses), true
        case WellbeingResponses:
                v, _ := value.(WellbeingResponses)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WellbeingResponses\n", t, value)
        }
        return nil, false
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WithdrawalTimeListType) Clone() (*WithdrawalTimeListType) {
return reprint.This(t).(*WithdrawalTimeListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WithdrawalTimeListTypePointer(value interface{}) (*WithdrawalTimeListType, bool) {
switch t := value.(type) {
        case *WithdrawalTimeListType:
                return value.(*WithdrawalTimeListType), true
        case WithdrawalTimeListType:
                v, _ := value.(WithdrawalTimeListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WithdrawalTimeListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWithdrawalTimeListType() *WithdrawalTimeListType {
  if out, ok := WithdrawalTimeListTypePointer(WithdrawalTimeListType{}); !ok {
                log.Fatalf("Could not create pointer to WithdrawalTimeListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WithdrawalType) Clone() (*WithdrawalType) {
return reprint.This(t).(*WithdrawalType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WithdrawalTypePointer(value interface{}) (*WithdrawalType, bool) {
switch t := value.(type) {
        case *WithdrawalType:
                return value.(*WithdrawalType), true
        case WithdrawalType:
                v, _ := value.(WithdrawalType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WithdrawalType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWithdrawalType() *WithdrawalType {
  if out, ok := WithdrawalTypePointer(WithdrawalType{}); !ok {
                log.Fatalf("Could not create pointer to WithdrawalType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *WorkingWithChildrenCheckType) Clone() (*WorkingWithChildrenCheckType) {
return reprint.This(t).(*WorkingWithChildrenCheckType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func WorkingWithChildrenCheckTypePointer(value interface{}) (*WorkingWithChildrenCheckType, bool) {
switch t := value.(type) {
        case *WorkingWithChildrenCheckType:
                return value.(*WorkingWithChildrenCheckType), true
        case WorkingWithChildrenCheckType:
                v, _ := value.(WorkingWithChildrenCheckType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to WorkingWithChildrenCheckType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewWorkingWithChildrenCheckType() *WorkingWithChildrenCheckType {
  if out, ok := WorkingWithChildrenCheckTypePointer(WorkingWithChildrenCheckType{}); !ok {
                log.Fatalf("Could not create pointer to WorkingWithChildrenCheckType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *XMLDataType) Clone() (*XMLDataType) {
return reprint.This(t).(*XMLDataType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func XMLDataTypePointer(value interface{}) (*XMLDataType, bool) {
switch t := value.(type) {
        case *XMLDataType:
                return value.(*XMLDataType), true
        case XMLDataType:
                v, _ := value.(XMLDataType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to XMLDataType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewXMLDataType() *XMLDataType {
  if out, ok := XMLDataTypePointer(XMLDataType{}); !ok {
                log.Fatalf("Could not create pointer to XMLDataType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *YearLevelEnrollmentListType) Clone() (*YearLevelEnrollmentListType) {
return reprint.This(t).(*YearLevelEnrollmentListType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func YearLevelEnrollmentListTypePointer(value interface{}) (*YearLevelEnrollmentListType, bool) {
switch t := value.(type) {
        case *YearLevelEnrollmentListType:
                return value.(*YearLevelEnrollmentListType), true
        case YearLevelEnrollmentListType:
                v, _ := value.(YearLevelEnrollmentListType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to YearLevelEnrollmentListType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewYearLevelEnrollmentListType() *YearLevelEnrollmentListType {
  if out, ok := YearLevelEnrollmentListTypePointer(YearLevelEnrollmentListType{}); !ok {
                log.Fatalf("Could not create pointer to YearLevelEnrollmentListType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *YearLevelEnrollmentType) Clone() (*YearLevelEnrollmentType) {
return reprint.This(t).(*YearLevelEnrollmentType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func YearLevelEnrollmentTypePointer(value interface{}) (*YearLevelEnrollmentType, bool) {
switch t := value.(type) {
        case *YearLevelEnrollmentType:
                return value.(*YearLevelEnrollmentType), true
        case YearLevelEnrollmentType:
                v, _ := value.(YearLevelEnrollmentType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to YearLevelEnrollmentType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewYearLevelEnrollmentType() *YearLevelEnrollmentType {
  if out, ok := YearLevelEnrollmentTypePointer(YearLevelEnrollmentType{}); !ok {
                log.Fatalf("Could not create pointer to YearLevelEnrollmentType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *YearLevelType) Clone() (*YearLevelType) {
return reprint.This(t).(*YearLevelType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func YearLevelTypePointer(value interface{}) (*YearLevelType, bool) {
switch t := value.(type) {
        case *YearLevelType:
                return value.(*YearLevelType), true
        case YearLevelType:
                v, _ := value.(YearLevelType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to YearLevelType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewYearLevelType() *YearLevelType {
  if out, ok := YearLevelTypePointer(YearLevelType{}); !ok {
                log.Fatalf("Could not create pointer to YearLevelType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *YearLevelsType) Clone() (*YearLevelsType) {
return reprint.This(t).(*YearLevelsType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func YearLevelsTypePointer(value interface{}) (*YearLevelsType, bool) {
switch t := value.(type) {
        case *YearLevelsType:
                return value.(*YearLevelsType), true
        case YearLevelsType:
                v, _ := value.(YearLevelsType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to YearLevelsType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewYearLevelsType() *YearLevelsType {
  if out, ok := YearLevelsTypePointer(YearLevelsType{}); !ok {
                log.Fatalf("Could not create pointer to YearLevelsType\n")
                return nil
        } else {
                return out
        }
  }
// Performs a deep clone on the type, and is used to duplicate an element into another container (particularly if the element is itself nested)
  func (t *YearRangeType) Clone() (*YearRangeType) {
return reprint.This(t).(*YearRangeType)
}
// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches X.
  func YearRangeTypePointer(value interface{}) (*YearRangeType, bool) {
switch t := value.(type) {
        case *YearRangeType:
                return value.(*YearRangeType), true
        case YearRangeType:
                v, _ := value.(YearRangeType)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to YearRangeType\n", t, value)
        }
        return nil, false
  }

// Generates a new object as a pointer to a struct
func NewYearRangeType() *YearRangeType {
  if out, ok := YearRangeTypePointer(YearRangeType{}); !ok {
                log.Fatalf("Could not create pointer to YearRangeType\n")
                return nil
        } else {
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ACStrandAreaListType) Append(values ...ACStrandSubjectAreaType) *ACStrandAreaListType {
    
        if t == nil {
                t, _ = ACStrandAreaListTypePointer(ACStrandAreaListType{})
        }
        if t.ACStrandSubjectArea == nil {
                t.ACStrandSubjectArea = make([]ACStrandSubjectAreaType, 0)
        }
        for _, value := range values {
        t.ACStrandSubjectArea = append(t.ACStrandSubjectArea, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ACStrandAreaListType) AddNew() *ACStrandAreaListType {
        if t == nil {
                t, _ = ACStrandAreaListTypePointer(ACStrandAreaListType{})
        }
        if t.ACStrandSubjectArea == nil {
                t.ACStrandSubjectArea = make([]ACStrandSubjectAreaType, 0)
        }
        t.ACStrandSubjectArea = append(t.ACStrandSubjectArea, ACStrandSubjectAreaType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ACStrandAreaListType) Last() *ACStrandSubjectAreaType {
  if t.ACStrandSubjectArea == nil {
    t = t.AddNew()
    }
        return &(t.ACStrandSubjectArea[len(t.ACStrandSubjectArea)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ACStrandAreaListType) Index(n int) (*ACStrandSubjectAreaType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ACStrandAreaListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ACStrandSubjectArea == nil {
    t = t.AddNew()
    }
        return &(t.ACStrandSubjectArea[n])
}

// Length of the list.
func (t *ACStrandAreaListType) Len() int {
  if t.ACStrandSubjectArea == nil {
    t = t.AddNew()
    }
        return len(t.ACStrandSubjectArea)
}

// Convert list object to slice
func (t *ACStrandAreaListType) ToSlice() []*ACStrandSubjectAreaType {
  ret := make([]*ACStrandSubjectAreaType, 0)
  for _, x:= range t.ACStrandSubjectArea {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AGContextualQuestionListType) Append(values ...AGContextualQuestionType) *AGContextualQuestionListType {
    
        if t == nil {
                t, _ = AGContextualQuestionListTypePointer(AGContextualQuestionListType{})
        }
        if t.AGContextualQuestion == nil {
                t.AGContextualQuestion = make([]AGContextualQuestionType, 0)
        }
        for _, value := range values {
        t.AGContextualQuestion = append(t.AGContextualQuestion, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AGContextualQuestionListType) AddNew() *AGContextualQuestionListType {
        if t == nil {
                t, _ = AGContextualQuestionListTypePointer(AGContextualQuestionListType{})
        }
        if t.AGContextualQuestion == nil {
                t.AGContextualQuestion = make([]AGContextualQuestionType, 0)
        }
        t.AGContextualQuestion = append(t.AGContextualQuestion, AGContextualQuestionType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AGContextualQuestionListType) Last() *AGContextualQuestionType {
  if t.AGContextualQuestion == nil {
    t = t.AddNew()
    }
        return &(t.AGContextualQuestion[len(t.AGContextualQuestion)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AGContextualQuestionListType) Index(n int) (*AGContextualQuestionType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AGContextualQuestionListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AGContextualQuestion == nil {
    t = t.AddNew()
    }
        return &(t.AGContextualQuestion[n])
}

// Length of the list.
func (t *AGContextualQuestionListType) Len() int {
  if t.AGContextualQuestion == nil {
    t = t.AddNew()
    }
        return len(t.AGContextualQuestion)
}

// Convert list object to slice
func (t *AGContextualQuestionListType) ToSlice() []*AGContextualQuestionType {
  ret := make([]*AGContextualQuestionType, 0)
  for _, x:= range t.AGContextualQuestion {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AGReportingObjectResponseListType) Append(values ...AGReportingObjectResponseType) *AGReportingObjectResponseListType {
    
        if t == nil {
                t, _ = AGReportingObjectResponseListTypePointer(AGReportingObjectResponseListType{})
        }
        if t.AGReportingObjectResponse == nil {
                t.AGReportingObjectResponse = make([]AGReportingObjectResponseType, 0)
        }
        for _, value := range values {
        t.AGReportingObjectResponse = append(t.AGReportingObjectResponse, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AGReportingObjectResponseListType) AddNew() *AGReportingObjectResponseListType {
        if t == nil {
                t, _ = AGReportingObjectResponseListTypePointer(AGReportingObjectResponseListType{})
        }
        if t.AGReportingObjectResponse == nil {
                t.AGReportingObjectResponse = make([]AGReportingObjectResponseType, 0)
        }
        t.AGReportingObjectResponse = append(t.AGReportingObjectResponse, AGReportingObjectResponseType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AGReportingObjectResponseListType) Last() *AGReportingObjectResponseType {
  if t.AGReportingObjectResponse == nil {
    t = t.AddNew()
    }
        return &(t.AGReportingObjectResponse[len(t.AGReportingObjectResponse)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AGReportingObjectResponseListType) Index(n int) (*AGReportingObjectResponseType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AGReportingObjectResponseListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AGReportingObjectResponse == nil {
    t = t.AddNew()
    }
        return &(t.AGReportingObjectResponse[n])
}

// Length of the list.
func (t *AGReportingObjectResponseListType) Len() int {
  if t.AGReportingObjectResponse == nil {
    t = t.AddNew()
    }
        return len(t.AGReportingObjectResponse)
}

// Convert list object to slice
func (t *AGReportingObjectResponseListType) ToSlice() []*AGReportingObjectResponseType {
  ret := make([]*AGReportingObjectResponseType, 0)
  for _, x:= range t.AGReportingObjectResponse {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AGRoundListType) Append(values ...AGRoundType) *AGRoundListType {
    
        if t == nil {
                t, _ = AGRoundListTypePointer(AGRoundListType{})
        }
        if t.AGRound == nil {
                t.AGRound = make([]AGRoundType, 0)
        }
        for _, value := range values {
        t.AGRound = append(t.AGRound, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AGRoundListType) AddNew() *AGRoundListType {
        if t == nil {
                t, _ = AGRoundListTypePointer(AGRoundListType{})
        }
        if t.AGRound == nil {
                t.AGRound = make([]AGRoundType, 0)
        }
        t.AGRound = append(t.AGRound, AGRoundType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AGRoundListType) Last() *AGRoundType {
  if t.AGRound == nil {
    t = t.AddNew()
    }
        return &(t.AGRound[len(t.AGRound)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AGRoundListType) Index(n int) (*AGRoundType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AGRoundListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AGRound == nil {
    t = t.AddNew()
    }
        return &(t.AGRound[n])
}

// Length of the list.
func (t *AGRoundListType) Len() int {
  if t.AGRound == nil {
    t = t.AddNew()
    }
        return len(t.AGRound)
}

// Convert list object to slice
func (t *AGRoundListType) ToSlice() []*AGRoundType {
  ret := make([]*AGRoundType, 0)
  for _, x:= range t.AGRound {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AGRuleListType) Append(values ...AGRuleType) *AGRuleListType {
    
        if t == nil {
                t, _ = AGRuleListTypePointer(AGRuleListType{})
        }
        if t.AGRule == nil {
                t.AGRule = make([]AGRuleType, 0)
        }
        for _, value := range values {
        t.AGRule = append(t.AGRule, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AGRuleListType) AddNew() *AGRuleListType {
        if t == nil {
                t, _ = AGRuleListTypePointer(AGRuleListType{})
        }
        if t.AGRule == nil {
                t.AGRule = make([]AGRuleType, 0)
        }
        t.AGRule = append(t.AGRule, AGRuleType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AGRuleListType) Last() *AGRuleType {
  if t.AGRule == nil {
    t = t.AddNew()
    }
        return &(t.AGRule[len(t.AGRule)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AGRuleListType) Index(n int) (*AGRuleType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AGRuleListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AGRule == nil {
    t = t.AddNew()
    }
        return &(t.AGRule[n])
}

// Length of the list.
func (t *AGRuleListType) Len() int {
  if t.AGRule == nil {
    t = t.AddNew()
    }
        return len(t.AGRule)
}

// Convert list object to slice
func (t *AGRuleListType) ToSlice() []*AGRuleType {
  ret := make([]*AGRuleType, 0)
  for _, x:= range t.AGRule {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AccountCodeListType) Append(values ...string) *AccountCodeListType {
    
        if t == nil {
                t, _ = AccountCodeListTypePointer(AccountCodeListType{})
        }
        if t.AccountCode == nil {
                t.AccountCode = make([]string, 0)
        }
        for _, value := range values {
        t.AccountCode = append(t.AccountCode, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AccountCodeListType) AddNew() *AccountCodeListType {
        if t == nil {
                t, _ = AccountCodeListTypePointer(AccountCodeListType{})
        }
        if t.AccountCode == nil {
                t.AccountCode = make([]string, 0)
        }
        t.AccountCode = append(t.AccountCode, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AccountCodeListType) Last() *string {
  if t.AccountCode == nil {
    t = t.AddNew()
    }
        return &(t.AccountCode[len(t.AccountCode)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AccountCodeListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AccountCodeListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AccountCode == nil {
    t = t.AddNew()
    }
        return &(t.AccountCode[n])
}

// Length of the list.
func (t *AccountCodeListType) Len() int {
  if t.AccountCode == nil {
    t = t.AddNew()
    }
        return len(t.AccountCode)
}

// Convert list object to slice
func (t *AccountCodeListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.AccountCode {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *AccountCodeListType) AppendString(value string) *AccountCodeListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AddressCollectionReportingListType) Append(values ...AddressCollectionReportingType) *AddressCollectionReportingListType {
    
        if t == nil {
                t, _ = AddressCollectionReportingListTypePointer(AddressCollectionReportingListType{})
        }
        if t.AddressCollectionReporting == nil {
                t.AddressCollectionReporting = make([]AddressCollectionReportingType, 0)
        }
        for _, value := range values {
        t.AddressCollectionReporting = append(t.AddressCollectionReporting, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AddressCollectionReportingListType) AddNew() *AddressCollectionReportingListType {
        if t == nil {
                t, _ = AddressCollectionReportingListTypePointer(AddressCollectionReportingListType{})
        }
        if t.AddressCollectionReporting == nil {
                t.AddressCollectionReporting = make([]AddressCollectionReportingType, 0)
        }
        t.AddressCollectionReporting = append(t.AddressCollectionReporting, AddressCollectionReportingType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AddressCollectionReportingListType) Last() *AddressCollectionReportingType {
  if t.AddressCollectionReporting == nil {
    t = t.AddNew()
    }
        return &(t.AddressCollectionReporting[len(t.AddressCollectionReporting)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AddressCollectionReportingListType) Index(n int) (*AddressCollectionReportingType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AddressCollectionReportingListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AddressCollectionReporting == nil {
    t = t.AddNew()
    }
        return &(t.AddressCollectionReporting[n])
}

// Length of the list.
func (t *AddressCollectionReportingListType) Len() int {
  if t.AddressCollectionReporting == nil {
    t = t.AddNew()
    }
        return len(t.AddressCollectionReporting)
}

// Convert list object to slice
func (t *AddressCollectionReportingListType) ToSlice() []*AddressCollectionReportingType {
  ret := make([]*AddressCollectionReportingType, 0)
  for _, x:= range t.AddressCollectionReporting {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AddressCollectionStudentListType) Append(values ...AddressCollectionStudentType) *AddressCollectionStudentListType {
    
        if t == nil {
                t, _ = AddressCollectionStudentListTypePointer(AddressCollectionStudentListType{})
        }
        if t.AddressCollectionStudent == nil {
                t.AddressCollectionStudent = make([]AddressCollectionStudentType, 0)
        }
        for _, value := range values {
        t.AddressCollectionStudent = append(t.AddressCollectionStudent, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AddressCollectionStudentListType) AddNew() *AddressCollectionStudentListType {
        if t == nil {
                t, _ = AddressCollectionStudentListTypePointer(AddressCollectionStudentListType{})
        }
        if t.AddressCollectionStudent == nil {
                t.AddressCollectionStudent = make([]AddressCollectionStudentType, 0)
        }
        t.AddressCollectionStudent = append(t.AddressCollectionStudent, AddressCollectionStudentType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AddressCollectionStudentListType) Last() *AddressCollectionStudentType {
  if t.AddressCollectionStudent == nil {
    t = t.AddNew()
    }
        return &(t.AddressCollectionStudent[len(t.AddressCollectionStudent)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AddressCollectionStudentListType) Index(n int) (*AddressCollectionStudentType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AddressCollectionStudentListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AddressCollectionStudent == nil {
    t = t.AddNew()
    }
        return &(t.AddressCollectionStudent[n])
}

// Length of the list.
func (t *AddressCollectionStudentListType) Len() int {
  if t.AddressCollectionStudent == nil {
    t = t.AddNew()
    }
        return len(t.AddressCollectionStudent)
}

// Convert list object to slice
func (t *AddressCollectionStudentListType) ToSlice() []*AddressCollectionStudentType {
  ret := make([]*AddressCollectionStudentType, 0)
  for _, x:= range t.AddressCollectionStudent {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AddressListType) Append(values ...AddressType) *AddressListType {
    
        if t == nil {
                t, _ = AddressListTypePointer(AddressListType{})
        }
        if t.Address == nil {
                t.Address = make([]AddressType, 0)
        }
        for _, value := range values {
        t.Address = append(t.Address, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AddressListType) AddNew() *AddressListType {
        if t == nil {
                t, _ = AddressListTypePointer(AddressListType{})
        }
        if t.Address == nil {
                t.Address = make([]AddressType, 0)
        }
        t.Address = append(t.Address, AddressType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AddressListType) Last() *AddressType {
  if t.Address == nil {
    t = t.AddNew()
    }
        return &(t.Address[len(t.Address)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AddressListType) Index(n int) (*AddressType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AddressListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Address == nil {
    t = t.AddNew()
    }
        return &(t.Address[n])
}

// Length of the list.
func (t *AddressListType) Len() int {
  if t.Address == nil {
    t = t.AddNew()
    }
        return len(t.Address)
}

// Convert list object to slice
func (t *AddressListType) ToSlice() []*AddressType {
  ret := make([]*AddressType, 0)
  for _, x:= range t.Address {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AlertMessagesType) Append(values ...AlertMessageType) *AlertMessagesType {
    
        if t == nil {
                t, _ = AlertMessagesTypePointer(AlertMessagesType{})
        }
        if t.AlertMessage == nil {
                t.AlertMessage = make([]AlertMessageType, 0)
        }
        for _, value := range values {
        t.AlertMessage = append(t.AlertMessage, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AlertMessagesType) AddNew() *AlertMessagesType {
        if t == nil {
                t, _ = AlertMessagesTypePointer(AlertMessagesType{})
        }
        if t.AlertMessage == nil {
                t.AlertMessage = make([]AlertMessageType, 0)
        }
        t.AlertMessage = append(t.AlertMessage, AlertMessageType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AlertMessagesType) Last() *AlertMessageType {
  if t.AlertMessage == nil {
    t = t.AddNew()
    }
        return &(t.AlertMessage[len(t.AlertMessage)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AlertMessagesType) Index(n int) (*AlertMessageType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AlertMessagesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AlertMessage == nil {
    t = t.AddNew()
    }
        return &(t.AlertMessage[n])
}

// Length of the list.
func (t *AlertMessagesType) Len() int {
  if t.AlertMessage == nil {
    t = t.AddNew()
    }
        return len(t.AlertMessage)
}

// Convert list object to slice
func (t *AlertMessagesType) ToSlice() []*AlertMessageType {
  ret := make([]*AlertMessageType, 0)
  for _, x:= range t.AlertMessage {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AlternateIdentificationCodeListType) Append(values ...string) *AlternateIdentificationCodeListType {
    
        if t == nil {
                t, _ = AlternateIdentificationCodeListTypePointer(AlternateIdentificationCodeListType{})
        }
        if t.AlternateIdentificationCode == nil {
                t.AlternateIdentificationCode = make([]string, 0)
        }
        for _, value := range values {
        t.AlternateIdentificationCode = append(t.AlternateIdentificationCode, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AlternateIdentificationCodeListType) AddNew() *AlternateIdentificationCodeListType {
        if t == nil {
                t, _ = AlternateIdentificationCodeListTypePointer(AlternateIdentificationCodeListType{})
        }
        if t.AlternateIdentificationCode == nil {
                t.AlternateIdentificationCode = make([]string, 0)
        }
        t.AlternateIdentificationCode = append(t.AlternateIdentificationCode, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AlternateIdentificationCodeListType) Last() *string {
  if t.AlternateIdentificationCode == nil {
    t = t.AddNew()
    }
        return &(t.AlternateIdentificationCode[len(t.AlternateIdentificationCode)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AlternateIdentificationCodeListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AlternateIdentificationCodeListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AlternateIdentificationCode == nil {
    t = t.AddNew()
    }
        return &(t.AlternateIdentificationCode[n])
}

// Length of the list.
func (t *AlternateIdentificationCodeListType) Len() int {
  if t.AlternateIdentificationCode == nil {
    t = t.AddNew()
    }
        return len(t.AlternateIdentificationCode)
}

// Convert list object to slice
func (t *AlternateIdentificationCodeListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.AlternateIdentificationCode {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *AlternateIdentificationCodeListType) AppendString(value string) *AlternateIdentificationCodeListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ApplicableLawListType) Append(values ...ApplicableLawType) *ApplicableLawListType {
    
        if t == nil {
                t, _ = ApplicableLawListTypePointer(ApplicableLawListType{})
        }
        if t.ApplicableLaw == nil {
                t.ApplicableLaw = make([]ApplicableLawType, 0)
        }
        for _, value := range values {
        t.ApplicableLaw = append(t.ApplicableLaw, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ApplicableLawListType) AddNew() *ApplicableLawListType {
        if t == nil {
                t, _ = ApplicableLawListTypePointer(ApplicableLawListType{})
        }
        if t.ApplicableLaw == nil {
                t.ApplicableLaw = make([]ApplicableLawType, 0)
        }
        t.ApplicableLaw = append(t.ApplicableLaw, ApplicableLawType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ApplicableLawListType) Last() *ApplicableLawType {
  if t.ApplicableLaw == nil {
    t = t.AddNew()
    }
        return &(t.ApplicableLaw[len(t.ApplicableLaw)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ApplicableLawListType) Index(n int) (*ApplicableLawType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ApplicableLawListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ApplicableLaw == nil {
    t = t.AddNew()
    }
        return &(t.ApplicableLaw[n])
}

// Length of the list.
func (t *ApplicableLawListType) Len() int {
  if t.ApplicableLaw == nil {
    t = t.AddNew()
    }
        return len(t.ApplicableLaw)
}

// Convert list object to slice
func (t *ApplicableLawListType) ToSlice() []*ApplicableLawType {
  ret := make([]*ApplicableLawType, 0)
  for _, x:= range t.ApplicableLaw {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ApprovalsType) Append(values ...ApprovalType) *ApprovalsType {
    
        if t == nil {
                t, _ = ApprovalsTypePointer(ApprovalsType{})
        }
        if t.Approval == nil {
                t.Approval = make([]ApprovalType, 0)
        }
        for _, value := range values {
        t.Approval = append(t.Approval, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ApprovalsType) AddNew() *ApprovalsType {
        if t == nil {
                t, _ = ApprovalsTypePointer(ApprovalsType{})
        }
        if t.Approval == nil {
                t.Approval = make([]ApprovalType, 0)
        }
        t.Approval = append(t.Approval, ApprovalType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ApprovalsType) Last() *ApprovalType {
  if t.Approval == nil {
    t = t.AddNew()
    }
        return &(t.Approval[len(t.Approval)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ApprovalsType) Index(n int) (*ApprovalType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ApprovalsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Approval == nil {
    t = t.AddNew()
    }
        return &(t.Approval[n])
}

// Length of the list.
func (t *ApprovalsType) Len() int {
  if t.Approval == nil {
    t = t.AddNew()
    }
        return len(t.Approval)
}

// Convert list object to slice
func (t *ApprovalsType) ToSlice() []*ApprovalType {
  ret := make([]*ApprovalType, 0)
  for _, x:= range t.Approval {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AssignmentListType) Append(values ...string) *AssignmentListType {
    
        if t == nil {
                t, _ = AssignmentListTypePointer(AssignmentListType{})
        }
        if t.GradingAssignmentRefId == nil {
                t.GradingAssignmentRefId = make([]string, 0)
        }
        for _, value := range values {
        t.GradingAssignmentRefId = append(t.GradingAssignmentRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AssignmentListType) AddNew() *AssignmentListType {
        if t == nil {
                t, _ = AssignmentListTypePointer(AssignmentListType{})
        }
        if t.GradingAssignmentRefId == nil {
                t.GradingAssignmentRefId = make([]string, 0)
        }
        t.GradingAssignmentRefId = append(t.GradingAssignmentRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AssignmentListType) Last() *string {
  if t.GradingAssignmentRefId == nil {
    t = t.AddNew()
    }
        return &(t.GradingAssignmentRefId[len(t.GradingAssignmentRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AssignmentListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AssignmentListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.GradingAssignmentRefId == nil {
    t = t.AddNew()
    }
        return &(t.GradingAssignmentRefId[n])
}

// Length of the list.
func (t *AssignmentListType) Len() int {
  if t.GradingAssignmentRefId == nil {
    t = t.AddNew()
    }
        return len(t.GradingAssignmentRefId)
}

// Convert list object to slice
func (t *AssignmentListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.GradingAssignmentRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *AssignmentListType) AppendString(value string) *AssignmentListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AssociatedObjectsType) Append(values ...AssociatedObjectsType_AssociatedObject) *AssociatedObjectsType {
    
        if t == nil {
                t, _ = AssociatedObjectsTypePointer(AssociatedObjectsType{})
        }
        if t.AssociatedObject == nil {
                t.AssociatedObject = make([]AssociatedObjectsType_AssociatedObject, 0)
        }
        for _, value := range values {
        t.AssociatedObject = append(t.AssociatedObject, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AssociatedObjectsType) AddNew() *AssociatedObjectsType {
        if t == nil {
                t, _ = AssociatedObjectsTypePointer(AssociatedObjectsType{})
        }
        if t.AssociatedObject == nil {
                t.AssociatedObject = make([]AssociatedObjectsType_AssociatedObject, 0)
        }
        t.AssociatedObject = append(t.AssociatedObject, AssociatedObjectsType_AssociatedObject{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AssociatedObjectsType) Last() *AssociatedObjectsType_AssociatedObject {
  if t.AssociatedObject == nil {
    t = t.AddNew()
    }
        return &(t.AssociatedObject[len(t.AssociatedObject)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AssociatedObjectsType) Index(n int) (*AssociatedObjectsType_AssociatedObject) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AssociatedObjectsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AssociatedObject == nil {
    t = t.AddNew()
    }
        return &(t.AssociatedObject[n])
}

// Length of the list.
func (t *AssociatedObjectsType) Len() int {
  if t.AssociatedObject == nil {
    t = t.AddNew()
    }
        return len(t.AssociatedObject)
}

// Convert list object to slice
func (t *AssociatedObjectsType) ToSlice() []*AssociatedObjectsType_AssociatedObject {
  ret := make([]*AssociatedObjectsType_AssociatedObject, 0)
  for _, x:= range t.AssociatedObject {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AttendanceTimesType) Append(values ...AttendanceTimeType) *AttendanceTimesType {
    
        if t == nil {
                t, _ = AttendanceTimesTypePointer(AttendanceTimesType{})
        }
        if t.AttendanceTime == nil {
                t.AttendanceTime = make([]AttendanceTimeType, 0)
        }
        for _, value := range values {
        t.AttendanceTime = append(t.AttendanceTime, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AttendanceTimesType) AddNew() *AttendanceTimesType {
        if t == nil {
                t, _ = AttendanceTimesTypePointer(AttendanceTimesType{})
        }
        if t.AttendanceTime == nil {
                t.AttendanceTime = make([]AttendanceTimeType, 0)
        }
        t.AttendanceTime = append(t.AttendanceTime, AttendanceTimeType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AttendanceTimesType) Last() *AttendanceTimeType {
  if t.AttendanceTime == nil {
    t = t.AddNew()
    }
        return &(t.AttendanceTime[len(t.AttendanceTime)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AttendanceTimesType) Index(n int) (*AttendanceTimeType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AttendanceTimesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AttendanceTime == nil {
    t = t.AddNew()
    }
        return &(t.AttendanceTime[n])
}

// Length of the list.
func (t *AttendanceTimesType) Len() int {
  if t.AttendanceTime == nil {
    t = t.AddNew()
    }
        return len(t.AttendanceTime)
}

// Convert list object to slice
func (t *AttendanceTimesType) ToSlice() []*AttendanceTimeType {
  ret := make([]*AttendanceTimeType, 0)
  for _, x:= range t.AttendanceTime {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AuthorsType) Append(values ...string) *AuthorsType {
    
        if t == nil {
                t, _ = AuthorsTypePointer(AuthorsType{})
        }
        if t.Author == nil {
                t.Author = make([]string, 0)
        }
        for _, value := range values {
        t.Author = append(t.Author, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AuthorsType) AddNew() *AuthorsType {
        if t == nil {
                t, _ = AuthorsTypePointer(AuthorsType{})
        }
        if t.Author == nil {
                t.Author = make([]string, 0)
        }
        t.Author = append(t.Author, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AuthorsType) Last() *string {
  if t.Author == nil {
    t = t.AddNew()
    }
        return &(t.Author[len(t.Author)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *AuthorsType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AuthorsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Author == nil {
    t = t.AddNew()
    }
        return &(t.Author[n])
}

// Length of the list.
func (t *AuthorsType) Len() int {
  if t.Author == nil {
    t = t.AddNew()
    }
        return len(t.Author)
}

// Convert list object to slice
func (t *AuthorsType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.Author {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *AuthorsType) AppendString(value string) *AuthorsType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CalendarSummaryListType) Append(values ...string) *CalendarSummaryListType {
    
        if t == nil {
                t, _ = CalendarSummaryListTypePointer(CalendarSummaryListType{})
        }
        if t.CalendarSummaryRefId == nil {
                t.CalendarSummaryRefId = make([]string, 0)
        }
        for _, value := range values {
        t.CalendarSummaryRefId = append(t.CalendarSummaryRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CalendarSummaryListType) AddNew() *CalendarSummaryListType {
        if t == nil {
                t, _ = CalendarSummaryListTypePointer(CalendarSummaryListType{})
        }
        if t.CalendarSummaryRefId == nil {
                t.CalendarSummaryRefId = make([]string, 0)
        }
        t.CalendarSummaryRefId = append(t.CalendarSummaryRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CalendarSummaryListType) Last() *string {
  if t.CalendarSummaryRefId == nil {
    t = t.AddNew()
    }
        return &(t.CalendarSummaryRefId[len(t.CalendarSummaryRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *CalendarSummaryListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CalendarSummaryListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.CalendarSummaryRefId == nil {
    t = t.AddNew()
    }
        return &(t.CalendarSummaryRefId[n])
}

// Length of the list.
func (t *CalendarSummaryListType) Len() int {
  if t.CalendarSummaryRefId == nil {
    t = t.AddNew()
    }
        return len(t.CalendarSummaryRefId)
}

// Convert list object to slice
func (t *CalendarSummaryListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.CalendarSummaryRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *CalendarSummaryListType) AppendString(value string) *CalendarSummaryListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CensusReportingListType) Append(values ...CensusReportingType) *CensusReportingListType {
    
        if t == nil {
                t, _ = CensusReportingListTypePointer(CensusReportingListType{})
        }
        if t.CensusReporting == nil {
                t.CensusReporting = make([]CensusReportingType, 0)
        }
        for _, value := range values {
        t.CensusReporting = append(t.CensusReporting, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CensusReportingListType) AddNew() *CensusReportingListType {
        if t == nil {
                t, _ = CensusReportingListTypePointer(CensusReportingListType{})
        }
        if t.CensusReporting == nil {
                t.CensusReporting = make([]CensusReportingType, 0)
        }
        t.CensusReporting = append(t.CensusReporting, CensusReportingType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CensusReportingListType) Last() *CensusReportingType {
  if t.CensusReporting == nil {
    t = t.AddNew()
    }
        return &(t.CensusReporting[len(t.CensusReporting)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *CensusReportingListType) Index(n int) (*CensusReportingType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CensusReportingListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.CensusReporting == nil {
    t = t.AddNew()
    }
        return &(t.CensusReporting[n])
}

// Length of the list.
func (t *CensusReportingListType) Len() int {
  if t.CensusReporting == nil {
    t = t.AddNew()
    }
        return len(t.CensusReporting)
}

// Convert list object to slice
func (t *CensusReportingListType) ToSlice() []*CensusReportingType {
  ret := make([]*CensusReportingType, 0)
  for _, x:= range t.CensusReporting {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CensusStaffListType) Append(values ...CensusStaffType) *CensusStaffListType {
    
        if t == nil {
                t, _ = CensusStaffListTypePointer(CensusStaffListType{})
        }
        if t.CensusStaff == nil {
                t.CensusStaff = make([]CensusStaffType, 0)
        }
        for _, value := range values {
        t.CensusStaff = append(t.CensusStaff, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CensusStaffListType) AddNew() *CensusStaffListType {
        if t == nil {
                t, _ = CensusStaffListTypePointer(CensusStaffListType{})
        }
        if t.CensusStaff == nil {
                t.CensusStaff = make([]CensusStaffType, 0)
        }
        t.CensusStaff = append(t.CensusStaff, CensusStaffType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CensusStaffListType) Last() *CensusStaffType {
  if t.CensusStaff == nil {
    t = t.AddNew()
    }
        return &(t.CensusStaff[len(t.CensusStaff)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *CensusStaffListType) Index(n int) (*CensusStaffType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CensusStaffListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.CensusStaff == nil {
    t = t.AddNew()
    }
        return &(t.CensusStaff[n])
}

// Length of the list.
func (t *CensusStaffListType) Len() int {
  if t.CensusStaff == nil {
    t = t.AddNew()
    }
        return len(t.CensusStaff)
}

// Convert list object to slice
func (t *CensusStaffListType) ToSlice() []*CensusStaffType {
  ret := make([]*CensusStaffType, 0)
  for _, x:= range t.CensusStaff {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CensusStudentListType) Append(values ...CensusStudentType) *CensusStudentListType {
    
        if t == nil {
                t, _ = CensusStudentListTypePointer(CensusStudentListType{})
        }
        if t.CensusStudent == nil {
                t.CensusStudent = make([]CensusStudentType, 0)
        }
        for _, value := range values {
        t.CensusStudent = append(t.CensusStudent, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CensusStudentListType) AddNew() *CensusStudentListType {
        if t == nil {
                t, _ = CensusStudentListTypePointer(CensusStudentListType{})
        }
        if t.CensusStudent == nil {
                t.CensusStudent = make([]CensusStudentType, 0)
        }
        t.CensusStudent = append(t.CensusStudent, CensusStudentType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CensusStudentListType) Last() *CensusStudentType {
  if t.CensusStudent == nil {
    t = t.AddNew()
    }
        return &(t.CensusStudent[len(t.CensusStudent)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *CensusStudentListType) Index(n int) (*CensusStudentType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CensusStudentListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.CensusStudent == nil {
    t = t.AddNew()
    }
        return &(t.CensusStudent[n])
}

// Length of the list.
func (t *CensusStudentListType) Len() int {
  if t.CensusStudent == nil {
    t = t.AddNew()
    }
        return len(t.CensusStudent)
}

// Convert list object to slice
func (t *CensusStudentListType) ToSlice() []*CensusStudentType {
  ret := make([]*CensusStudentType, 0)
  for _, x:= range t.CensusStudent {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CharacteristicsType) Append(values ...string) *CharacteristicsType {
    
        if t == nil {
                t, _ = CharacteristicsTypePointer(CharacteristicsType{})
        }
        if t.AggregateCharacteristicInfoRefId == nil {
                t.AggregateCharacteristicInfoRefId = make([]string, 0)
        }
        for _, value := range values {
        t.AggregateCharacteristicInfoRefId = append(t.AggregateCharacteristicInfoRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CharacteristicsType) AddNew() *CharacteristicsType {
        if t == nil {
                t, _ = CharacteristicsTypePointer(CharacteristicsType{})
        }
        if t.AggregateCharacteristicInfoRefId == nil {
                t.AggregateCharacteristicInfoRefId = make([]string, 0)
        }
        t.AggregateCharacteristicInfoRefId = append(t.AggregateCharacteristicInfoRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CharacteristicsType) Last() *string {
  if t.AggregateCharacteristicInfoRefId == nil {
    t = t.AddNew()
    }
        return &(t.AggregateCharacteristicInfoRefId[len(t.AggregateCharacteristicInfoRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *CharacteristicsType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CharacteristicsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.AggregateCharacteristicInfoRefId == nil {
    t = t.AddNew()
    }
        return &(t.AggregateCharacteristicInfoRefId[n])
}

// Length of the list.
func (t *CharacteristicsType) Len() int {
  if t.AggregateCharacteristicInfoRefId == nil {
    t = t.AddNew()
    }
        return len(t.AggregateCharacteristicInfoRefId)
}

// Convert list object to slice
func (t *CharacteristicsType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.AggregateCharacteristicInfoRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *CharacteristicsType) AppendString(value string) *CharacteristicsType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CodeFrameTestItemListType) Append(values ...CodeFrameTestItemType) *CodeFrameTestItemListType {
    
        if t == nil {
                t, _ = CodeFrameTestItemListTypePointer(CodeFrameTestItemListType{})
        }
        if t.TestItem == nil {
                t.TestItem = make([]CodeFrameTestItemType, 0)
        }
        for _, value := range values {
        t.TestItem = append(t.TestItem, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CodeFrameTestItemListType) AddNew() *CodeFrameTestItemListType {
        if t == nil {
                t, _ = CodeFrameTestItemListTypePointer(CodeFrameTestItemListType{})
        }
        if t.TestItem == nil {
                t.TestItem = make([]CodeFrameTestItemType, 0)
        }
        t.TestItem = append(t.TestItem, CodeFrameTestItemType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CodeFrameTestItemListType) Last() *CodeFrameTestItemType {
  if t.TestItem == nil {
    t = t.AddNew()
    }
        return &(t.TestItem[len(t.TestItem)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *CodeFrameTestItemListType) Index(n int) (*CodeFrameTestItemType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CodeFrameTestItemListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TestItem == nil {
    t = t.AddNew()
    }
        return &(t.TestItem[n])
}

// Length of the list.
func (t *CodeFrameTestItemListType) Len() int {
  if t.TestItem == nil {
    t = t.AddNew()
    }
        return len(t.TestItem)
}

// Convert list object to slice
func (t *CodeFrameTestItemListType) ToSlice() []*CodeFrameTestItemType {
  ret := make([]*CodeFrameTestItemType, 0)
  for _, x:= range t.TestItem {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ComponentsType) Append(values ...ComponentType) *ComponentsType {
    
        if t == nil {
                t, _ = ComponentsTypePointer(ComponentsType{})
        }
        if t.Component == nil {
                t.Component = make([]ComponentType, 0)
        }
        for _, value := range values {
        t.Component = append(t.Component, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ComponentsType) AddNew() *ComponentsType {
        if t == nil {
                t, _ = ComponentsTypePointer(ComponentsType{})
        }
        if t.Component == nil {
                t.Component = make([]ComponentType, 0)
        }
        t.Component = append(t.Component, ComponentType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ComponentsType) Last() *ComponentType {
  if t.Component == nil {
    t = t.AddNew()
    }
        return &(t.Component[len(t.Component)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ComponentsType) Index(n int) (*ComponentType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ComponentsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Component == nil {
    t = t.AddNew()
    }
        return &(t.Component[n])
}

// Length of the list.
func (t *ComponentsType) Len() int {
  if t.Component == nil {
    t = t.AddNew()
    }
        return len(t.Component)
}

// Convert list object to slice
func (t *ComponentsType) ToSlice() []*ComponentType {
  ret := make([]*ComponentType, 0)
  for _, x:= range t.Component {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ContactsType) Append(values ...ContactType) *ContactsType {
    
        if t == nil {
                t, _ = ContactsTypePointer(ContactsType{})
        }
        if t.Contact == nil {
                t.Contact = make([]ContactType, 0)
        }
        for _, value := range values {
        t.Contact = append(t.Contact, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ContactsType) AddNew() *ContactsType {
        if t == nil {
                t, _ = ContactsTypePointer(ContactsType{})
        }
        if t.Contact == nil {
                t.Contact = make([]ContactType, 0)
        }
        t.Contact = append(t.Contact, ContactType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ContactsType) Last() *ContactType {
  if t.Contact == nil {
    t = t.AddNew()
    }
        return &(t.Contact[len(t.Contact)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ContactsType) Index(n int) (*ContactType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ContactsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Contact == nil {
    t = t.AddNew()
    }
        return &(t.Contact[n])
}

// Length of the list.
func (t *ContactsType) Len() int {
  if t.Contact == nil {
    t = t.AddNew()
    }
        return len(t.Contact)
}

// Convert list object to slice
func (t *ContactsType) ToSlice() []*ContactType {
  ret := make([]*ContactType, 0)
  for _, x:= range t.Contact {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ContentDescriptionListType) Append(values ...string) *ContentDescriptionListType {
    
        if t == nil {
                t, _ = ContentDescriptionListTypePointer(ContentDescriptionListType{})
        }
        if t.ContentDescription == nil {
                t.ContentDescription = make([]string, 0)
        }
        for _, value := range values {
        t.ContentDescription = append(t.ContentDescription, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ContentDescriptionListType) AddNew() *ContentDescriptionListType {
        if t == nil {
                t, _ = ContentDescriptionListTypePointer(ContentDescriptionListType{})
        }
        if t.ContentDescription == nil {
                t.ContentDescription = make([]string, 0)
        }
        t.ContentDescription = append(t.ContentDescription, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ContentDescriptionListType) Last() *string {
  if t.ContentDescription == nil {
    t = t.AddNew()
    }
        return &(t.ContentDescription[len(t.ContentDescription)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ContentDescriptionListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ContentDescriptionListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ContentDescription == nil {
    t = t.AddNew()
    }
        return &(t.ContentDescription[n])
}

// Length of the list.
func (t *ContentDescriptionListType) Len() int {
  if t.ContentDescription == nil {
    t = t.AddNew()
    }
        return len(t.ContentDescription)
}

// Convert list object to slice
func (t *ContentDescriptionListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.ContentDescription {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *ContentDescriptionListType) AppendString(value string) *ContentDescriptionListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CountryList2Type) Append(values ...CountryType) *CountryList2Type {
    
        if t == nil {
                t, _ = CountryList2TypePointer(CountryList2Type{})
        }
        if t.CountryOfResidency == nil {
                t.CountryOfResidency = make([]CountryType, 0)
        }
        for _, value := range values {
        t.CountryOfResidency = append(t.CountryOfResidency, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CountryList2Type) AddNew() *CountryList2Type {
        if t == nil {
                t, _ = CountryList2TypePointer(CountryList2Type{})
        }
        if t.CountryOfResidency == nil {
                t.CountryOfResidency = make([]CountryType, 0)
        }
        t.CountryOfResidency = append(t.CountryOfResidency, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CountryList2Type) Last() *CountryType {
  if t.CountryOfResidency == nil {
    t = t.AddNew()
    }
        return &(t.CountryOfResidency[len(t.CountryOfResidency)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *CountryList2Type) Index(n int) (*CountryType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CountryList2Type.Index(): subscript %d out of range on list\n", n)
    }
  if t.CountryOfResidency == nil {
    t = t.AddNew()
    }
        return &(t.CountryOfResidency[n])
}

// Length of the list.
func (t *CountryList2Type) Len() int {
  if t.CountryOfResidency == nil {
    t = t.AddNew()
    }
        return len(t.CountryOfResidency)
}

// Convert list object to slice
func (t *CountryList2Type) ToSlice() []*CountryType {
  ret := make([]*CountryType, 0)
  for _, x:= range t.CountryOfResidency {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *CountryList2Type) AppendString(value string) *CountryList2Type {
        return t.Append((CountryType)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CountryListType) Append(values ...CountryType) *CountryListType {
    
        if t == nil {
                t, _ = CountryListTypePointer(CountryListType{})
        }
        if t.CountryOfCitizenship == nil {
                t.CountryOfCitizenship = make([]CountryType, 0)
        }
        for _, value := range values {
        t.CountryOfCitizenship = append(t.CountryOfCitizenship, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CountryListType) AddNew() *CountryListType {
        if t == nil {
                t, _ = CountryListTypePointer(CountryListType{})
        }
        if t.CountryOfCitizenship == nil {
                t.CountryOfCitizenship = make([]CountryType, 0)
        }
        t.CountryOfCitizenship = append(t.CountryOfCitizenship, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CountryListType) Last() *CountryType {
  if t.CountryOfCitizenship == nil {
    t = t.AddNew()
    }
        return &(t.CountryOfCitizenship[len(t.CountryOfCitizenship)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *CountryListType) Index(n int) (*CountryType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CountryListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.CountryOfCitizenship == nil {
    t = t.AddNew()
    }
        return &(t.CountryOfCitizenship[n])
}

// Length of the list.
func (t *CountryListType) Len() int {
  if t.CountryOfCitizenship == nil {
    t = t.AddNew()
    }
        return len(t.CountryOfCitizenship)
}

// Convert list object to slice
func (t *CountryListType) ToSlice() []*CountryType {
  ret := make([]*CountryType, 0)
  for _, x:= range t.CountryOfCitizenship {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *CountryListType) AppendString(value string) *CountryListType {
        return t.Append((CountryType)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CreatorListType) Append(values ...LifeCycleCreatorType) *CreatorListType {
    
        if t == nil {
                t, _ = CreatorListTypePointer(CreatorListType{})
        }
        if t.Creator == nil {
                t.Creator = make([]LifeCycleCreatorType, 0)
        }
        for _, value := range values {
        t.Creator = append(t.Creator, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CreatorListType) AddNew() *CreatorListType {
        if t == nil {
                t, _ = CreatorListTypePointer(CreatorListType{})
        }
        if t.Creator == nil {
                t.Creator = make([]LifeCycleCreatorType, 0)
        }
        t.Creator = append(t.Creator, LifeCycleCreatorType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CreatorListType) Last() *LifeCycleCreatorType {
  if t.Creator == nil {
    t = t.AddNew()
    }
        return &(t.Creator[len(t.Creator)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *CreatorListType) Index(n int) (*LifeCycleCreatorType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CreatorListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Creator == nil {
    t = t.AddNew()
    }
        return &(t.Creator[n])
}

// Length of the list.
func (t *CreatorListType) Len() int {
  if t.Creator == nil {
    t = t.AddNew()
    }
        return len(t.Creator)
}

// Convert list object to slice
func (t *CreatorListType) ToSlice() []*LifeCycleCreatorType {
  ret := make([]*LifeCycleCreatorType, 0)
  for _, x:= range t.Creator {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *DataDomainObligationListType) Append(values ...DataDomainObligationType) *DataDomainObligationListType {
    
        if t == nil {
                t, _ = DataDomainObligationListTypePointer(DataDomainObligationListType{})
        }
        if t.DataDomainObligation == nil {
                t.DataDomainObligation = make([]DataDomainObligationType, 0)
        }
        for _, value := range values {
        t.DataDomainObligation = append(t.DataDomainObligation, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *DataDomainObligationListType) AddNew() *DataDomainObligationListType {
        if t == nil {
                t, _ = DataDomainObligationListTypePointer(DataDomainObligationListType{})
        }
        if t.DataDomainObligation == nil {
                t.DataDomainObligation = make([]DataDomainObligationType, 0)
        }
        t.DataDomainObligation = append(t.DataDomainObligation, DataDomainObligationType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *DataDomainObligationListType) Last() *DataDomainObligationType {
  if t.DataDomainObligation == nil {
    t = t.AddNew()
    }
        return &(t.DataDomainObligation[len(t.DataDomainObligation)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *DataDomainObligationListType) Index(n int) (*DataDomainObligationType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("DataDomainObligationListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.DataDomainObligation == nil {
    t = t.AddNew()
    }
        return &(t.DataDomainObligation[n])
}

// Length of the list.
func (t *DataDomainObligationListType) Len() int {
  if t.DataDomainObligation == nil {
    t = t.AddNew()
    }
        return len(t.DataDomainObligation)
}

// Convert list object to slice
func (t *DataDomainObligationListType) ToSlice() []*DataDomainObligationType {
  ret := make([]*DataDomainObligationType, 0)
  for _, x:= range t.DataDomainObligation {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *DisabilityCategoryListType) Append(values ...AUCodeSetsNCCDDisabilityType) *DisabilityCategoryListType {
    
        if t == nil {
                t, _ = DisabilityCategoryListTypePointer(DisabilityCategoryListType{})
        }
        if t.DisabilityCategoryConsidered == nil {
                t.DisabilityCategoryConsidered = make([]AUCodeSetsNCCDDisabilityType, 0)
        }
        for _, value := range values {
        t.DisabilityCategoryConsidered = append(t.DisabilityCategoryConsidered, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *DisabilityCategoryListType) AddNew() *DisabilityCategoryListType {
        if t == nil {
                t, _ = DisabilityCategoryListTypePointer(DisabilityCategoryListType{})
        }
        if t.DisabilityCategoryConsidered == nil {
                t.DisabilityCategoryConsidered = make([]AUCodeSetsNCCDDisabilityType, 0)
        }
        t.DisabilityCategoryConsidered = append(t.DisabilityCategoryConsidered, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *DisabilityCategoryListType) Last() *AUCodeSetsNCCDDisabilityType {
  if t.DisabilityCategoryConsidered == nil {
    t = t.AddNew()
    }
        return &(t.DisabilityCategoryConsidered[len(t.DisabilityCategoryConsidered)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *DisabilityCategoryListType) Index(n int) (*AUCodeSetsNCCDDisabilityType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("DisabilityCategoryListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.DisabilityCategoryConsidered == nil {
    t = t.AddNew()
    }
        return &(t.DisabilityCategoryConsidered[n])
}

// Length of the list.
func (t *DisabilityCategoryListType) Len() int {
  if t.DisabilityCategoryConsidered == nil {
    t = t.AddNew()
    }
        return len(t.DisabilityCategoryConsidered)
}

// Convert list object to slice
func (t *DisabilityCategoryListType) ToSlice() []*AUCodeSetsNCCDDisabilityType {
  ret := make([]*AUCodeSetsNCCDDisabilityType, 0)
  for _, x:= range t.DisabilityCategoryConsidered {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *DisabilityCategoryListType) AppendString(value string) *DisabilityCategoryListType {
        return t.Append((AUCodeSetsNCCDDisabilityType)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *DoNotShareWithListType) Append(values ...DoNotShareWithType) *DoNotShareWithListType {
    
        if t == nil {
                t, _ = DoNotShareWithListTypePointer(DoNotShareWithListType{})
        }
        if t.DoNotShareWith == nil {
                t.DoNotShareWith = make([]DoNotShareWithType, 0)
        }
        for _, value := range values {
        t.DoNotShareWith = append(t.DoNotShareWith, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *DoNotShareWithListType) AddNew() *DoNotShareWithListType {
        if t == nil {
                t, _ = DoNotShareWithListTypePointer(DoNotShareWithListType{})
        }
        if t.DoNotShareWith == nil {
                t.DoNotShareWith = make([]DoNotShareWithType, 0)
        }
        t.DoNotShareWith = append(t.DoNotShareWith, DoNotShareWithType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *DoNotShareWithListType) Last() *DoNotShareWithType {
  if t.DoNotShareWith == nil {
    t = t.AddNew()
    }
        return &(t.DoNotShareWith[len(t.DoNotShareWith)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *DoNotShareWithListType) Index(n int) (*DoNotShareWithType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("DoNotShareWithListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.DoNotShareWith == nil {
    t = t.AddNew()
    }
        return &(t.DoNotShareWith[n])
}

// Length of the list.
func (t *DoNotShareWithListType) Len() int {
  if t.DoNotShareWith == nil {
    t = t.AddNew()
    }
        return len(t.DoNotShareWith)
}

// Convert list object to slice
func (t *DoNotShareWithListType) ToSlice() []*DoNotShareWithType {
  ret := make([]*DoNotShareWithType, 0)
  for _, x:= range t.DoNotShareWith {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *EducationalAssessmentListType) Append(values ...EducationalAssessmentType) *EducationalAssessmentListType {
    
        if t == nil {
                t, _ = EducationalAssessmentListTypePointer(EducationalAssessmentListType{})
        }
        if t.EducationalAssessment == nil {
                t.EducationalAssessment = make([]EducationalAssessmentType, 0)
        }
        for _, value := range values {
        t.EducationalAssessment = append(t.EducationalAssessment, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *EducationalAssessmentListType) AddNew() *EducationalAssessmentListType {
        if t == nil {
                t, _ = EducationalAssessmentListTypePointer(EducationalAssessmentListType{})
        }
        if t.EducationalAssessment == nil {
                t.EducationalAssessment = make([]EducationalAssessmentType, 0)
        }
        t.EducationalAssessment = append(t.EducationalAssessment, EducationalAssessmentType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *EducationalAssessmentListType) Last() *EducationalAssessmentType {
  if t.EducationalAssessment == nil {
    t = t.AddNew()
    }
        return &(t.EducationalAssessment[len(t.EducationalAssessment)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *EducationalAssessmentListType) Index(n int) (*EducationalAssessmentType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("EducationalAssessmentListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.EducationalAssessment == nil {
    t = t.AddNew()
    }
        return &(t.EducationalAssessment[n])
}

// Length of the list.
func (t *EducationalAssessmentListType) Len() int {
  if t.EducationalAssessment == nil {
    t = t.AddNew()
    }
        return len(t.EducationalAssessment)
}

// Convert list object to slice
func (t *EducationalAssessmentListType) ToSlice() []*EducationalAssessmentType {
  ret := make([]*EducationalAssessmentType, 0)
  for _, x:= range t.EducationalAssessment {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ElectronicIdListType) Append(values ...ElectronicIdType) *ElectronicIdListType {
    
        if t == nil {
                t, _ = ElectronicIdListTypePointer(ElectronicIdListType{})
        }
        if t.ElectronicId == nil {
                t.ElectronicId = make([]ElectronicIdType, 0)
        }
        for _, value := range values {
        t.ElectronicId = append(t.ElectronicId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ElectronicIdListType) AddNew() *ElectronicIdListType {
        if t == nil {
                t, _ = ElectronicIdListTypePointer(ElectronicIdListType{})
        }
        if t.ElectronicId == nil {
                t.ElectronicId = make([]ElectronicIdType, 0)
        }
        t.ElectronicId = append(t.ElectronicId, ElectronicIdType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ElectronicIdListType) Last() *ElectronicIdType {
  if t.ElectronicId == nil {
    t = t.AddNew()
    }
        return &(t.ElectronicId[len(t.ElectronicId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ElectronicIdListType) Index(n int) (*ElectronicIdType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ElectronicIdListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ElectronicId == nil {
    t = t.AddNew()
    }
        return &(t.ElectronicId[n])
}

// Length of the list.
func (t *ElectronicIdListType) Len() int {
  if t.ElectronicId == nil {
    t = t.AddNew()
    }
        return len(t.ElectronicId)
}

// Convert list object to slice
func (t *ElectronicIdListType) ToSlice() []*ElectronicIdType {
  ret := make([]*ElectronicIdType, 0)
  for _, x:= range t.ElectronicId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *EmailListType) Append(values ...EmailType) *EmailListType {
    
        if t == nil {
                t, _ = EmailListTypePointer(EmailListType{})
        }
        if t.Email == nil {
                t.Email = make([]EmailType, 0)
        }
        for _, value := range values {
        t.Email = append(t.Email, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *EmailListType) AddNew() *EmailListType {
        if t == nil {
                t, _ = EmailListTypePointer(EmailListType{})
        }
        if t.Email == nil {
                t.Email = make([]EmailType, 0)
        }
        t.Email = append(t.Email, EmailType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *EmailListType) Last() *EmailType {
  if t.Email == nil {
    t = t.AddNew()
    }
        return &(t.Email[len(t.Email)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *EmailListType) Index(n int) (*EmailType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("EmailListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Email == nil {
    t = t.AddNew()
    }
        return &(t.Email[n])
}

// Length of the list.
func (t *EmailListType) Len() int {
  if t.Email == nil {
    t = t.AddNew()
    }
        return len(t.Email)
}

// Convert list object to slice
func (t *EmailListType) ToSlice() []*EmailType {
  ret := make([]*EmailType, 0)
  for _, x:= range t.Email {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *EssentialMaterialsType) Append(values ...string) *EssentialMaterialsType {
    
        if t == nil {
                t, _ = EssentialMaterialsTypePointer(EssentialMaterialsType{})
        }
        if t.EssentialMaterial == nil {
                t.EssentialMaterial = make([]string, 0)
        }
        for _, value := range values {
        t.EssentialMaterial = append(t.EssentialMaterial, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *EssentialMaterialsType) AddNew() *EssentialMaterialsType {
        if t == nil {
                t, _ = EssentialMaterialsTypePointer(EssentialMaterialsType{})
        }
        if t.EssentialMaterial == nil {
                t.EssentialMaterial = make([]string, 0)
        }
        t.EssentialMaterial = append(t.EssentialMaterial, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *EssentialMaterialsType) Last() *string {
  if t.EssentialMaterial == nil {
    t = t.AddNew()
    }
        return &(t.EssentialMaterial[len(t.EssentialMaterial)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *EssentialMaterialsType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("EssentialMaterialsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.EssentialMaterial == nil {
    t = t.AddNew()
    }
        return &(t.EssentialMaterial[n])
}

// Length of the list.
func (t *EssentialMaterialsType) Len() int {
  if t.EssentialMaterial == nil {
    t = t.AddNew()
    }
        return len(t.EssentialMaterial)
}

// Convert list object to slice
func (t *EssentialMaterialsType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.EssentialMaterial {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *EssentialMaterialsType) AppendString(value string) *EssentialMaterialsType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *EvaluationsType) Append(values ...EvaluationType) *EvaluationsType {
    
        if t == nil {
                t, _ = EvaluationsTypePointer(EvaluationsType{})
        }
        if t.Evaluation == nil {
                t.Evaluation = make([]EvaluationType, 0)
        }
        for _, value := range values {
        t.Evaluation = append(t.Evaluation, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *EvaluationsType) AddNew() *EvaluationsType {
        if t == nil {
                t, _ = EvaluationsTypePointer(EvaluationsType{})
        }
        if t.Evaluation == nil {
                t.Evaluation = make([]EvaluationType, 0)
        }
        t.Evaluation = append(t.Evaluation, EvaluationType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *EvaluationsType) Last() *EvaluationType {
  if t.Evaluation == nil {
    t = t.AddNew()
    }
        return &(t.Evaluation[len(t.Evaluation)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *EvaluationsType) Index(n int) (*EvaluationType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("EvaluationsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Evaluation == nil {
    t = t.AddNew()
    }
        return &(t.Evaluation[n])
}

// Length of the list.
func (t *EvaluationsType) Len() int {
  if t.Evaluation == nil {
    t = t.AddNew()
    }
        return len(t.Evaluation)
}

// Convert list object to slice
func (t *EvaluationsType) ToSlice() []*EvaluationType {
  ret := make([]*EvaluationType, 0)
  for _, x:= range t.Evaluation {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ExclusionRulesType) Append(values ...ExclusionRuleType) *ExclusionRulesType {
    
        if t == nil {
                t, _ = ExclusionRulesTypePointer(ExclusionRulesType{})
        }
        if t.ExclusionRule == nil {
                t.ExclusionRule = make([]ExclusionRuleType, 0)
        }
        for _, value := range values {
        t.ExclusionRule = append(t.ExclusionRule, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ExclusionRulesType) AddNew() *ExclusionRulesType {
        if t == nil {
                t, _ = ExclusionRulesTypePointer(ExclusionRulesType{})
        }
        if t.ExclusionRule == nil {
                t.ExclusionRule = make([]ExclusionRuleType, 0)
        }
        t.ExclusionRule = append(t.ExclusionRule, ExclusionRuleType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ExclusionRulesType) Last() *ExclusionRuleType {
  if t.ExclusionRule == nil {
    t = t.AddNew()
    }
        return &(t.ExclusionRule[len(t.ExclusionRule)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ExclusionRulesType) Index(n int) (*ExclusionRuleType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ExclusionRulesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ExclusionRule == nil {
    t = t.AddNew()
    }
        return &(t.ExclusionRule[n])
}

// Length of the list.
func (t *ExclusionRulesType) Len() int {
  if t.ExclusionRule == nil {
    t = t.AddNew()
    }
        return len(t.ExclusionRule)
}

// Convert list object to slice
func (t *ExclusionRulesType) ToSlice() []*ExclusionRuleType {
  ret := make([]*ExclusionRuleType, 0)
  for _, x:= range t.ExclusionRule {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ExpenseAccountsType) Append(values ...ExpenseAccountType) *ExpenseAccountsType {
    
        if t == nil {
                t, _ = ExpenseAccountsTypePointer(ExpenseAccountsType{})
        }
        if t.ExpenseAccount == nil {
                t.ExpenseAccount = make([]ExpenseAccountType, 0)
        }
        for _, value := range values {
        t.ExpenseAccount = append(t.ExpenseAccount, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ExpenseAccountsType) AddNew() *ExpenseAccountsType {
        if t == nil {
                t, _ = ExpenseAccountsTypePointer(ExpenseAccountsType{})
        }
        if t.ExpenseAccount == nil {
                t.ExpenseAccount = make([]ExpenseAccountType, 0)
        }
        t.ExpenseAccount = append(t.ExpenseAccount, ExpenseAccountType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ExpenseAccountsType) Last() *ExpenseAccountType {
  if t.ExpenseAccount == nil {
    t = t.AddNew()
    }
        return &(t.ExpenseAccount[len(t.ExpenseAccount)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ExpenseAccountsType) Index(n int) (*ExpenseAccountType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ExpenseAccountsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ExpenseAccount == nil {
    t = t.AddNew()
    }
        return &(t.ExpenseAccount[n])
}

// Length of the list.
func (t *ExpenseAccountsType) Len() int {
  if t.ExpenseAccount == nil {
    t = t.AddNew()
    }
        return len(t.ExpenseAccount)
}

// Convert list object to slice
func (t *ExpenseAccountsType) ToSlice() []*ExpenseAccountType {
  ret := make([]*ExpenseAccountType, 0)
  for _, x:= range t.ExpenseAccount {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *FQContextualQuestionListType) Append(values ...FQContextualQuestionType) *FQContextualQuestionListType {
    
        if t == nil {
                t, _ = FQContextualQuestionListTypePointer(FQContextualQuestionListType{})
        }
        if t.FQContextualQuestion == nil {
                t.FQContextualQuestion = make([]FQContextualQuestionType, 0)
        }
        for _, value := range values {
        t.FQContextualQuestion = append(t.FQContextualQuestion, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *FQContextualQuestionListType) AddNew() *FQContextualQuestionListType {
        if t == nil {
                t, _ = FQContextualQuestionListTypePointer(FQContextualQuestionListType{})
        }
        if t.FQContextualQuestion == nil {
                t.FQContextualQuestion = make([]FQContextualQuestionType, 0)
        }
        t.FQContextualQuestion = append(t.FQContextualQuestion, FQContextualQuestionType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *FQContextualQuestionListType) Last() *FQContextualQuestionType {
  if t.FQContextualQuestion == nil {
    t = t.AddNew()
    }
        return &(t.FQContextualQuestion[len(t.FQContextualQuestion)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *FQContextualQuestionListType) Index(n int) (*FQContextualQuestionType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("FQContextualQuestionListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.FQContextualQuestion == nil {
    t = t.AddNew()
    }
        return &(t.FQContextualQuestion[n])
}

// Length of the list.
func (t *FQContextualQuestionListType) Len() int {
  if t.FQContextualQuestion == nil {
    t = t.AddNew()
    }
        return len(t.FQContextualQuestion)
}

// Convert list object to slice
func (t *FQContextualQuestionListType) ToSlice() []*FQContextualQuestionType {
  ret := make([]*FQContextualQuestionType, 0)
  for _, x:= range t.FQContextualQuestion {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *FQItemListType) Append(values ...FQItemType) *FQItemListType {
    
        if t == nil {
                t, _ = FQItemListTypePointer(FQItemListType{})
        }
        if t.FQItem == nil {
                t.FQItem = make([]FQItemType, 0)
        }
        for _, value := range values {
        t.FQItem = append(t.FQItem, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *FQItemListType) AddNew() *FQItemListType {
        if t == nil {
                t, _ = FQItemListTypePointer(FQItemListType{})
        }
        if t.FQItem == nil {
                t.FQItem = make([]FQItemType, 0)
        }
        t.FQItem = append(t.FQItem, FQItemType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *FQItemListType) Last() *FQItemType {
  if t.FQItem == nil {
    t = t.AddNew()
    }
        return &(t.FQItem[len(t.FQItem)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *FQItemListType) Index(n int) (*FQItemType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("FQItemListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.FQItem == nil {
    t = t.AddNew()
    }
        return &(t.FQItem[n])
}

// Length of the list.
func (t *FQItemListType) Len() int {
  if t.FQItem == nil {
    t = t.AddNew()
    }
        return len(t.FQItem)
}

// Convert list object to slice
func (t *FQItemListType) ToSlice() []*FQItemType {
  ret := make([]*FQItemType, 0)
  for _, x:= range t.FQItem {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *FQReportingListType) Append(values ...FQReportingType) *FQReportingListType {
    
        if t == nil {
                t, _ = FQReportingListTypePointer(FQReportingListType{})
        }
        if t.FQReporting == nil {
                t.FQReporting = make([]FQReportingType, 0)
        }
        for _, value := range values {
        t.FQReporting = append(t.FQReporting, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *FQReportingListType) AddNew() *FQReportingListType {
        if t == nil {
                t, _ = FQReportingListTypePointer(FQReportingListType{})
        }
        if t.FQReporting == nil {
                t.FQReporting = make([]FQReportingType, 0)
        }
        t.FQReporting = append(t.FQReporting, FQReportingType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *FQReportingListType) Last() *FQReportingType {
  if t.FQReporting == nil {
    t = t.AddNew()
    }
        return &(t.FQReporting[len(t.FQReporting)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *FQReportingListType) Index(n int) (*FQReportingType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("FQReportingListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.FQReporting == nil {
    t = t.AddNew()
    }
        return &(t.FQReporting[n])
}

// Length of the list.
func (t *FQReportingListType) Len() int {
  if t.FQReporting == nil {
    t = t.AddNew()
    }
        return len(t.FQReporting)
}

// Convert list object to slice
func (t *FQReportingListType) ToSlice() []*FQReportingType {
  ret := make([]*FQReportingType, 0)
  for _, x:= range t.FQReporting {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *FinancialAccountRefIdListType) Append(values ...string) *FinancialAccountRefIdListType {
    
        if t == nil {
                t, _ = FinancialAccountRefIdListTypePointer(FinancialAccountRefIdListType{})
        }
        if t.FinancialAccountRefId == nil {
                t.FinancialAccountRefId = make([]string, 0)
        }
        for _, value := range values {
        t.FinancialAccountRefId = append(t.FinancialAccountRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *FinancialAccountRefIdListType) AddNew() *FinancialAccountRefIdListType {
        if t == nil {
                t, _ = FinancialAccountRefIdListTypePointer(FinancialAccountRefIdListType{})
        }
        if t.FinancialAccountRefId == nil {
                t.FinancialAccountRefId = make([]string, 0)
        }
        t.FinancialAccountRefId = append(t.FinancialAccountRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *FinancialAccountRefIdListType) Last() *string {
  if t.FinancialAccountRefId == nil {
    t = t.AddNew()
    }
        return &(t.FinancialAccountRefId[len(t.FinancialAccountRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *FinancialAccountRefIdListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("FinancialAccountRefIdListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.FinancialAccountRefId == nil {
    t = t.AddNew()
    }
        return &(t.FinancialAccountRefId[n])
}

// Length of the list.
func (t *FinancialAccountRefIdListType) Len() int {
  if t.FinancialAccountRefId == nil {
    t = t.AddNew()
    }
        return len(t.FinancialAccountRefId)
}

// Convert list object to slice
func (t *FinancialAccountRefIdListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.FinancialAccountRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *FinancialAccountRefIdListType) AppendString(value string) *FinancialAccountRefIdListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *FineInfoListType) Append(values ...FineInfoType) *FineInfoListType {
    
        if t == nil {
                t, _ = FineInfoListTypePointer(FineInfoListType{})
        }
        if t.FineInfo == nil {
                t.FineInfo = make([]FineInfoType, 0)
        }
        for _, value := range values {
        t.FineInfo = append(t.FineInfo, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *FineInfoListType) AddNew() *FineInfoListType {
        if t == nil {
                t, _ = FineInfoListTypePointer(FineInfoListType{})
        }
        if t.FineInfo == nil {
                t.FineInfo = make([]FineInfoType, 0)
        }
        t.FineInfo = append(t.FineInfo, FineInfoType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *FineInfoListType) Last() *FineInfoType {
  if t.FineInfo == nil {
    t = t.AddNew()
    }
        return &(t.FineInfo[len(t.FineInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *FineInfoListType) Index(n int) (*FineInfoType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("FineInfoListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.FineInfo == nil {
    t = t.AddNew()
    }
        return &(t.FineInfo[n])
}

// Length of the list.
func (t *FineInfoListType) Len() int {
  if t.FineInfo == nil {
    t = t.AddNew()
    }
        return len(t.FineInfo)
}

// Convert list object to slice
func (t *FineInfoListType) ToSlice() []*FineInfoType {
  ret := make([]*FineInfoType, 0)
  for _, x:= range t.FineInfo {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *FollowUpActionListType) Append(values ...FollowUpActionType) *FollowUpActionListType {
    
        if t == nil {
                t, _ = FollowUpActionListTypePointer(FollowUpActionListType{})
        }
        if t.FollowUpAction == nil {
                t.FollowUpAction = make([]FollowUpActionType, 0)
        }
        for _, value := range values {
        t.FollowUpAction = append(t.FollowUpAction, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *FollowUpActionListType) AddNew() *FollowUpActionListType {
        if t == nil {
                t, _ = FollowUpActionListTypePointer(FollowUpActionListType{})
        }
        if t.FollowUpAction == nil {
                t.FollowUpAction = make([]FollowUpActionType, 0)
        }
        t.FollowUpAction = append(t.FollowUpAction, FollowUpActionType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *FollowUpActionListType) Last() *FollowUpActionType {
  if t.FollowUpAction == nil {
    t = t.AddNew()
    }
        return &(t.FollowUpAction[len(t.FollowUpAction)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *FollowUpActionListType) Index(n int) (*FollowUpActionType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("FollowUpActionListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.FollowUpAction == nil {
    t = t.AddNew()
    }
        return &(t.FollowUpAction[n])
}

// Length of the list.
func (t *FollowUpActionListType) Len() int {
  if t.FollowUpAction == nil {
    t = t.AddNew()
    }
        return len(t.FollowUpAction)
}

// Convert list object to slice
func (t *FollowUpActionListType) ToSlice() []*FollowUpActionType {
  ret := make([]*FollowUpActionType, 0)
  for _, x:= range t.FollowUpAction {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *GradingScoreListType) Append(values ...AssignmentScoreType) *GradingScoreListType {
    
        if t == nil {
                t, _ = GradingScoreListTypePointer(GradingScoreListType{})
        }
        if t.GradingAssignmentScore == nil {
                t.GradingAssignmentScore = make([]AssignmentScoreType, 0)
        }
        for _, value := range values {
        t.GradingAssignmentScore = append(t.GradingAssignmentScore, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *GradingScoreListType) AddNew() *GradingScoreListType {
        if t == nil {
                t, _ = GradingScoreListTypePointer(GradingScoreListType{})
        }
        if t.GradingAssignmentScore == nil {
                t.GradingAssignmentScore = make([]AssignmentScoreType, 0)
        }
        t.GradingAssignmentScore = append(t.GradingAssignmentScore, AssignmentScoreType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *GradingScoreListType) Last() *AssignmentScoreType {
  if t.GradingAssignmentScore == nil {
    t = t.AddNew()
    }
        return &(t.GradingAssignmentScore[len(t.GradingAssignmentScore)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *GradingScoreListType) Index(n int) (*AssignmentScoreType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("GradingScoreListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.GradingAssignmentScore == nil {
    t = t.AddNew()
    }
        return &(t.GradingAssignmentScore[n])
}

// Length of the list.
func (t *GradingScoreListType) Len() int {
  if t.GradingAssignmentScore == nil {
    t = t.AddNew()
    }
        return len(t.GradingAssignmentScore)
}

// Convert list object to slice
func (t *GradingScoreListType) ToSlice() []*AssignmentScoreType {
  ret := make([]*AssignmentScoreType, 0)
  for _, x:= range t.GradingAssignmentScore {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *HoldInfoListType) Append(values ...HoldInfoType) *HoldInfoListType {
    
        if t == nil {
                t, _ = HoldInfoListTypePointer(HoldInfoListType{})
        }
        if t.HoldInfo == nil {
                t.HoldInfo = make([]HoldInfoType, 0)
        }
        for _, value := range values {
        t.HoldInfo = append(t.HoldInfo, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *HoldInfoListType) AddNew() *HoldInfoListType {
        if t == nil {
                t, _ = HoldInfoListTypePointer(HoldInfoListType{})
        }
        if t.HoldInfo == nil {
                t.HoldInfo = make([]HoldInfoType, 0)
        }
        t.HoldInfo = append(t.HoldInfo, HoldInfoType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *HoldInfoListType) Last() *HoldInfoType {
  if t.HoldInfo == nil {
    t = t.AddNew()
    }
        return &(t.HoldInfo[len(t.HoldInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *HoldInfoListType) Index(n int) (*HoldInfoType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("HoldInfoListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.HoldInfo == nil {
    t = t.AddNew()
    }
        return &(t.HoldInfo[n])
}

// Length of the list.
func (t *HoldInfoListType) Len() int {
  if t.HoldInfo == nil {
    t = t.AddNew()
    }
        return len(t.HoldInfo)
}

// Convert list object to slice
func (t *HoldInfoListType) ToSlice() []*HoldInfoType {
  ret := make([]*HoldInfoType, 0)
  for _, x:= range t.HoldInfo {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *HouseholdContactInfoListType) Append(values ...HouseholdContactInfoType) *HouseholdContactInfoListType {
    
        if t == nil {
                t, _ = HouseholdContactInfoListTypePointer(HouseholdContactInfoListType{})
        }
        if t.HouseholdContactInfo == nil {
                t.HouseholdContactInfo = make([]HouseholdContactInfoType, 0)
        }
        for _, value := range values {
        t.HouseholdContactInfo = append(t.HouseholdContactInfo, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *HouseholdContactInfoListType) AddNew() *HouseholdContactInfoListType {
        if t == nil {
                t, _ = HouseholdContactInfoListTypePointer(HouseholdContactInfoListType{})
        }
        if t.HouseholdContactInfo == nil {
                t.HouseholdContactInfo = make([]HouseholdContactInfoType, 0)
        }
        t.HouseholdContactInfo = append(t.HouseholdContactInfo, HouseholdContactInfoType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *HouseholdContactInfoListType) Last() *HouseholdContactInfoType {
  if t.HouseholdContactInfo == nil {
    t = t.AddNew()
    }
        return &(t.HouseholdContactInfo[len(t.HouseholdContactInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *HouseholdContactInfoListType) Index(n int) (*HouseholdContactInfoType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("HouseholdContactInfoListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.HouseholdContactInfo == nil {
    t = t.AddNew()
    }
        return &(t.HouseholdContactInfo[n])
}

// Length of the list.
func (t *HouseholdContactInfoListType) Len() int {
  if t.HouseholdContactInfo == nil {
    t = t.AddNew()
    }
        return len(t.HouseholdContactInfo)
}

// Convert list object to slice
func (t *HouseholdContactInfoListType) ToSlice() []*HouseholdContactInfoType {
  ret := make([]*HouseholdContactInfoType, 0)
  for _, x:= range t.HouseholdContactInfo {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *HouseholdListType) Append(values ...LocalIdType) *HouseholdListType {
    
        if t == nil {
                t, _ = HouseholdListTypePointer(HouseholdListType{})
        }
        if t.Household == nil {
                t.Household = make([]LocalIdType, 0)
        }
        for _, value := range values {
        t.Household = append(t.Household, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *HouseholdListType) AddNew() *HouseholdListType {
        if t == nil {
                t, _ = HouseholdListTypePointer(HouseholdListType{})
        }
        if t.Household == nil {
                t.Household = make([]LocalIdType, 0)
        }
        t.Household = append(t.Household, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *HouseholdListType) Last() *LocalIdType {
  if t.Household == nil {
    t = t.AddNew()
    }
        return &(t.Household[len(t.Household)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *HouseholdListType) Index(n int) (*LocalIdType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("HouseholdListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Household == nil {
    t = t.AddNew()
    }
        return &(t.Household[n])
}

// Length of the list.
func (t *HouseholdListType) Len() int {
  if t.Household == nil {
    t = t.AddNew()
    }
        return len(t.Household)
}

// Convert list object to slice
func (t *HouseholdListType) ToSlice() []*LocalIdType {
  ret := make([]*LocalIdType, 0)
  for _, x:= range t.Household {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *HouseholdListType) AppendString(value string) *HouseholdListType {
        return t.Append((LocalIdType)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *IdentityAssertionsType) Append(values ...IdentityAssertionType) *IdentityAssertionsType {
    
        if t == nil {
                t, _ = IdentityAssertionsTypePointer(IdentityAssertionsType{})
        }
        if t.IdentityAssertion == nil {
                t.IdentityAssertion = make([]IdentityAssertionType, 0)
        }
        for _, value := range values {
        t.IdentityAssertion = append(t.IdentityAssertion, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *IdentityAssertionsType) AddNew() *IdentityAssertionsType {
        if t == nil {
                t, _ = IdentityAssertionsTypePointer(IdentityAssertionsType{})
        }
        if t.IdentityAssertion == nil {
                t.IdentityAssertion = make([]IdentityAssertionType, 0)
        }
        t.IdentityAssertion = append(t.IdentityAssertion, IdentityAssertionType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *IdentityAssertionsType) Last() *IdentityAssertionType {
  if t.IdentityAssertion == nil {
    t = t.AddNew()
    }
        return &(t.IdentityAssertion[len(t.IdentityAssertion)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *IdentityAssertionsType) Index(n int) (*IdentityAssertionType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("IdentityAssertionsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.IdentityAssertion == nil {
    t = t.AddNew()
    }
        return &(t.IdentityAssertion[n])
}

// Length of the list.
func (t *IdentityAssertionsType) Len() int {
  if t.IdentityAssertion == nil {
    t = t.AddNew()
    }
        return len(t.IdentityAssertion)
}

// Convert list object to slice
func (t *IdentityAssertionsType) ToSlice() []*IdentityAssertionType {
  ret := make([]*IdentityAssertionType, 0)
  for _, x:= range t.IdentityAssertion {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *JournalAdjustmentListType) Append(values ...JournalAdjustmentType) *JournalAdjustmentListType {
    
        if t == nil {
                t, _ = JournalAdjustmentListTypePointer(JournalAdjustmentListType{})
        }
        if t.JournalAdjustment == nil {
                t.JournalAdjustment = make([]JournalAdjustmentType, 0)
        }
        for _, value := range values {
        t.JournalAdjustment = append(t.JournalAdjustment, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *JournalAdjustmentListType) AddNew() *JournalAdjustmentListType {
        if t == nil {
                t, _ = JournalAdjustmentListTypePointer(JournalAdjustmentListType{})
        }
        if t.JournalAdjustment == nil {
                t.JournalAdjustment = make([]JournalAdjustmentType, 0)
        }
        t.JournalAdjustment = append(t.JournalAdjustment, JournalAdjustmentType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *JournalAdjustmentListType) Last() *JournalAdjustmentType {
  if t.JournalAdjustment == nil {
    t = t.AddNew()
    }
        return &(t.JournalAdjustment[len(t.JournalAdjustment)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *JournalAdjustmentListType) Index(n int) (*JournalAdjustmentType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("JournalAdjustmentListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.JournalAdjustment == nil {
    t = t.AddNew()
    }
        return &(t.JournalAdjustment[n])
}

// Length of the list.
func (t *JournalAdjustmentListType) Len() int {
  if t.JournalAdjustment == nil {
    t = t.AddNew()
    }
        return len(t.JournalAdjustment)
}

// Convert list object to slice
func (t *JournalAdjustmentListType) ToSlice() []*JournalAdjustmentType {
  ret := make([]*JournalAdjustmentType, 0)
  for _, x:= range t.JournalAdjustment {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LEAContactListType) Append(values ...LEAContactType) *LEAContactListType {
    
        if t == nil {
                t, _ = LEAContactListTypePointer(LEAContactListType{})
        }
        if t.LEAContact == nil {
                t.LEAContact = make([]LEAContactType, 0)
        }
        for _, value := range values {
        t.LEAContact = append(t.LEAContact, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LEAContactListType) AddNew() *LEAContactListType {
        if t == nil {
                t, _ = LEAContactListTypePointer(LEAContactListType{})
        }
        if t.LEAContact == nil {
                t.LEAContact = make([]LEAContactType, 0)
        }
        t.LEAContact = append(t.LEAContact, LEAContactType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LEAContactListType) Last() *LEAContactType {
  if t.LEAContact == nil {
    t = t.AddNew()
    }
        return &(t.LEAContact[len(t.LEAContact)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LEAContactListType) Index(n int) (*LEAContactType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LEAContactListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.LEAContact == nil {
    t = t.AddNew()
    }
        return &(t.LEAContact[n])
}

// Length of the list.
func (t *LEAContactListType) Len() int {
  if t.LEAContact == nil {
    t = t.AddNew()
    }
        return len(t.LEAContact)
}

// Convert list object to slice
func (t *LEAContactListType) ToSlice() []*LEAContactType {
  ret := make([]*LEAContactType, 0)
  for _, x:= range t.LEAContact {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LResourcesType) Append(values ...ResourcesType) *LResourcesType {
    
        if t == nil {
                t, _ = LResourcesTypePointer(LResourcesType{})
        }
        if t.LearningResourceRefId == nil {
                t.LearningResourceRefId = make([]ResourcesType, 0)
        }
        for _, value := range values {
        t.LearningResourceRefId = append(t.LearningResourceRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LResourcesType) AddNew() *LResourcesType {
        if t == nil {
                t, _ = LResourcesTypePointer(LResourcesType{})
        }
        if t.LearningResourceRefId == nil {
                t.LearningResourceRefId = make([]ResourcesType, 0)
        }
        t.LearningResourceRefId = append(t.LearningResourceRefId, ResourcesType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LResourcesType) Last() *ResourcesType {
  if t.LearningResourceRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningResourceRefId[len(t.LearningResourceRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LResourcesType) Index(n int) (*ResourcesType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LResourcesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.LearningResourceRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningResourceRefId[n])
}

// Length of the list.
func (t *LResourcesType) Len() int {
  if t.LearningResourceRefId == nil {
    t = t.AddNew()
    }
        return len(t.LearningResourceRefId)
}

// Convert list object to slice
func (t *LResourcesType) ToSlice() []*ResourcesType {
  ret := make([]*ResourcesType, 0)
  for _, x:= range t.LearningResourceRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LanguageListType) Append(values ...LanguageBaseType) *LanguageListType {
    
        if t == nil {
                t, _ = LanguageListTypePointer(LanguageListType{})
        }
        if t.Language == nil {
                t.Language = make([]LanguageBaseType, 0)
        }
        for _, value := range values {
        t.Language = append(t.Language, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LanguageListType) AddNew() *LanguageListType {
        if t == nil {
                t, _ = LanguageListTypePointer(LanguageListType{})
        }
        if t.Language == nil {
                t.Language = make([]LanguageBaseType, 0)
        }
        t.Language = append(t.Language, LanguageBaseType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LanguageListType) Last() *LanguageBaseType {
  if t.Language == nil {
    t = t.AddNew()
    }
        return &(t.Language[len(t.Language)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LanguageListType) Index(n int) (*LanguageBaseType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LanguageListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Language == nil {
    t = t.AddNew()
    }
        return &(t.Language[n])
}

// Length of the list.
func (t *LanguageListType) Len() int {
  if t.Language == nil {
    t = t.AddNew()
    }
        return len(t.Language)
}

// Convert list object to slice
func (t *LanguageListType) ToSlice() []*LanguageBaseType {
  ret := make([]*LanguageBaseType, 0)
  for _, x:= range t.Language {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LearningObjectivesType) Append(values ...string) *LearningObjectivesType {
    
        if t == nil {
                t, _ = LearningObjectivesTypePointer(LearningObjectivesType{})
        }
        if t.LearningObjective == nil {
                t.LearningObjective = make([]string, 0)
        }
        for _, value := range values {
        t.LearningObjective = append(t.LearningObjective, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LearningObjectivesType) AddNew() *LearningObjectivesType {
        if t == nil {
                t, _ = LearningObjectivesTypePointer(LearningObjectivesType{})
        }
        if t.LearningObjective == nil {
                t.LearningObjective = make([]string, 0)
        }
        t.LearningObjective = append(t.LearningObjective, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LearningObjectivesType) Last() *string {
  if t.LearningObjective == nil {
    t = t.AddNew()
    }
        return &(t.LearningObjective[len(t.LearningObjective)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LearningObjectivesType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LearningObjectivesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.LearningObjective == nil {
    t = t.AddNew()
    }
        return &(t.LearningObjective[n])
}

// Length of the list.
func (t *LearningObjectivesType) Len() int {
  if t.LearningObjective == nil {
    t = t.AddNew()
    }
        return len(t.LearningObjective)
}

// Convert list object to slice
func (t *LearningObjectivesType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.LearningObjective {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *LearningObjectivesType) AppendString(value string) *LearningObjectivesType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LearningResourcesType) Append(values ...string) *LearningResourcesType {
    
        if t == nil {
                t, _ = LearningResourcesTypePointer(LearningResourcesType{})
        }
        if t.LearningResourceRefId == nil {
                t.LearningResourceRefId = make([]string, 0)
        }
        for _, value := range values {
        t.LearningResourceRefId = append(t.LearningResourceRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LearningResourcesType) AddNew() *LearningResourcesType {
        if t == nil {
                t, _ = LearningResourcesTypePointer(LearningResourcesType{})
        }
        if t.LearningResourceRefId == nil {
                t.LearningResourceRefId = make([]string, 0)
        }
        t.LearningResourceRefId = append(t.LearningResourceRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LearningResourcesType) Last() *string {
  if t.LearningResourceRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningResourceRefId[len(t.LearningResourceRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LearningResourcesType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LearningResourcesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.LearningResourceRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningResourceRefId[n])
}

// Length of the list.
func (t *LearningResourcesType) Len() int {
  if t.LearningResourceRefId == nil {
    t = t.AddNew()
    }
        return len(t.LearningResourceRefId)
}

// Convert list object to slice
func (t *LearningResourcesType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.LearningResourceRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *LearningResourcesType) AppendString(value string) *LearningResourcesType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LearningStandardListType) Append(values ...LearningStandardType) *LearningStandardListType {
    
        if t == nil {
                t, _ = LearningStandardListTypePointer(LearningStandardListType{})
        }
        if t.LearningStandard == nil {
                t.LearningStandard = make([]LearningStandardType, 0)
        }
        for _, value := range values {
        t.LearningStandard = append(t.LearningStandard, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LearningStandardListType) AddNew() *LearningStandardListType {
        if t == nil {
                t, _ = LearningStandardListTypePointer(LearningStandardListType{})
        }
        if t.LearningStandard == nil {
                t.LearningStandard = make([]LearningStandardType, 0)
        }
        t.LearningStandard = append(t.LearningStandard, LearningStandardType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LearningStandardListType) Last() *LearningStandardType {
  if t.LearningStandard == nil {
    t = t.AddNew()
    }
        return &(t.LearningStandard[len(t.LearningStandard)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LearningStandardListType) Index(n int) (*LearningStandardType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LearningStandardListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.LearningStandard == nil {
    t = t.AddNew()
    }
        return &(t.LearningStandard[n])
}

// Length of the list.
func (t *LearningStandardListType) Len() int {
  if t.LearningStandard == nil {
    t = t.AddNew()
    }
        return len(t.LearningStandard)
}

// Convert list object to slice
func (t *LearningStandardListType) ToSlice() []*LearningStandardType {
  ret := make([]*LearningStandardType, 0)
  for _, x:= range t.LearningStandard {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LearningStandardsDocumentType) Append(values ...string) *LearningStandardsDocumentType {
    
        if t == nil {
                t, _ = LearningStandardsDocumentTypePointer(LearningStandardsDocumentType{})
        }
        if t.LearningStandardDocumentRefId == nil {
                t.LearningStandardDocumentRefId = make([]string, 0)
        }
        for _, value := range values {
        t.LearningStandardDocumentRefId = append(t.LearningStandardDocumentRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LearningStandardsDocumentType) AddNew() *LearningStandardsDocumentType {
        if t == nil {
                t, _ = LearningStandardsDocumentTypePointer(LearningStandardsDocumentType{})
        }
        if t.LearningStandardDocumentRefId == nil {
                t.LearningStandardDocumentRefId = make([]string, 0)
        }
        t.LearningStandardDocumentRefId = append(t.LearningStandardDocumentRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LearningStandardsDocumentType) Last() *string {
  if t.LearningStandardDocumentRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningStandardDocumentRefId[len(t.LearningStandardDocumentRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LearningStandardsDocumentType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LearningStandardsDocumentType.Index(): subscript %d out of range on list\n", n)
    }
  if t.LearningStandardDocumentRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningStandardDocumentRefId[n])
}

// Length of the list.
func (t *LearningStandardsDocumentType) Len() int {
  if t.LearningStandardDocumentRefId == nil {
    t = t.AddNew()
    }
        return len(t.LearningStandardDocumentRefId)
}

// Convert list object to slice
func (t *LearningStandardsDocumentType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.LearningStandardDocumentRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *LearningStandardsDocumentType) AppendString(value string) *LearningStandardsDocumentType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LearningStandardsType) Append(values ...string) *LearningStandardsType {
    
        if t == nil {
                t, _ = LearningStandardsTypePointer(LearningStandardsType{})
        }
        if t.LearningStandardItemRefId == nil {
                t.LearningStandardItemRefId = make([]string, 0)
        }
        for _, value := range values {
        t.LearningStandardItemRefId = append(t.LearningStandardItemRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LearningStandardsType) AddNew() *LearningStandardsType {
        if t == nil {
                t, _ = LearningStandardsTypePointer(LearningStandardsType{})
        }
        if t.LearningStandardItemRefId == nil {
                t.LearningStandardItemRefId = make([]string, 0)
        }
        t.LearningStandardItemRefId = append(t.LearningStandardItemRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LearningStandardsType) Last() *string {
  if t.LearningStandardItemRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningStandardItemRefId[len(t.LearningStandardItemRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LearningStandardsType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LearningStandardsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.LearningStandardItemRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningStandardItemRefId[n])
}

// Length of the list.
func (t *LearningStandardsType) Len() int {
  if t.LearningStandardItemRefId == nil {
    t = t.AddNew()
    }
        return len(t.LearningStandardItemRefId)
}

// Convert list object to slice
func (t *LearningStandardsType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.LearningStandardItemRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *LearningStandardsType) AppendString(value string) *LearningStandardsType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LibraryMessageListType) Append(values ...LibraryMessageType) *LibraryMessageListType {
    
        if t == nil {
                t, _ = LibraryMessageListTypePointer(LibraryMessageListType{})
        }
        if t.Message == nil {
                t.Message = make([]LibraryMessageType, 0)
        }
        for _, value := range values {
        t.Message = append(t.Message, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LibraryMessageListType) AddNew() *LibraryMessageListType {
        if t == nil {
                t, _ = LibraryMessageListTypePointer(LibraryMessageListType{})
        }
        if t.Message == nil {
                t.Message = make([]LibraryMessageType, 0)
        }
        t.Message = append(t.Message, LibraryMessageType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LibraryMessageListType) Last() *LibraryMessageType {
  if t.Message == nil {
    t = t.AddNew()
    }
        return &(t.Message[len(t.Message)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LibraryMessageListType) Index(n int) (*LibraryMessageType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LibraryMessageListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Message == nil {
    t = t.AddNew()
    }
        return &(t.Message[n])
}

// Length of the list.
func (t *LibraryMessageListType) Len() int {
  if t.Message == nil {
    t = t.AddNew()
    }
        return len(t.Message)
}

// Convert list object to slice
func (t *LibraryMessageListType) ToSlice() []*LibraryMessageType {
  ret := make([]*LibraryMessageType, 0)
  for _, x:= range t.Message {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LibraryTransactionListType) Append(values ...LibraryTransactionType) *LibraryTransactionListType {
    
        if t == nil {
                t, _ = LibraryTransactionListTypePointer(LibraryTransactionListType{})
        }
        if t.Transaction == nil {
                t.Transaction = make([]LibraryTransactionType, 0)
        }
        for _, value := range values {
        t.Transaction = append(t.Transaction, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LibraryTransactionListType) AddNew() *LibraryTransactionListType {
        if t == nil {
                t, _ = LibraryTransactionListTypePointer(LibraryTransactionListType{})
        }
        if t.Transaction == nil {
                t.Transaction = make([]LibraryTransactionType, 0)
        }
        t.Transaction = append(t.Transaction, LibraryTransactionType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LibraryTransactionListType) Last() *LibraryTransactionType {
  if t.Transaction == nil {
    t = t.AddNew()
    }
        return &(t.Transaction[len(t.Transaction)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LibraryTransactionListType) Index(n int) (*LibraryTransactionType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LibraryTransactionListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Transaction == nil {
    t = t.AddNew()
    }
        return &(t.Transaction[n])
}

// Length of the list.
func (t *LibraryTransactionListType) Len() int {
  if t.Transaction == nil {
    t = t.AddNew()
    }
        return len(t.Transaction)
}

// Convert list object to slice
func (t *LibraryTransactionListType) ToSlice() []*LibraryTransactionType {
  ret := make([]*LibraryTransactionType, 0)
  for _, x:= range t.Transaction {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LocalCodeListType) Append(values ...LocalCodeType) *LocalCodeListType {
    
        if t == nil {
                t, _ = LocalCodeListTypePointer(LocalCodeListType{})
        }
        if t.LocalCode == nil {
                t.LocalCode = make([]LocalCodeType, 0)
        }
        for _, value := range values {
        t.LocalCode = append(t.LocalCode, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LocalCodeListType) AddNew() *LocalCodeListType {
        if t == nil {
                t, _ = LocalCodeListTypePointer(LocalCodeListType{})
        }
        if t.LocalCode == nil {
                t.LocalCode = make([]LocalCodeType, 0)
        }
        t.LocalCode = append(t.LocalCode, LocalCodeType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LocalCodeListType) Last() *LocalCodeType {
  if t.LocalCode == nil {
    t = t.AddNew()
    }
        return &(t.LocalCode[len(t.LocalCode)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *LocalCodeListType) Index(n int) (*LocalCodeType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LocalCodeListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.LocalCode == nil {
    t = t.AddNew()
    }
        return &(t.LocalCode[n])
}

// Length of the list.
func (t *LocalCodeListType) Len() int {
  if t.LocalCode == nil {
    t = t.AddNew()
    }
        return len(t.LocalCode)
}

// Convert list object to slice
func (t *LocalCodeListType) ToSlice() []*LocalCodeType {
  ret := make([]*LocalCodeType, 0)
  for _, x:= range t.LocalCode {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *MediaTypesType) Append(values ...string) *MediaTypesType {
    
        if t == nil {
                t, _ = MediaTypesTypePointer(MediaTypesType{})
        }
        if t.MediaType == nil {
                t.MediaType = make([]string, 0)
        }
        for _, value := range values {
        t.MediaType = append(t.MediaType, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *MediaTypesType) AddNew() *MediaTypesType {
        if t == nil {
                t, _ = MediaTypesTypePointer(MediaTypesType{})
        }
        if t.MediaType == nil {
                t.MediaType = make([]string, 0)
        }
        t.MediaType = append(t.MediaType, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *MediaTypesType) Last() *string {
  if t.MediaType == nil {
    t = t.AddNew()
    }
        return &(t.MediaType[len(t.MediaType)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *MediaTypesType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("MediaTypesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.MediaType == nil {
    t = t.AddNew()
    }
        return &(t.MediaType[n])
}

// Length of the list.
func (t *MediaTypesType) Len() int {
  if t.MediaType == nil {
    t = t.AddNew()
    }
        return len(t.MediaType)
}

// Convert list object to slice
func (t *MediaTypesType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.MediaType {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *MediaTypesType) AppendString(value string) *MediaTypesType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *MedicalAlertMessagesType) Append(values ...MedicalAlertMessageType) *MedicalAlertMessagesType {
    
        if t == nil {
                t, _ = MedicalAlertMessagesTypePointer(MedicalAlertMessagesType{})
        }
        if t.MedicalAlertMessage == nil {
                t.MedicalAlertMessage = make([]MedicalAlertMessageType, 0)
        }
        for _, value := range values {
        t.MedicalAlertMessage = append(t.MedicalAlertMessage, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *MedicalAlertMessagesType) AddNew() *MedicalAlertMessagesType {
        if t == nil {
                t, _ = MedicalAlertMessagesTypePointer(MedicalAlertMessagesType{})
        }
        if t.MedicalAlertMessage == nil {
                t.MedicalAlertMessage = make([]MedicalAlertMessageType, 0)
        }
        t.MedicalAlertMessage = append(t.MedicalAlertMessage, MedicalAlertMessageType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *MedicalAlertMessagesType) Last() *MedicalAlertMessageType {
  if t.MedicalAlertMessage == nil {
    t = t.AddNew()
    }
        return &(t.MedicalAlertMessage[len(t.MedicalAlertMessage)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *MedicalAlertMessagesType) Index(n int) (*MedicalAlertMessageType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("MedicalAlertMessagesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.MedicalAlertMessage == nil {
    t = t.AddNew()
    }
        return &(t.MedicalAlertMessage[n])
}

// Length of the list.
func (t *MedicalAlertMessagesType) Len() int {
  if t.MedicalAlertMessage == nil {
    t = t.AddNew()
    }
        return len(t.MedicalAlertMessage)
}

// Convert list object to slice
func (t *MedicalAlertMessagesType) ToSlice() []*MedicalAlertMessageType {
  ret := make([]*MedicalAlertMessageType, 0)
  for _, x:= range t.MedicalAlertMessage {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *MedicationListType) Append(values ...MedicationType) *MedicationListType {
    
        if t == nil {
                t, _ = MedicationListTypePointer(MedicationListType{})
        }
        if t.Medication == nil {
                t.Medication = make([]MedicationType, 0)
        }
        for _, value := range values {
        t.Medication = append(t.Medication, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *MedicationListType) AddNew() *MedicationListType {
        if t == nil {
                t, _ = MedicationListTypePointer(MedicationListType{})
        }
        if t.Medication == nil {
                t.Medication = make([]MedicationType, 0)
        }
        t.Medication = append(t.Medication, MedicationType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *MedicationListType) Last() *MedicationType {
  if t.Medication == nil {
    t = t.AddNew()
    }
        return &(t.Medication[len(t.Medication)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *MedicationListType) Index(n int) (*MedicationType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("MedicationListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Medication == nil {
    t = t.AddNew()
    }
        return &(t.Medication[n])
}

// Length of the list.
func (t *MedicationListType) Len() int {
  if t.Medication == nil {
    t = t.AddNew()
    }
        return len(t.Medication)
}

// Convert list object to slice
func (t *MedicationListType) ToSlice() []*MedicationType {
  ret := make([]*MedicationType, 0)
  for _, x:= range t.Medication {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ModifiedListType) Append(values ...ModifiedType) *ModifiedListType {
    
        if t == nil {
                t, _ = ModifiedListTypePointer(ModifiedListType{})
        }
        if t.Modified == nil {
                t.Modified = make([]ModifiedType, 0)
        }
        for _, value := range values {
        t.Modified = append(t.Modified, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ModifiedListType) AddNew() *ModifiedListType {
        if t == nil {
                t, _ = ModifiedListTypePointer(ModifiedListType{})
        }
        if t.Modified == nil {
                t.Modified = make([]ModifiedType, 0)
        }
        t.Modified = append(t.Modified, ModifiedType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ModifiedListType) Last() *ModifiedType {
  if t.Modified == nil {
    t = t.AddNew()
    }
        return &(t.Modified[len(t.Modified)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ModifiedListType) Index(n int) (*ModifiedType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ModifiedListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Modified == nil {
    t = t.AddNew()
    }
        return &(t.Modified[n])
}

// Length of the list.
func (t *ModifiedListType) Len() int {
  if t.Modified == nil {
    t = t.AddNew()
    }
        return len(t.Modified)
}

// Convert list object to slice
func (t *ModifiedListType) ToSlice() []*ModifiedType {
  ret := make([]*ModifiedType, 0)
  for _, x:= range t.Modified {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPCodeFrameTestletListType) Append(values ...NAPTestletCodeFrameType) *NAPCodeFrameTestletListType {
    
        if t == nil {
                t, _ = NAPCodeFrameTestletListTypePointer(NAPCodeFrameTestletListType{})
        }
        if t.Testlet == nil {
                t.Testlet = make([]NAPTestletCodeFrameType, 0)
        }
        for _, value := range values {
        t.Testlet = append(t.Testlet, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPCodeFrameTestletListType) AddNew() *NAPCodeFrameTestletListType {
        if t == nil {
                t, _ = NAPCodeFrameTestletListTypePointer(NAPCodeFrameTestletListType{})
        }
        if t.Testlet == nil {
                t.Testlet = make([]NAPTestletCodeFrameType, 0)
        }
        t.Testlet = append(t.Testlet, NAPTestletCodeFrameType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPCodeFrameTestletListType) Last() *NAPTestletCodeFrameType {
  if t.Testlet == nil {
    t = t.AddNew()
    }
        return &(t.Testlet[len(t.Testlet)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NAPCodeFrameTestletListType) Index(n int) (*NAPTestletCodeFrameType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPCodeFrameTestletListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Testlet == nil {
    t = t.AddNew()
    }
        return &(t.Testlet[n])
}

// Length of the list.
func (t *NAPCodeFrameTestletListType) Len() int {
  if t.Testlet == nil {
    t = t.AddNew()
    }
        return len(t.Testlet)
}

// Convert list object to slice
func (t *NAPCodeFrameTestletListType) ToSlice() []*NAPTestletCodeFrameType {
  ret := make([]*NAPTestletCodeFrameType, 0)
  for _, x:= range t.Testlet {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPLANClassListType) Append(values ...string) *NAPLANClassListType {
    
        if t == nil {
                t, _ = NAPLANClassListTypePointer(NAPLANClassListType{})
        }
        if t.ClassCode == nil {
                t.ClassCode = make([]string, 0)
        }
        for _, value := range values {
        t.ClassCode = append(t.ClassCode, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPLANClassListType) AddNew() *NAPLANClassListType {
        if t == nil {
                t, _ = NAPLANClassListTypePointer(NAPLANClassListType{})
        }
        if t.ClassCode == nil {
                t.ClassCode = make([]string, 0)
        }
        t.ClassCode = append(t.ClassCode, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPLANClassListType) Last() *string {
  if t.ClassCode == nil {
    t = t.AddNew()
    }
        return &(t.ClassCode[len(t.ClassCode)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NAPLANClassListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPLANClassListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ClassCode == nil {
    t = t.AddNew()
    }
        return &(t.ClassCode[n])
}

// Length of the list.
func (t *NAPLANClassListType) Len() int {
  if t.ClassCode == nil {
    t = t.AddNew()
    }
        return len(t.ClassCode)
}

// Convert list object to slice
func (t *NAPLANClassListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.ClassCode {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *NAPLANClassListType) AppendString(value string) *NAPLANClassListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPLANScoreListType) Append(values ...NAPLANScoreType) *NAPLANScoreListType {
    
        if t == nil {
                t, _ = NAPLANScoreListTypePointer(NAPLANScoreListType{})
        }
        if t.NAPLANScore == nil {
                t.NAPLANScore = make([]NAPLANScoreType, 0)
        }
        for _, value := range values {
        t.NAPLANScore = append(t.NAPLANScore, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPLANScoreListType) AddNew() *NAPLANScoreListType {
        if t == nil {
                t, _ = NAPLANScoreListTypePointer(NAPLANScoreListType{})
        }
        if t.NAPLANScore == nil {
                t.NAPLANScore = make([]NAPLANScoreType, 0)
        }
        t.NAPLANScore = append(t.NAPLANScore, NAPLANScoreType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPLANScoreListType) Last() *NAPLANScoreType {
  if t.NAPLANScore == nil {
    t = t.AddNew()
    }
        return &(t.NAPLANScore[len(t.NAPLANScore)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NAPLANScoreListType) Index(n int) (*NAPLANScoreType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPLANScoreListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.NAPLANScore == nil {
    t = t.AddNew()
    }
        return &(t.NAPLANScore[n])
}

// Length of the list.
func (t *NAPLANScoreListType) Len() int {
  if t.NAPLANScore == nil {
    t = t.AddNew()
    }
        return len(t.NAPLANScore)
}

// Convert list object to slice
func (t *NAPLANScoreListType) ToSlice() []*NAPLANScoreType {
  ret := make([]*NAPLANScoreType, 0)
  for _, x:= range t.NAPLANScore {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPLANScoreWithYearsListType) Append(values ...NAPLANScoreWithYearsType) *NAPLANScoreWithYearsListType {
    
        if t == nil {
                t, _ = NAPLANScoreWithYearsListTypePointer(NAPLANScoreWithYearsListType{})
        }
        if t.NAPLANScore == nil {
                t.NAPLANScore = make([]NAPLANScoreWithYearsType, 0)
        }
        for _, value := range values {
        t.NAPLANScore = append(t.NAPLANScore, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPLANScoreWithYearsListType) AddNew() *NAPLANScoreWithYearsListType {
        if t == nil {
                t, _ = NAPLANScoreWithYearsListTypePointer(NAPLANScoreWithYearsListType{})
        }
        if t.NAPLANScore == nil {
                t.NAPLANScore = make([]NAPLANScoreWithYearsType, 0)
        }
        t.NAPLANScore = append(t.NAPLANScore, NAPLANScoreWithYearsType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPLANScoreWithYearsListType) Last() *NAPLANScoreWithYearsType {
  if t.NAPLANScore == nil {
    t = t.AddNew()
    }
        return &(t.NAPLANScore[len(t.NAPLANScore)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NAPLANScoreWithYearsListType) Index(n int) (*NAPLANScoreWithYearsType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPLANScoreWithYearsListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.NAPLANScore == nil {
    t = t.AddNew()
    }
        return &(t.NAPLANScore[n])
}

// Length of the list.
func (t *NAPLANScoreWithYearsListType) Len() int {
  if t.NAPLANScore == nil {
    t = t.AddNew()
    }
        return len(t.NAPLANScore)
}

// Convert list object to slice
func (t *NAPLANScoreWithYearsListType) ToSlice() []*NAPLANScoreWithYearsType {
  ret := make([]*NAPLANScoreWithYearsType, 0)
  for _, x:= range t.NAPLANScore {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPStudentResponseTestletListType) Append(values ...NAPTestletResponseType) *NAPStudentResponseTestletListType {
    
        if t == nil {
                t, _ = NAPStudentResponseTestletListTypePointer(NAPStudentResponseTestletListType{})
        }
        if t.Testlet == nil {
                t.Testlet = make([]NAPTestletResponseType, 0)
        }
        for _, value := range values {
        t.Testlet = append(t.Testlet, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPStudentResponseTestletListType) AddNew() *NAPStudentResponseTestletListType {
        if t == nil {
                t, _ = NAPStudentResponseTestletListTypePointer(NAPStudentResponseTestletListType{})
        }
        if t.Testlet == nil {
                t.Testlet = make([]NAPTestletResponseType, 0)
        }
        t.Testlet = append(t.Testlet, NAPTestletResponseType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPStudentResponseTestletListType) Last() *NAPTestletResponseType {
  if t.Testlet == nil {
    t = t.AddNew()
    }
        return &(t.Testlet[len(t.Testlet)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NAPStudentResponseTestletListType) Index(n int) (*NAPTestletResponseType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPStudentResponseTestletListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Testlet == nil {
    t = t.AddNew()
    }
        return &(t.Testlet[n])
}

// Length of the list.
func (t *NAPStudentResponseTestletListType) Len() int {
  if t.Testlet == nil {
    t = t.AddNew()
    }
        return len(t.Testlet)
}

// Convert list object to slice
func (t *NAPStudentResponseTestletListType) ToSlice() []*NAPTestletResponseType {
  ret := make([]*NAPTestletResponseType, 0)
  for _, x:= range t.Testlet {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPSubscoreListType) Append(values ...NAPSubscoreType) *NAPSubscoreListType {
    
        if t == nil {
                t, _ = NAPSubscoreListTypePointer(NAPSubscoreListType{})
        }
        if t.Subscore == nil {
                t.Subscore = make([]NAPSubscoreType, 0)
        }
        for _, value := range values {
        t.Subscore = append(t.Subscore, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPSubscoreListType) AddNew() *NAPSubscoreListType {
        if t == nil {
                t, _ = NAPSubscoreListTypePointer(NAPSubscoreListType{})
        }
        if t.Subscore == nil {
                t.Subscore = make([]NAPSubscoreType, 0)
        }
        t.Subscore = append(t.Subscore, NAPSubscoreType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPSubscoreListType) Last() *NAPSubscoreType {
  if t.Subscore == nil {
    t = t.AddNew()
    }
        return &(t.Subscore[len(t.Subscore)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NAPSubscoreListType) Index(n int) (*NAPSubscoreType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPSubscoreListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Subscore == nil {
    t = t.AddNew()
    }
        return &(t.Subscore[n])
}

// Length of the list.
func (t *NAPSubscoreListType) Len() int {
  if t.Subscore == nil {
    t = t.AddNew()
    }
        return len(t.Subscore)
}

// Convert list object to slice
func (t *NAPSubscoreListType) ToSlice() []*NAPSubscoreType {
  ret := make([]*NAPSubscoreType, 0)
  for _, x:= range t.Subscore {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPTestItemListType) Append(values ...NAPTestItem2Type) *NAPTestItemListType {
    
        if t == nil {
                t, _ = NAPTestItemListTypePointer(NAPTestItemListType{})
        }
        if t.TestItem == nil {
                t.TestItem = make([]NAPTestItem2Type, 0)
        }
        for _, value := range values {
        t.TestItem = append(t.TestItem, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPTestItemListType) AddNew() *NAPTestItemListType {
        if t == nil {
                t, _ = NAPTestItemListTypePointer(NAPTestItemListType{})
        }
        if t.TestItem == nil {
                t.TestItem = make([]NAPTestItem2Type, 0)
        }
        t.TestItem = append(t.TestItem, NAPTestItem2Type{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPTestItemListType) Last() *NAPTestItem2Type {
  if t.TestItem == nil {
    t = t.AddNew()
    }
        return &(t.TestItem[len(t.TestItem)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NAPTestItemListType) Index(n int) (*NAPTestItem2Type) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPTestItemListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TestItem == nil {
    t = t.AddNew()
    }
        return &(t.TestItem[n])
}

// Length of the list.
func (t *NAPTestItemListType) Len() int {
  if t.TestItem == nil {
    t = t.AddNew()
    }
        return len(t.TestItem)
}

// Convert list object to slice
func (t *NAPTestItemListType) ToSlice() []*NAPTestItem2Type {
  ret := make([]*NAPTestItem2Type, 0)
  for _, x:= range t.TestItem {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPTestletItemResponseListType) Append(values ...NAPTestletResponseItemType) *NAPTestletItemResponseListType {
    
        if t == nil {
                t, _ = NAPTestletItemResponseListTypePointer(NAPTestletItemResponseListType{})
        }
        if t.ItemResponse == nil {
                t.ItemResponse = make([]NAPTestletResponseItemType, 0)
        }
        for _, value := range values {
        t.ItemResponse = append(t.ItemResponse, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPTestletItemResponseListType) AddNew() *NAPTestletItemResponseListType {
        if t == nil {
                t, _ = NAPTestletItemResponseListTypePointer(NAPTestletItemResponseListType{})
        }
        if t.ItemResponse == nil {
                t.ItemResponse = make([]NAPTestletResponseItemType, 0)
        }
        t.ItemResponse = append(t.ItemResponse, NAPTestletResponseItemType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPTestletItemResponseListType) Last() *NAPTestletResponseItemType {
  if t.ItemResponse == nil {
    t = t.AddNew()
    }
        return &(t.ItemResponse[len(t.ItemResponse)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NAPTestletItemResponseListType) Index(n int) (*NAPTestletResponseItemType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPTestletItemResponseListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ItemResponse == nil {
    t = t.AddNew()
    }
        return &(t.ItemResponse[n])
}

// Length of the list.
func (t *NAPTestletItemResponseListType) Len() int {
  if t.ItemResponse == nil {
    t = t.AddNew()
    }
        return len(t.ItemResponse)
}

// Convert list object to slice
func (t *NAPTestletItemResponseListType) ToSlice() []*NAPTestletResponseItemType {
  ret := make([]*NAPTestletResponseItemType, 0)
  for _, x:= range t.ItemResponse {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPWritingRubricListType) Append(values ...NAPWritingRubricType) *NAPWritingRubricListType {
    
        if t == nil {
                t, _ = NAPWritingRubricListTypePointer(NAPWritingRubricListType{})
        }
        if t.NAPWritingRubric == nil {
                t.NAPWritingRubric = make([]NAPWritingRubricType, 0)
        }
        for _, value := range values {
        t.NAPWritingRubric = append(t.NAPWritingRubric, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPWritingRubricListType) AddNew() *NAPWritingRubricListType {
        if t == nil {
                t, _ = NAPWritingRubricListTypePointer(NAPWritingRubricListType{})
        }
        if t.NAPWritingRubric == nil {
                t.NAPWritingRubric = make([]NAPWritingRubricType, 0)
        }
        t.NAPWritingRubric = append(t.NAPWritingRubric, NAPWritingRubricType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPWritingRubricListType) Last() *NAPWritingRubricType {
  if t.NAPWritingRubric == nil {
    t = t.AddNew()
    }
        return &(t.NAPWritingRubric[len(t.NAPWritingRubric)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NAPWritingRubricListType) Index(n int) (*NAPWritingRubricType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPWritingRubricListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.NAPWritingRubric == nil {
    t = t.AddNew()
    }
        return &(t.NAPWritingRubric[n])
}

// Length of the list.
func (t *NAPWritingRubricListType) Len() int {
  if t.NAPWritingRubric == nil {
    t = t.AddNew()
    }
        return len(t.NAPWritingRubric)
}

// Convert list object to slice
func (t *NAPWritingRubricListType) ToSlice() []*NAPWritingRubricType {
  ret := make([]*NAPWritingRubricType, 0)
  for _, x:= range t.NAPWritingRubric {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NCCDListType) Append(values ...NCCDType) *NCCDListType {
    
        if t == nil {
                t, _ = NCCDListTypePointer(NCCDListType{})
        }
        if t.NCCD == nil {
                t.NCCD = make([]NCCDType, 0)
        }
        for _, value := range values {
        t.NCCD = append(t.NCCD, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NCCDListType) AddNew() *NCCDListType {
        if t == nil {
                t, _ = NCCDListTypePointer(NCCDListType{})
        }
        if t.NCCD == nil {
                t.NCCD = make([]NCCDType, 0)
        }
        t.NCCD = append(t.NCCD, NCCDType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NCCDListType) Last() *NCCDType {
  if t.NCCD == nil {
    t = t.AddNew()
    }
        return &(t.NCCD[len(t.NCCD)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NCCDListType) Index(n int) (*NCCDType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NCCDListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.NCCD == nil {
    t = t.AddNew()
    }
        return &(t.NCCD[n])
}

// Length of the list.
func (t *NCCDListType) Len() int {
  if t.NCCD == nil {
    t = t.AddNew()
    }
        return len(t.NCCD)
}

// Convert list object to slice
func (t *NCCDListType) ToSlice() []*NCCDType {
  ret := make([]*NCCDType, 0)
  for _, x:= range t.NCCD {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NeverShareWithListType) Append(values ...NeverShareWithType) *NeverShareWithListType {
    
        if t == nil {
                t, _ = NeverShareWithListTypePointer(NeverShareWithListType{})
        }
        if t.NeverShareWith == nil {
                t.NeverShareWith = make([]NeverShareWithType, 0)
        }
        for _, value := range values {
        t.NeverShareWith = append(t.NeverShareWith, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NeverShareWithListType) AddNew() *NeverShareWithListType {
        if t == nil {
                t, _ = NeverShareWithListTypePointer(NeverShareWithListType{})
        }
        if t.NeverShareWith == nil {
                t.NeverShareWith = make([]NeverShareWithType, 0)
        }
        t.NeverShareWith = append(t.NeverShareWith, NeverShareWithType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NeverShareWithListType) Last() *NeverShareWithType {
  if t.NeverShareWith == nil {
    t = t.AddNew()
    }
        return &(t.NeverShareWith[len(t.NeverShareWith)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *NeverShareWithListType) Index(n int) (*NeverShareWithType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NeverShareWithListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.NeverShareWith == nil {
    t = t.AddNew()
    }
        return &(t.NeverShareWith[n])
}

// Length of the list.
func (t *NeverShareWithListType) Len() int {
  if t.NeverShareWith == nil {
    t = t.AddNew()
    }
        return len(t.NeverShareWith)
}

// Convert list object to slice
func (t *NeverShareWithListType) ToSlice() []*NeverShareWithType {
  ret := make([]*NeverShareWithType, 0)
  for _, x:= range t.NeverShareWith {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *OrganizationsType) Append(values ...string) *OrganizationsType {
    
        if t == nil {
                t, _ = OrganizationsTypePointer(OrganizationsType{})
        }
        if t.Organization == nil {
                t.Organization = make([]string, 0)
        }
        for _, value := range values {
        t.Organization = append(t.Organization, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *OrganizationsType) AddNew() *OrganizationsType {
        if t == nil {
                t, _ = OrganizationsTypePointer(OrganizationsType{})
        }
        if t.Organization == nil {
                t.Organization = make([]string, 0)
        }
        t.Organization = append(t.Organization, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *OrganizationsType) Last() *string {
  if t.Organization == nil {
    t = t.AddNew()
    }
        return &(t.Organization[len(t.Organization)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *OrganizationsType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("OrganizationsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Organization == nil {
    t = t.AddNew()
    }
        return &(t.Organization[n])
}

// Length of the list.
func (t *OrganizationsType) Len() int {
  if t.Organization == nil {
    t = t.AddNew()
    }
        return len(t.Organization)
}

// Convert list object to slice
func (t *OrganizationsType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.Organization {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *OrganizationsType) AppendString(value string) *OrganizationsType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *OtherCodeListType) Append(values ...OtherCodeListType_OtherCode) *OtherCodeListType {
    
        if t == nil {
                t, _ = OtherCodeListTypePointer(OtherCodeListType{})
        }
        if t.OtherCode == nil {
                t.OtherCode = make([]OtherCodeListType_OtherCode, 0)
        }
        for _, value := range values {
        t.OtherCode = append(t.OtherCode, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *OtherCodeListType) AddNew() *OtherCodeListType {
        if t == nil {
                t, _ = OtherCodeListTypePointer(OtherCodeListType{})
        }
        if t.OtherCode == nil {
                t.OtherCode = make([]OtherCodeListType_OtherCode, 0)
        }
        t.OtherCode = append(t.OtherCode, OtherCodeListType_OtherCode{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *OtherCodeListType) Last() *OtherCodeListType_OtherCode {
  if t.OtherCode == nil {
    t = t.AddNew()
    }
        return &(t.OtherCode[len(t.OtherCode)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *OtherCodeListType) Index(n int) (*OtherCodeListType_OtherCode) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("OtherCodeListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.OtherCode == nil {
    t = t.AddNew()
    }
        return &(t.OtherCode[n])
}

// Length of the list.
func (t *OtherCodeListType) Len() int {
  if t.OtherCode == nil {
    t = t.AddNew()
    }
        return len(t.OtherCode)
}

// Convert list object to slice
func (t *OtherCodeListType) ToSlice() []*OtherCodeListType_OtherCode {
  ret := make([]*OtherCodeListType_OtherCode, 0)
  for _, x:= range t.OtherCode {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *OtherIdListType) Append(values ...OtherIdType) *OtherIdListType {
    
        if t == nil {
                t, _ = OtherIdListTypePointer(OtherIdListType{})
        }
        if t.OtherId == nil {
                t.OtherId = make([]OtherIdType, 0)
        }
        for _, value := range values {
        t.OtherId = append(t.OtherId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *OtherIdListType) AddNew() *OtherIdListType {
        if t == nil {
                t, _ = OtherIdListTypePointer(OtherIdListType{})
        }
        if t.OtherId == nil {
                t.OtherId = make([]OtherIdType, 0)
        }
        t.OtherId = append(t.OtherId, OtherIdType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *OtherIdListType) Last() *OtherIdType {
  if t.OtherId == nil {
    t = t.AddNew()
    }
        return &(t.OtherId[len(t.OtherId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *OtherIdListType) Index(n int) (*OtherIdType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("OtherIdListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.OtherId == nil {
    t = t.AddNew()
    }
        return &(t.OtherId[n])
}

// Length of the list.
func (t *OtherIdListType) Len() int {
  if t.OtherId == nil {
    t = t.AddNew()
    }
        return len(t.OtherId)
}

// Convert list object to slice
func (t *OtherIdListType) ToSlice() []*OtherIdType {
  ret := make([]*OtherIdType, 0)
  for _, x:= range t.OtherId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *OtherNamesType) Append(values ...OtherNameType) *OtherNamesType {
    
        if t == nil {
                t, _ = OtherNamesTypePointer(OtherNamesType{})
        }
        if t.Name == nil {
                t.Name = make([]OtherNameType, 0)
        }
        for _, value := range values {
        t.Name = append(t.Name, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *OtherNamesType) AddNew() *OtherNamesType {
        if t == nil {
                t, _ = OtherNamesTypePointer(OtherNamesType{})
        }
        if t.Name == nil {
                t.Name = make([]OtherNameType, 0)
        }
        t.Name = append(t.Name, OtherNameType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *OtherNamesType) Last() *OtherNameType {
  if t.Name == nil {
    t = t.AddNew()
    }
        return &(t.Name[len(t.Name)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *OtherNamesType) Index(n int) (*OtherNameType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("OtherNamesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Name == nil {
    t = t.AddNew()
    }
        return &(t.Name[n])
}

// Length of the list.
func (t *OtherNamesType) Len() int {
  if t.Name == nil {
    t = t.AddNew()
    }
        return len(t.Name)
}

// Convert list object to slice
func (t *OtherNamesType) ToSlice() []*OtherNameType {
  ret := make([]*OtherNameType, 0)
  for _, x:= range t.Name {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PNPCodeListType) Append(values ...AUCodeSetsPNPCodeType) *PNPCodeListType {
    
        if t == nil {
                t, _ = PNPCodeListTypePointer(PNPCodeListType{})
        }
        if t.PNPCode == nil {
                t.PNPCode = make([]AUCodeSetsPNPCodeType, 0)
        }
        for _, value := range values {
        t.PNPCode = append(t.PNPCode, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PNPCodeListType) AddNew() *PNPCodeListType {
        if t == nil {
                t, _ = PNPCodeListTypePointer(PNPCodeListType{})
        }
        if t.PNPCode == nil {
                t.PNPCode = make([]AUCodeSetsPNPCodeType, 0)
        }
        t.PNPCode = append(t.PNPCode, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PNPCodeListType) Last() *AUCodeSetsPNPCodeType {
  if t.PNPCode == nil {
    t = t.AddNew()
    }
        return &(t.PNPCode[len(t.PNPCode)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PNPCodeListType) Index(n int) (*AUCodeSetsPNPCodeType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PNPCodeListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PNPCode == nil {
    t = t.AddNew()
    }
        return &(t.PNPCode[n])
}

// Length of the list.
func (t *PNPCodeListType) Len() int {
  if t.PNPCode == nil {
    t = t.AddNew()
    }
        return len(t.PNPCode)
}

// Convert list object to slice
func (t *PNPCodeListType) ToSlice() []*AUCodeSetsPNPCodeType {
  ret := make([]*AUCodeSetsPNPCodeType, 0)
  for _, x:= range t.PNPCode {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *PNPCodeListType) AppendString(value string) *PNPCodeListType {
        return t.Append((AUCodeSetsPNPCodeType)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PasswordListType) Append(values ...PasswordListType_Password) *PasswordListType {
    
        if t == nil {
                t, _ = PasswordListTypePointer(PasswordListType{})
        }
        if t.Password == nil {
                t.Password = make([]PasswordListType_Password, 0)
        }
        for _, value := range values {
        t.Password = append(t.Password, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PasswordListType) AddNew() *PasswordListType {
        if t == nil {
                t, _ = PasswordListTypePointer(PasswordListType{})
        }
        if t.Password == nil {
                t.Password = make([]PasswordListType_Password, 0)
        }
        t.Password = append(t.Password, PasswordListType_Password{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PasswordListType) Last() *PasswordListType_Password {
  if t.Password == nil {
    t = t.AddNew()
    }
        return &(t.Password[len(t.Password)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PasswordListType) Index(n int) (*PasswordListType_Password) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PasswordListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Password == nil {
    t = t.AddNew()
    }
        return &(t.Password[n])
}

// Length of the list.
func (t *PasswordListType) Len() int {
  if t.Password == nil {
    t = t.AddNew()
    }
        return len(t.Password)
}

// Convert list object to slice
func (t *PasswordListType) ToSlice() []*PasswordListType_Password {
  ret := make([]*PasswordListType_Password, 0)
  for _, x:= range t.Password {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PaymentReceiptLineListType) Append(values ...PaymentReceiptLineType) *PaymentReceiptLineListType {
    
        if t == nil {
                t, _ = PaymentReceiptLineListTypePointer(PaymentReceiptLineListType{})
        }
        if t.PaymentReceiptLine == nil {
                t.PaymentReceiptLine = make([]PaymentReceiptLineType, 0)
        }
        for _, value := range values {
        t.PaymentReceiptLine = append(t.PaymentReceiptLine, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PaymentReceiptLineListType) AddNew() *PaymentReceiptLineListType {
        if t == nil {
                t, _ = PaymentReceiptLineListTypePointer(PaymentReceiptLineListType{})
        }
        if t.PaymentReceiptLine == nil {
                t.PaymentReceiptLine = make([]PaymentReceiptLineType, 0)
        }
        t.PaymentReceiptLine = append(t.PaymentReceiptLine, PaymentReceiptLineType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PaymentReceiptLineListType) Last() *PaymentReceiptLineType {
  if t.PaymentReceiptLine == nil {
    t = t.AddNew()
    }
        return &(t.PaymentReceiptLine[len(t.PaymentReceiptLine)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PaymentReceiptLineListType) Index(n int) (*PaymentReceiptLineType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PaymentReceiptLineListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PaymentReceiptLine == nil {
    t = t.AddNew()
    }
        return &(t.PaymentReceiptLine[n])
}

// Length of the list.
func (t *PaymentReceiptLineListType) Len() int {
  if t.PaymentReceiptLine == nil {
    t = t.AddNew()
    }
        return len(t.PaymentReceiptLine)
}

// Convert list object to slice
func (t *PaymentReceiptLineListType) ToSlice() []*PaymentReceiptLineType {
  ret := make([]*PaymentReceiptLineType, 0)
  for _, x:= range t.PaymentReceiptLine {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PeriodAttendancesType) Append(values ...PeriodAttendanceType) *PeriodAttendancesType {
    
        if t == nil {
                t, _ = PeriodAttendancesTypePointer(PeriodAttendancesType{})
        }
        if t.PeriodAttendance == nil {
                t.PeriodAttendance = make([]PeriodAttendanceType, 0)
        }
        for _, value := range values {
        t.PeriodAttendance = append(t.PeriodAttendance, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PeriodAttendancesType) AddNew() *PeriodAttendancesType {
        if t == nil {
                t, _ = PeriodAttendancesTypePointer(PeriodAttendancesType{})
        }
        if t.PeriodAttendance == nil {
                t.PeriodAttendance = make([]PeriodAttendanceType, 0)
        }
        t.PeriodAttendance = append(t.PeriodAttendance, PeriodAttendanceType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PeriodAttendancesType) Last() *PeriodAttendanceType {
  if t.PeriodAttendance == nil {
    t = t.AddNew()
    }
        return &(t.PeriodAttendance[len(t.PeriodAttendance)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PeriodAttendancesType) Index(n int) (*PeriodAttendanceType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PeriodAttendancesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PeriodAttendance == nil {
    t = t.AddNew()
    }
        return &(t.PeriodAttendance[n])
}

// Length of the list.
func (t *PeriodAttendancesType) Len() int {
  if t.PeriodAttendance == nil {
    t = t.AddNew()
    }
        return len(t.PeriodAttendance)
}

// Convert list object to slice
func (t *PeriodAttendancesType) ToSlice() []*PeriodAttendanceType {
  ret := make([]*PeriodAttendanceType, 0)
  for _, x:= range t.PeriodAttendance {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PermissionToParticipateListType) Append(values ...PermissionToParticipateType) *PermissionToParticipateListType {
    
        if t == nil {
                t, _ = PermissionToParticipateListTypePointer(PermissionToParticipateListType{})
        }
        if t.PermissionToParticipate == nil {
                t.PermissionToParticipate = make([]PermissionToParticipateType, 0)
        }
        for _, value := range values {
        t.PermissionToParticipate = append(t.PermissionToParticipate, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PermissionToParticipateListType) AddNew() *PermissionToParticipateListType {
        if t == nil {
                t, _ = PermissionToParticipateListTypePointer(PermissionToParticipateListType{})
        }
        if t.PermissionToParticipate == nil {
                t.PermissionToParticipate = make([]PermissionToParticipateType, 0)
        }
        t.PermissionToParticipate = append(t.PermissionToParticipate, PermissionToParticipateType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PermissionToParticipateListType) Last() *PermissionToParticipateType {
  if t.PermissionToParticipate == nil {
    t = t.AddNew()
    }
        return &(t.PermissionToParticipate[len(t.PermissionToParticipate)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PermissionToParticipateListType) Index(n int) (*PermissionToParticipateType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PermissionToParticipateListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PermissionToParticipate == nil {
    t = t.AddNew()
    }
        return &(t.PermissionToParticipate[n])
}

// Length of the list.
func (t *PermissionToParticipateListType) Len() int {
  if t.PermissionToParticipate == nil {
    t = t.AddNew()
    }
        return len(t.PermissionToParticipate)
}

// Convert list object to slice
func (t *PermissionToParticipateListType) ToSlice() []*PermissionToParticipateType {
  ret := make([]*PermissionToParticipateType, 0)
  for _, x:= range t.PermissionToParticipate {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PersonInvolvementListType) Append(values ...PersonInvolvementType) *PersonInvolvementListType {
    
        if t == nil {
                t, _ = PersonInvolvementListTypePointer(PersonInvolvementListType{})
        }
        if t.PersonInvolvement == nil {
                t.PersonInvolvement = make([]PersonInvolvementType, 0)
        }
        for _, value := range values {
        t.PersonInvolvement = append(t.PersonInvolvement, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PersonInvolvementListType) AddNew() *PersonInvolvementListType {
        if t == nil {
                t, _ = PersonInvolvementListTypePointer(PersonInvolvementListType{})
        }
        if t.PersonInvolvement == nil {
                t.PersonInvolvement = make([]PersonInvolvementType, 0)
        }
        t.PersonInvolvement = append(t.PersonInvolvement, PersonInvolvementType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PersonInvolvementListType) Last() *PersonInvolvementType {
  if t.PersonInvolvement == nil {
    t = t.AddNew()
    }
        return &(t.PersonInvolvement[len(t.PersonInvolvement)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PersonInvolvementListType) Index(n int) (*PersonInvolvementType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PersonInvolvementListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PersonInvolvement == nil {
    t = t.AddNew()
    }
        return &(t.PersonInvolvement[n])
}

// Length of the list.
func (t *PersonInvolvementListType) Len() int {
  if t.PersonInvolvement == nil {
    t = t.AddNew()
    }
        return len(t.PersonInvolvement)
}

// Convert list object to slice
func (t *PersonInvolvementListType) ToSlice() []*PersonInvolvementType {
  ret := make([]*PersonInvolvementType, 0)
  for _, x:= range t.PersonInvolvement {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PhoneNumberListType) Append(values ...PhoneNumberType) *PhoneNumberListType {
    
        if t == nil {
                t, _ = PhoneNumberListTypePointer(PhoneNumberListType{})
        }
        if t.PhoneNumber == nil {
                t.PhoneNumber = make([]PhoneNumberType, 0)
        }
        for _, value := range values {
        t.PhoneNumber = append(t.PhoneNumber, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PhoneNumberListType) AddNew() *PhoneNumberListType {
        if t == nil {
                t, _ = PhoneNumberListTypePointer(PhoneNumberListType{})
        }
        if t.PhoneNumber == nil {
                t.PhoneNumber = make([]PhoneNumberType, 0)
        }
        t.PhoneNumber = append(t.PhoneNumber, PhoneNumberType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PhoneNumberListType) Last() *PhoneNumberType {
  if t.PhoneNumber == nil {
    t = t.AddNew()
    }
        return &(t.PhoneNumber[len(t.PhoneNumber)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PhoneNumberListType) Index(n int) (*PhoneNumberType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PhoneNumberListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PhoneNumber == nil {
    t = t.AddNew()
    }
        return &(t.PhoneNumber[n])
}

// Length of the list.
func (t *PhoneNumberListType) Len() int {
  if t.PhoneNumber == nil {
    t = t.AddNew()
    }
        return len(t.PhoneNumber)
}

// Convert list object to slice
func (t *PhoneNumberListType) ToSlice() []*PhoneNumberType {
  ret := make([]*PhoneNumberType, 0)
  for _, x:= range t.PhoneNumber {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PlanRequiredListType) Append(values ...WellbeingPlanType) *PlanRequiredListType {
    
        if t == nil {
                t, _ = PlanRequiredListTypePointer(PlanRequiredListType{})
        }
        if t.Plan == nil {
                t.Plan = make([]WellbeingPlanType, 0)
        }
        for _, value := range values {
        t.Plan = append(t.Plan, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PlanRequiredListType) AddNew() *PlanRequiredListType {
        if t == nil {
                t, _ = PlanRequiredListTypePointer(PlanRequiredListType{})
        }
        if t.Plan == nil {
                t.Plan = make([]WellbeingPlanType, 0)
        }
        t.Plan = append(t.Plan, WellbeingPlanType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PlanRequiredListType) Last() *WellbeingPlanType {
  if t.Plan == nil {
    t = t.AddNew()
    }
        return &(t.Plan[len(t.Plan)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PlanRequiredListType) Index(n int) (*WellbeingPlanType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PlanRequiredListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Plan == nil {
    t = t.AddNew()
    }
        return &(t.Plan[n])
}

// Length of the list.
func (t *PlanRequiredListType) Len() int {
  if t.Plan == nil {
    t = t.AddNew()
    }
        return len(t.Plan)
}

// Convert list object to slice
func (t *PlanRequiredListType) ToSlice() []*WellbeingPlanType {
  ret := make([]*WellbeingPlanType, 0)
  for _, x:= range t.Plan {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PlausibleScaledValueListType) Append(values ...float64) *PlausibleScaledValueListType {
    
        if t == nil {
                t, _ = PlausibleScaledValueListTypePointer(PlausibleScaledValueListType{})
        }
        if t.PlausibleScaledValue == nil {
                t.PlausibleScaledValue = make([]float64, 0)
        }
        for _, value := range values {
        t.PlausibleScaledValue = append(t.PlausibleScaledValue, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PlausibleScaledValueListType) AddNew() *PlausibleScaledValueListType {
        if t == nil {
                t, _ = PlausibleScaledValueListTypePointer(PlausibleScaledValueListType{})
        }
        if t.PlausibleScaledValue == nil {
                t.PlausibleScaledValue = make([]float64, 0)
        }
        t.PlausibleScaledValue = append(t.PlausibleScaledValue, 0)
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PlausibleScaledValueListType) Last() *float64 {
  if t.PlausibleScaledValue == nil {
    t = t.AddNew()
    }
        return &(t.PlausibleScaledValue[len(t.PlausibleScaledValue)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PlausibleScaledValueListType) Index(n int) (*float64) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PlausibleScaledValueListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PlausibleScaledValue == nil {
    t = t.AddNew()
    }
        return &(t.PlausibleScaledValue[n])
}

// Length of the list.
func (t *PlausibleScaledValueListType) Len() int {
  if t.PlausibleScaledValue == nil {
    t = t.AddNew()
    }
        return len(t.PlausibleScaledValue)
}

// Convert list object to slice
func (t *PlausibleScaledValueListType) ToSlice() []*float64 {
  ret := make([]*float64, 0)
  for _, x:= range t.PlausibleScaledValue {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PrerequisitesType) Append(values ...string) *PrerequisitesType {
    
        if t == nil {
                t, _ = PrerequisitesTypePointer(PrerequisitesType{})
        }
        if t.Prerequisite == nil {
                t.Prerequisite = make([]string, 0)
        }
        for _, value := range values {
        t.Prerequisite = append(t.Prerequisite, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PrerequisitesType) AddNew() *PrerequisitesType {
        if t == nil {
                t, _ = PrerequisitesTypePointer(PrerequisitesType{})
        }
        if t.Prerequisite == nil {
                t.Prerequisite = make([]string, 0)
        }
        t.Prerequisite = append(t.Prerequisite, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PrerequisitesType) Last() *string {
  if t.Prerequisite == nil {
    t = t.AddNew()
    }
        return &(t.Prerequisite[len(t.Prerequisite)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PrerequisitesType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PrerequisitesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Prerequisite == nil {
    t = t.AddNew()
    }
        return &(t.Prerequisite[n])
}

// Length of the list.
func (t *PrerequisitesType) Len() int {
  if t.Prerequisite == nil {
    t = t.AddNew()
    }
        return len(t.Prerequisite)
}

// Convert list object to slice
func (t *PrerequisitesType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.Prerequisite {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *PrerequisitesType) AppendString(value string) *PrerequisitesType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PreviousSchoolListType) Append(values ...PreviousSchoolType) *PreviousSchoolListType {
    
        if t == nil {
                t, _ = PreviousSchoolListTypePointer(PreviousSchoolListType{})
        }
        if t.PreviousSchool == nil {
                t.PreviousSchool = make([]PreviousSchoolType, 0)
        }
        for _, value := range values {
        t.PreviousSchool = append(t.PreviousSchool, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PreviousSchoolListType) AddNew() *PreviousSchoolListType {
        if t == nil {
                t, _ = PreviousSchoolListTypePointer(PreviousSchoolListType{})
        }
        if t.PreviousSchool == nil {
                t.PreviousSchool = make([]PreviousSchoolType, 0)
        }
        t.PreviousSchool = append(t.PreviousSchool, PreviousSchoolType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PreviousSchoolListType) Last() *PreviousSchoolType {
  if t.PreviousSchool == nil {
    t = t.AddNew()
    }
        return &(t.PreviousSchool[len(t.PreviousSchool)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PreviousSchoolListType) Index(n int) (*PreviousSchoolType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PreviousSchoolListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PreviousSchool == nil {
    t = t.AddNew()
    }
        return &(t.PreviousSchool[n])
}

// Length of the list.
func (t *PreviousSchoolListType) Len() int {
  if t.PreviousSchool == nil {
    t = t.AddNew()
    }
        return len(t.PreviousSchool)
}

// Convert list object to slice
func (t *PreviousSchoolListType) ToSlice() []*PreviousSchoolType {
  ret := make([]*PreviousSchoolType, 0)
  for _, x:= range t.PreviousSchool {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ProgramFundingSourcesType) Append(values ...ProgramFundingSourceType) *ProgramFundingSourcesType {
    
        if t == nil {
                t, _ = ProgramFundingSourcesTypePointer(ProgramFundingSourcesType{})
        }
        if t.ProgramFundingSource == nil {
                t.ProgramFundingSource = make([]ProgramFundingSourceType, 0)
        }
        for _, value := range values {
        t.ProgramFundingSource = append(t.ProgramFundingSource, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ProgramFundingSourcesType) AddNew() *ProgramFundingSourcesType {
        if t == nil {
                t, _ = ProgramFundingSourcesTypePointer(ProgramFundingSourcesType{})
        }
        if t.ProgramFundingSource == nil {
                t.ProgramFundingSource = make([]ProgramFundingSourceType, 0)
        }
        t.ProgramFundingSource = append(t.ProgramFundingSource, ProgramFundingSourceType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ProgramFundingSourcesType) Last() *ProgramFundingSourceType {
  if t.ProgramFundingSource == nil {
    t = t.AddNew()
    }
        return &(t.ProgramFundingSource[len(t.ProgramFundingSource)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ProgramFundingSourcesType) Index(n int) (*ProgramFundingSourceType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ProgramFundingSourcesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ProgramFundingSource == nil {
    t = t.AddNew()
    }
        return &(t.ProgramFundingSource[n])
}

// Length of the list.
func (t *ProgramFundingSourcesType) Len() int {
  if t.ProgramFundingSource == nil {
    t = t.AddNew()
    }
        return len(t.ProgramFundingSource)
}

// Convert list object to slice
func (t *ProgramFundingSourcesType) ToSlice() []*ProgramFundingSourceType {
  ret := make([]*ProgramFundingSourceType, 0)
  for _, x:= range t.ProgramFundingSource {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PublishingPermissionListType) Append(values ...PublishingPermissionType) *PublishingPermissionListType {
    
        if t == nil {
                t, _ = PublishingPermissionListTypePointer(PublishingPermissionListType{})
        }
        if t.PublishingPermission == nil {
                t.PublishingPermission = make([]PublishingPermissionType, 0)
        }
        for _, value := range values {
        t.PublishingPermission = append(t.PublishingPermission, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PublishingPermissionListType) AddNew() *PublishingPermissionListType {
        if t == nil {
                t, _ = PublishingPermissionListTypePointer(PublishingPermissionListType{})
        }
        if t.PublishingPermission == nil {
                t.PublishingPermission = make([]PublishingPermissionType, 0)
        }
        t.PublishingPermission = append(t.PublishingPermission, PublishingPermissionType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PublishingPermissionListType) Last() *PublishingPermissionType {
  if t.PublishingPermission == nil {
    t = t.AddNew()
    }
        return &(t.PublishingPermission[len(t.PublishingPermission)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PublishingPermissionListType) Index(n int) (*PublishingPermissionType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PublishingPermissionListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PublishingPermission == nil {
    t = t.AddNew()
    }
        return &(t.PublishingPermission[n])
}

// Length of the list.
func (t *PublishingPermissionListType) Len() int {
  if t.PublishingPermission == nil {
    t = t.AddNew()
    }
        return len(t.PublishingPermission)
}

// Convert list object to slice
func (t *PublishingPermissionListType) ToSlice() []*PublishingPermissionType {
  ret := make([]*PublishingPermissionType, 0)
  for _, x:= range t.PublishingPermission {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PurchasingItemsType) Append(values ...PurchasingItemType) *PurchasingItemsType {
    
        if t == nil {
                t, _ = PurchasingItemsTypePointer(PurchasingItemsType{})
        }
        if t.PurchasingItem == nil {
                t.PurchasingItem = make([]PurchasingItemType, 0)
        }
        for _, value := range values {
        t.PurchasingItem = append(t.PurchasingItem, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PurchasingItemsType) AddNew() *PurchasingItemsType {
        if t == nil {
                t, _ = PurchasingItemsTypePointer(PurchasingItemsType{})
        }
        if t.PurchasingItem == nil {
                t.PurchasingItem = make([]PurchasingItemType, 0)
        }
        t.PurchasingItem = append(t.PurchasingItem, PurchasingItemType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PurchasingItemsType) Last() *PurchasingItemType {
  if t.PurchasingItem == nil {
    t = t.AddNew()
    }
        return &(t.PurchasingItem[len(t.PurchasingItem)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *PurchasingItemsType) Index(n int) (*PurchasingItemType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PurchasingItemsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.PurchasingItem == nil {
    t = t.AddNew()
    }
        return &(t.PurchasingItem[n])
}

// Length of the list.
func (t *PurchasingItemsType) Len() int {
  if t.PurchasingItem == nil {
    t = t.AddNew()
    }
        return len(t.PurchasingItem)
}

// Convert list object to slice
func (t *PurchasingItemsType) ToSlice() []*PurchasingItemType {
  ret := make([]*PurchasingItemType, 0)
  for _, x:= range t.PurchasingItem {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *RecognitionListType) Append(values ...string) *RecognitionListType {
    
        if t == nil {
                t, _ = RecognitionListTypePointer(RecognitionListType{})
        }
        if t.Recognition == nil {
                t.Recognition = make([]string, 0)
        }
        for _, value := range values {
        t.Recognition = append(t.Recognition, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *RecognitionListType) AddNew() *RecognitionListType {
        if t == nil {
                t, _ = RecognitionListTypePointer(RecognitionListType{})
        }
        if t.Recognition == nil {
                t.Recognition = make([]string, 0)
        }
        t.Recognition = append(t.Recognition, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *RecognitionListType) Last() *string {
  if t.Recognition == nil {
    t = t.AddNew()
    }
        return &(t.Recognition[len(t.Recognition)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *RecognitionListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("RecognitionListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Recognition == nil {
    t = t.AddNew()
    }
        return &(t.Recognition[n])
}

// Length of the list.
func (t *RecognitionListType) Len() int {
  if t.Recognition == nil {
    t = t.AddNew()
    }
        return len(t.Recognition)
}

// Convert list object to slice
func (t *RecognitionListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.Recognition {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *RecognitionListType) AppendString(value string) *RecognitionListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *RelatedLearningStandardItemRefIdListType) Append(values ...RelatedLearningStandardItemRefIdType) *RelatedLearningStandardItemRefIdListType {
    
        if t == nil {
                t, _ = RelatedLearningStandardItemRefIdListTypePointer(RelatedLearningStandardItemRefIdListType{})
        }
        if t.LearningStandardItemRefId == nil {
                t.LearningStandardItemRefId = make([]RelatedLearningStandardItemRefIdType, 0)
        }
        for _, value := range values {
        t.LearningStandardItemRefId = append(t.LearningStandardItemRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *RelatedLearningStandardItemRefIdListType) AddNew() *RelatedLearningStandardItemRefIdListType {
        if t == nil {
                t, _ = RelatedLearningStandardItemRefIdListTypePointer(RelatedLearningStandardItemRefIdListType{})
        }
        if t.LearningStandardItemRefId == nil {
                t.LearningStandardItemRefId = make([]RelatedLearningStandardItemRefIdType, 0)
        }
        t.LearningStandardItemRefId = append(t.LearningStandardItemRefId, RelatedLearningStandardItemRefIdType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *RelatedLearningStandardItemRefIdListType) Last() *RelatedLearningStandardItemRefIdType {
  if t.LearningStandardItemRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningStandardItemRefId[len(t.LearningStandardItemRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *RelatedLearningStandardItemRefIdListType) Index(n int) (*RelatedLearningStandardItemRefIdType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("RelatedLearningStandardItemRefIdListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.LearningStandardItemRefId == nil {
    t = t.AddNew()
    }
        return &(t.LearningStandardItemRefId[n])
}

// Length of the list.
func (t *RelatedLearningStandardItemRefIdListType) Len() int {
  if t.LearningStandardItemRefId == nil {
    t = t.AddNew()
    }
        return len(t.LearningStandardItemRefId)
}

// Convert list object to slice
func (t *RelatedLearningStandardItemRefIdListType) ToSlice() []*RelatedLearningStandardItemRefIdType {
  ret := make([]*RelatedLearningStandardItemRefIdType, 0)
  for _, x:= range t.LearningStandardItemRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ReligiousEventListType) Append(values ...ReligiousEventType) *ReligiousEventListType {
    
        if t == nil {
                t, _ = ReligiousEventListTypePointer(ReligiousEventListType{})
        }
        if t.ReligiousEvent == nil {
                t.ReligiousEvent = make([]ReligiousEventType, 0)
        }
        for _, value := range values {
        t.ReligiousEvent = append(t.ReligiousEvent, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ReligiousEventListType) AddNew() *ReligiousEventListType {
        if t == nil {
                t, _ = ReligiousEventListTypePointer(ReligiousEventListType{})
        }
        if t.ReligiousEvent == nil {
                t.ReligiousEvent = make([]ReligiousEventType, 0)
        }
        t.ReligiousEvent = append(t.ReligiousEvent, ReligiousEventType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ReligiousEventListType) Last() *ReligiousEventType {
  if t.ReligiousEvent == nil {
    t = t.AddNew()
    }
        return &(t.ReligiousEvent[len(t.ReligiousEvent)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ReligiousEventListType) Index(n int) (*ReligiousEventType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ReligiousEventListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ReligiousEvent == nil {
    t = t.AddNew()
    }
        return &(t.ReligiousEvent[n])
}

// Length of the list.
func (t *ReligiousEventListType) Len() int {
  if t.ReligiousEvent == nil {
    t = t.AddNew()
    }
        return len(t.ReligiousEvent)
}

// Convert list object to slice
func (t *ReligiousEventListType) ToSlice() []*ReligiousEventType {
  ret := make([]*ReligiousEventType, 0)
  for _, x:= range t.ReligiousEvent {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ReportingAuthorityListType) Append(values ...ReportingAuthorityType) *ReportingAuthorityListType {
    
        if t == nil {
                t, _ = ReportingAuthorityListTypePointer(ReportingAuthorityListType{})
        }
        if t.ReportingAuthority == nil {
                t.ReportingAuthority = make([]ReportingAuthorityType, 0)
        }
        for _, value := range values {
        t.ReportingAuthority = append(t.ReportingAuthority, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ReportingAuthorityListType) AddNew() *ReportingAuthorityListType {
        if t == nil {
                t, _ = ReportingAuthorityListTypePointer(ReportingAuthorityListType{})
        }
        if t.ReportingAuthority == nil {
                t.ReportingAuthority = make([]ReportingAuthorityType, 0)
        }
        t.ReportingAuthority = append(t.ReportingAuthority, ReportingAuthorityType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ReportingAuthorityListType) Last() *ReportingAuthorityType {
  if t.ReportingAuthority == nil {
    t = t.AddNew()
    }
        return &(t.ReportingAuthority[len(t.ReportingAuthority)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ReportingAuthorityListType) Index(n int) (*ReportingAuthorityType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ReportingAuthorityListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ReportingAuthority == nil {
    t = t.AddNew()
    }
        return &(t.ReportingAuthority[n])
}

// Length of the list.
func (t *ReportingAuthorityListType) Len() int {
  if t.ReportingAuthority == nil {
    t = t.AddNew()
    }
        return len(t.ReportingAuthority)
}

// Convert list object to slice
func (t *ReportingAuthorityListType) ToSlice() []*ReportingAuthorityType {
  ret := make([]*ReportingAuthorityType, 0)
  for _, x:= range t.ReportingAuthority {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *RoomListType) Append(values ...string) *RoomListType {
    
        if t == nil {
                t, _ = RoomListTypePointer(RoomListType{})
        }
        if t.RoomInfoRefId == nil {
                t.RoomInfoRefId = make([]string, 0)
        }
        for _, value := range values {
        t.RoomInfoRefId = append(t.RoomInfoRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *RoomListType) AddNew() *RoomListType {
        if t == nil {
                t, _ = RoomListTypePointer(RoomListType{})
        }
        if t.RoomInfoRefId == nil {
                t.RoomInfoRefId = make([]string, 0)
        }
        t.RoomInfoRefId = append(t.RoomInfoRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *RoomListType) Last() *string {
  if t.RoomInfoRefId == nil {
    t = t.AddNew()
    }
        return &(t.RoomInfoRefId[len(t.RoomInfoRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *RoomListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("RoomListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.RoomInfoRefId == nil {
    t = t.AddNew()
    }
        return &(t.RoomInfoRefId[n])
}

// Length of the list.
func (t *RoomListType) Len() int {
  if t.RoomInfoRefId == nil {
    t = t.AddNew()
    }
        return len(t.RoomInfoRefId)
}

// Convert list object to slice
func (t *RoomListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.RoomInfoRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *RoomListType) AppendString(value string) *RoomListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SIF_ExtendedElementsType) Append(values ...SIF_ExtendedElementsType_SIF_ExtendedElement) *SIF_ExtendedElementsType {
    
        if t == nil {
                t, _ = SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{})
        }
        if t.SIF_ExtendedElement == nil {
                t.SIF_ExtendedElement = make([]SIF_ExtendedElementsType_SIF_ExtendedElement, 0)
        }
        for _, value := range values {
        t.SIF_ExtendedElement = append(t.SIF_ExtendedElement, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SIF_ExtendedElementsType) AddNew() *SIF_ExtendedElementsType {
        if t == nil {
                t, _ = SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{})
        }
        if t.SIF_ExtendedElement == nil {
                t.SIF_ExtendedElement = make([]SIF_ExtendedElementsType_SIF_ExtendedElement, 0)
        }
        t.SIF_ExtendedElement = append(t.SIF_ExtendedElement, SIF_ExtendedElementsType_SIF_ExtendedElement{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SIF_ExtendedElementsType) Last() *SIF_ExtendedElementsType_SIF_ExtendedElement {
  if t.SIF_ExtendedElement == nil {
    t = t.AddNew()
    }
        return &(t.SIF_ExtendedElement[len(t.SIF_ExtendedElement)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SIF_ExtendedElementsType) Index(n int) (*SIF_ExtendedElementsType_SIF_ExtendedElement) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SIF_ExtendedElementsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SIF_ExtendedElement == nil {
    t = t.AddNew()
    }
        return &(t.SIF_ExtendedElement[n])
}

// Length of the list.
func (t *SIF_ExtendedElementsType) Len() int {
  if t.SIF_ExtendedElement == nil {
    t = t.AddNew()
    }
        return len(t.SIF_ExtendedElement)
}

// Convert list object to slice
func (t *SIF_ExtendedElementsType) ToSlice() []*SIF_ExtendedElementsType_SIF_ExtendedElement {
  ret := make([]*SIF_ExtendedElementsType_SIF_ExtendedElement, 0)
  for _, x:= range t.SIF_ExtendedElement {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *STDNAttachmentListType) Append(values ...STDNAttachmentType) *STDNAttachmentListType {
    
        if t == nil {
                t, _ = STDNAttachmentListTypePointer(STDNAttachmentListType{})
        }
        if t.STDNAttachment == nil {
                t.STDNAttachment = make([]STDNAttachmentType, 0)
        }
        for _, value := range values {
        t.STDNAttachment = append(t.STDNAttachment, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *STDNAttachmentListType) AddNew() *STDNAttachmentListType {
        if t == nil {
                t, _ = STDNAttachmentListTypePointer(STDNAttachmentListType{})
        }
        if t.STDNAttachment == nil {
                t.STDNAttachment = make([]STDNAttachmentType, 0)
        }
        t.STDNAttachment = append(t.STDNAttachment, STDNAttachmentType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *STDNAttachmentListType) Last() *STDNAttachmentType {
  if t.STDNAttachment == nil {
    t = t.AddNew()
    }
        return &(t.STDNAttachment[len(t.STDNAttachment)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *STDNAttachmentListType) Index(n int) (*STDNAttachmentType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("STDNAttachmentListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.STDNAttachment == nil {
    t = t.AddNew()
    }
        return &(t.STDNAttachment[n])
}

// Length of the list.
func (t *STDNAttachmentListType) Len() int {
  if t.STDNAttachment == nil {
    t = t.AddNew()
    }
        return len(t.STDNAttachment)
}

// Convert list object to slice
func (t *STDNAttachmentListType) ToSlice() []*STDNAttachmentType {
  ret := make([]*STDNAttachmentType, 0)
  for _, x:= range t.STDNAttachment {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *STDNGradeListType) Append(values ...STDNGradeType) *STDNGradeListType {
    
        if t == nil {
                t, _ = STDNGradeListTypePointer(STDNGradeListType{})
        }
        if t.StudentGrade == nil {
                t.StudentGrade = make([]STDNGradeType, 0)
        }
        for _, value := range values {
        t.StudentGrade = append(t.StudentGrade, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *STDNGradeListType) AddNew() *STDNGradeListType {
        if t == nil {
                t, _ = STDNGradeListTypePointer(STDNGradeListType{})
        }
        if t.StudentGrade == nil {
                t.StudentGrade = make([]STDNGradeType, 0)
        }
        t.StudentGrade = append(t.StudentGrade, STDNGradeType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *STDNGradeListType) Last() *STDNGradeType {
  if t.StudentGrade == nil {
    t = t.AddNew()
    }
        return &(t.StudentGrade[len(t.StudentGrade)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *STDNGradeListType) Index(n int) (*STDNGradeType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("STDNGradeListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StudentGrade == nil {
    t = t.AddNew()
    }
        return &(t.StudentGrade[n])
}

// Length of the list.
func (t *STDNGradeListType) Len() int {
  if t.StudentGrade == nil {
    t = t.AddNew()
    }
        return len(t.StudentGrade)
}

// Convert list object to slice
func (t *STDNGradeListType) ToSlice() []*STDNGradeType {
  ret := make([]*STDNGradeType, 0)
  for _, x:= range t.StudentGrade {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ScheduledTeacherListType) Append(values ...TeacherCoverType) *ScheduledTeacherListType {
    
        if t == nil {
                t, _ = ScheduledTeacherListTypePointer(ScheduledTeacherListType{})
        }
        if t.TeacherCover == nil {
                t.TeacherCover = make([]TeacherCoverType, 0)
        }
        for _, value := range values {
        t.TeacherCover = append(t.TeacherCover, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ScheduledTeacherListType) AddNew() *ScheduledTeacherListType {
        if t == nil {
                t, _ = ScheduledTeacherListTypePointer(ScheduledTeacherListType{})
        }
        if t.TeacherCover == nil {
                t.TeacherCover = make([]TeacherCoverType, 0)
        }
        t.TeacherCover = append(t.TeacherCover, TeacherCoverType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ScheduledTeacherListType) Last() *TeacherCoverType {
  if t.TeacherCover == nil {
    t = t.AddNew()
    }
        return &(t.TeacherCover[len(t.TeacherCover)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ScheduledTeacherListType) Index(n int) (*TeacherCoverType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ScheduledTeacherListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TeacherCover == nil {
    t = t.AddNew()
    }
        return &(t.TeacherCover[n])
}

// Length of the list.
func (t *ScheduledTeacherListType) Len() int {
  if t.TeacherCover == nil {
    t = t.AddNew()
    }
        return len(t.TeacherCover)
}

// Convert list object to slice
func (t *ScheduledTeacherListType) ToSlice() []*TeacherCoverType {
  ret := make([]*TeacherCoverType, 0)
  for _, x:= range t.TeacherCover {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SchoolContactListType) Append(values ...SchoolContactType) *SchoolContactListType {
    
        if t == nil {
                t, _ = SchoolContactListTypePointer(SchoolContactListType{})
        }
        if t.SchoolContact == nil {
                t.SchoolContact = make([]SchoolContactType, 0)
        }
        for _, value := range values {
        t.SchoolContact = append(t.SchoolContact, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SchoolContactListType) AddNew() *SchoolContactListType {
        if t == nil {
                t, _ = SchoolContactListTypePointer(SchoolContactListType{})
        }
        if t.SchoolContact == nil {
                t.SchoolContact = make([]SchoolContactType, 0)
        }
        t.SchoolContact = append(t.SchoolContact, SchoolContactType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SchoolContactListType) Last() *SchoolContactType {
  if t.SchoolContact == nil {
    t = t.AddNew()
    }
        return &(t.SchoolContact[len(t.SchoolContact)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SchoolContactListType) Index(n int) (*SchoolContactType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SchoolContactListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SchoolContact == nil {
    t = t.AddNew()
    }
        return &(t.SchoolContact[n])
}

// Length of the list.
func (t *SchoolContactListType) Len() int {
  if t.SchoolContact == nil {
    t = t.AddNew()
    }
        return len(t.SchoolContact)
}

// Convert list object to slice
func (t *SchoolContactListType) ToSlice() []*SchoolContactType {
  ret := make([]*SchoolContactType, 0)
  for _, x:= range t.SchoolContact {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SchoolFocusListType) Append(values ...AUCodeSetsSchoolFocusCodeType) *SchoolFocusListType {
    
        if t == nil {
                t, _ = SchoolFocusListTypePointer(SchoolFocusListType{})
        }
        if t.SchoolFocus == nil {
                t.SchoolFocus = make([]AUCodeSetsSchoolFocusCodeType, 0)
        }
        for _, value := range values {
        t.SchoolFocus = append(t.SchoolFocus, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SchoolFocusListType) AddNew() *SchoolFocusListType {
        if t == nil {
                t, _ = SchoolFocusListTypePointer(SchoolFocusListType{})
        }
        if t.SchoolFocus == nil {
                t.SchoolFocus = make([]AUCodeSetsSchoolFocusCodeType, 0)
        }
        t.SchoolFocus = append(t.SchoolFocus, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SchoolFocusListType) Last() *AUCodeSetsSchoolFocusCodeType {
  if t.SchoolFocus == nil {
    t = t.AddNew()
    }
        return &(t.SchoolFocus[len(t.SchoolFocus)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SchoolFocusListType) Index(n int) (*AUCodeSetsSchoolFocusCodeType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SchoolFocusListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SchoolFocus == nil {
    t = t.AddNew()
    }
        return &(t.SchoolFocus[n])
}

// Length of the list.
func (t *SchoolFocusListType) Len() int {
  if t.SchoolFocus == nil {
    t = t.AddNew()
    }
        return len(t.SchoolFocus)
}

// Convert list object to slice
func (t *SchoolFocusListType) ToSlice() []*AUCodeSetsSchoolFocusCodeType {
  ret := make([]*AUCodeSetsSchoolFocusCodeType, 0)
  for _, x:= range t.SchoolFocus {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *SchoolFocusListType) AppendString(value string) *SchoolFocusListType {
        return t.Append((AUCodeSetsSchoolFocusCodeType)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SchoolGroupListType) Append(values ...LocalIdType) *SchoolGroupListType {
    
        if t == nil {
                t, _ = SchoolGroupListTypePointer(SchoolGroupListType{})
        }
        if t.SchoolGroup == nil {
                t.SchoolGroup = make([]LocalIdType, 0)
        }
        for _, value := range values {
        t.SchoolGroup = append(t.SchoolGroup, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SchoolGroupListType) AddNew() *SchoolGroupListType {
        if t == nil {
                t, _ = SchoolGroupListTypePointer(SchoolGroupListType{})
        }
        if t.SchoolGroup == nil {
                t.SchoolGroup = make([]LocalIdType, 0)
        }
        t.SchoolGroup = append(t.SchoolGroup, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SchoolGroupListType) Last() *LocalIdType {
  if t.SchoolGroup == nil {
    t = t.AddNew()
    }
        return &(t.SchoolGroup[len(t.SchoolGroup)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SchoolGroupListType) Index(n int) (*LocalIdType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SchoolGroupListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SchoolGroup == nil {
    t = t.AddNew()
    }
        return &(t.SchoolGroup[n])
}

// Length of the list.
func (t *SchoolGroupListType) Len() int {
  if t.SchoolGroup == nil {
    t = t.AddNew()
    }
        return len(t.SchoolGroup)
}

// Convert list object to slice
func (t *SchoolGroupListType) ToSlice() []*LocalIdType {
  ret := make([]*LocalIdType, 0)
  for _, x:= range t.SchoolGroup {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *SchoolGroupListType) AppendString(value string) *SchoolGroupListType {
        return t.Append((LocalIdType)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SchoolProgramListType) Append(values ...SchoolProgramType) *SchoolProgramListType {
    
        if t == nil {
                t, _ = SchoolProgramListTypePointer(SchoolProgramListType{})
        }
        if t.Program == nil {
                t.Program = make([]SchoolProgramType, 0)
        }
        for _, value := range values {
        t.Program = append(t.Program, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SchoolProgramListType) AddNew() *SchoolProgramListType {
        if t == nil {
                t, _ = SchoolProgramListTypePointer(SchoolProgramListType{})
        }
        if t.Program == nil {
                t.Program = make([]SchoolProgramType, 0)
        }
        t.Program = append(t.Program, SchoolProgramType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SchoolProgramListType) Last() *SchoolProgramType {
  if t.Program == nil {
    t = t.AddNew()
    }
        return &(t.Program[len(t.Program)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SchoolProgramListType) Index(n int) (*SchoolProgramType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SchoolProgramListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Program == nil {
    t = t.AddNew()
    }
        return &(t.Program[n])
}

// Length of the list.
func (t *SchoolProgramListType) Len() int {
  if t.Program == nil {
    t = t.AddNew()
    }
        return len(t.Program)
}

// Convert list object to slice
func (t *SchoolProgramListType) ToSlice() []*SchoolProgramType {
  ret := make([]*SchoolProgramType, 0)
  for _, x:= range t.Program {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ScoreDescriptionListType) Append(values ...ScoreDescriptionType) *ScoreDescriptionListType {
    
        if t == nil {
                t, _ = ScoreDescriptionListTypePointer(ScoreDescriptionListType{})
        }
        if t.ScoreDescription == nil {
                t.ScoreDescription = make([]ScoreDescriptionType, 0)
        }
        for _, value := range values {
        t.ScoreDescription = append(t.ScoreDescription, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ScoreDescriptionListType) AddNew() *ScoreDescriptionListType {
        if t == nil {
                t, _ = ScoreDescriptionListTypePointer(ScoreDescriptionListType{})
        }
        if t.ScoreDescription == nil {
                t.ScoreDescription = make([]ScoreDescriptionType, 0)
        }
        t.ScoreDescription = append(t.ScoreDescription, ScoreDescriptionType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ScoreDescriptionListType) Last() *ScoreDescriptionType {
  if t.ScoreDescription == nil {
    t = t.AddNew()
    }
        return &(t.ScoreDescription[len(t.ScoreDescription)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ScoreDescriptionListType) Index(n int) (*ScoreDescriptionType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ScoreDescriptionListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ScoreDescription == nil {
    t = t.AddNew()
    }
        return &(t.ScoreDescription[n])
}

// Length of the list.
func (t *ScoreDescriptionListType) Len() int {
  if t.ScoreDescription == nil {
    t = t.AddNew()
    }
        return len(t.ScoreDescription)
}

// Convert list object to slice
func (t *ScoreDescriptionListType) ToSlice() []*ScoreDescriptionType {
  ret := make([]*ScoreDescriptionType, 0)
  for _, x:= range t.ScoreDescription {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ScoreListType) Append(values ...ScoreType) *ScoreListType {
    
        if t == nil {
                t, _ = ScoreListTypePointer(ScoreListType{})
        }
        if t.Score == nil {
                t.Score = make([]ScoreType, 0)
        }
        for _, value := range values {
        t.Score = append(t.Score, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ScoreListType) AddNew() *ScoreListType {
        if t == nil {
                t, _ = ScoreListTypePointer(ScoreListType{})
        }
        if t.Score == nil {
                t.Score = make([]ScoreType, 0)
        }
        t.Score = append(t.Score, ScoreType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ScoreListType) Last() *ScoreType {
  if t.Score == nil {
    t = t.AddNew()
    }
        return &(t.Score[len(t.Score)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ScoreListType) Index(n int) (*ScoreType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ScoreListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Score == nil {
    t = t.AddNew()
    }
        return &(t.Score[n])
}

// Length of the list.
func (t *ScoreListType) Len() int {
  if t.Score == nil {
    t = t.AddNew()
    }
        return len(t.Score)
}

// Convert list object to slice
func (t *ScoreListType) ToSlice() []*ScoreType {
  ret := make([]*ScoreType, 0)
  for _, x:= range t.Score {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SettingLocationListType) Append(values ...SettingLocationType) *SettingLocationListType {
    
        if t == nil {
                t, _ = SettingLocationListTypePointer(SettingLocationListType{})
        }
        if t.SettingLocation == nil {
                t.SettingLocation = make([]SettingLocationType, 0)
        }
        for _, value := range values {
        t.SettingLocation = append(t.SettingLocation, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SettingLocationListType) AddNew() *SettingLocationListType {
        if t == nil {
                t, _ = SettingLocationListTypePointer(SettingLocationListType{})
        }
        if t.SettingLocation == nil {
                t.SettingLocation = make([]SettingLocationType, 0)
        }
        t.SettingLocation = append(t.SettingLocation, SettingLocationType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SettingLocationListType) Last() *SettingLocationType {
  if t.SettingLocation == nil {
    t = t.AddNew()
    }
        return &(t.SettingLocation[len(t.SettingLocation)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SettingLocationListType) Index(n int) (*SettingLocationType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SettingLocationListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SettingLocation == nil {
    t = t.AddNew()
    }
        return &(t.SettingLocation[n])
}

// Length of the list.
func (t *SettingLocationListType) Len() int {
  if t.SettingLocation == nil {
    t = t.AddNew()
    }
        return len(t.SettingLocation)
}

// Convert list object to slice
func (t *SettingLocationListType) ToSlice() []*SettingLocationType {
  ret := make([]*SettingLocationType, 0)
  for _, x:= range t.SettingLocation {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ShareWithListType) Append(values ...ShareWithType) *ShareWithListType {
    
        if t == nil {
                t, _ = ShareWithListTypePointer(ShareWithListType{})
        }
        if t.ShareWith == nil {
                t.ShareWith = make([]ShareWithType, 0)
        }
        for _, value := range values {
        t.ShareWith = append(t.ShareWith, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ShareWithListType) AddNew() *ShareWithListType {
        if t == nil {
                t, _ = ShareWithListTypePointer(ShareWithListType{})
        }
        if t.ShareWith == nil {
                t.ShareWith = make([]ShareWithType, 0)
        }
        t.ShareWith = append(t.ShareWith, ShareWithType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ShareWithListType) Last() *ShareWithType {
  if t.ShareWith == nil {
    t = t.AddNew()
    }
        return &(t.ShareWith[len(t.ShareWith)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ShareWithListType) Index(n int) (*ShareWithType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ShareWithListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ShareWith == nil {
    t = t.AddNew()
    }
        return &(t.ShareWith[n])
}

// Length of the list.
func (t *ShareWithListType) Len() int {
  if t.ShareWith == nil {
    t = t.AddNew()
    }
        return len(t.ShareWith)
}

// Convert list object to slice
func (t *ShareWithListType) ToSlice() []*ShareWithType {
  ret := make([]*ShareWithType, 0)
  for _, x:= range t.ShareWith {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SoftwareRequirementListType) Append(values ...SoftwareRequirementType) *SoftwareRequirementListType {
    
        if t == nil {
                t, _ = SoftwareRequirementListTypePointer(SoftwareRequirementListType{})
        }
        if t.SoftwareRequirement == nil {
                t.SoftwareRequirement = make([]SoftwareRequirementType, 0)
        }
        for _, value := range values {
        t.SoftwareRequirement = append(t.SoftwareRequirement, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SoftwareRequirementListType) AddNew() *SoftwareRequirementListType {
        if t == nil {
                t, _ = SoftwareRequirementListTypePointer(SoftwareRequirementListType{})
        }
        if t.SoftwareRequirement == nil {
                t.SoftwareRequirement = make([]SoftwareRequirementType, 0)
        }
        t.SoftwareRequirement = append(t.SoftwareRequirement, SoftwareRequirementType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SoftwareRequirementListType) Last() *SoftwareRequirementType {
  if t.SoftwareRequirement == nil {
    t = t.AddNew()
    }
        return &(t.SoftwareRequirement[len(t.SoftwareRequirement)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SoftwareRequirementListType) Index(n int) (*SoftwareRequirementType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SoftwareRequirementListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SoftwareRequirement == nil {
    t = t.AddNew()
    }
        return &(t.SoftwareRequirement[n])
}

// Length of the list.
func (t *SoftwareRequirementListType) Len() int {
  if t.SoftwareRequirement == nil {
    t = t.AddNew()
    }
        return len(t.SoftwareRequirement)
}

// Convert list object to slice
func (t *SoftwareRequirementListType) ToSlice() []*SoftwareRequirementType {
  ret := make([]*SoftwareRequirementType, 0)
  for _, x:= range t.SoftwareRequirement {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SourceObjectsType) Append(values ...SourceObjectsType_SourceObject) *SourceObjectsType {
    
        if t == nil {
                t, _ = SourceObjectsTypePointer(SourceObjectsType{})
        }
        if t.SourceObject == nil {
                t.SourceObject = make([]SourceObjectsType_SourceObject, 0)
        }
        for _, value := range values {
        t.SourceObject = append(t.SourceObject, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SourceObjectsType) AddNew() *SourceObjectsType {
        if t == nil {
                t, _ = SourceObjectsTypePointer(SourceObjectsType{})
        }
        if t.SourceObject == nil {
                t.SourceObject = make([]SourceObjectsType_SourceObject, 0)
        }
        t.SourceObject = append(t.SourceObject, SourceObjectsType_SourceObject{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SourceObjectsType) Last() *SourceObjectsType_SourceObject {
  if t.SourceObject == nil {
    t = t.AddNew()
    }
        return &(t.SourceObject[len(t.SourceObject)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SourceObjectsType) Index(n int) (*SourceObjectsType_SourceObject) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SourceObjectsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SourceObject == nil {
    t = t.AddNew()
    }
        return &(t.SourceObject[n])
}

// Length of the list.
func (t *SourceObjectsType) Len() int {
  if t.SourceObject == nil {
    t = t.AddNew()
    }
        return len(t.SourceObject)
}

// Convert list object to slice
func (t *SourceObjectsType) ToSlice() []*SourceObjectsType_SourceObject {
  ret := make([]*SourceObjectsType_SourceObject, 0)
  for _, x:= range t.SourceObject {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SpanGapListType) Append(values ...SpanGapType) *SpanGapListType {
    
        if t == nil {
                t, _ = SpanGapListTypePointer(SpanGapListType{})
        }
        if t.SpanGap == nil {
                t.SpanGap = make([]SpanGapType, 0)
        }
        for _, value := range values {
        t.SpanGap = append(t.SpanGap, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SpanGapListType) AddNew() *SpanGapListType {
        if t == nil {
                t, _ = SpanGapListTypePointer(SpanGapListType{})
        }
        if t.SpanGap == nil {
                t.SpanGap = make([]SpanGapType, 0)
        }
        t.SpanGap = append(t.SpanGap, SpanGapType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SpanGapListType) Last() *SpanGapType {
  if t.SpanGap == nil {
    t = t.AddNew()
    }
        return &(t.SpanGap[len(t.SpanGap)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SpanGapListType) Index(n int) (*SpanGapType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SpanGapListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SpanGap == nil {
    t = t.AddNew()
    }
        return &(t.SpanGap[n])
}

// Length of the list.
func (t *SpanGapListType) Len() int {
  if t.SpanGap == nil {
    t = t.AddNew()
    }
        return len(t.SpanGap)
}

// Convert list object to slice
func (t *SpanGapListType) ToSlice() []*SpanGapType {
  ret := make([]*SpanGapType, 0)
  for _, x:= range t.SpanGap {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StaffListType) Append(values ...string) *StaffListType {
    
        if t == nil {
                t, _ = StaffListTypePointer(StaffListType{})
        }
        if t.StaffPersonalRefId == nil {
                t.StaffPersonalRefId = make([]string, 0)
        }
        for _, value := range values {
        t.StaffPersonalRefId = append(t.StaffPersonalRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StaffListType) AddNew() *StaffListType {
        if t == nil {
                t, _ = StaffListTypePointer(StaffListType{})
        }
        if t.StaffPersonalRefId == nil {
                t.StaffPersonalRefId = make([]string, 0)
        }
        t.StaffPersonalRefId = append(t.StaffPersonalRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StaffListType) Last() *string {
  if t.StaffPersonalRefId == nil {
    t = t.AddNew()
    }
        return &(t.StaffPersonalRefId[len(t.StaffPersonalRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StaffListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StaffListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StaffPersonalRefId == nil {
    t = t.AddNew()
    }
        return &(t.StaffPersonalRefId[n])
}

// Length of the list.
func (t *StaffListType) Len() int {
  if t.StaffPersonalRefId == nil {
    t = t.AddNew()
    }
        return len(t.StaffPersonalRefId)
}

// Convert list object to slice
func (t *StaffListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.StaffPersonalRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *StaffListType) AppendString(value string) *StaffListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StaffSubjectListType) Append(values ...StaffSubjectType) *StaffSubjectListType {
    
        if t == nil {
                t, _ = StaffSubjectListTypePointer(StaffSubjectListType{})
        }
        if t.StaffSubject == nil {
                t.StaffSubject = make([]StaffSubjectType, 0)
        }
        for _, value := range values {
        t.StaffSubject = append(t.StaffSubject, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StaffSubjectListType) AddNew() *StaffSubjectListType {
        if t == nil {
                t, _ = StaffSubjectListTypePointer(StaffSubjectListType{})
        }
        if t.StaffSubject == nil {
                t.StaffSubject = make([]StaffSubjectType, 0)
        }
        t.StaffSubject = append(t.StaffSubject, StaffSubjectType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StaffSubjectListType) Last() *StaffSubjectType {
  if t.StaffSubject == nil {
    t = t.AddNew()
    }
        return &(t.StaffSubject[len(t.StaffSubject)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StaffSubjectListType) Index(n int) (*StaffSubjectType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StaffSubjectListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StaffSubject == nil {
    t = t.AddNew()
    }
        return &(t.StaffSubject[n])
}

// Length of the list.
func (t *StaffSubjectListType) Len() int {
  if t.StaffSubject == nil {
    t = t.AddNew()
    }
        return len(t.StaffSubject)
}

// Convert list object to slice
func (t *StaffSubjectListType) ToSlice() []*StaffSubjectType {
  ret := make([]*StaffSubjectType, 0)
  for _, x:= range t.StaffSubject {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StatementCodesType) Append(values ...string) *StatementCodesType {
    
        if t == nil {
                t, _ = StatementCodesTypePointer(StatementCodesType{})
        }
        if t.StatementCode == nil {
                t.StatementCode = make([]string, 0)
        }
        for _, value := range values {
        t.StatementCode = append(t.StatementCode, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StatementCodesType) AddNew() *StatementCodesType {
        if t == nil {
                t, _ = StatementCodesTypePointer(StatementCodesType{})
        }
        if t.StatementCode == nil {
                t.StatementCode = make([]string, 0)
        }
        t.StatementCode = append(t.StatementCode, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StatementCodesType) Last() *string {
  if t.StatementCode == nil {
    t = t.AddNew()
    }
        return &(t.StatementCode[len(t.StatementCode)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StatementCodesType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StatementCodesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StatementCode == nil {
    t = t.AddNew()
    }
        return &(t.StatementCode[n])
}

// Length of the list.
func (t *StatementCodesType) Len() int {
  if t.StatementCode == nil {
    t = t.AddNew()
    }
        return len(t.StatementCode)
}

// Convert list object to slice
func (t *StatementCodesType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.StatementCode {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *StatementCodesType) AppendString(value string) *StatementCodesType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StatementsType) Append(values ...string) *StatementsType {
    
        if t == nil {
                t, _ = StatementsTypePointer(StatementsType{})
        }
        if t.Statement == nil {
                t.Statement = make([]string, 0)
        }
        for _, value := range values {
        t.Statement = append(t.Statement, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StatementsType) AddNew() *StatementsType {
        if t == nil {
                t, _ = StatementsTypePointer(StatementsType{})
        }
        if t.Statement == nil {
                t.Statement = make([]string, 0)
        }
        t.Statement = append(t.Statement, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StatementsType) Last() *string {
  if t.Statement == nil {
    t = t.AddNew()
    }
        return &(t.Statement[len(t.Statement)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StatementsType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StatementsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Statement == nil {
    t = t.AddNew()
    }
        return &(t.Statement[n])
}

// Length of the list.
func (t *StatementsType) Len() int {
  if t.Statement == nil {
    t = t.AddNew()
    }
        return len(t.Statement)
}

// Convert list object to slice
func (t *StatementsType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.Statement {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *StatementsType) AppendString(value string) *StatementsType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StatisticalAreasType) Append(values ...StatisticalAreaType) *StatisticalAreasType {
    
        if t == nil {
                t, _ = StatisticalAreasTypePointer(StatisticalAreasType{})
        }
        if t.StatisticalArea == nil {
                t.StatisticalArea = make([]StatisticalAreaType, 0)
        }
        for _, value := range values {
        t.StatisticalArea = append(t.StatisticalArea, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StatisticalAreasType) AddNew() *StatisticalAreasType {
        if t == nil {
                t, _ = StatisticalAreasTypePointer(StatisticalAreasType{})
        }
        if t.StatisticalArea == nil {
                t.StatisticalArea = make([]StatisticalAreaType, 0)
        }
        t.StatisticalArea = append(t.StatisticalArea, StatisticalAreaType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StatisticalAreasType) Last() *StatisticalAreaType {
  if t.StatisticalArea == nil {
    t = t.AddNew()
    }
        return &(t.StatisticalArea[len(t.StatisticalArea)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StatisticalAreasType) Index(n int) (*StatisticalAreaType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StatisticalAreasType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StatisticalArea == nil {
    t = t.AddNew()
    }
        return &(t.StatisticalArea[n])
}

// Length of the list.
func (t *StatisticalAreasType) Len() int {
  if t.StatisticalArea == nil {
    t = t.AddNew()
    }
        return len(t.StatisticalArea)
}

// Convert list object to slice
func (t *StatisticalAreasType) ToSlice() []*StatisticalAreaType {
  ret := make([]*StatisticalAreaType, 0)
  for _, x:= range t.StatisticalArea {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StatsCohortListType) Append(values ...StatsCohortType) *StatsCohortListType {
    
        if t == nil {
                t, _ = StatsCohortListTypePointer(StatsCohortListType{})
        }
        if t.StatsCohort == nil {
                t.StatsCohort = make([]StatsCohortType, 0)
        }
        for _, value := range values {
        t.StatsCohort = append(t.StatsCohort, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StatsCohortListType) AddNew() *StatsCohortListType {
        if t == nil {
                t, _ = StatsCohortListTypePointer(StatsCohortListType{})
        }
        if t.StatsCohort == nil {
                t.StatsCohort = make([]StatsCohortType, 0)
        }
        t.StatsCohort = append(t.StatsCohort, StatsCohortType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StatsCohortListType) Last() *StatsCohortType {
  if t.StatsCohort == nil {
    t = t.AddNew()
    }
        return &(t.StatsCohort[len(t.StatsCohort)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StatsCohortListType) Index(n int) (*StatsCohortType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StatsCohortListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StatsCohort == nil {
    t = t.AddNew()
    }
        return &(t.StatsCohort[n])
}

// Length of the list.
func (t *StatsCohortListType) Len() int {
  if t.StatsCohort == nil {
    t = t.AddNew()
    }
        return len(t.StatsCohort)
}

// Convert list object to slice
func (t *StatsCohortListType) ToSlice() []*StatsCohortType {
  ret := make([]*StatsCohortType, 0)
  for _, x:= range t.StatsCohort {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StatsCohortYearLevelListType) Append(values ...StatsCohortYearLevelType) *StatsCohortYearLevelListType {
    
        if t == nil {
                t, _ = StatsCohortYearLevelListTypePointer(StatsCohortYearLevelListType{})
        }
        if t.StatsCohortYearLevel == nil {
                t.StatsCohortYearLevel = make([]StatsCohortYearLevelType, 0)
        }
        for _, value := range values {
        t.StatsCohortYearLevel = append(t.StatsCohortYearLevel, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StatsCohortYearLevelListType) AddNew() *StatsCohortYearLevelListType {
        if t == nil {
                t, _ = StatsCohortYearLevelListTypePointer(StatsCohortYearLevelListType{})
        }
        if t.StatsCohortYearLevel == nil {
                t.StatsCohortYearLevel = make([]StatsCohortYearLevelType, 0)
        }
        t.StatsCohortYearLevel = append(t.StatsCohortYearLevel, StatsCohortYearLevelType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StatsCohortYearLevelListType) Last() *StatsCohortYearLevelType {
  if t.StatsCohortYearLevel == nil {
    t = t.AddNew()
    }
        return &(t.StatsCohortYearLevel[len(t.StatsCohortYearLevel)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StatsCohortYearLevelListType) Index(n int) (*StatsCohortYearLevelType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StatsCohortYearLevelListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StatsCohortYearLevel == nil {
    t = t.AddNew()
    }
        return &(t.StatsCohortYearLevel[n])
}

// Length of the list.
func (t *StatsCohortYearLevelListType) Len() int {
  if t.StatsCohortYearLevel == nil {
    t = t.AddNew()
    }
        return len(t.StatsCohortYearLevel)
}

// Convert list object to slice
func (t *StatsCohortYearLevelListType) ToSlice() []*StatsCohortYearLevelType {
  ret := make([]*StatsCohortYearLevelType, 0)
  for _, x:= range t.StatsCohortYearLevel {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StimulusListType) Append(values ...StimulusType) *StimulusListType {
    
        if t == nil {
                t, _ = StimulusListTypePointer(StimulusListType{})
        }
        if t.Stimulus == nil {
                t.Stimulus = make([]StimulusType, 0)
        }
        for _, value := range values {
        t.Stimulus = append(t.Stimulus, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StimulusListType) AddNew() *StimulusListType {
        if t == nil {
                t, _ = StimulusListTypePointer(StimulusListType{})
        }
        if t.Stimulus == nil {
                t.Stimulus = make([]StimulusType, 0)
        }
        t.Stimulus = append(t.Stimulus, StimulusType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StimulusListType) Last() *StimulusType {
  if t.Stimulus == nil {
    t = t.AddNew()
    }
        return &(t.Stimulus[len(t.Stimulus)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StimulusListType) Index(n int) (*StimulusType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StimulusListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Stimulus == nil {
    t = t.AddNew()
    }
        return &(t.Stimulus[n])
}

// Length of the list.
func (t *StimulusListType) Len() int {
  if t.Stimulus == nil {
    t = t.AddNew()
    }
        return len(t.Stimulus)
}

// Convert list object to slice
func (t *StimulusListType) ToSlice() []*StimulusType {
  ret := make([]*StimulusType, 0)
  for _, x:= range t.Stimulus {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StimulusLocalIdListType) Append(values ...LocalIdType) *StimulusLocalIdListType {
    
        if t == nil {
                t, _ = StimulusLocalIdListTypePointer(StimulusLocalIdListType{})
        }
        if t.StimulusLocalId == nil {
                t.StimulusLocalId = make([]LocalIdType, 0)
        }
        for _, value := range values {
        t.StimulusLocalId = append(t.StimulusLocalId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StimulusLocalIdListType) AddNew() *StimulusLocalIdListType {
        if t == nil {
                t, _ = StimulusLocalIdListTypePointer(StimulusLocalIdListType{})
        }
        if t.StimulusLocalId == nil {
                t.StimulusLocalId = make([]LocalIdType, 0)
        }
        t.StimulusLocalId = append(t.StimulusLocalId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StimulusLocalIdListType) Last() *LocalIdType {
  if t.StimulusLocalId == nil {
    t = t.AddNew()
    }
        return &(t.StimulusLocalId[len(t.StimulusLocalId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StimulusLocalIdListType) Index(n int) (*LocalIdType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StimulusLocalIdListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StimulusLocalId == nil {
    t = t.AddNew()
    }
        return &(t.StimulusLocalId[n])
}

// Length of the list.
func (t *StimulusLocalIdListType) Len() int {
  if t.StimulusLocalId == nil {
    t = t.AddNew()
    }
        return len(t.StimulusLocalId)
}

// Convert list object to slice
func (t *StimulusLocalIdListType) ToSlice() []*LocalIdType {
  ret := make([]*LocalIdType, 0)
  for _, x:= range t.StimulusLocalId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *StimulusLocalIdListType) AppendString(value string) *StimulusLocalIdListType {
        return t.Append((LocalIdType)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StrategiesType) Append(values ...string) *StrategiesType {
    
        if t == nil {
                t, _ = StrategiesTypePointer(StrategiesType{})
        }
        if t.Strategy == nil {
                t.Strategy = make([]string, 0)
        }
        for _, value := range values {
        t.Strategy = append(t.Strategy, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StrategiesType) AddNew() *StrategiesType {
        if t == nil {
                t, _ = StrategiesTypePointer(StrategiesType{})
        }
        if t.Strategy == nil {
                t.Strategy = make([]string, 0)
        }
        t.Strategy = append(t.Strategy, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StrategiesType) Last() *string {
  if t.Strategy == nil {
    t = t.AddNew()
    }
        return &(t.Strategy[len(t.Strategy)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StrategiesType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StrategiesType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Strategy == nil {
    t = t.AddNew()
    }
        return &(t.Strategy[n])
}

// Length of the list.
func (t *StrategiesType) Len() int {
  if t.Strategy == nil {
    t = t.AddNew()
    }
        return len(t.Strategy)
}

// Convert list object to slice
func (t *StrategiesType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.Strategy {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *StrategiesType) AppendString(value string) *StrategiesType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentAttendanceCollectionReportingListType) Append(values ...StudentAttendanceCollectionReportingType) *StudentAttendanceCollectionReportingListType {
    
        if t == nil {
                t, _ = StudentAttendanceCollectionReportingListTypePointer(StudentAttendanceCollectionReportingListType{})
        }
        if t.StudentAttendanceCollectionReporting == nil {
                t.StudentAttendanceCollectionReporting = make([]StudentAttendanceCollectionReportingType, 0)
        }
        for _, value := range values {
        t.StudentAttendanceCollectionReporting = append(t.StudentAttendanceCollectionReporting, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentAttendanceCollectionReportingListType) AddNew() *StudentAttendanceCollectionReportingListType {
        if t == nil {
                t, _ = StudentAttendanceCollectionReportingListTypePointer(StudentAttendanceCollectionReportingListType{})
        }
        if t.StudentAttendanceCollectionReporting == nil {
                t.StudentAttendanceCollectionReporting = make([]StudentAttendanceCollectionReportingType, 0)
        }
        t.StudentAttendanceCollectionReporting = append(t.StudentAttendanceCollectionReporting, StudentAttendanceCollectionReportingType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentAttendanceCollectionReportingListType) Last() *StudentAttendanceCollectionReportingType {
  if t.StudentAttendanceCollectionReporting == nil {
    t = t.AddNew()
    }
        return &(t.StudentAttendanceCollectionReporting[len(t.StudentAttendanceCollectionReporting)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StudentAttendanceCollectionReportingListType) Index(n int) (*StudentAttendanceCollectionReportingType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentAttendanceCollectionReportingListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StudentAttendanceCollectionReporting == nil {
    t = t.AddNew()
    }
        return &(t.StudentAttendanceCollectionReporting[n])
}

// Length of the list.
func (t *StudentAttendanceCollectionReportingListType) Len() int {
  if t.StudentAttendanceCollectionReporting == nil {
    t = t.AddNew()
    }
        return len(t.StudentAttendanceCollectionReporting)
}

// Convert list object to slice
func (t *StudentAttendanceCollectionReportingListType) ToSlice() []*StudentAttendanceCollectionReportingType {
  ret := make([]*StudentAttendanceCollectionReportingType, 0)
  for _, x:= range t.StudentAttendanceCollectionReporting {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentGradeMarkersListType) Append(values ...MarkerType) *StudentGradeMarkersListType {
    
        if t == nil {
                t, _ = StudentGradeMarkersListTypePointer(StudentGradeMarkersListType{})
        }
        if t.Marker == nil {
                t.Marker = make([]MarkerType, 0)
        }
        for _, value := range values {
        t.Marker = append(t.Marker, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentGradeMarkersListType) AddNew() *StudentGradeMarkersListType {
        if t == nil {
                t, _ = StudentGradeMarkersListTypePointer(StudentGradeMarkersListType{})
        }
        if t.Marker == nil {
                t.Marker = make([]MarkerType, 0)
        }
        t.Marker = append(t.Marker, MarkerType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentGradeMarkersListType) Last() *MarkerType {
  if t.Marker == nil {
    t = t.AddNew()
    }
        return &(t.Marker[len(t.Marker)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StudentGradeMarkersListType) Index(n int) (*MarkerType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentGradeMarkersListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Marker == nil {
    t = t.AddNew()
    }
        return &(t.Marker[n])
}

// Length of the list.
func (t *StudentGradeMarkersListType) Len() int {
  if t.Marker == nil {
    t = t.AddNew()
    }
        return len(t.Marker)
}

// Convert list object to slice
func (t *StudentGradeMarkersListType) ToSlice() []*MarkerType {
  ret := make([]*MarkerType, 0)
  for _, x:= range t.Marker {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentGroupListType) Append(values ...StudentGroupType) *StudentGroupListType {
    
        if t == nil {
                t, _ = StudentGroupListTypePointer(StudentGroupListType{})
        }
        if t.StudentGroup == nil {
                t.StudentGroup = make([]StudentGroupType, 0)
        }
        for _, value := range values {
        t.StudentGroup = append(t.StudentGroup, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentGroupListType) AddNew() *StudentGroupListType {
        if t == nil {
                t, _ = StudentGroupListTypePointer(StudentGroupListType{})
        }
        if t.StudentGroup == nil {
                t.StudentGroup = make([]StudentGroupType, 0)
        }
        t.StudentGroup = append(t.StudentGroup, StudentGroupType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentGroupListType) Last() *StudentGroupType {
  if t.StudentGroup == nil {
    t = t.AddNew()
    }
        return &(t.StudentGroup[len(t.StudentGroup)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StudentGroupListType) Index(n int) (*StudentGroupType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentGroupListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StudentGroup == nil {
    t = t.AddNew()
    }
        return &(t.StudentGroup[n])
}

// Length of the list.
func (t *StudentGroupListType) Len() int {
  if t.StudentGroup == nil {
    t = t.AddNew()
    }
        return len(t.StudentGroup)
}

// Convert list object to slice
func (t *StudentGroupListType) ToSlice() []*StudentGroupType {
  ret := make([]*StudentGroupType, 0)
  for _, x:= range t.StudentGroup {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentListType) Append(values ...TeachingGroupStudentType) *StudentListType {
    
        if t == nil {
                t, _ = StudentListTypePointer(StudentListType{})
        }
        if t.TeachingGroupStudent == nil {
                t.TeachingGroupStudent = make([]TeachingGroupStudentType, 0)
        }
        for _, value := range values {
        t.TeachingGroupStudent = append(t.TeachingGroupStudent, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentListType) AddNew() *StudentListType {
        if t == nil {
                t, _ = StudentListTypePointer(StudentListType{})
        }
        if t.TeachingGroupStudent == nil {
                t.TeachingGroupStudent = make([]TeachingGroupStudentType, 0)
        }
        t.TeachingGroupStudent = append(t.TeachingGroupStudent, TeachingGroupStudentType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentListType) Last() *TeachingGroupStudentType {
  if t.TeachingGroupStudent == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupStudent[len(t.TeachingGroupStudent)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StudentListType) Index(n int) (*TeachingGroupStudentType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TeachingGroupStudent == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupStudent[n])
}

// Length of the list.
func (t *StudentListType) Len() int {
  if t.TeachingGroupStudent == nil {
    t = t.AddNew()
    }
        return len(t.TeachingGroupStudent)
}

// Convert list object to slice
func (t *StudentListType) ToSlice() []*TeachingGroupStudentType {
  ret := make([]*TeachingGroupStudentType, 0)
  for _, x:= range t.TeachingGroupStudent {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentSubjectChoiceListType) Append(values ...StudentSubjectChoiceType) *StudentSubjectChoiceListType {
    
        if t == nil {
                t, _ = StudentSubjectChoiceListTypePointer(StudentSubjectChoiceListType{})
        }
        if t.StudentSubjectChoice == nil {
                t.StudentSubjectChoice = make([]StudentSubjectChoiceType, 0)
        }
        for _, value := range values {
        t.StudentSubjectChoice = append(t.StudentSubjectChoice, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentSubjectChoiceListType) AddNew() *StudentSubjectChoiceListType {
        if t == nil {
                t, _ = StudentSubjectChoiceListTypePointer(StudentSubjectChoiceListType{})
        }
        if t.StudentSubjectChoice == nil {
                t.StudentSubjectChoice = make([]StudentSubjectChoiceType, 0)
        }
        t.StudentSubjectChoice = append(t.StudentSubjectChoice, StudentSubjectChoiceType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentSubjectChoiceListType) Last() *StudentSubjectChoiceType {
  if t.StudentSubjectChoice == nil {
    t = t.AddNew()
    }
        return &(t.StudentSubjectChoice[len(t.StudentSubjectChoice)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StudentSubjectChoiceListType) Index(n int) (*StudentSubjectChoiceType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentSubjectChoiceListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StudentSubjectChoice == nil {
    t = t.AddNew()
    }
        return &(t.StudentSubjectChoice[n])
}

// Length of the list.
func (t *StudentSubjectChoiceListType) Len() int {
  if t.StudentSubjectChoice == nil {
    t = t.AddNew()
    }
        return len(t.StudentSubjectChoice)
}

// Convert list object to slice
func (t *StudentSubjectChoiceListType) ToSlice() []*StudentSubjectChoiceType {
  ret := make([]*StudentSubjectChoiceType, 0)
  for _, x:= range t.StudentSubjectChoice {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentsType) Append(values ...string) *StudentsType {
    
        if t == nil {
                t, _ = StudentsTypePointer(StudentsType{})
        }
        if t.StudentPersonalRefId == nil {
                t.StudentPersonalRefId = make([]string, 0)
        }
        for _, value := range values {
        t.StudentPersonalRefId = append(t.StudentPersonalRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentsType) AddNew() *StudentsType {
        if t == nil {
                t, _ = StudentsTypePointer(StudentsType{})
        }
        if t.StudentPersonalRefId == nil {
                t.StudentPersonalRefId = make([]string, 0)
        }
        t.StudentPersonalRefId = append(t.StudentPersonalRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentsType) Last() *string {
  if t.StudentPersonalRefId == nil {
    t = t.AddNew()
    }
        return &(t.StudentPersonalRefId[len(t.StudentPersonalRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *StudentsType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.StudentPersonalRefId == nil {
    t = t.AddNew()
    }
        return &(t.StudentPersonalRefId[n])
}

// Length of the list.
func (t *StudentsType) Len() int {
  if t.StudentPersonalRefId == nil {
    t = t.AddNew()
    }
        return len(t.StudentPersonalRefId)
}

// Convert list object to slice
func (t *StudentsType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.StudentPersonalRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *StudentsType) AppendString(value string) *StudentsType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SubjectAreaListType) Append(values ...SubjectAreaType) *SubjectAreaListType {
    
        if t == nil {
                t, _ = SubjectAreaListTypePointer(SubjectAreaListType{})
        }
        if t.SubjectArea == nil {
                t.SubjectArea = make([]SubjectAreaType, 0)
        }
        for _, value := range values {
        t.SubjectArea = append(t.SubjectArea, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SubjectAreaListType) AddNew() *SubjectAreaListType {
        if t == nil {
                t, _ = SubjectAreaListTypePointer(SubjectAreaListType{})
        }
        if t.SubjectArea == nil {
                t.SubjectArea = make([]SubjectAreaType, 0)
        }
        t.SubjectArea = append(t.SubjectArea, SubjectAreaType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SubjectAreaListType) Last() *SubjectAreaType {
  if t.SubjectArea == nil {
    t = t.AddNew()
    }
        return &(t.SubjectArea[len(t.SubjectArea)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SubjectAreaListType) Index(n int) (*SubjectAreaType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SubjectAreaListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SubjectArea == nil {
    t = t.AddNew()
    }
        return &(t.SubjectArea[n])
}

// Length of the list.
func (t *SubjectAreaListType) Len() int {
  if t.SubjectArea == nil {
    t = t.AddNew()
    }
        return len(t.SubjectArea)
}

// Convert list object to slice
func (t *SubjectAreaListType) ToSlice() []*SubjectAreaType {
  ret := make([]*SubjectAreaType, 0)
  for _, x:= range t.SubjectArea {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SubstituteItemListType) Append(values ...SubstituteItemType) *SubstituteItemListType {
    
        if t == nil {
                t, _ = SubstituteItemListTypePointer(SubstituteItemListType{})
        }
        if t.SubstituteItem == nil {
                t.SubstituteItem = make([]SubstituteItemType, 0)
        }
        for _, value := range values {
        t.SubstituteItem = append(t.SubstituteItem, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SubstituteItemListType) AddNew() *SubstituteItemListType {
        if t == nil {
                t, _ = SubstituteItemListTypePointer(SubstituteItemListType{})
        }
        if t.SubstituteItem == nil {
                t.SubstituteItem = make([]SubstituteItemType, 0)
        }
        t.SubstituteItem = append(t.SubstituteItem, SubstituteItemType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SubstituteItemListType) Last() *SubstituteItemType {
  if t.SubstituteItem == nil {
    t = t.AddNew()
    }
        return &(t.SubstituteItem[len(t.SubstituteItem)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SubstituteItemListType) Index(n int) (*SubstituteItemType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SubstituteItemListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.SubstituteItem == nil {
    t = t.AddNew()
    }
        return &(t.SubstituteItem[n])
}

// Length of the list.
func (t *SubstituteItemListType) Len() int {
  if t.SubstituteItem == nil {
    t = t.AddNew()
    }
        return len(t.SubstituteItem)
}

// Convert list object to slice
func (t *SubstituteItemListType) ToSlice() []*SubstituteItemType {
  ret := make([]*SubstituteItemType, 0)
  for _, x:= range t.SubstituteItem {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SymptomListType) Append(values ...string) *SymptomListType {
    
        if t == nil {
                t, _ = SymptomListTypePointer(SymptomListType{})
        }
        if t.Symptom == nil {
                t.Symptom = make([]string, 0)
        }
        for _, value := range values {
        t.Symptom = append(t.Symptom, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SymptomListType) AddNew() *SymptomListType {
        if t == nil {
                t, _ = SymptomListTypePointer(SymptomListType{})
        }
        if t.Symptom == nil {
                t.Symptom = make([]string, 0)
        }
        t.Symptom = append(t.Symptom, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SymptomListType) Last() *string {
  if t.Symptom == nil {
    t = t.AddNew()
    }
        return &(t.Symptom[len(t.Symptom)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *SymptomListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SymptomListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Symptom == nil {
    t = t.AddNew()
    }
        return &(t.Symptom[n])
}

// Length of the list.
func (t *SymptomListType) Len() int {
  if t.Symptom == nil {
    t = t.AddNew()
    }
        return len(t.Symptom)
}

// Convert list object to slice
func (t *SymptomListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.Symptom {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *SymptomListType) AppendString(value string) *SymptomListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TeacherListType) Append(values ...TeachingGroupTeacherType) *TeacherListType {
    
        if t == nil {
                t, _ = TeacherListTypePointer(TeacherListType{})
        }
        if t.TeachingGroupTeacher == nil {
                t.TeachingGroupTeacher = make([]TeachingGroupTeacherType, 0)
        }
        for _, value := range values {
        t.TeachingGroupTeacher = append(t.TeachingGroupTeacher, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TeacherListType) AddNew() *TeacherListType {
        if t == nil {
                t, _ = TeacherListTypePointer(TeacherListType{})
        }
        if t.TeachingGroupTeacher == nil {
                t.TeachingGroupTeacher = make([]TeachingGroupTeacherType, 0)
        }
        t.TeachingGroupTeacher = append(t.TeachingGroupTeacher, TeachingGroupTeacherType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TeacherListType) Last() *TeachingGroupTeacherType {
  if t.TeachingGroupTeacher == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupTeacher[len(t.TeachingGroupTeacher)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TeacherListType) Index(n int) (*TeachingGroupTeacherType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TeacherListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TeachingGroupTeacher == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupTeacher[n])
}

// Length of the list.
func (t *TeacherListType) Len() int {
  if t.TeachingGroupTeacher == nil {
    t = t.AddNew()
    }
        return len(t.TeachingGroupTeacher)
}

// Convert list object to slice
func (t *TeacherListType) ToSlice() []*TeachingGroupTeacherType {
  ret := make([]*TeachingGroupTeacherType, 0)
  for _, x:= range t.TeachingGroupTeacher {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TeachingGroupListType) Append(values ...string) *TeachingGroupListType {
    
        if t == nil {
                t, _ = TeachingGroupListTypePointer(TeachingGroupListType{})
        }
        if t.TeachingGroupRefId == nil {
                t.TeachingGroupRefId = make([]string, 0)
        }
        for _, value := range values {
        t.TeachingGroupRefId = append(t.TeachingGroupRefId, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TeachingGroupListType) AddNew() *TeachingGroupListType {
        if t == nil {
                t, _ = TeachingGroupListTypePointer(TeachingGroupListType{})
        }
        if t.TeachingGroupRefId == nil {
                t.TeachingGroupRefId = make([]string, 0)
        }
        t.TeachingGroupRefId = append(t.TeachingGroupRefId, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TeachingGroupListType) Last() *string {
  if t.TeachingGroupRefId == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupRefId[len(t.TeachingGroupRefId)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TeachingGroupListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TeachingGroupListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TeachingGroupRefId == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupRefId[n])
}

// Length of the list.
func (t *TeachingGroupListType) Len() int {
  if t.TeachingGroupRefId == nil {
    t = t.AddNew()
    }
        return len(t.TeachingGroupRefId)
}

// Convert list object to slice
func (t *TeachingGroupListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.TeachingGroupRefId {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *TeachingGroupListType) AppendString(value string) *TeachingGroupListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TeachingGroupPeriodListType) Append(values ...TeachingGroupPeriodType) *TeachingGroupPeriodListType {
    
        if t == nil {
                t, _ = TeachingGroupPeriodListTypePointer(TeachingGroupPeriodListType{})
        }
        if t.TeachingGroupPeriod == nil {
                t.TeachingGroupPeriod = make([]TeachingGroupPeriodType, 0)
        }
        for _, value := range values {
        t.TeachingGroupPeriod = append(t.TeachingGroupPeriod, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TeachingGroupPeriodListType) AddNew() *TeachingGroupPeriodListType {
        if t == nil {
                t, _ = TeachingGroupPeriodListTypePointer(TeachingGroupPeriodListType{})
        }
        if t.TeachingGroupPeriod == nil {
                t.TeachingGroupPeriod = make([]TeachingGroupPeriodType, 0)
        }
        t.TeachingGroupPeriod = append(t.TeachingGroupPeriod, TeachingGroupPeriodType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TeachingGroupPeriodListType) Last() *TeachingGroupPeriodType {
  if t.TeachingGroupPeriod == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupPeriod[len(t.TeachingGroupPeriod)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TeachingGroupPeriodListType) Index(n int) (*TeachingGroupPeriodType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TeachingGroupPeriodListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TeachingGroupPeriod == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupPeriod[n])
}

// Length of the list.
func (t *TeachingGroupPeriodListType) Len() int {
  if t.TeachingGroupPeriod == nil {
    t = t.AddNew()
    }
        return len(t.TeachingGroupPeriod)
}

// Convert list object to slice
func (t *TeachingGroupPeriodListType) ToSlice() []*TeachingGroupPeriodType {
  ret := make([]*TeachingGroupPeriodType, 0)
  for _, x:= range t.TeachingGroupPeriod {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TeachingGroupScheduleListType) Append(values ...TeachingGroupScheduleType) *TeachingGroupScheduleListType {
    
        if t == nil {
                t, _ = TeachingGroupScheduleListTypePointer(TeachingGroupScheduleListType{})
        }
        if t.TeachingGroupSchedule == nil {
                t.TeachingGroupSchedule = make([]TeachingGroupScheduleType, 0)
        }
        for _, value := range values {
        t.TeachingGroupSchedule = append(t.TeachingGroupSchedule, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TeachingGroupScheduleListType) AddNew() *TeachingGroupScheduleListType {
        if t == nil {
                t, _ = TeachingGroupScheduleListTypePointer(TeachingGroupScheduleListType{})
        }
        if t.TeachingGroupSchedule == nil {
                t.TeachingGroupSchedule = make([]TeachingGroupScheduleType, 0)
        }
        t.TeachingGroupSchedule = append(t.TeachingGroupSchedule, TeachingGroupScheduleType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TeachingGroupScheduleListType) Last() *TeachingGroupScheduleType {
  if t.TeachingGroupSchedule == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupSchedule[len(t.TeachingGroupSchedule)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TeachingGroupScheduleListType) Index(n int) (*TeachingGroupScheduleType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TeachingGroupScheduleListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TeachingGroupSchedule == nil {
    t = t.AddNew()
    }
        return &(t.TeachingGroupSchedule[n])
}

// Length of the list.
func (t *TeachingGroupScheduleListType) Len() int {
  if t.TeachingGroupSchedule == nil {
    t = t.AddNew()
    }
        return len(t.TeachingGroupSchedule)
}

// Convert list object to slice
func (t *TeachingGroupScheduleListType) ToSlice() []*TeachingGroupScheduleType {
  ret := make([]*TeachingGroupScheduleType, 0)
  for _, x:= range t.TeachingGroupSchedule {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TestDisruptionListType) Append(values ...TestDisruptionType) *TestDisruptionListType {
    
        if t == nil {
                t, _ = TestDisruptionListTypePointer(TestDisruptionListType{})
        }
        if t.TestDisruption == nil {
                t.TestDisruption = make([]TestDisruptionType, 0)
        }
        for _, value := range values {
        t.TestDisruption = append(t.TestDisruption, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TestDisruptionListType) AddNew() *TestDisruptionListType {
        if t == nil {
                t, _ = TestDisruptionListTypePointer(TestDisruptionListType{})
        }
        if t.TestDisruption == nil {
                t.TestDisruption = make([]TestDisruptionType, 0)
        }
        t.TestDisruption = append(t.TestDisruption, TestDisruptionType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TestDisruptionListType) Last() *TestDisruptionType {
  if t.TestDisruption == nil {
    t = t.AddNew()
    }
        return &(t.TestDisruption[len(t.TestDisruption)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TestDisruptionListType) Index(n int) (*TestDisruptionType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TestDisruptionListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TestDisruption == nil {
    t = t.AddNew()
    }
        return &(t.TestDisruption[n])
}

// Length of the list.
func (t *TestDisruptionListType) Len() int {
  if t.TestDisruption == nil {
    t = t.AddNew()
    }
        return len(t.TestDisruption)
}

// Convert list object to slice
func (t *TestDisruptionListType) ToSlice() []*TestDisruptionType {
  ret := make([]*TestDisruptionType, 0)
  for _, x:= range t.TestDisruption {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TimeElementListType) Append(values ...TimeElementType) *TimeElementListType {
    
        if t == nil {
                t, _ = TimeElementListTypePointer(TimeElementListType{})
        }
        if t.TimeElement == nil {
                t.TimeElement = make([]TimeElementType, 0)
        }
        for _, value := range values {
        t.TimeElement = append(t.TimeElement, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TimeElementListType) AddNew() *TimeElementListType {
        if t == nil {
                t, _ = TimeElementListTypePointer(TimeElementListType{})
        }
        if t.TimeElement == nil {
                t.TimeElement = make([]TimeElementType, 0)
        }
        t.TimeElement = append(t.TimeElement, TimeElementType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TimeElementListType) Last() *TimeElementType {
  if t.TimeElement == nil {
    t = t.AddNew()
    }
        return &(t.TimeElement[len(t.TimeElement)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TimeElementListType) Index(n int) (*TimeElementType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TimeElementListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TimeElement == nil {
    t = t.AddNew()
    }
        return &(t.TimeElement[n])
}

// Length of the list.
func (t *TimeElementListType) Len() int {
  if t.TimeElement == nil {
    t = t.AddNew()
    }
        return len(t.TimeElement)
}

// Convert list object to slice
func (t *TimeElementListType) ToSlice() []*TimeElementType {
  ret := make([]*TimeElementType, 0)
  for _, x:= range t.TimeElement {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TimeTableChangeReasonListType) Append(values ...TimeTableChangeReasonType) *TimeTableChangeReasonListType {
    
        if t == nil {
                t, _ = TimeTableChangeReasonListTypePointer(TimeTableChangeReasonListType{})
        }
        if t.TimeTableChangeReason == nil {
                t.TimeTableChangeReason = make([]TimeTableChangeReasonType, 0)
        }
        for _, value := range values {
        t.TimeTableChangeReason = append(t.TimeTableChangeReason, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TimeTableChangeReasonListType) AddNew() *TimeTableChangeReasonListType {
        if t == nil {
                t, _ = TimeTableChangeReasonListTypePointer(TimeTableChangeReasonListType{})
        }
        if t.TimeTableChangeReason == nil {
                t.TimeTableChangeReason = make([]TimeTableChangeReasonType, 0)
        }
        t.TimeTableChangeReason = append(t.TimeTableChangeReason, TimeTableChangeReasonType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TimeTableChangeReasonListType) Last() *TimeTableChangeReasonType {
  if t.TimeTableChangeReason == nil {
    t = t.AddNew()
    }
        return &(t.TimeTableChangeReason[len(t.TimeTableChangeReason)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TimeTableChangeReasonListType) Index(n int) (*TimeTableChangeReasonType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TimeTableChangeReasonListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TimeTableChangeReason == nil {
    t = t.AddNew()
    }
        return &(t.TimeTableChangeReason[n])
}

// Length of the list.
func (t *TimeTableChangeReasonListType) Len() int {
  if t.TimeTableChangeReason == nil {
    t = t.AddNew()
    }
        return len(t.TimeTableChangeReason)
}

// Convert list object to slice
func (t *TimeTableChangeReasonListType) ToSlice() []*TimeTableChangeReasonType {
  ret := make([]*TimeTableChangeReasonType, 0)
  for _, x:= range t.TimeTableChangeReason {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TimeTableDayListType) Append(values ...TimeTableDayType) *TimeTableDayListType {
    
        if t == nil {
                t, _ = TimeTableDayListTypePointer(TimeTableDayListType{})
        }
        if t.TimeTableDay == nil {
                t.TimeTableDay = make([]TimeTableDayType, 0)
        }
        for _, value := range values {
        t.TimeTableDay = append(t.TimeTableDay, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TimeTableDayListType) AddNew() *TimeTableDayListType {
        if t == nil {
                t, _ = TimeTableDayListTypePointer(TimeTableDayListType{})
        }
        if t.TimeTableDay == nil {
                t.TimeTableDay = make([]TimeTableDayType, 0)
        }
        t.TimeTableDay = append(t.TimeTableDay, TimeTableDayType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TimeTableDayListType) Last() *TimeTableDayType {
  if t.TimeTableDay == nil {
    t = t.AddNew()
    }
        return &(t.TimeTableDay[len(t.TimeTableDay)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TimeTableDayListType) Index(n int) (*TimeTableDayType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TimeTableDayListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TimeTableDay == nil {
    t = t.AddNew()
    }
        return &(t.TimeTableDay[n])
}

// Length of the list.
func (t *TimeTableDayListType) Len() int {
  if t.TimeTableDay == nil {
    t = t.AddNew()
    }
        return len(t.TimeTableDay)
}

// Convert list object to slice
func (t *TimeTableDayListType) ToSlice() []*TimeTableDayType {
  ret := make([]*TimeTableDayType, 0)
  for _, x:= range t.TimeTableDay {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TimeTablePeriodListType) Append(values ...TimeTablePeriodType) *TimeTablePeriodListType {
    
        if t == nil {
                t, _ = TimeTablePeriodListTypePointer(TimeTablePeriodListType{})
        }
        if t.TimeTablePeriod == nil {
                t.TimeTablePeriod = make([]TimeTablePeriodType, 0)
        }
        for _, value := range values {
        t.TimeTablePeriod = append(t.TimeTablePeriod, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TimeTablePeriodListType) AddNew() *TimeTablePeriodListType {
        if t == nil {
                t, _ = TimeTablePeriodListTypePointer(TimeTablePeriodListType{})
        }
        if t.TimeTablePeriod == nil {
                t.TimeTablePeriod = make([]TimeTablePeriodType, 0)
        }
        t.TimeTablePeriod = append(t.TimeTablePeriod, TimeTablePeriodType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TimeTablePeriodListType) Last() *TimeTablePeriodType {
  if t.TimeTablePeriod == nil {
    t = t.AddNew()
    }
        return &(t.TimeTablePeriod[len(t.TimeTablePeriod)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TimeTablePeriodListType) Index(n int) (*TimeTablePeriodType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TimeTablePeriodListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TimeTablePeriod == nil {
    t = t.AddNew()
    }
        return &(t.TimeTablePeriod[n])
}

// Length of the list.
func (t *TimeTablePeriodListType) Len() int {
  if t.TimeTablePeriod == nil {
    t = t.AddNew()
    }
        return len(t.TimeTablePeriod)
}

// Convert list object to slice
func (t *TimeTablePeriodListType) ToSlice() []*TimeTablePeriodType {
  ret := make([]*TimeTablePeriodType, 0)
  for _, x:= range t.TimeTablePeriod {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TimeTableScheduleCellListType) Append(values ...TimeTableScheduleCellType) *TimeTableScheduleCellListType {
    
        if t == nil {
                t, _ = TimeTableScheduleCellListTypePointer(TimeTableScheduleCellListType{})
        }
        if t.TimeTableScheduleCell == nil {
                t.TimeTableScheduleCell = make([]TimeTableScheduleCellType, 0)
        }
        for _, value := range values {
        t.TimeTableScheduleCell = append(t.TimeTableScheduleCell, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TimeTableScheduleCellListType) AddNew() *TimeTableScheduleCellListType {
        if t == nil {
                t, _ = TimeTableScheduleCellListTypePointer(TimeTableScheduleCellListType{})
        }
        if t.TimeTableScheduleCell == nil {
                t.TimeTableScheduleCell = make([]TimeTableScheduleCellType, 0)
        }
        t.TimeTableScheduleCell = append(t.TimeTableScheduleCell, TimeTableScheduleCellType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TimeTableScheduleCellListType) Last() *TimeTableScheduleCellType {
  if t.TimeTableScheduleCell == nil {
    t = t.AddNew()
    }
        return &(t.TimeTableScheduleCell[len(t.TimeTableScheduleCell)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *TimeTableScheduleCellListType) Index(n int) (*TimeTableScheduleCellType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TimeTableScheduleCellListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.TimeTableScheduleCell == nil {
    t = t.AddNew()
    }
        return &(t.TimeTableScheduleCell[n])
}

// Length of the list.
func (t *TimeTableScheduleCellListType) Len() int {
  if t.TimeTableScheduleCell == nil {
    t = t.AddNew()
    }
        return len(t.TimeTableScheduleCell)
}

// Convert list object to slice
func (t *TimeTableScheduleCellListType) ToSlice() []*TimeTableScheduleCellType {
  ret := make([]*TimeTableScheduleCellType, 0)
  for _, x:= range t.TimeTableScheduleCell {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ValidLetterMarkListType) Append(values ...ValidLetterMarkType) *ValidLetterMarkListType {
    
        if t == nil {
                t, _ = ValidLetterMarkListTypePointer(ValidLetterMarkListType{})
        }
        if t.ValidLetterMark == nil {
                t.ValidLetterMark = make([]ValidLetterMarkType, 0)
        }
        for _, value := range values {
        t.ValidLetterMark = append(t.ValidLetterMark, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ValidLetterMarkListType) AddNew() *ValidLetterMarkListType {
        if t == nil {
                t, _ = ValidLetterMarkListTypePointer(ValidLetterMarkListType{})
        }
        if t.ValidLetterMark == nil {
                t.ValidLetterMark = make([]ValidLetterMarkType, 0)
        }
        t.ValidLetterMark = append(t.ValidLetterMark, ValidLetterMarkType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ValidLetterMarkListType) Last() *ValidLetterMarkType {
  if t.ValidLetterMark == nil {
    t = t.AddNew()
    }
        return &(t.ValidLetterMark[len(t.ValidLetterMark)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *ValidLetterMarkListType) Index(n int) (*ValidLetterMarkType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ValidLetterMarkListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.ValidLetterMark == nil {
    t = t.AddNew()
    }
        return &(t.ValidLetterMark[n])
}

// Length of the list.
func (t *ValidLetterMarkListType) Len() int {
  if t.ValidLetterMark == nil {
    t = t.AddNew()
    }
        return len(t.ValidLetterMark)
}

// Convert list object to slice
func (t *ValidLetterMarkListType) ToSlice() []*ValidLetterMarkType {
  ret := make([]*ValidLetterMarkType, 0)
  for _, x:= range t.ValidLetterMark {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *VisaSubClassListType) Append(values ...VisaSubClassType) *VisaSubClassListType {
    
        if t == nil {
                t, _ = VisaSubClassListTypePointer(VisaSubClassListType{})
        }
        if t.VisaSubClass == nil {
                t.VisaSubClass = make([]VisaSubClassType, 0)
        }
        for _, value := range values {
        t.VisaSubClass = append(t.VisaSubClass, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *VisaSubClassListType) AddNew() *VisaSubClassListType {
        if t == nil {
                t, _ = VisaSubClassListTypePointer(VisaSubClassListType{})
        }
        if t.VisaSubClass == nil {
                t.VisaSubClass = make([]VisaSubClassType, 0)
        }
        t.VisaSubClass = append(t.VisaSubClass, VisaSubClassType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *VisaSubClassListType) Last() *VisaSubClassType {
  if t.VisaSubClass == nil {
    t = t.AddNew()
    }
        return &(t.VisaSubClass[len(t.VisaSubClass)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *VisaSubClassListType) Index(n int) (*VisaSubClassType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("VisaSubClassListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.VisaSubClass == nil {
    t = t.AddNew()
    }
        return &(t.VisaSubClass[n])
}

// Length of the list.
func (t *VisaSubClassListType) Len() int {
  if t.VisaSubClass == nil {
    t = t.AddNew()
    }
        return len(t.VisaSubClass)
}

// Convert list object to slice
func (t *VisaSubClassListType) ToSlice() []*VisaSubClassType {
  ret := make([]*VisaSubClassType, 0)
  for _, x:= range t.VisaSubClass {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WellbeingDocumentListType) Append(values ...WellbeingDocumentType) *WellbeingDocumentListType {
    
        if t == nil {
                t, _ = WellbeingDocumentListTypePointer(WellbeingDocumentListType{})
        }
        if t.Document == nil {
                t.Document = make([]WellbeingDocumentType, 0)
        }
        for _, value := range values {
        t.Document = append(t.Document, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WellbeingDocumentListType) AddNew() *WellbeingDocumentListType {
        if t == nil {
                t, _ = WellbeingDocumentListTypePointer(WellbeingDocumentListType{})
        }
        if t.Document == nil {
                t.Document = make([]WellbeingDocumentType, 0)
        }
        t.Document = append(t.Document, WellbeingDocumentType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WellbeingDocumentListType) Last() *WellbeingDocumentType {
  if t.Document == nil {
    t = t.AddNew()
    }
        return &(t.Document[len(t.Document)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *WellbeingDocumentListType) Index(n int) (*WellbeingDocumentType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WellbeingDocumentListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Document == nil {
    t = t.AddNew()
    }
        return &(t.Document[n])
}

// Length of the list.
func (t *WellbeingDocumentListType) Len() int {
  if t.Document == nil {
    t = t.AddNew()
    }
        return len(t.Document)
}

// Convert list object to slice
func (t *WellbeingDocumentListType) ToSlice() []*WellbeingDocumentType {
  ret := make([]*WellbeingDocumentType, 0)
  for _, x:= range t.Document {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WellbeingEventCategoryListType) Append(values ...WellbeingEventCategoryType) *WellbeingEventCategoryListType {
    
        if t == nil {
                t, _ = WellbeingEventCategoryListTypePointer(WellbeingEventCategoryListType{})
        }
        if t.WellbeingEventCategory == nil {
                t.WellbeingEventCategory = make([]WellbeingEventCategoryType, 0)
        }
        for _, value := range values {
        t.WellbeingEventCategory = append(t.WellbeingEventCategory, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WellbeingEventCategoryListType) AddNew() *WellbeingEventCategoryListType {
        if t == nil {
                t, _ = WellbeingEventCategoryListTypePointer(WellbeingEventCategoryListType{})
        }
        if t.WellbeingEventCategory == nil {
                t.WellbeingEventCategory = make([]WellbeingEventCategoryType, 0)
        }
        t.WellbeingEventCategory = append(t.WellbeingEventCategory, WellbeingEventCategoryType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WellbeingEventCategoryListType) Last() *WellbeingEventCategoryType {
  if t.WellbeingEventCategory == nil {
    t = t.AddNew()
    }
        return &(t.WellbeingEventCategory[len(t.WellbeingEventCategory)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *WellbeingEventCategoryListType) Index(n int) (*WellbeingEventCategoryType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WellbeingEventCategoryListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.WellbeingEventCategory == nil {
    t = t.AddNew()
    }
        return &(t.WellbeingEventCategory[n])
}

// Length of the list.
func (t *WellbeingEventCategoryListType) Len() int {
  if t.WellbeingEventCategory == nil {
    t = t.AddNew()
    }
        return len(t.WellbeingEventCategory)
}

// Convert list object to slice
func (t *WellbeingEventCategoryListType) ToSlice() []*WellbeingEventCategoryType {
  ret := make([]*WellbeingEventCategoryType, 0)
  for _, x:= range t.WellbeingEventCategory {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WellbeingEventSubCategoryListType) Append(values ...string) *WellbeingEventSubCategoryListType {
    
        if t == nil {
                t, _ = WellbeingEventSubCategoryListTypePointer(WellbeingEventSubCategoryListType{})
        }
        if t.WellbeingEventSubCategory == nil {
                t.WellbeingEventSubCategory = make([]string, 0)
        }
        for _, value := range values {
        t.WellbeingEventSubCategory = append(t.WellbeingEventSubCategory, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WellbeingEventSubCategoryListType) AddNew() *WellbeingEventSubCategoryListType {
        if t == nil {
                t, _ = WellbeingEventSubCategoryListTypePointer(WellbeingEventSubCategoryListType{})
        }
        if t.WellbeingEventSubCategory == nil {
                t.WellbeingEventSubCategory = make([]string, 0)
        }
        t.WellbeingEventSubCategory = append(t.WellbeingEventSubCategory, "")
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WellbeingEventSubCategoryListType) Last() *string {
  if t.WellbeingEventSubCategory == nil {
    t = t.AddNew()
    }
        return &(t.WellbeingEventSubCategory[len(t.WellbeingEventSubCategory)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *WellbeingEventSubCategoryListType) Index(n int) (*string) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WellbeingEventSubCategoryListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.WellbeingEventSubCategory == nil {
    t = t.AddNew()
    }
        return &(t.WellbeingEventSubCategory[n])
}

// Length of the list.
func (t *WellbeingEventSubCategoryListType) Len() int {
  if t.WellbeingEventSubCategory == nil {
    t = t.AddNew()
    }
        return len(t.WellbeingEventSubCategory)
}

// Convert list object to slice
func (t *WellbeingEventSubCategoryListType) ToSlice() []*string {
  ret := make([]*string, 0)
  for _, x:= range t.WellbeingEventSubCategory {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}


// Append a single string to the list. Only defined for lists of strings or of types aliased to string.
      func (t *WellbeingEventSubCategoryListType) AppendString(value string) *WellbeingEventSubCategoryListType {
        return t.Append((string)(value))
        }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WithdrawalTimeListType) Append(values ...WithdrawalType) *WithdrawalTimeListType {
    
        if t == nil {
                t, _ = WithdrawalTimeListTypePointer(WithdrawalTimeListType{})
        }
        if t.Withdrawal == nil {
                t.Withdrawal = make([]WithdrawalType, 0)
        }
        for _, value := range values {
        t.Withdrawal = append(t.Withdrawal, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WithdrawalTimeListType) AddNew() *WithdrawalTimeListType {
        if t == nil {
                t, _ = WithdrawalTimeListTypePointer(WithdrawalTimeListType{})
        }
        if t.Withdrawal == nil {
                t.Withdrawal = make([]WithdrawalType, 0)
        }
        t.Withdrawal = append(t.Withdrawal, WithdrawalType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WithdrawalTimeListType) Last() *WithdrawalType {
  if t.Withdrawal == nil {
    t = t.AddNew()
    }
        return &(t.Withdrawal[len(t.Withdrawal)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *WithdrawalTimeListType) Index(n int) (*WithdrawalType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WithdrawalTimeListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.Withdrawal == nil {
    t = t.AddNew()
    }
        return &(t.Withdrawal[n])
}

// Length of the list.
func (t *WithdrawalTimeListType) Len() int {
  if t.Withdrawal == nil {
    t = t.AddNew()
    }
        return len(t.Withdrawal)
}

// Convert list object to slice
func (t *WithdrawalTimeListType) ToSlice() []*WithdrawalType {
  ret := make([]*WithdrawalType, 0)
  for _, x:= range t.Withdrawal {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *YearLevelEnrollmentListType) Append(values ...YearLevelEnrollmentType) *YearLevelEnrollmentListType {
    
        if t == nil {
                t, _ = YearLevelEnrollmentListTypePointer(YearLevelEnrollmentListType{})
        }
        if t.YearLevelEnrollment == nil {
                t.YearLevelEnrollment = make([]YearLevelEnrollmentType, 0)
        }
        for _, value := range values {
        t.YearLevelEnrollment = append(t.YearLevelEnrollment, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *YearLevelEnrollmentListType) AddNew() *YearLevelEnrollmentListType {
        if t == nil {
                t, _ = YearLevelEnrollmentListTypePointer(YearLevelEnrollmentListType{})
        }
        if t.YearLevelEnrollment == nil {
                t.YearLevelEnrollment = make([]YearLevelEnrollmentType, 0)
        }
        t.YearLevelEnrollment = append(t.YearLevelEnrollment, YearLevelEnrollmentType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *YearLevelEnrollmentListType) Last() *YearLevelEnrollmentType {
  if t.YearLevelEnrollment == nil {
    t = t.AddNew()
    }
        return &(t.YearLevelEnrollment[len(t.YearLevelEnrollment)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *YearLevelEnrollmentListType) Index(n int) (*YearLevelEnrollmentType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("YearLevelEnrollmentListType.Index(): subscript %d out of range on list\n", n)
    }
  if t.YearLevelEnrollment == nil {
    t = t.AddNew()
    }
        return &(t.YearLevelEnrollment[n])
}

// Length of the list.
func (t *YearLevelEnrollmentListType) Len() int {
  if t.YearLevelEnrollment == nil {
    t = t.AddNew()
    }
        return len(t.YearLevelEnrollment)
}

// Convert list object to slice
func (t *YearLevelEnrollmentListType) ToSlice() []*YearLevelEnrollmentType {
  ret := make([]*YearLevelEnrollmentType, 0)
  for _, x:= range t.YearLevelEnrollment {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *YearLevelsType) Append(values ...YearLevelType) *YearLevelsType {
    
        if t == nil {
                t, _ = YearLevelsTypePointer(YearLevelsType{})
        }
        if t.YearLevel == nil {
                t.YearLevel = make([]YearLevelType, 0)
        }
        for _, value := range values {
        t.YearLevel = append(t.YearLevel, value)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *YearLevelsType) AddNew() *YearLevelsType {
        if t == nil {
                t, _ = YearLevelsTypePointer(YearLevelsType{})
        }
        if t.YearLevel == nil {
                t.YearLevel = make([]YearLevelType, 0)
        }
        t.YearLevel = append(t.YearLevel, YearLevelType{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *YearLevelsType) Last() *YearLevelType {
  if t.YearLevel == nil {
    t = t.AddNew()
    }
        return &(t.YearLevel[len(t.YearLevel)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds.
func (t *YearLevelsType) Index(n int) (*YearLevelType) {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("YearLevelsType.Index(): subscript %d out of range on list\n", n)
    }
  if t.YearLevel == nil {
    t = t.AddNew()
    }
        return &(t.YearLevel[n])
}

// Length of the list.
func (t *YearLevelsType) Len() int {
  if t.YearLevel == nil {
    t = t.AddNew()
    }
        return len(t.YearLevel)
}

// Convert list object to slice
func (t *YearLevelsType) ToSlice() []*YearLevelType {
  ret := make([]*YearLevelType, 0)
  for _, x:= range t.YearLevel {
    dup := x
    ret = append(ret, &dup)
  }
  return ret
}



  // Generates a new object as a pointer to a struct
func NewActivitys() *Activitys {
  if out, ok := ActivitysPointer(Activitys{}); !ok {
                log.Fatalf("Could not create pointer to Activitys\n")
                return nil
        } else {
          out.activitys.Activity = make([]activity, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *Activitys) Append(values ...*Activity) *Activitys {
        if t == nil {
                t, _ = ActivitysPointer(Activitys{})
        }
        /*
        if t.activitys == nil {
          t.activitys = activitys{Activity: make([]activity, 0)}
        }
        */
        if t.activitys.Activity == nil {
                t.activitys.Activity = make([]activity, 0)
        }
        for _, value := range values {
        t.activitys.Activity = append(t.activitys.Activity, value.activity)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *Activitys) AddNew() *Activitys {
        if t == nil {
                t, _ = ActivitysPointer(Activitys{})
        }
        /*
        if t.activitys == nil {
          t.activitys = activitys{Activity: make([]activity, 0)}
        }
        */
        if t.activitys.Activity == nil {
                t.activitys.Activity = make([]activity, 0)
        }
        t.activitys.Activity = append(t.activitys.Activity, activity{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *Activitys) Last() *activity {
  /*
  if t.activitys == nil {
    t = t.AddNew()
    }
    */
  if t.activitys.Activity == nil {
    t = t.AddNew()
    }
        return &(t.activitys.Activity[len(t.activitys.Activity)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *Activitys) Index(n int) *Activity {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("Activitys.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.activitys == nil {
    t = t.AddNew()
    }
    */
  if t.activitys.Activity == nil {
    t = t.AddNew()
    }
        return &Activity{(t.activitys.Activity[n])}
}

// Length of the list.
func (t *Activitys) Len() int {
  /*
  if t.activitys == nil {
    t = t.AddNew()
    }
    */
  if t.activitys.Activity == nil {
    t = t.AddNew()
    }
        return len(t.activitys.Activity)
}

// Convert list object to slice
func (t *Activitys) ToSlice() []*Activity {
    ret := make([]*Activity, 0)
  for _, x:= range t.activitys.Activity {
    ret = append(ret, &Activity{activity: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewAddressCollections() *AddressCollections {
  if out, ok := AddressCollectionsPointer(AddressCollections{}); !ok {
                log.Fatalf("Could not create pointer to AddressCollections\n")
                return nil
        } else {
          out.addresscollections.AddressCollection = make([]addresscollection, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AddressCollections) Append(values ...*AddressCollection) *AddressCollections {
        if t == nil {
                t, _ = AddressCollectionsPointer(AddressCollections{})
        }
        /*
        if t.addresscollections == nil {
          t.addresscollections = addresscollections{AddressCollection: make([]addresscollection, 0)}
        }
        */
        if t.addresscollections.AddressCollection == nil {
                t.addresscollections.AddressCollection = make([]addresscollection, 0)
        }
        for _, value := range values {
        t.addresscollections.AddressCollection = append(t.addresscollections.AddressCollection, value.addresscollection)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AddressCollections) AddNew() *AddressCollections {
        if t == nil {
                t, _ = AddressCollectionsPointer(AddressCollections{})
        }
        /*
        if t.addresscollections == nil {
          t.addresscollections = addresscollections{AddressCollection: make([]addresscollection, 0)}
        }
        */
        if t.addresscollections.AddressCollection == nil {
                t.addresscollections.AddressCollection = make([]addresscollection, 0)
        }
        t.addresscollections.AddressCollection = append(t.addresscollections.AddressCollection, addresscollection{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AddressCollections) Last() *addresscollection {
  /*
  if t.addresscollections == nil {
    t = t.AddNew()
    }
    */
  if t.addresscollections.AddressCollection == nil {
    t = t.AddNew()
    }
        return &(t.addresscollections.AddressCollection[len(t.addresscollections.AddressCollection)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *AddressCollections) Index(n int) *AddressCollection {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AddressCollections.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.addresscollections == nil {
    t = t.AddNew()
    }
    */
  if t.addresscollections.AddressCollection == nil {
    t = t.AddNew()
    }
        return &AddressCollection{(t.addresscollections.AddressCollection[n])}
}

// Length of the list.
func (t *AddressCollections) Len() int {
  /*
  if t.addresscollections == nil {
    t = t.AddNew()
    }
    */
  if t.addresscollections.AddressCollection == nil {
    t = t.AddNew()
    }
        return len(t.addresscollections.AddressCollection)
}

// Convert list object to slice
func (t *AddressCollections) ToSlice() []*AddressCollection {
    ret := make([]*AddressCollection, 0)
  for _, x:= range t.addresscollections.AddressCollection {
    ret = append(ret, &AddressCollection{addresscollection: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewAggregateCharacteristicInfos() *AggregateCharacteristicInfos {
  if out, ok := AggregateCharacteristicInfosPointer(AggregateCharacteristicInfos{}); !ok {
                log.Fatalf("Could not create pointer to AggregateCharacteristicInfos\n")
                return nil
        } else {
          out.aggregatecharacteristicinfos.AggregateCharacteristicInfo = make([]aggregatecharacteristicinfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AggregateCharacteristicInfos) Append(values ...*AggregateCharacteristicInfo) *AggregateCharacteristicInfos {
        if t == nil {
                t, _ = AggregateCharacteristicInfosPointer(AggregateCharacteristicInfos{})
        }
        /*
        if t.aggregatecharacteristicinfos == nil {
          t.aggregatecharacteristicinfos = aggregatecharacteristicinfos{AggregateCharacteristicInfo: make([]aggregatecharacteristicinfo, 0)}
        }
        */
        if t.aggregatecharacteristicinfos.AggregateCharacteristicInfo == nil {
                t.aggregatecharacteristicinfos.AggregateCharacteristicInfo = make([]aggregatecharacteristicinfo, 0)
        }
        for _, value := range values {
        t.aggregatecharacteristicinfos.AggregateCharacteristicInfo = append(t.aggregatecharacteristicinfos.AggregateCharacteristicInfo, value.aggregatecharacteristicinfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AggregateCharacteristicInfos) AddNew() *AggregateCharacteristicInfos {
        if t == nil {
                t, _ = AggregateCharacteristicInfosPointer(AggregateCharacteristicInfos{})
        }
        /*
        if t.aggregatecharacteristicinfos == nil {
          t.aggregatecharacteristicinfos = aggregatecharacteristicinfos{AggregateCharacteristicInfo: make([]aggregatecharacteristicinfo, 0)}
        }
        */
        if t.aggregatecharacteristicinfos.AggregateCharacteristicInfo == nil {
                t.aggregatecharacteristicinfos.AggregateCharacteristicInfo = make([]aggregatecharacteristicinfo, 0)
        }
        t.aggregatecharacteristicinfos.AggregateCharacteristicInfo = append(t.aggregatecharacteristicinfos.AggregateCharacteristicInfo, aggregatecharacteristicinfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AggregateCharacteristicInfos) Last() *aggregatecharacteristicinfo {
  /*
  if t.aggregatecharacteristicinfos == nil {
    t = t.AddNew()
    }
    */
  if t.aggregatecharacteristicinfos.AggregateCharacteristicInfo == nil {
    t = t.AddNew()
    }
        return &(t.aggregatecharacteristicinfos.AggregateCharacteristicInfo[len(t.aggregatecharacteristicinfos.AggregateCharacteristicInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *AggregateCharacteristicInfos) Index(n int) *AggregateCharacteristicInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AggregateCharacteristicInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.aggregatecharacteristicinfos == nil {
    t = t.AddNew()
    }
    */
  if t.aggregatecharacteristicinfos.AggregateCharacteristicInfo == nil {
    t = t.AddNew()
    }
        return &AggregateCharacteristicInfo{(t.aggregatecharacteristicinfos.AggregateCharacteristicInfo[n])}
}

// Length of the list.
func (t *AggregateCharacteristicInfos) Len() int {
  /*
  if t.aggregatecharacteristicinfos == nil {
    t = t.AddNew()
    }
    */
  if t.aggregatecharacteristicinfos.AggregateCharacteristicInfo == nil {
    t = t.AddNew()
    }
        return len(t.aggregatecharacteristicinfos.AggregateCharacteristicInfo)
}

// Convert list object to slice
func (t *AggregateCharacteristicInfos) ToSlice() []*AggregateCharacteristicInfo {
    ret := make([]*AggregateCharacteristicInfo, 0)
  for _, x:= range t.aggregatecharacteristicinfos.AggregateCharacteristicInfo {
    ret = append(ret, &AggregateCharacteristicInfo{aggregatecharacteristicinfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewAggregateStatisticFacts() *AggregateStatisticFacts {
  if out, ok := AggregateStatisticFactsPointer(AggregateStatisticFacts{}); !ok {
                log.Fatalf("Could not create pointer to AggregateStatisticFacts\n")
                return nil
        } else {
          out.aggregatestatisticfacts.AggregateStatisticFact = make([]aggregatestatisticfact, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AggregateStatisticFacts) Append(values ...*AggregateStatisticFact) *AggregateStatisticFacts {
        if t == nil {
                t, _ = AggregateStatisticFactsPointer(AggregateStatisticFacts{})
        }
        /*
        if t.aggregatestatisticfacts == nil {
          t.aggregatestatisticfacts = aggregatestatisticfacts{AggregateStatisticFact: make([]aggregatestatisticfact, 0)}
        }
        */
        if t.aggregatestatisticfacts.AggregateStatisticFact == nil {
                t.aggregatestatisticfacts.AggregateStatisticFact = make([]aggregatestatisticfact, 0)
        }
        for _, value := range values {
        t.aggregatestatisticfacts.AggregateStatisticFact = append(t.aggregatestatisticfacts.AggregateStatisticFact, value.aggregatestatisticfact)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AggregateStatisticFacts) AddNew() *AggregateStatisticFacts {
        if t == nil {
                t, _ = AggregateStatisticFactsPointer(AggregateStatisticFacts{})
        }
        /*
        if t.aggregatestatisticfacts == nil {
          t.aggregatestatisticfacts = aggregatestatisticfacts{AggregateStatisticFact: make([]aggregatestatisticfact, 0)}
        }
        */
        if t.aggregatestatisticfacts.AggregateStatisticFact == nil {
                t.aggregatestatisticfacts.AggregateStatisticFact = make([]aggregatestatisticfact, 0)
        }
        t.aggregatestatisticfacts.AggregateStatisticFact = append(t.aggregatestatisticfacts.AggregateStatisticFact, aggregatestatisticfact{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AggregateStatisticFacts) Last() *aggregatestatisticfact {
  /*
  if t.aggregatestatisticfacts == nil {
    t = t.AddNew()
    }
    */
  if t.aggregatestatisticfacts.AggregateStatisticFact == nil {
    t = t.AddNew()
    }
        return &(t.aggregatestatisticfacts.AggregateStatisticFact[len(t.aggregatestatisticfacts.AggregateStatisticFact)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *AggregateStatisticFacts) Index(n int) *AggregateStatisticFact {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AggregateStatisticFacts.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.aggregatestatisticfacts == nil {
    t = t.AddNew()
    }
    */
  if t.aggregatestatisticfacts.AggregateStatisticFact == nil {
    t = t.AddNew()
    }
        return &AggregateStatisticFact{(t.aggregatestatisticfacts.AggregateStatisticFact[n])}
}

// Length of the list.
func (t *AggregateStatisticFacts) Len() int {
  /*
  if t.aggregatestatisticfacts == nil {
    t = t.AddNew()
    }
    */
  if t.aggregatestatisticfacts.AggregateStatisticFact == nil {
    t = t.AddNew()
    }
        return len(t.aggregatestatisticfacts.AggregateStatisticFact)
}

// Convert list object to slice
func (t *AggregateStatisticFacts) ToSlice() []*AggregateStatisticFact {
    ret := make([]*AggregateStatisticFact, 0)
  for _, x:= range t.aggregatestatisticfacts.AggregateStatisticFact {
    ret = append(ret, &AggregateStatisticFact{aggregatestatisticfact: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewAggregateStatisticInfos() *AggregateStatisticInfos {
  if out, ok := AggregateStatisticInfosPointer(AggregateStatisticInfos{}); !ok {
                log.Fatalf("Could not create pointer to AggregateStatisticInfos\n")
                return nil
        } else {
          out.aggregatestatisticinfos.AggregateStatisticInfo = make([]aggregatestatisticinfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *AggregateStatisticInfos) Append(values ...*AggregateStatisticInfo) *AggregateStatisticInfos {
        if t == nil {
                t, _ = AggregateStatisticInfosPointer(AggregateStatisticInfos{})
        }
        /*
        if t.aggregatestatisticinfos == nil {
          t.aggregatestatisticinfos = aggregatestatisticinfos{AggregateStatisticInfo: make([]aggregatestatisticinfo, 0)}
        }
        */
        if t.aggregatestatisticinfos.AggregateStatisticInfo == nil {
                t.aggregatestatisticinfos.AggregateStatisticInfo = make([]aggregatestatisticinfo, 0)
        }
        for _, value := range values {
        t.aggregatestatisticinfos.AggregateStatisticInfo = append(t.aggregatestatisticinfos.AggregateStatisticInfo, value.aggregatestatisticinfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *AggregateStatisticInfos) AddNew() *AggregateStatisticInfos {
        if t == nil {
                t, _ = AggregateStatisticInfosPointer(AggregateStatisticInfos{})
        }
        /*
        if t.aggregatestatisticinfos == nil {
          t.aggregatestatisticinfos = aggregatestatisticinfos{AggregateStatisticInfo: make([]aggregatestatisticinfo, 0)}
        }
        */
        if t.aggregatestatisticinfos.AggregateStatisticInfo == nil {
                t.aggregatestatisticinfos.AggregateStatisticInfo = make([]aggregatestatisticinfo, 0)
        }
        t.aggregatestatisticinfos.AggregateStatisticInfo = append(t.aggregatestatisticinfos.AggregateStatisticInfo, aggregatestatisticinfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *AggregateStatisticInfos) Last() *aggregatestatisticinfo {
  /*
  if t.aggregatestatisticinfos == nil {
    t = t.AddNew()
    }
    */
  if t.aggregatestatisticinfos.AggregateStatisticInfo == nil {
    t = t.AddNew()
    }
        return &(t.aggregatestatisticinfos.AggregateStatisticInfo[len(t.aggregatestatisticinfos.AggregateStatisticInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *AggregateStatisticInfos) Index(n int) *AggregateStatisticInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("AggregateStatisticInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.aggregatestatisticinfos == nil {
    t = t.AddNew()
    }
    */
  if t.aggregatestatisticinfos.AggregateStatisticInfo == nil {
    t = t.AddNew()
    }
        return &AggregateStatisticInfo{(t.aggregatestatisticinfos.AggregateStatisticInfo[n])}
}

// Length of the list.
func (t *AggregateStatisticInfos) Len() int {
  /*
  if t.aggregatestatisticinfos == nil {
    t = t.AddNew()
    }
    */
  if t.aggregatestatisticinfos.AggregateStatisticInfo == nil {
    t = t.AddNew()
    }
        return len(t.aggregatestatisticinfos.AggregateStatisticInfo)
}

// Convert list object to slice
func (t *AggregateStatisticInfos) ToSlice() []*AggregateStatisticInfo {
    ret := make([]*AggregateStatisticInfo, 0)
  for _, x:= range t.aggregatestatisticinfos.AggregateStatisticInfo {
    ret = append(ret, &AggregateStatisticInfo{aggregatestatisticinfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewCalendarDates() *CalendarDates {
  if out, ok := CalendarDatesPointer(CalendarDates{}); !ok {
                log.Fatalf("Could not create pointer to CalendarDates\n")
                return nil
        } else {
          out.calendardates.CalendarDate = make([]calendardate, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CalendarDates) Append(values ...*CalendarDate) *CalendarDates {
        if t == nil {
                t, _ = CalendarDatesPointer(CalendarDates{})
        }
        /*
        if t.calendardates == nil {
          t.calendardates = calendardates{CalendarDate: make([]calendardate, 0)}
        }
        */
        if t.calendardates.CalendarDate == nil {
                t.calendardates.CalendarDate = make([]calendardate, 0)
        }
        for _, value := range values {
        t.calendardates.CalendarDate = append(t.calendardates.CalendarDate, value.calendardate)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CalendarDates) AddNew() *CalendarDates {
        if t == nil {
                t, _ = CalendarDatesPointer(CalendarDates{})
        }
        /*
        if t.calendardates == nil {
          t.calendardates = calendardates{CalendarDate: make([]calendardate, 0)}
        }
        */
        if t.calendardates.CalendarDate == nil {
                t.calendardates.CalendarDate = make([]calendardate, 0)
        }
        t.calendardates.CalendarDate = append(t.calendardates.CalendarDate, calendardate{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CalendarDates) Last() *calendardate {
  /*
  if t.calendardates == nil {
    t = t.AddNew()
    }
    */
  if t.calendardates.CalendarDate == nil {
    t = t.AddNew()
    }
        return &(t.calendardates.CalendarDate[len(t.calendardates.CalendarDate)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *CalendarDates) Index(n int) *CalendarDate {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CalendarDates.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.calendardates == nil {
    t = t.AddNew()
    }
    */
  if t.calendardates.CalendarDate == nil {
    t = t.AddNew()
    }
        return &CalendarDate{(t.calendardates.CalendarDate[n])}
}

// Length of the list.
func (t *CalendarDates) Len() int {
  /*
  if t.calendardates == nil {
    t = t.AddNew()
    }
    */
  if t.calendardates.CalendarDate == nil {
    t = t.AddNew()
    }
        return len(t.calendardates.CalendarDate)
}

// Convert list object to slice
func (t *CalendarDates) ToSlice() []*CalendarDate {
    ret := make([]*CalendarDate, 0)
  for _, x:= range t.calendardates.CalendarDate {
    ret = append(ret, &CalendarDate{calendardate: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewCalendarSummarys() *CalendarSummarys {
  if out, ok := CalendarSummarysPointer(CalendarSummarys{}); !ok {
                log.Fatalf("Could not create pointer to CalendarSummarys\n")
                return nil
        } else {
          out.calendarsummarys.CalendarSummary = make([]calendarsummary, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CalendarSummarys) Append(values ...*CalendarSummary) *CalendarSummarys {
        if t == nil {
                t, _ = CalendarSummarysPointer(CalendarSummarys{})
        }
        /*
        if t.calendarsummarys == nil {
          t.calendarsummarys = calendarsummarys{CalendarSummary: make([]calendarsummary, 0)}
        }
        */
        if t.calendarsummarys.CalendarSummary == nil {
                t.calendarsummarys.CalendarSummary = make([]calendarsummary, 0)
        }
        for _, value := range values {
        t.calendarsummarys.CalendarSummary = append(t.calendarsummarys.CalendarSummary, value.calendarsummary)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CalendarSummarys) AddNew() *CalendarSummarys {
        if t == nil {
                t, _ = CalendarSummarysPointer(CalendarSummarys{})
        }
        /*
        if t.calendarsummarys == nil {
          t.calendarsummarys = calendarsummarys{CalendarSummary: make([]calendarsummary, 0)}
        }
        */
        if t.calendarsummarys.CalendarSummary == nil {
                t.calendarsummarys.CalendarSummary = make([]calendarsummary, 0)
        }
        t.calendarsummarys.CalendarSummary = append(t.calendarsummarys.CalendarSummary, calendarsummary{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CalendarSummarys) Last() *calendarsummary {
  /*
  if t.calendarsummarys == nil {
    t = t.AddNew()
    }
    */
  if t.calendarsummarys.CalendarSummary == nil {
    t = t.AddNew()
    }
        return &(t.calendarsummarys.CalendarSummary[len(t.calendarsummarys.CalendarSummary)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *CalendarSummarys) Index(n int) *CalendarSummary {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CalendarSummarys.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.calendarsummarys == nil {
    t = t.AddNew()
    }
    */
  if t.calendarsummarys.CalendarSummary == nil {
    t = t.AddNew()
    }
        return &CalendarSummary{(t.calendarsummarys.CalendarSummary[n])}
}

// Length of the list.
func (t *CalendarSummarys) Len() int {
  /*
  if t.calendarsummarys == nil {
    t = t.AddNew()
    }
    */
  if t.calendarsummarys.CalendarSummary == nil {
    t = t.AddNew()
    }
        return len(t.calendarsummarys.CalendarSummary)
}

// Convert list object to slice
func (t *CalendarSummarys) ToSlice() []*CalendarSummary {
    ret := make([]*CalendarSummary, 0)
  for _, x:= range t.calendarsummarys.CalendarSummary {
    ret = append(ret, &CalendarSummary{calendarsummary: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewCensusCollections() *CensusCollections {
  if out, ok := CensusCollectionsPointer(CensusCollections{}); !ok {
                log.Fatalf("Could not create pointer to CensusCollections\n")
                return nil
        } else {
          out.censuscollections.CensusCollection = make([]censuscollection, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CensusCollections) Append(values ...*CensusCollection) *CensusCollections {
        if t == nil {
                t, _ = CensusCollectionsPointer(CensusCollections{})
        }
        /*
        if t.censuscollections == nil {
          t.censuscollections = censuscollections{CensusCollection: make([]censuscollection, 0)}
        }
        */
        if t.censuscollections.CensusCollection == nil {
                t.censuscollections.CensusCollection = make([]censuscollection, 0)
        }
        for _, value := range values {
        t.censuscollections.CensusCollection = append(t.censuscollections.CensusCollection, value.censuscollection)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CensusCollections) AddNew() *CensusCollections {
        if t == nil {
                t, _ = CensusCollectionsPointer(CensusCollections{})
        }
        /*
        if t.censuscollections == nil {
          t.censuscollections = censuscollections{CensusCollection: make([]censuscollection, 0)}
        }
        */
        if t.censuscollections.CensusCollection == nil {
                t.censuscollections.CensusCollection = make([]censuscollection, 0)
        }
        t.censuscollections.CensusCollection = append(t.censuscollections.CensusCollection, censuscollection{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CensusCollections) Last() *censuscollection {
  /*
  if t.censuscollections == nil {
    t = t.AddNew()
    }
    */
  if t.censuscollections.CensusCollection == nil {
    t = t.AddNew()
    }
        return &(t.censuscollections.CensusCollection[len(t.censuscollections.CensusCollection)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *CensusCollections) Index(n int) *CensusCollection {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CensusCollections.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.censuscollections == nil {
    t = t.AddNew()
    }
    */
  if t.censuscollections.CensusCollection == nil {
    t = t.AddNew()
    }
        return &CensusCollection{(t.censuscollections.CensusCollection[n])}
}

// Length of the list.
func (t *CensusCollections) Len() int {
  /*
  if t.censuscollections == nil {
    t = t.AddNew()
    }
    */
  if t.censuscollections.CensusCollection == nil {
    t = t.AddNew()
    }
        return len(t.censuscollections.CensusCollection)
}

// Convert list object to slice
func (t *CensusCollections) ToSlice() []*CensusCollection {
    ret := make([]*CensusCollection, 0)
  for _, x:= range t.censuscollections.CensusCollection {
    ret = append(ret, &CensusCollection{censuscollection: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewChargedLocationInfos() *ChargedLocationInfos {
  if out, ok := ChargedLocationInfosPointer(ChargedLocationInfos{}); !ok {
                log.Fatalf("Could not create pointer to ChargedLocationInfos\n")
                return nil
        } else {
          out.chargedlocationinfos.ChargedLocationInfo = make([]chargedlocationinfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ChargedLocationInfos) Append(values ...*ChargedLocationInfo) *ChargedLocationInfos {
        if t == nil {
                t, _ = ChargedLocationInfosPointer(ChargedLocationInfos{})
        }
        /*
        if t.chargedlocationinfos == nil {
          t.chargedlocationinfos = chargedlocationinfos{ChargedLocationInfo: make([]chargedlocationinfo, 0)}
        }
        */
        if t.chargedlocationinfos.ChargedLocationInfo == nil {
                t.chargedlocationinfos.ChargedLocationInfo = make([]chargedlocationinfo, 0)
        }
        for _, value := range values {
        t.chargedlocationinfos.ChargedLocationInfo = append(t.chargedlocationinfos.ChargedLocationInfo, value.chargedlocationinfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ChargedLocationInfos) AddNew() *ChargedLocationInfos {
        if t == nil {
                t, _ = ChargedLocationInfosPointer(ChargedLocationInfos{})
        }
        /*
        if t.chargedlocationinfos == nil {
          t.chargedlocationinfos = chargedlocationinfos{ChargedLocationInfo: make([]chargedlocationinfo, 0)}
        }
        */
        if t.chargedlocationinfos.ChargedLocationInfo == nil {
                t.chargedlocationinfos.ChargedLocationInfo = make([]chargedlocationinfo, 0)
        }
        t.chargedlocationinfos.ChargedLocationInfo = append(t.chargedlocationinfos.ChargedLocationInfo, chargedlocationinfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ChargedLocationInfos) Last() *chargedlocationinfo {
  /*
  if t.chargedlocationinfos == nil {
    t = t.AddNew()
    }
    */
  if t.chargedlocationinfos.ChargedLocationInfo == nil {
    t = t.AddNew()
    }
        return &(t.chargedlocationinfos.ChargedLocationInfo[len(t.chargedlocationinfos.ChargedLocationInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *ChargedLocationInfos) Index(n int) *ChargedLocationInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ChargedLocationInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.chargedlocationinfos == nil {
    t = t.AddNew()
    }
    */
  if t.chargedlocationinfos.ChargedLocationInfo == nil {
    t = t.AddNew()
    }
        return &ChargedLocationInfo{(t.chargedlocationinfos.ChargedLocationInfo[n])}
}

// Length of the list.
func (t *ChargedLocationInfos) Len() int {
  /*
  if t.chargedlocationinfos == nil {
    t = t.AddNew()
    }
    */
  if t.chargedlocationinfos.ChargedLocationInfo == nil {
    t = t.AddNew()
    }
        return len(t.chargedlocationinfos.ChargedLocationInfo)
}

// Convert list object to slice
func (t *ChargedLocationInfos) ToSlice() []*ChargedLocationInfo {
    ret := make([]*ChargedLocationInfo, 0)
  for _, x:= range t.chargedlocationinfos.ChargedLocationInfo {
    ret = append(ret, &ChargedLocationInfo{chargedlocationinfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewCollectionAcquittals() *CollectionAcquittals {
  if out, ok := CollectionAcquittalsPointer(CollectionAcquittals{}); !ok {
                log.Fatalf("Could not create pointer to CollectionAcquittals\n")
                return nil
        } else {
          out.collectionacquittals.CollectionAcquittal = make([]collectionacquittal, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CollectionAcquittals) Append(values ...*CollectionAcquittal) *CollectionAcquittals {
        if t == nil {
                t, _ = CollectionAcquittalsPointer(CollectionAcquittals{})
        }
        /*
        if t.collectionacquittals == nil {
          t.collectionacquittals = collectionacquittals{CollectionAcquittal: make([]collectionacquittal, 0)}
        }
        */
        if t.collectionacquittals.CollectionAcquittal == nil {
                t.collectionacquittals.CollectionAcquittal = make([]collectionacquittal, 0)
        }
        for _, value := range values {
        t.collectionacquittals.CollectionAcquittal = append(t.collectionacquittals.CollectionAcquittal, value.collectionacquittal)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CollectionAcquittals) AddNew() *CollectionAcquittals {
        if t == nil {
                t, _ = CollectionAcquittalsPointer(CollectionAcquittals{})
        }
        /*
        if t.collectionacquittals == nil {
          t.collectionacquittals = collectionacquittals{CollectionAcquittal: make([]collectionacquittal, 0)}
        }
        */
        if t.collectionacquittals.CollectionAcquittal == nil {
                t.collectionacquittals.CollectionAcquittal = make([]collectionacquittal, 0)
        }
        t.collectionacquittals.CollectionAcquittal = append(t.collectionacquittals.CollectionAcquittal, collectionacquittal{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CollectionAcquittals) Last() *collectionacquittal {
  /*
  if t.collectionacquittals == nil {
    t = t.AddNew()
    }
    */
  if t.collectionacquittals.CollectionAcquittal == nil {
    t = t.AddNew()
    }
        return &(t.collectionacquittals.CollectionAcquittal[len(t.collectionacquittals.CollectionAcquittal)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *CollectionAcquittals) Index(n int) *CollectionAcquittal {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CollectionAcquittals.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.collectionacquittals == nil {
    t = t.AddNew()
    }
    */
  if t.collectionacquittals.CollectionAcquittal == nil {
    t = t.AddNew()
    }
        return &CollectionAcquittal{(t.collectionacquittals.CollectionAcquittal[n])}
}

// Length of the list.
func (t *CollectionAcquittals) Len() int {
  /*
  if t.collectionacquittals == nil {
    t = t.AddNew()
    }
    */
  if t.collectionacquittals.CollectionAcquittal == nil {
    t = t.AddNew()
    }
        return len(t.collectionacquittals.CollectionAcquittal)
}

// Convert list object to slice
func (t *CollectionAcquittals) ToSlice() []*CollectionAcquittal {
    ret := make([]*CollectionAcquittal, 0)
  for _, x:= range t.collectionacquittals.CollectionAcquittal {
    ret = append(ret, &CollectionAcquittal{collectionacquittal: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewCollectionDeclarations() *CollectionDeclarations {
  if out, ok := CollectionDeclarationsPointer(CollectionDeclarations{}); !ok {
                log.Fatalf("Could not create pointer to CollectionDeclarations\n")
                return nil
        } else {
          out.collectiondeclarations.CollectionDeclaration = make([]collectiondeclaration, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CollectionDeclarations) Append(values ...*CollectionDeclaration) *CollectionDeclarations {
        if t == nil {
                t, _ = CollectionDeclarationsPointer(CollectionDeclarations{})
        }
        /*
        if t.collectiondeclarations == nil {
          t.collectiondeclarations = collectiondeclarations{CollectionDeclaration: make([]collectiondeclaration, 0)}
        }
        */
        if t.collectiondeclarations.CollectionDeclaration == nil {
                t.collectiondeclarations.CollectionDeclaration = make([]collectiondeclaration, 0)
        }
        for _, value := range values {
        t.collectiondeclarations.CollectionDeclaration = append(t.collectiondeclarations.CollectionDeclaration, value.collectiondeclaration)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CollectionDeclarations) AddNew() *CollectionDeclarations {
        if t == nil {
                t, _ = CollectionDeclarationsPointer(CollectionDeclarations{})
        }
        /*
        if t.collectiondeclarations == nil {
          t.collectiondeclarations = collectiondeclarations{CollectionDeclaration: make([]collectiondeclaration, 0)}
        }
        */
        if t.collectiondeclarations.CollectionDeclaration == nil {
                t.collectiondeclarations.CollectionDeclaration = make([]collectiondeclaration, 0)
        }
        t.collectiondeclarations.CollectionDeclaration = append(t.collectiondeclarations.CollectionDeclaration, collectiondeclaration{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CollectionDeclarations) Last() *collectiondeclaration {
  /*
  if t.collectiondeclarations == nil {
    t = t.AddNew()
    }
    */
  if t.collectiondeclarations.CollectionDeclaration == nil {
    t = t.AddNew()
    }
        return &(t.collectiondeclarations.CollectionDeclaration[len(t.collectiondeclarations.CollectionDeclaration)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *CollectionDeclarations) Index(n int) *CollectionDeclaration {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CollectionDeclarations.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.collectiondeclarations == nil {
    t = t.AddNew()
    }
    */
  if t.collectiondeclarations.CollectionDeclaration == nil {
    t = t.AddNew()
    }
        return &CollectionDeclaration{(t.collectiondeclarations.CollectionDeclaration[n])}
}

// Length of the list.
func (t *CollectionDeclarations) Len() int {
  /*
  if t.collectiondeclarations == nil {
    t = t.AddNew()
    }
    */
  if t.collectiondeclarations.CollectionDeclaration == nil {
    t = t.AddNew()
    }
        return len(t.collectiondeclarations.CollectionDeclaration)
}

// Convert list object to slice
func (t *CollectionDeclarations) ToSlice() []*CollectionDeclaration {
    ret := make([]*CollectionDeclaration, 0)
  for _, x:= range t.collectiondeclarations.CollectionDeclaration {
    ret = append(ret, &CollectionDeclaration{collectiondeclaration: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewCollectionRounds() *CollectionRounds {
  if out, ok := CollectionRoundsPointer(CollectionRounds{}); !ok {
                log.Fatalf("Could not create pointer to CollectionRounds\n")
                return nil
        } else {
          out.collectionrounds.CollectionRound = make([]collectionround, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CollectionRounds) Append(values ...*CollectionRound) *CollectionRounds {
        if t == nil {
                t, _ = CollectionRoundsPointer(CollectionRounds{})
        }
        /*
        if t.collectionrounds == nil {
          t.collectionrounds = collectionrounds{CollectionRound: make([]collectionround, 0)}
        }
        */
        if t.collectionrounds.CollectionRound == nil {
                t.collectionrounds.CollectionRound = make([]collectionround, 0)
        }
        for _, value := range values {
        t.collectionrounds.CollectionRound = append(t.collectionrounds.CollectionRound, value.collectionround)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CollectionRounds) AddNew() *CollectionRounds {
        if t == nil {
                t, _ = CollectionRoundsPointer(CollectionRounds{})
        }
        /*
        if t.collectionrounds == nil {
          t.collectionrounds = collectionrounds{CollectionRound: make([]collectionround, 0)}
        }
        */
        if t.collectionrounds.CollectionRound == nil {
                t.collectionrounds.CollectionRound = make([]collectionround, 0)
        }
        t.collectionrounds.CollectionRound = append(t.collectionrounds.CollectionRound, collectionround{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CollectionRounds) Last() *collectionround {
  /*
  if t.collectionrounds == nil {
    t = t.AddNew()
    }
    */
  if t.collectionrounds.CollectionRound == nil {
    t = t.AddNew()
    }
        return &(t.collectionrounds.CollectionRound[len(t.collectionrounds.CollectionRound)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *CollectionRounds) Index(n int) *CollectionRound {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CollectionRounds.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.collectionrounds == nil {
    t = t.AddNew()
    }
    */
  if t.collectionrounds.CollectionRound == nil {
    t = t.AddNew()
    }
        return &CollectionRound{(t.collectionrounds.CollectionRound[n])}
}

// Length of the list.
func (t *CollectionRounds) Len() int {
  /*
  if t.collectionrounds == nil {
    t = t.AddNew()
    }
    */
  if t.collectionrounds.CollectionRound == nil {
    t = t.AddNew()
    }
        return len(t.collectionrounds.CollectionRound)
}

// Convert list object to slice
func (t *CollectionRounds) ToSlice() []*CollectionRound {
    ret := make([]*CollectionRound, 0)
  for _, x:= range t.collectionrounds.CollectionRound {
    ret = append(ret, &CollectionRound{collectionround: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewCollectionStatuss() *CollectionStatuss {
  if out, ok := CollectionStatussPointer(CollectionStatuss{}); !ok {
                log.Fatalf("Could not create pointer to CollectionStatuss\n")
                return nil
        } else {
          out.collectionstatuss.CollectionStatus = make([]collectionstatus, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *CollectionStatuss) Append(values ...*CollectionStatus) *CollectionStatuss {
        if t == nil {
                t, _ = CollectionStatussPointer(CollectionStatuss{})
        }
        /*
        if t.collectionstatuss == nil {
          t.collectionstatuss = collectionstatuss{CollectionStatus: make([]collectionstatus, 0)}
        }
        */
        if t.collectionstatuss.CollectionStatus == nil {
                t.collectionstatuss.CollectionStatus = make([]collectionstatus, 0)
        }
        for _, value := range values {
        t.collectionstatuss.CollectionStatus = append(t.collectionstatuss.CollectionStatus, value.collectionstatus)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *CollectionStatuss) AddNew() *CollectionStatuss {
        if t == nil {
                t, _ = CollectionStatussPointer(CollectionStatuss{})
        }
        /*
        if t.collectionstatuss == nil {
          t.collectionstatuss = collectionstatuss{CollectionStatus: make([]collectionstatus, 0)}
        }
        */
        if t.collectionstatuss.CollectionStatus == nil {
                t.collectionstatuss.CollectionStatus = make([]collectionstatus, 0)
        }
        t.collectionstatuss.CollectionStatus = append(t.collectionstatuss.CollectionStatus, collectionstatus{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *CollectionStatuss) Last() *collectionstatus {
  /*
  if t.collectionstatuss == nil {
    t = t.AddNew()
    }
    */
  if t.collectionstatuss.CollectionStatus == nil {
    t = t.AddNew()
    }
        return &(t.collectionstatuss.CollectionStatus[len(t.collectionstatuss.CollectionStatus)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *CollectionStatuss) Index(n int) *CollectionStatus {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("CollectionStatuss.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.collectionstatuss == nil {
    t = t.AddNew()
    }
    */
  if t.collectionstatuss.CollectionStatus == nil {
    t = t.AddNew()
    }
        return &CollectionStatus{(t.collectionstatuss.CollectionStatus[n])}
}

// Length of the list.
func (t *CollectionStatuss) Len() int {
  /*
  if t.collectionstatuss == nil {
    t = t.AddNew()
    }
    */
  if t.collectionstatuss.CollectionStatus == nil {
    t = t.AddNew()
    }
        return len(t.collectionstatuss.CollectionStatus)
}

// Convert list object to slice
func (t *CollectionStatuss) ToSlice() []*CollectionStatus {
    ret := make([]*CollectionStatus, 0)
  for _, x:= range t.collectionstatuss.CollectionStatus {
    ret = append(ret, &CollectionStatus{collectionstatus: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewDebtors() *Debtors {
  if out, ok := DebtorsPointer(Debtors{}); !ok {
                log.Fatalf("Could not create pointer to Debtors\n")
                return nil
        } else {
          out.debtors.Debtor = make([]debtor, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *Debtors) Append(values ...*Debtor) *Debtors {
        if t == nil {
                t, _ = DebtorsPointer(Debtors{})
        }
        /*
        if t.debtors == nil {
          t.debtors = debtors{Debtor: make([]debtor, 0)}
        }
        */
        if t.debtors.Debtor == nil {
                t.debtors.Debtor = make([]debtor, 0)
        }
        for _, value := range values {
        t.debtors.Debtor = append(t.debtors.Debtor, value.debtor)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *Debtors) AddNew() *Debtors {
        if t == nil {
                t, _ = DebtorsPointer(Debtors{})
        }
        /*
        if t.debtors == nil {
          t.debtors = debtors{Debtor: make([]debtor, 0)}
        }
        */
        if t.debtors.Debtor == nil {
                t.debtors.Debtor = make([]debtor, 0)
        }
        t.debtors.Debtor = append(t.debtors.Debtor, debtor{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *Debtors) Last() *debtor {
  /*
  if t.debtors == nil {
    t = t.AddNew()
    }
    */
  if t.debtors.Debtor == nil {
    t = t.AddNew()
    }
        return &(t.debtors.Debtor[len(t.debtors.Debtor)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *Debtors) Index(n int) *Debtor {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("Debtors.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.debtors == nil {
    t = t.AddNew()
    }
    */
  if t.debtors.Debtor == nil {
    t = t.AddNew()
    }
        return &Debtor{(t.debtors.Debtor[n])}
}

// Length of the list.
func (t *Debtors) Len() int {
  /*
  if t.debtors == nil {
    t = t.AddNew()
    }
    */
  if t.debtors.Debtor == nil {
    t = t.AddNew()
    }
        return len(t.debtors.Debtor)
}

// Convert list object to slice
func (t *Debtors) ToSlice() []*Debtor {
    ret := make([]*Debtor, 0)
  for _, x:= range t.debtors.Debtor {
    ret = append(ret, &Debtor{debtor: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewEquipmentInfos() *EquipmentInfos {
  if out, ok := EquipmentInfosPointer(EquipmentInfos{}); !ok {
                log.Fatalf("Could not create pointer to EquipmentInfos\n")
                return nil
        } else {
          out.equipmentinfos.EquipmentInfo = make([]equipmentinfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *EquipmentInfos) Append(values ...*EquipmentInfo) *EquipmentInfos {
        if t == nil {
                t, _ = EquipmentInfosPointer(EquipmentInfos{})
        }
        /*
        if t.equipmentinfos == nil {
          t.equipmentinfos = equipmentinfos{EquipmentInfo: make([]equipmentinfo, 0)}
        }
        */
        if t.equipmentinfos.EquipmentInfo == nil {
                t.equipmentinfos.EquipmentInfo = make([]equipmentinfo, 0)
        }
        for _, value := range values {
        t.equipmentinfos.EquipmentInfo = append(t.equipmentinfos.EquipmentInfo, value.equipmentinfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *EquipmentInfos) AddNew() *EquipmentInfos {
        if t == nil {
                t, _ = EquipmentInfosPointer(EquipmentInfos{})
        }
        /*
        if t.equipmentinfos == nil {
          t.equipmentinfos = equipmentinfos{EquipmentInfo: make([]equipmentinfo, 0)}
        }
        */
        if t.equipmentinfos.EquipmentInfo == nil {
                t.equipmentinfos.EquipmentInfo = make([]equipmentinfo, 0)
        }
        t.equipmentinfos.EquipmentInfo = append(t.equipmentinfos.EquipmentInfo, equipmentinfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *EquipmentInfos) Last() *equipmentinfo {
  /*
  if t.equipmentinfos == nil {
    t = t.AddNew()
    }
    */
  if t.equipmentinfos.EquipmentInfo == nil {
    t = t.AddNew()
    }
        return &(t.equipmentinfos.EquipmentInfo[len(t.equipmentinfos.EquipmentInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *EquipmentInfos) Index(n int) *EquipmentInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("EquipmentInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.equipmentinfos == nil {
    t = t.AddNew()
    }
    */
  if t.equipmentinfos.EquipmentInfo == nil {
    t = t.AddNew()
    }
        return &EquipmentInfo{(t.equipmentinfos.EquipmentInfo[n])}
}

// Length of the list.
func (t *EquipmentInfos) Len() int {
  /*
  if t.equipmentinfos == nil {
    t = t.AddNew()
    }
    */
  if t.equipmentinfos.EquipmentInfo == nil {
    t = t.AddNew()
    }
        return len(t.equipmentinfos.EquipmentInfo)
}

// Convert list object to slice
func (t *EquipmentInfos) ToSlice() []*EquipmentInfo {
    ret := make([]*EquipmentInfo, 0)
  for _, x:= range t.equipmentinfos.EquipmentInfo {
    ret = append(ret, &EquipmentInfo{equipmentinfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewFinancialAccounts() *FinancialAccounts {
  if out, ok := FinancialAccountsPointer(FinancialAccounts{}); !ok {
                log.Fatalf("Could not create pointer to FinancialAccounts\n")
                return nil
        } else {
          out.financialaccounts.FinancialAccount = make([]financialaccount, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *FinancialAccounts) Append(values ...*FinancialAccount) *FinancialAccounts {
        if t == nil {
                t, _ = FinancialAccountsPointer(FinancialAccounts{})
        }
        /*
        if t.financialaccounts == nil {
          t.financialaccounts = financialaccounts{FinancialAccount: make([]financialaccount, 0)}
        }
        */
        if t.financialaccounts.FinancialAccount == nil {
                t.financialaccounts.FinancialAccount = make([]financialaccount, 0)
        }
        for _, value := range values {
        t.financialaccounts.FinancialAccount = append(t.financialaccounts.FinancialAccount, value.financialaccount)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *FinancialAccounts) AddNew() *FinancialAccounts {
        if t == nil {
                t, _ = FinancialAccountsPointer(FinancialAccounts{})
        }
        /*
        if t.financialaccounts == nil {
          t.financialaccounts = financialaccounts{FinancialAccount: make([]financialaccount, 0)}
        }
        */
        if t.financialaccounts.FinancialAccount == nil {
                t.financialaccounts.FinancialAccount = make([]financialaccount, 0)
        }
        t.financialaccounts.FinancialAccount = append(t.financialaccounts.FinancialAccount, financialaccount{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *FinancialAccounts) Last() *financialaccount {
  /*
  if t.financialaccounts == nil {
    t = t.AddNew()
    }
    */
  if t.financialaccounts.FinancialAccount == nil {
    t = t.AddNew()
    }
        return &(t.financialaccounts.FinancialAccount[len(t.financialaccounts.FinancialAccount)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *FinancialAccounts) Index(n int) *FinancialAccount {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("FinancialAccounts.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.financialaccounts == nil {
    t = t.AddNew()
    }
    */
  if t.financialaccounts.FinancialAccount == nil {
    t = t.AddNew()
    }
        return &FinancialAccount{(t.financialaccounts.FinancialAccount[n])}
}

// Length of the list.
func (t *FinancialAccounts) Len() int {
  /*
  if t.financialaccounts == nil {
    t = t.AddNew()
    }
    */
  if t.financialaccounts.FinancialAccount == nil {
    t = t.AddNew()
    }
        return len(t.financialaccounts.FinancialAccount)
}

// Convert list object to slice
func (t *FinancialAccounts) ToSlice() []*FinancialAccount {
    ret := make([]*FinancialAccount, 0)
  for _, x:= range t.financialaccounts.FinancialAccount {
    ret = append(ret, &FinancialAccount{financialaccount: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewFinancialQuestionnaireCollections() *FinancialQuestionnaireCollections {
  if out, ok := FinancialQuestionnaireCollectionsPointer(FinancialQuestionnaireCollections{}); !ok {
                log.Fatalf("Could not create pointer to FinancialQuestionnaireCollections\n")
                return nil
        } else {
          out.financialquestionnairecollections.FinancialQuestionnaireCollection = make([]financialquestionnairecollection, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *FinancialQuestionnaireCollections) Append(values ...*FinancialQuestionnaireCollection) *FinancialQuestionnaireCollections {
        if t == nil {
                t, _ = FinancialQuestionnaireCollectionsPointer(FinancialQuestionnaireCollections{})
        }
        /*
        if t.financialquestionnairecollections == nil {
          t.financialquestionnairecollections = financialquestionnairecollections{FinancialQuestionnaireCollection: make([]financialquestionnairecollection, 0)}
        }
        */
        if t.financialquestionnairecollections.FinancialQuestionnaireCollection == nil {
                t.financialquestionnairecollections.FinancialQuestionnaireCollection = make([]financialquestionnairecollection, 0)
        }
        for _, value := range values {
        t.financialquestionnairecollections.FinancialQuestionnaireCollection = append(t.financialquestionnairecollections.FinancialQuestionnaireCollection, value.financialquestionnairecollection)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *FinancialQuestionnaireCollections) AddNew() *FinancialQuestionnaireCollections {
        if t == nil {
                t, _ = FinancialQuestionnaireCollectionsPointer(FinancialQuestionnaireCollections{})
        }
        /*
        if t.financialquestionnairecollections == nil {
          t.financialquestionnairecollections = financialquestionnairecollections{FinancialQuestionnaireCollection: make([]financialquestionnairecollection, 0)}
        }
        */
        if t.financialquestionnairecollections.FinancialQuestionnaireCollection == nil {
                t.financialquestionnairecollections.FinancialQuestionnaireCollection = make([]financialquestionnairecollection, 0)
        }
        t.financialquestionnairecollections.FinancialQuestionnaireCollection = append(t.financialquestionnairecollections.FinancialQuestionnaireCollection, financialquestionnairecollection{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *FinancialQuestionnaireCollections) Last() *financialquestionnairecollection {
  /*
  if t.financialquestionnairecollections == nil {
    t = t.AddNew()
    }
    */
  if t.financialquestionnairecollections.FinancialQuestionnaireCollection == nil {
    t = t.AddNew()
    }
        return &(t.financialquestionnairecollections.FinancialQuestionnaireCollection[len(t.financialquestionnairecollections.FinancialQuestionnaireCollection)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *FinancialQuestionnaireCollections) Index(n int) *FinancialQuestionnaireCollection {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("FinancialQuestionnaireCollections.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.financialquestionnairecollections == nil {
    t = t.AddNew()
    }
    */
  if t.financialquestionnairecollections.FinancialQuestionnaireCollection == nil {
    t = t.AddNew()
    }
        return &FinancialQuestionnaireCollection{(t.financialquestionnairecollections.FinancialQuestionnaireCollection[n])}
}

// Length of the list.
func (t *FinancialQuestionnaireCollections) Len() int {
  /*
  if t.financialquestionnairecollections == nil {
    t = t.AddNew()
    }
    */
  if t.financialquestionnairecollections.FinancialQuestionnaireCollection == nil {
    t = t.AddNew()
    }
        return len(t.financialquestionnairecollections.FinancialQuestionnaireCollection)
}

// Convert list object to slice
func (t *FinancialQuestionnaireCollections) ToSlice() []*FinancialQuestionnaireCollection {
    ret := make([]*FinancialQuestionnaireCollection, 0)
  for _, x:= range t.financialquestionnairecollections.FinancialQuestionnaireCollection {
    ret = append(ret, &FinancialQuestionnaireCollection{financialquestionnairecollection: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewGradingAssignmentScores() *GradingAssignmentScores {
  if out, ok := GradingAssignmentScoresPointer(GradingAssignmentScores{}); !ok {
                log.Fatalf("Could not create pointer to GradingAssignmentScores\n")
                return nil
        } else {
          out.gradingassignmentscores.GradingAssignmentScore = make([]gradingassignmentscore, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *GradingAssignmentScores) Append(values ...*GradingAssignmentScore) *GradingAssignmentScores {
        if t == nil {
                t, _ = GradingAssignmentScoresPointer(GradingAssignmentScores{})
        }
        /*
        if t.gradingassignmentscores == nil {
          t.gradingassignmentscores = gradingassignmentscores{GradingAssignmentScore: make([]gradingassignmentscore, 0)}
        }
        */
        if t.gradingassignmentscores.GradingAssignmentScore == nil {
                t.gradingassignmentscores.GradingAssignmentScore = make([]gradingassignmentscore, 0)
        }
        for _, value := range values {
        t.gradingassignmentscores.GradingAssignmentScore = append(t.gradingassignmentscores.GradingAssignmentScore, value.gradingassignmentscore)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *GradingAssignmentScores) AddNew() *GradingAssignmentScores {
        if t == nil {
                t, _ = GradingAssignmentScoresPointer(GradingAssignmentScores{})
        }
        /*
        if t.gradingassignmentscores == nil {
          t.gradingassignmentscores = gradingassignmentscores{GradingAssignmentScore: make([]gradingassignmentscore, 0)}
        }
        */
        if t.gradingassignmentscores.GradingAssignmentScore == nil {
                t.gradingassignmentscores.GradingAssignmentScore = make([]gradingassignmentscore, 0)
        }
        t.gradingassignmentscores.GradingAssignmentScore = append(t.gradingassignmentscores.GradingAssignmentScore, gradingassignmentscore{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *GradingAssignmentScores) Last() *gradingassignmentscore {
  /*
  if t.gradingassignmentscores == nil {
    t = t.AddNew()
    }
    */
  if t.gradingassignmentscores.GradingAssignmentScore == nil {
    t = t.AddNew()
    }
        return &(t.gradingassignmentscores.GradingAssignmentScore[len(t.gradingassignmentscores.GradingAssignmentScore)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *GradingAssignmentScores) Index(n int) *GradingAssignmentScore {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("GradingAssignmentScores.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.gradingassignmentscores == nil {
    t = t.AddNew()
    }
    */
  if t.gradingassignmentscores.GradingAssignmentScore == nil {
    t = t.AddNew()
    }
        return &GradingAssignmentScore{(t.gradingassignmentscores.GradingAssignmentScore[n])}
}

// Length of the list.
func (t *GradingAssignmentScores) Len() int {
  /*
  if t.gradingassignmentscores == nil {
    t = t.AddNew()
    }
    */
  if t.gradingassignmentscores.GradingAssignmentScore == nil {
    t = t.AddNew()
    }
        return len(t.gradingassignmentscores.GradingAssignmentScore)
}

// Convert list object to slice
func (t *GradingAssignmentScores) ToSlice() []*GradingAssignmentScore {
    ret := make([]*GradingAssignmentScore, 0)
  for _, x:= range t.gradingassignmentscores.GradingAssignmentScore {
    ret = append(ret, &GradingAssignmentScore{gradingassignmentscore: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewGradingAssignments() *GradingAssignments {
  if out, ok := GradingAssignmentsPointer(GradingAssignments{}); !ok {
                log.Fatalf("Could not create pointer to GradingAssignments\n")
                return nil
        } else {
          out.gradingassignments.GradingAssignment = make([]gradingassignment, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *GradingAssignments) Append(values ...*GradingAssignment) *GradingAssignments {
        if t == nil {
                t, _ = GradingAssignmentsPointer(GradingAssignments{})
        }
        /*
        if t.gradingassignments == nil {
          t.gradingassignments = gradingassignments{GradingAssignment: make([]gradingassignment, 0)}
        }
        */
        if t.gradingassignments.GradingAssignment == nil {
                t.gradingassignments.GradingAssignment = make([]gradingassignment, 0)
        }
        for _, value := range values {
        t.gradingassignments.GradingAssignment = append(t.gradingassignments.GradingAssignment, value.gradingassignment)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *GradingAssignments) AddNew() *GradingAssignments {
        if t == nil {
                t, _ = GradingAssignmentsPointer(GradingAssignments{})
        }
        /*
        if t.gradingassignments == nil {
          t.gradingassignments = gradingassignments{GradingAssignment: make([]gradingassignment, 0)}
        }
        */
        if t.gradingassignments.GradingAssignment == nil {
                t.gradingassignments.GradingAssignment = make([]gradingassignment, 0)
        }
        t.gradingassignments.GradingAssignment = append(t.gradingassignments.GradingAssignment, gradingassignment{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *GradingAssignments) Last() *gradingassignment {
  /*
  if t.gradingassignments == nil {
    t = t.AddNew()
    }
    */
  if t.gradingassignments.GradingAssignment == nil {
    t = t.AddNew()
    }
        return &(t.gradingassignments.GradingAssignment[len(t.gradingassignments.GradingAssignment)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *GradingAssignments) Index(n int) *GradingAssignment {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("GradingAssignments.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.gradingassignments == nil {
    t = t.AddNew()
    }
    */
  if t.gradingassignments.GradingAssignment == nil {
    t = t.AddNew()
    }
        return &GradingAssignment{(t.gradingassignments.GradingAssignment[n])}
}

// Length of the list.
func (t *GradingAssignments) Len() int {
  /*
  if t.gradingassignments == nil {
    t = t.AddNew()
    }
    */
  if t.gradingassignments.GradingAssignment == nil {
    t = t.AddNew()
    }
        return len(t.gradingassignments.GradingAssignment)
}

// Convert list object to slice
func (t *GradingAssignments) ToSlice() []*GradingAssignment {
    ret := make([]*GradingAssignment, 0)
  for _, x:= range t.gradingassignments.GradingAssignment {
    ret = append(ret, &GradingAssignment{gradingassignment: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewIdentitys() *Identitys {
  if out, ok := IdentitysPointer(Identitys{}); !ok {
                log.Fatalf("Could not create pointer to Identitys\n")
                return nil
        } else {
          out.identitys.Identity = make([]identity, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *Identitys) Append(values ...*Identity) *Identitys {
        if t == nil {
                t, _ = IdentitysPointer(Identitys{})
        }
        /*
        if t.identitys == nil {
          t.identitys = identitys{Identity: make([]identity, 0)}
        }
        */
        if t.identitys.Identity == nil {
                t.identitys.Identity = make([]identity, 0)
        }
        for _, value := range values {
        t.identitys.Identity = append(t.identitys.Identity, value.identity)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *Identitys) AddNew() *Identitys {
        if t == nil {
                t, _ = IdentitysPointer(Identitys{})
        }
        /*
        if t.identitys == nil {
          t.identitys = identitys{Identity: make([]identity, 0)}
        }
        */
        if t.identitys.Identity == nil {
                t.identitys.Identity = make([]identity, 0)
        }
        t.identitys.Identity = append(t.identitys.Identity, identity{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *Identitys) Last() *identity {
  /*
  if t.identitys == nil {
    t = t.AddNew()
    }
    */
  if t.identitys.Identity == nil {
    t = t.AddNew()
    }
        return &(t.identitys.Identity[len(t.identitys.Identity)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *Identitys) Index(n int) *Identity {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("Identitys.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.identitys == nil {
    t = t.AddNew()
    }
    */
  if t.identitys.Identity == nil {
    t = t.AddNew()
    }
        return &Identity{(t.identitys.Identity[n])}
}

// Length of the list.
func (t *Identitys) Len() int {
  /*
  if t.identitys == nil {
    t = t.AddNew()
    }
    */
  if t.identitys.Identity == nil {
    t = t.AddNew()
    }
        return len(t.identitys.Identity)
}

// Convert list object to slice
func (t *Identitys) ToSlice() []*Identity {
    ret := make([]*Identity, 0)
  for _, x:= range t.identitys.Identity {
    ret = append(ret, &Identity{identity: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewInvoices() *Invoices {
  if out, ok := InvoicesPointer(Invoices{}); !ok {
                log.Fatalf("Could not create pointer to Invoices\n")
                return nil
        } else {
          out.invoices.Invoice = make([]invoice, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *Invoices) Append(values ...*Invoice) *Invoices {
        if t == nil {
                t, _ = InvoicesPointer(Invoices{})
        }
        /*
        if t.invoices == nil {
          t.invoices = invoices{Invoice: make([]invoice, 0)}
        }
        */
        if t.invoices.Invoice == nil {
                t.invoices.Invoice = make([]invoice, 0)
        }
        for _, value := range values {
        t.invoices.Invoice = append(t.invoices.Invoice, value.invoice)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *Invoices) AddNew() *Invoices {
        if t == nil {
                t, _ = InvoicesPointer(Invoices{})
        }
        /*
        if t.invoices == nil {
          t.invoices = invoices{Invoice: make([]invoice, 0)}
        }
        */
        if t.invoices.Invoice == nil {
                t.invoices.Invoice = make([]invoice, 0)
        }
        t.invoices.Invoice = append(t.invoices.Invoice, invoice{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *Invoices) Last() *invoice {
  /*
  if t.invoices == nil {
    t = t.AddNew()
    }
    */
  if t.invoices.Invoice == nil {
    t = t.AddNew()
    }
        return &(t.invoices.Invoice[len(t.invoices.Invoice)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *Invoices) Index(n int) *Invoice {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("Invoices.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.invoices == nil {
    t = t.AddNew()
    }
    */
  if t.invoices.Invoice == nil {
    t = t.AddNew()
    }
        return &Invoice{(t.invoices.Invoice[n])}
}

// Length of the list.
func (t *Invoices) Len() int {
  /*
  if t.invoices == nil {
    t = t.AddNew()
    }
    */
  if t.invoices.Invoice == nil {
    t = t.AddNew()
    }
        return len(t.invoices.Invoice)
}

// Convert list object to slice
func (t *Invoices) ToSlice() []*Invoice {
    ret := make([]*Invoice, 0)
  for _, x:= range t.invoices.Invoice {
    ret = append(ret, &Invoice{invoice: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewJournals() *Journals {
  if out, ok := JournalsPointer(Journals{}); !ok {
                log.Fatalf("Could not create pointer to Journals\n")
                return nil
        } else {
          out.journals.Journal = make([]journal, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *Journals) Append(values ...*Journal) *Journals {
        if t == nil {
                t, _ = JournalsPointer(Journals{})
        }
        /*
        if t.journals == nil {
          t.journals = journals{Journal: make([]journal, 0)}
        }
        */
        if t.journals.Journal == nil {
                t.journals.Journal = make([]journal, 0)
        }
        for _, value := range values {
        t.journals.Journal = append(t.journals.Journal, value.journal)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *Journals) AddNew() *Journals {
        if t == nil {
                t, _ = JournalsPointer(Journals{})
        }
        /*
        if t.journals == nil {
          t.journals = journals{Journal: make([]journal, 0)}
        }
        */
        if t.journals.Journal == nil {
                t.journals.Journal = make([]journal, 0)
        }
        t.journals.Journal = append(t.journals.Journal, journal{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *Journals) Last() *journal {
  /*
  if t.journals == nil {
    t = t.AddNew()
    }
    */
  if t.journals.Journal == nil {
    t = t.AddNew()
    }
        return &(t.journals.Journal[len(t.journals.Journal)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *Journals) Index(n int) *Journal {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("Journals.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.journals == nil {
    t = t.AddNew()
    }
    */
  if t.journals.Journal == nil {
    t = t.AddNew()
    }
        return &Journal{(t.journals.Journal[n])}
}

// Length of the list.
func (t *Journals) Len() int {
  /*
  if t.journals == nil {
    t = t.AddNew()
    }
    */
  if t.journals.Journal == nil {
    t = t.AddNew()
    }
        return len(t.journals.Journal)
}

// Convert list object to slice
func (t *Journals) ToSlice() []*Journal {
    ret := make([]*Journal, 0)
  for _, x:= range t.journals.Journal {
    ret = append(ret, &Journal{journal: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewLEAInfos() *LEAInfos {
  if out, ok := LEAInfosPointer(LEAInfos{}); !ok {
                log.Fatalf("Could not create pointer to LEAInfos\n")
                return nil
        } else {
          out.leainfos.LEAInfo = make([]leainfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LEAInfos) Append(values ...*LEAInfo) *LEAInfos {
        if t == nil {
                t, _ = LEAInfosPointer(LEAInfos{})
        }
        /*
        if t.leainfos == nil {
          t.leainfos = leainfos{LEAInfo: make([]leainfo, 0)}
        }
        */
        if t.leainfos.LEAInfo == nil {
                t.leainfos.LEAInfo = make([]leainfo, 0)
        }
        for _, value := range values {
        t.leainfos.LEAInfo = append(t.leainfos.LEAInfo, value.leainfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LEAInfos) AddNew() *LEAInfos {
        if t == nil {
                t, _ = LEAInfosPointer(LEAInfos{})
        }
        /*
        if t.leainfos == nil {
          t.leainfos = leainfos{LEAInfo: make([]leainfo, 0)}
        }
        */
        if t.leainfos.LEAInfo == nil {
                t.leainfos.LEAInfo = make([]leainfo, 0)
        }
        t.leainfos.LEAInfo = append(t.leainfos.LEAInfo, leainfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LEAInfos) Last() *leainfo {
  /*
  if t.leainfos == nil {
    t = t.AddNew()
    }
    */
  if t.leainfos.LEAInfo == nil {
    t = t.AddNew()
    }
        return &(t.leainfos.LEAInfo[len(t.leainfos.LEAInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *LEAInfos) Index(n int) *LEAInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LEAInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.leainfos == nil {
    t = t.AddNew()
    }
    */
  if t.leainfos.LEAInfo == nil {
    t = t.AddNew()
    }
        return &LEAInfo{(t.leainfos.LEAInfo[n])}
}

// Length of the list.
func (t *LEAInfos) Len() int {
  /*
  if t.leainfos == nil {
    t = t.AddNew()
    }
    */
  if t.leainfos.LEAInfo == nil {
    t = t.AddNew()
    }
        return len(t.leainfos.LEAInfo)
}

// Convert list object to slice
func (t *LEAInfos) ToSlice() []*LEAInfo {
    ret := make([]*LEAInfo, 0)
  for _, x:= range t.leainfos.LEAInfo {
    ret = append(ret, &LEAInfo{leainfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewLearningResources() *LearningResources {
  if out, ok := LearningResourcesPointer(LearningResources{}); !ok {
                log.Fatalf("Could not create pointer to LearningResources\n")
                return nil
        } else {
          out.learningresources.LearningResource = make([]learningresource, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LearningResources) Append(values ...*LearningResource) *LearningResources {
        if t == nil {
                t, _ = LearningResourcesPointer(LearningResources{})
        }
        /*
        if t.learningresources == nil {
          t.learningresources = learningresources{LearningResource: make([]learningresource, 0)}
        }
        */
        if t.learningresources.LearningResource == nil {
                t.learningresources.LearningResource = make([]learningresource, 0)
        }
        for _, value := range values {
        t.learningresources.LearningResource = append(t.learningresources.LearningResource, value.learningresource)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LearningResources) AddNew() *LearningResources {
        if t == nil {
                t, _ = LearningResourcesPointer(LearningResources{})
        }
        /*
        if t.learningresources == nil {
          t.learningresources = learningresources{LearningResource: make([]learningresource, 0)}
        }
        */
        if t.learningresources.LearningResource == nil {
                t.learningresources.LearningResource = make([]learningresource, 0)
        }
        t.learningresources.LearningResource = append(t.learningresources.LearningResource, learningresource{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LearningResources) Last() *learningresource {
  /*
  if t.learningresources == nil {
    t = t.AddNew()
    }
    */
  if t.learningresources.LearningResource == nil {
    t = t.AddNew()
    }
        return &(t.learningresources.LearningResource[len(t.learningresources.LearningResource)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *LearningResources) Index(n int) *LearningResource {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LearningResources.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.learningresources == nil {
    t = t.AddNew()
    }
    */
  if t.learningresources.LearningResource == nil {
    t = t.AddNew()
    }
        return &LearningResource{(t.learningresources.LearningResource[n])}
}

// Length of the list.
func (t *LearningResources) Len() int {
  /*
  if t.learningresources == nil {
    t = t.AddNew()
    }
    */
  if t.learningresources.LearningResource == nil {
    t = t.AddNew()
    }
        return len(t.learningresources.LearningResource)
}

// Convert list object to slice
func (t *LearningResources) ToSlice() []*LearningResource {
    ret := make([]*LearningResource, 0)
  for _, x:= range t.learningresources.LearningResource {
    ret = append(ret, &LearningResource{learningresource: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewLearningStandardDocuments() *LearningStandardDocuments {
  if out, ok := LearningStandardDocumentsPointer(LearningStandardDocuments{}); !ok {
                log.Fatalf("Could not create pointer to LearningStandardDocuments\n")
                return nil
        } else {
          out.learningstandarddocuments.LearningStandardDocument = make([]learningstandarddocument, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LearningStandardDocuments) Append(values ...*LearningStandardDocument) *LearningStandardDocuments {
        if t == nil {
                t, _ = LearningStandardDocumentsPointer(LearningStandardDocuments{})
        }
        /*
        if t.learningstandarddocuments == nil {
          t.learningstandarddocuments = learningstandarddocuments{LearningStandardDocument: make([]learningstandarddocument, 0)}
        }
        */
        if t.learningstandarddocuments.LearningStandardDocument == nil {
                t.learningstandarddocuments.LearningStandardDocument = make([]learningstandarddocument, 0)
        }
        for _, value := range values {
        t.learningstandarddocuments.LearningStandardDocument = append(t.learningstandarddocuments.LearningStandardDocument, value.learningstandarddocument)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LearningStandardDocuments) AddNew() *LearningStandardDocuments {
        if t == nil {
                t, _ = LearningStandardDocumentsPointer(LearningStandardDocuments{})
        }
        /*
        if t.learningstandarddocuments == nil {
          t.learningstandarddocuments = learningstandarddocuments{LearningStandardDocument: make([]learningstandarddocument, 0)}
        }
        */
        if t.learningstandarddocuments.LearningStandardDocument == nil {
                t.learningstandarddocuments.LearningStandardDocument = make([]learningstandarddocument, 0)
        }
        t.learningstandarddocuments.LearningStandardDocument = append(t.learningstandarddocuments.LearningStandardDocument, learningstandarddocument{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LearningStandardDocuments) Last() *learningstandarddocument {
  /*
  if t.learningstandarddocuments == nil {
    t = t.AddNew()
    }
    */
  if t.learningstandarddocuments.LearningStandardDocument == nil {
    t = t.AddNew()
    }
        return &(t.learningstandarddocuments.LearningStandardDocument[len(t.learningstandarddocuments.LearningStandardDocument)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *LearningStandardDocuments) Index(n int) *LearningStandardDocument {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LearningStandardDocuments.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.learningstandarddocuments == nil {
    t = t.AddNew()
    }
    */
  if t.learningstandarddocuments.LearningStandardDocument == nil {
    t = t.AddNew()
    }
        return &LearningStandardDocument{(t.learningstandarddocuments.LearningStandardDocument[n])}
}

// Length of the list.
func (t *LearningStandardDocuments) Len() int {
  /*
  if t.learningstandarddocuments == nil {
    t = t.AddNew()
    }
    */
  if t.learningstandarddocuments.LearningStandardDocument == nil {
    t = t.AddNew()
    }
        return len(t.learningstandarddocuments.LearningStandardDocument)
}

// Convert list object to slice
func (t *LearningStandardDocuments) ToSlice() []*LearningStandardDocument {
    ret := make([]*LearningStandardDocument, 0)
  for _, x:= range t.learningstandarddocuments.LearningStandardDocument {
    ret = append(ret, &LearningStandardDocument{learningstandarddocument: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewLearningStandardItems() *LearningStandardItems {
  if out, ok := LearningStandardItemsPointer(LearningStandardItems{}); !ok {
                log.Fatalf("Could not create pointer to LearningStandardItems\n")
                return nil
        } else {
          out.learningstandarditems.LearningStandardItem = make([]learningstandarditem, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LearningStandardItems) Append(values ...*LearningStandardItem) *LearningStandardItems {
        if t == nil {
                t, _ = LearningStandardItemsPointer(LearningStandardItems{})
        }
        /*
        if t.learningstandarditems == nil {
          t.learningstandarditems = learningstandarditems{LearningStandardItem: make([]learningstandarditem, 0)}
        }
        */
        if t.learningstandarditems.LearningStandardItem == nil {
                t.learningstandarditems.LearningStandardItem = make([]learningstandarditem, 0)
        }
        for _, value := range values {
        t.learningstandarditems.LearningStandardItem = append(t.learningstandarditems.LearningStandardItem, value.learningstandarditem)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LearningStandardItems) AddNew() *LearningStandardItems {
        if t == nil {
                t, _ = LearningStandardItemsPointer(LearningStandardItems{})
        }
        /*
        if t.learningstandarditems == nil {
          t.learningstandarditems = learningstandarditems{LearningStandardItem: make([]learningstandarditem, 0)}
        }
        */
        if t.learningstandarditems.LearningStandardItem == nil {
                t.learningstandarditems.LearningStandardItem = make([]learningstandarditem, 0)
        }
        t.learningstandarditems.LearningStandardItem = append(t.learningstandarditems.LearningStandardItem, learningstandarditem{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LearningStandardItems) Last() *learningstandarditem {
  /*
  if t.learningstandarditems == nil {
    t = t.AddNew()
    }
    */
  if t.learningstandarditems.LearningStandardItem == nil {
    t = t.AddNew()
    }
        return &(t.learningstandarditems.LearningStandardItem[len(t.learningstandarditems.LearningStandardItem)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *LearningStandardItems) Index(n int) *LearningStandardItem {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LearningStandardItems.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.learningstandarditems == nil {
    t = t.AddNew()
    }
    */
  if t.learningstandarditems.LearningStandardItem == nil {
    t = t.AddNew()
    }
        return &LearningStandardItem{(t.learningstandarditems.LearningStandardItem[n])}
}

// Length of the list.
func (t *LearningStandardItems) Len() int {
  /*
  if t.learningstandarditems == nil {
    t = t.AddNew()
    }
    */
  if t.learningstandarditems.LearningStandardItem == nil {
    t = t.AddNew()
    }
        return len(t.learningstandarditems.LearningStandardItem)
}

// Convert list object to slice
func (t *LearningStandardItems) ToSlice() []*LearningStandardItem {
    ret := make([]*LearningStandardItem, 0)
  for _, x:= range t.learningstandarditems.LearningStandardItem {
    ret = append(ret, &LearningStandardItem{learningstandarditem: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewLibraryPatronStatuss() *LibraryPatronStatuss {
  if out, ok := LibraryPatronStatussPointer(LibraryPatronStatuss{}); !ok {
                log.Fatalf("Could not create pointer to LibraryPatronStatuss\n")
                return nil
        } else {
          out.librarypatronstatuss.LibraryPatronStatus = make([]librarypatronstatus, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *LibraryPatronStatuss) Append(values ...*LibraryPatronStatus) *LibraryPatronStatuss {
        if t == nil {
                t, _ = LibraryPatronStatussPointer(LibraryPatronStatuss{})
        }
        /*
        if t.librarypatronstatuss == nil {
          t.librarypatronstatuss = librarypatronstatuss{LibraryPatronStatus: make([]librarypatronstatus, 0)}
        }
        */
        if t.librarypatronstatuss.LibraryPatronStatus == nil {
                t.librarypatronstatuss.LibraryPatronStatus = make([]librarypatronstatus, 0)
        }
        for _, value := range values {
        t.librarypatronstatuss.LibraryPatronStatus = append(t.librarypatronstatuss.LibraryPatronStatus, value.librarypatronstatus)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *LibraryPatronStatuss) AddNew() *LibraryPatronStatuss {
        if t == nil {
                t, _ = LibraryPatronStatussPointer(LibraryPatronStatuss{})
        }
        /*
        if t.librarypatronstatuss == nil {
          t.librarypatronstatuss = librarypatronstatuss{LibraryPatronStatus: make([]librarypatronstatus, 0)}
        }
        */
        if t.librarypatronstatuss.LibraryPatronStatus == nil {
                t.librarypatronstatuss.LibraryPatronStatus = make([]librarypatronstatus, 0)
        }
        t.librarypatronstatuss.LibraryPatronStatus = append(t.librarypatronstatuss.LibraryPatronStatus, librarypatronstatus{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *LibraryPatronStatuss) Last() *librarypatronstatus {
  /*
  if t.librarypatronstatuss == nil {
    t = t.AddNew()
    }
    */
  if t.librarypatronstatuss.LibraryPatronStatus == nil {
    t = t.AddNew()
    }
        return &(t.librarypatronstatuss.LibraryPatronStatus[len(t.librarypatronstatuss.LibraryPatronStatus)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *LibraryPatronStatuss) Index(n int) *LibraryPatronStatus {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("LibraryPatronStatuss.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.librarypatronstatuss == nil {
    t = t.AddNew()
    }
    */
  if t.librarypatronstatuss.LibraryPatronStatus == nil {
    t = t.AddNew()
    }
        return &LibraryPatronStatus{(t.librarypatronstatuss.LibraryPatronStatus[n])}
}

// Length of the list.
func (t *LibraryPatronStatuss) Len() int {
  /*
  if t.librarypatronstatuss == nil {
    t = t.AddNew()
    }
    */
  if t.librarypatronstatuss.LibraryPatronStatus == nil {
    t = t.AddNew()
    }
        return len(t.librarypatronstatuss.LibraryPatronStatus)
}

// Convert list object to slice
func (t *LibraryPatronStatuss) ToSlice() []*LibraryPatronStatus {
    ret := make([]*LibraryPatronStatus, 0)
  for _, x:= range t.librarypatronstatuss.LibraryPatronStatus {
    ret = append(ret, &LibraryPatronStatus{librarypatronstatus: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewMarkValueInfos() *MarkValueInfos {
  if out, ok := MarkValueInfosPointer(MarkValueInfos{}); !ok {
                log.Fatalf("Could not create pointer to MarkValueInfos\n")
                return nil
        } else {
          out.markvalueinfos.MarkValueInfo = make([]markvalueinfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *MarkValueInfos) Append(values ...*MarkValueInfo) *MarkValueInfos {
        if t == nil {
                t, _ = MarkValueInfosPointer(MarkValueInfos{})
        }
        /*
        if t.markvalueinfos == nil {
          t.markvalueinfos = markvalueinfos{MarkValueInfo: make([]markvalueinfo, 0)}
        }
        */
        if t.markvalueinfos.MarkValueInfo == nil {
                t.markvalueinfos.MarkValueInfo = make([]markvalueinfo, 0)
        }
        for _, value := range values {
        t.markvalueinfos.MarkValueInfo = append(t.markvalueinfos.MarkValueInfo, value.markvalueinfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *MarkValueInfos) AddNew() *MarkValueInfos {
        if t == nil {
                t, _ = MarkValueInfosPointer(MarkValueInfos{})
        }
        /*
        if t.markvalueinfos == nil {
          t.markvalueinfos = markvalueinfos{MarkValueInfo: make([]markvalueinfo, 0)}
        }
        */
        if t.markvalueinfos.MarkValueInfo == nil {
                t.markvalueinfos.MarkValueInfo = make([]markvalueinfo, 0)
        }
        t.markvalueinfos.MarkValueInfo = append(t.markvalueinfos.MarkValueInfo, markvalueinfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *MarkValueInfos) Last() *markvalueinfo {
  /*
  if t.markvalueinfos == nil {
    t = t.AddNew()
    }
    */
  if t.markvalueinfos.MarkValueInfo == nil {
    t = t.AddNew()
    }
        return &(t.markvalueinfos.MarkValueInfo[len(t.markvalueinfos.MarkValueInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *MarkValueInfos) Index(n int) *MarkValueInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("MarkValueInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.markvalueinfos == nil {
    t = t.AddNew()
    }
    */
  if t.markvalueinfos.MarkValueInfo == nil {
    t = t.AddNew()
    }
        return &MarkValueInfo{(t.markvalueinfos.MarkValueInfo[n])}
}

// Length of the list.
func (t *MarkValueInfos) Len() int {
  /*
  if t.markvalueinfos == nil {
    t = t.AddNew()
    }
    */
  if t.markvalueinfos.MarkValueInfo == nil {
    t = t.AddNew()
    }
        return len(t.markvalueinfos.MarkValueInfo)
}

// Convert list object to slice
func (t *MarkValueInfos) ToSlice() []*MarkValueInfo {
    ret := make([]*MarkValueInfo, 0)
  for _, x:= range t.markvalueinfos.MarkValueInfo {
    ret = append(ret, &MarkValueInfo{markvalueinfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewNAPCodeFrames() *NAPCodeFrames {
  if out, ok := NAPCodeFramesPointer(NAPCodeFrames{}); !ok {
                log.Fatalf("Could not create pointer to NAPCodeFrames\n")
                return nil
        } else {
          out.napcodeframes.NAPCodeFrame = make([]napcodeframe, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPCodeFrames) Append(values ...*NAPCodeFrame) *NAPCodeFrames {
        if t == nil {
                t, _ = NAPCodeFramesPointer(NAPCodeFrames{})
        }
        /*
        if t.napcodeframes == nil {
          t.napcodeframes = napcodeframes{NAPCodeFrame: make([]napcodeframe, 0)}
        }
        */
        if t.napcodeframes.NAPCodeFrame == nil {
                t.napcodeframes.NAPCodeFrame = make([]napcodeframe, 0)
        }
        for _, value := range values {
        t.napcodeframes.NAPCodeFrame = append(t.napcodeframes.NAPCodeFrame, value.napcodeframe)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPCodeFrames) AddNew() *NAPCodeFrames {
        if t == nil {
                t, _ = NAPCodeFramesPointer(NAPCodeFrames{})
        }
        /*
        if t.napcodeframes == nil {
          t.napcodeframes = napcodeframes{NAPCodeFrame: make([]napcodeframe, 0)}
        }
        */
        if t.napcodeframes.NAPCodeFrame == nil {
                t.napcodeframes.NAPCodeFrame = make([]napcodeframe, 0)
        }
        t.napcodeframes.NAPCodeFrame = append(t.napcodeframes.NAPCodeFrame, napcodeframe{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPCodeFrames) Last() *napcodeframe {
  /*
  if t.napcodeframes == nil {
    t = t.AddNew()
    }
    */
  if t.napcodeframes.NAPCodeFrame == nil {
    t = t.AddNew()
    }
        return &(t.napcodeframes.NAPCodeFrame[len(t.napcodeframes.NAPCodeFrame)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *NAPCodeFrames) Index(n int) *NAPCodeFrame {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPCodeFrames.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.napcodeframes == nil {
    t = t.AddNew()
    }
    */
  if t.napcodeframes.NAPCodeFrame == nil {
    t = t.AddNew()
    }
        return &NAPCodeFrame{(t.napcodeframes.NAPCodeFrame[n])}
}

// Length of the list.
func (t *NAPCodeFrames) Len() int {
  /*
  if t.napcodeframes == nil {
    t = t.AddNew()
    }
    */
  if t.napcodeframes.NAPCodeFrame == nil {
    t = t.AddNew()
    }
        return len(t.napcodeframes.NAPCodeFrame)
}

// Convert list object to slice
func (t *NAPCodeFrames) ToSlice() []*NAPCodeFrame {
    ret := make([]*NAPCodeFrame, 0)
  for _, x:= range t.napcodeframes.NAPCodeFrame {
    ret = append(ret, &NAPCodeFrame{napcodeframe: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewNAPEventStudentLinks() *NAPEventStudentLinks {
  if out, ok := NAPEventStudentLinksPointer(NAPEventStudentLinks{}); !ok {
                log.Fatalf("Could not create pointer to NAPEventStudentLinks\n")
                return nil
        } else {
          out.napeventstudentlinks.NAPEventStudentLink = make([]napeventstudentlink, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPEventStudentLinks) Append(values ...*NAPEventStudentLink) *NAPEventStudentLinks {
        if t == nil {
                t, _ = NAPEventStudentLinksPointer(NAPEventStudentLinks{})
        }
        /*
        if t.napeventstudentlinks == nil {
          t.napeventstudentlinks = napeventstudentlinks{NAPEventStudentLink: make([]napeventstudentlink, 0)}
        }
        */
        if t.napeventstudentlinks.NAPEventStudentLink == nil {
                t.napeventstudentlinks.NAPEventStudentLink = make([]napeventstudentlink, 0)
        }
        for _, value := range values {
        t.napeventstudentlinks.NAPEventStudentLink = append(t.napeventstudentlinks.NAPEventStudentLink, value.napeventstudentlink)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPEventStudentLinks) AddNew() *NAPEventStudentLinks {
        if t == nil {
                t, _ = NAPEventStudentLinksPointer(NAPEventStudentLinks{})
        }
        /*
        if t.napeventstudentlinks == nil {
          t.napeventstudentlinks = napeventstudentlinks{NAPEventStudentLink: make([]napeventstudentlink, 0)}
        }
        */
        if t.napeventstudentlinks.NAPEventStudentLink == nil {
                t.napeventstudentlinks.NAPEventStudentLink = make([]napeventstudentlink, 0)
        }
        t.napeventstudentlinks.NAPEventStudentLink = append(t.napeventstudentlinks.NAPEventStudentLink, napeventstudentlink{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPEventStudentLinks) Last() *napeventstudentlink {
  /*
  if t.napeventstudentlinks == nil {
    t = t.AddNew()
    }
    */
  if t.napeventstudentlinks.NAPEventStudentLink == nil {
    t = t.AddNew()
    }
        return &(t.napeventstudentlinks.NAPEventStudentLink[len(t.napeventstudentlinks.NAPEventStudentLink)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *NAPEventStudentLinks) Index(n int) *NAPEventStudentLink {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPEventStudentLinks.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.napeventstudentlinks == nil {
    t = t.AddNew()
    }
    */
  if t.napeventstudentlinks.NAPEventStudentLink == nil {
    t = t.AddNew()
    }
        return &NAPEventStudentLink{(t.napeventstudentlinks.NAPEventStudentLink[n])}
}

// Length of the list.
func (t *NAPEventStudentLinks) Len() int {
  /*
  if t.napeventstudentlinks == nil {
    t = t.AddNew()
    }
    */
  if t.napeventstudentlinks.NAPEventStudentLink == nil {
    t = t.AddNew()
    }
        return len(t.napeventstudentlinks.NAPEventStudentLink)
}

// Convert list object to slice
func (t *NAPEventStudentLinks) ToSlice() []*NAPEventStudentLink {
    ret := make([]*NAPEventStudentLink, 0)
  for _, x:= range t.napeventstudentlinks.NAPEventStudentLink {
    ret = append(ret, &NAPEventStudentLink{napeventstudentlink: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewNAPStudentResponseSets() *NAPStudentResponseSets {
  if out, ok := NAPStudentResponseSetsPointer(NAPStudentResponseSets{}); !ok {
                log.Fatalf("Could not create pointer to NAPStudentResponseSets\n")
                return nil
        } else {
          out.napstudentresponsesets.NAPStudentResponseSet = make([]napstudentresponseset, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPStudentResponseSets) Append(values ...*NAPStudentResponseSet) *NAPStudentResponseSets {
        if t == nil {
                t, _ = NAPStudentResponseSetsPointer(NAPStudentResponseSets{})
        }
        /*
        if t.napstudentresponsesets == nil {
          t.napstudentresponsesets = napstudentresponsesets{NAPStudentResponseSet: make([]napstudentresponseset, 0)}
        }
        */
        if t.napstudentresponsesets.NAPStudentResponseSet == nil {
                t.napstudentresponsesets.NAPStudentResponseSet = make([]napstudentresponseset, 0)
        }
        for _, value := range values {
        t.napstudentresponsesets.NAPStudentResponseSet = append(t.napstudentresponsesets.NAPStudentResponseSet, value.napstudentresponseset)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPStudentResponseSets) AddNew() *NAPStudentResponseSets {
        if t == nil {
                t, _ = NAPStudentResponseSetsPointer(NAPStudentResponseSets{})
        }
        /*
        if t.napstudentresponsesets == nil {
          t.napstudentresponsesets = napstudentresponsesets{NAPStudentResponseSet: make([]napstudentresponseset, 0)}
        }
        */
        if t.napstudentresponsesets.NAPStudentResponseSet == nil {
                t.napstudentresponsesets.NAPStudentResponseSet = make([]napstudentresponseset, 0)
        }
        t.napstudentresponsesets.NAPStudentResponseSet = append(t.napstudentresponsesets.NAPStudentResponseSet, napstudentresponseset{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPStudentResponseSets) Last() *napstudentresponseset {
  /*
  if t.napstudentresponsesets == nil {
    t = t.AddNew()
    }
    */
  if t.napstudentresponsesets.NAPStudentResponseSet == nil {
    t = t.AddNew()
    }
        return &(t.napstudentresponsesets.NAPStudentResponseSet[len(t.napstudentresponsesets.NAPStudentResponseSet)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *NAPStudentResponseSets) Index(n int) *NAPStudentResponseSet {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPStudentResponseSets.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.napstudentresponsesets == nil {
    t = t.AddNew()
    }
    */
  if t.napstudentresponsesets.NAPStudentResponseSet == nil {
    t = t.AddNew()
    }
        return &NAPStudentResponseSet{(t.napstudentresponsesets.NAPStudentResponseSet[n])}
}

// Length of the list.
func (t *NAPStudentResponseSets) Len() int {
  /*
  if t.napstudentresponsesets == nil {
    t = t.AddNew()
    }
    */
  if t.napstudentresponsesets.NAPStudentResponseSet == nil {
    t = t.AddNew()
    }
        return len(t.napstudentresponsesets.NAPStudentResponseSet)
}

// Convert list object to slice
func (t *NAPStudentResponseSets) ToSlice() []*NAPStudentResponseSet {
    ret := make([]*NAPStudentResponseSet, 0)
  for _, x:= range t.napstudentresponsesets.NAPStudentResponseSet {
    ret = append(ret, &NAPStudentResponseSet{napstudentresponseset: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewNAPTestItems() *NAPTestItems {
  if out, ok := NAPTestItemsPointer(NAPTestItems{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestItems\n")
                return nil
        } else {
          out.naptestitems.NAPTestItem = make([]naptestitem, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPTestItems) Append(values ...*NAPTestItem) *NAPTestItems {
        if t == nil {
                t, _ = NAPTestItemsPointer(NAPTestItems{})
        }
        /*
        if t.naptestitems == nil {
          t.naptestitems = naptestitems{NAPTestItem: make([]naptestitem, 0)}
        }
        */
        if t.naptestitems.NAPTestItem == nil {
                t.naptestitems.NAPTestItem = make([]naptestitem, 0)
        }
        for _, value := range values {
        t.naptestitems.NAPTestItem = append(t.naptestitems.NAPTestItem, value.naptestitem)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPTestItems) AddNew() *NAPTestItems {
        if t == nil {
                t, _ = NAPTestItemsPointer(NAPTestItems{})
        }
        /*
        if t.naptestitems == nil {
          t.naptestitems = naptestitems{NAPTestItem: make([]naptestitem, 0)}
        }
        */
        if t.naptestitems.NAPTestItem == nil {
                t.naptestitems.NAPTestItem = make([]naptestitem, 0)
        }
        t.naptestitems.NAPTestItem = append(t.naptestitems.NAPTestItem, naptestitem{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPTestItems) Last() *naptestitem {
  /*
  if t.naptestitems == nil {
    t = t.AddNew()
    }
    */
  if t.naptestitems.NAPTestItem == nil {
    t = t.AddNew()
    }
        return &(t.naptestitems.NAPTestItem[len(t.naptestitems.NAPTestItem)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *NAPTestItems) Index(n int) *NAPTestItem {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPTestItems.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.naptestitems == nil {
    t = t.AddNew()
    }
    */
  if t.naptestitems.NAPTestItem == nil {
    t = t.AddNew()
    }
        return &NAPTestItem{(t.naptestitems.NAPTestItem[n])}
}

// Length of the list.
func (t *NAPTestItems) Len() int {
  /*
  if t.naptestitems == nil {
    t = t.AddNew()
    }
    */
  if t.naptestitems.NAPTestItem == nil {
    t = t.AddNew()
    }
        return len(t.naptestitems.NAPTestItem)
}

// Convert list object to slice
func (t *NAPTestItems) ToSlice() []*NAPTestItem {
    ret := make([]*NAPTestItem, 0)
  for _, x:= range t.naptestitems.NAPTestItem {
    ret = append(ret, &NAPTestItem{naptestitem: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewNAPTestScoreSummarys() *NAPTestScoreSummarys {
  if out, ok := NAPTestScoreSummarysPointer(NAPTestScoreSummarys{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestScoreSummarys\n")
                return nil
        } else {
          out.naptestscoresummarys.NAPTestScoreSummary = make([]naptestscoresummary, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPTestScoreSummarys) Append(values ...*NAPTestScoreSummary) *NAPTestScoreSummarys {
        if t == nil {
                t, _ = NAPTestScoreSummarysPointer(NAPTestScoreSummarys{})
        }
        /*
        if t.naptestscoresummarys == nil {
          t.naptestscoresummarys = naptestscoresummarys{NAPTestScoreSummary: make([]naptestscoresummary, 0)}
        }
        */
        if t.naptestscoresummarys.NAPTestScoreSummary == nil {
                t.naptestscoresummarys.NAPTestScoreSummary = make([]naptestscoresummary, 0)
        }
        for _, value := range values {
        t.naptestscoresummarys.NAPTestScoreSummary = append(t.naptestscoresummarys.NAPTestScoreSummary, value.naptestscoresummary)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPTestScoreSummarys) AddNew() *NAPTestScoreSummarys {
        if t == nil {
                t, _ = NAPTestScoreSummarysPointer(NAPTestScoreSummarys{})
        }
        /*
        if t.naptestscoresummarys == nil {
          t.naptestscoresummarys = naptestscoresummarys{NAPTestScoreSummary: make([]naptestscoresummary, 0)}
        }
        */
        if t.naptestscoresummarys.NAPTestScoreSummary == nil {
                t.naptestscoresummarys.NAPTestScoreSummary = make([]naptestscoresummary, 0)
        }
        t.naptestscoresummarys.NAPTestScoreSummary = append(t.naptestscoresummarys.NAPTestScoreSummary, naptestscoresummary{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPTestScoreSummarys) Last() *naptestscoresummary {
  /*
  if t.naptestscoresummarys == nil {
    t = t.AddNew()
    }
    */
  if t.naptestscoresummarys.NAPTestScoreSummary == nil {
    t = t.AddNew()
    }
        return &(t.naptestscoresummarys.NAPTestScoreSummary[len(t.naptestscoresummarys.NAPTestScoreSummary)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *NAPTestScoreSummarys) Index(n int) *NAPTestScoreSummary {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPTestScoreSummarys.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.naptestscoresummarys == nil {
    t = t.AddNew()
    }
    */
  if t.naptestscoresummarys.NAPTestScoreSummary == nil {
    t = t.AddNew()
    }
        return &NAPTestScoreSummary{(t.naptestscoresummarys.NAPTestScoreSummary[n])}
}

// Length of the list.
func (t *NAPTestScoreSummarys) Len() int {
  /*
  if t.naptestscoresummarys == nil {
    t = t.AddNew()
    }
    */
  if t.naptestscoresummarys.NAPTestScoreSummary == nil {
    t = t.AddNew()
    }
        return len(t.naptestscoresummarys.NAPTestScoreSummary)
}

// Convert list object to slice
func (t *NAPTestScoreSummarys) ToSlice() []*NAPTestScoreSummary {
    ret := make([]*NAPTestScoreSummary, 0)
  for _, x:= range t.naptestscoresummarys.NAPTestScoreSummary {
    ret = append(ret, &NAPTestScoreSummary{naptestscoresummary: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewNAPTestlets() *NAPTestlets {
  if out, ok := NAPTestletsPointer(NAPTestlets{}); !ok {
                log.Fatalf("Could not create pointer to NAPTestlets\n")
                return nil
        } else {
          out.naptestlets.NAPTestlet = make([]naptestlet, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPTestlets) Append(values ...*NAPTestlet) *NAPTestlets {
        if t == nil {
                t, _ = NAPTestletsPointer(NAPTestlets{})
        }
        /*
        if t.naptestlets == nil {
          t.naptestlets = naptestlets{NAPTestlet: make([]naptestlet, 0)}
        }
        */
        if t.naptestlets.NAPTestlet == nil {
                t.naptestlets.NAPTestlet = make([]naptestlet, 0)
        }
        for _, value := range values {
        t.naptestlets.NAPTestlet = append(t.naptestlets.NAPTestlet, value.naptestlet)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPTestlets) AddNew() *NAPTestlets {
        if t == nil {
                t, _ = NAPTestletsPointer(NAPTestlets{})
        }
        /*
        if t.naptestlets == nil {
          t.naptestlets = naptestlets{NAPTestlet: make([]naptestlet, 0)}
        }
        */
        if t.naptestlets.NAPTestlet == nil {
                t.naptestlets.NAPTestlet = make([]naptestlet, 0)
        }
        t.naptestlets.NAPTestlet = append(t.naptestlets.NAPTestlet, naptestlet{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPTestlets) Last() *naptestlet {
  /*
  if t.naptestlets == nil {
    t = t.AddNew()
    }
    */
  if t.naptestlets.NAPTestlet == nil {
    t = t.AddNew()
    }
        return &(t.naptestlets.NAPTestlet[len(t.naptestlets.NAPTestlet)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *NAPTestlets) Index(n int) *NAPTestlet {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPTestlets.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.naptestlets == nil {
    t = t.AddNew()
    }
    */
  if t.naptestlets.NAPTestlet == nil {
    t = t.AddNew()
    }
        return &NAPTestlet{(t.naptestlets.NAPTestlet[n])}
}

// Length of the list.
func (t *NAPTestlets) Len() int {
  /*
  if t.naptestlets == nil {
    t = t.AddNew()
    }
    */
  if t.naptestlets.NAPTestlet == nil {
    t = t.AddNew()
    }
        return len(t.naptestlets.NAPTestlet)
}

// Convert list object to slice
func (t *NAPTestlets) ToSlice() []*NAPTestlet {
    ret := make([]*NAPTestlet, 0)
  for _, x:= range t.naptestlets.NAPTestlet {
    ret = append(ret, &NAPTestlet{naptestlet: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewNAPTests() *NAPTests {
  if out, ok := NAPTestsPointer(NAPTests{}); !ok {
                log.Fatalf("Could not create pointer to NAPTests\n")
                return nil
        } else {
          out.naptests.NAPTest = make([]naptest, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *NAPTests) Append(values ...*NAPTest) *NAPTests {
        if t == nil {
                t, _ = NAPTestsPointer(NAPTests{})
        }
        /*
        if t.naptests == nil {
          t.naptests = naptests{NAPTest: make([]naptest, 0)}
        }
        */
        if t.naptests.NAPTest == nil {
                t.naptests.NAPTest = make([]naptest, 0)
        }
        for _, value := range values {
        t.naptests.NAPTest = append(t.naptests.NAPTest, value.naptest)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *NAPTests) AddNew() *NAPTests {
        if t == nil {
                t, _ = NAPTestsPointer(NAPTests{})
        }
        /*
        if t.naptests == nil {
          t.naptests = naptests{NAPTest: make([]naptest, 0)}
        }
        */
        if t.naptests.NAPTest == nil {
                t.naptests.NAPTest = make([]naptest, 0)
        }
        t.naptests.NAPTest = append(t.naptests.NAPTest, naptest{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *NAPTests) Last() *naptest {
  /*
  if t.naptests == nil {
    t = t.AddNew()
    }
    */
  if t.naptests.NAPTest == nil {
    t = t.AddNew()
    }
        return &(t.naptests.NAPTest[len(t.naptests.NAPTest)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *NAPTests) Index(n int) *NAPTest {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("NAPTests.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.naptests == nil {
    t = t.AddNew()
    }
    */
  if t.naptests.NAPTest == nil {
    t = t.AddNew()
    }
        return &NAPTest{(t.naptests.NAPTest[n])}
}

// Length of the list.
func (t *NAPTests) Len() int {
  /*
  if t.naptests == nil {
    t = t.AddNew()
    }
    */
  if t.naptests.NAPTest == nil {
    t = t.AddNew()
    }
        return len(t.naptests.NAPTest)
}

// Convert list object to slice
func (t *NAPTests) ToSlice() []*NAPTest {
    ret := make([]*NAPTest, 0)
  for _, x:= range t.naptests.NAPTest {
    ret = append(ret, &NAPTest{naptest: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewPaymentReceipts() *PaymentReceipts {
  if out, ok := PaymentReceiptsPointer(PaymentReceipts{}); !ok {
                log.Fatalf("Could not create pointer to PaymentReceipts\n")
                return nil
        } else {
          out.paymentreceipts.PaymentReceipt = make([]paymentreceipt, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PaymentReceipts) Append(values ...*PaymentReceipt) *PaymentReceipts {
        if t == nil {
                t, _ = PaymentReceiptsPointer(PaymentReceipts{})
        }
        /*
        if t.paymentreceipts == nil {
          t.paymentreceipts = paymentreceipts{PaymentReceipt: make([]paymentreceipt, 0)}
        }
        */
        if t.paymentreceipts.PaymentReceipt == nil {
                t.paymentreceipts.PaymentReceipt = make([]paymentreceipt, 0)
        }
        for _, value := range values {
        t.paymentreceipts.PaymentReceipt = append(t.paymentreceipts.PaymentReceipt, value.paymentreceipt)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PaymentReceipts) AddNew() *PaymentReceipts {
        if t == nil {
                t, _ = PaymentReceiptsPointer(PaymentReceipts{})
        }
        /*
        if t.paymentreceipts == nil {
          t.paymentreceipts = paymentreceipts{PaymentReceipt: make([]paymentreceipt, 0)}
        }
        */
        if t.paymentreceipts.PaymentReceipt == nil {
                t.paymentreceipts.PaymentReceipt = make([]paymentreceipt, 0)
        }
        t.paymentreceipts.PaymentReceipt = append(t.paymentreceipts.PaymentReceipt, paymentreceipt{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PaymentReceipts) Last() *paymentreceipt {
  /*
  if t.paymentreceipts == nil {
    t = t.AddNew()
    }
    */
  if t.paymentreceipts.PaymentReceipt == nil {
    t = t.AddNew()
    }
        return &(t.paymentreceipts.PaymentReceipt[len(t.paymentreceipts.PaymentReceipt)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *PaymentReceipts) Index(n int) *PaymentReceipt {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PaymentReceipts.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.paymentreceipts == nil {
    t = t.AddNew()
    }
    */
  if t.paymentreceipts.PaymentReceipt == nil {
    t = t.AddNew()
    }
        return &PaymentReceipt{(t.paymentreceipts.PaymentReceipt[n])}
}

// Length of the list.
func (t *PaymentReceipts) Len() int {
  /*
  if t.paymentreceipts == nil {
    t = t.AddNew()
    }
    */
  if t.paymentreceipts.PaymentReceipt == nil {
    t = t.AddNew()
    }
        return len(t.paymentreceipts.PaymentReceipt)
}

// Convert list object to slice
func (t *PaymentReceipts) ToSlice() []*PaymentReceipt {
    ret := make([]*PaymentReceipt, 0)
  for _, x:= range t.paymentreceipts.PaymentReceipt {
    ret = append(ret, &PaymentReceipt{paymentreceipt: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewPersonPictures() *PersonPictures {
  if out, ok := PersonPicturesPointer(PersonPictures{}); !ok {
                log.Fatalf("Could not create pointer to PersonPictures\n")
                return nil
        } else {
          out.personpictures.PersonPicture = make([]personpicture, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PersonPictures) Append(values ...*PersonPicture) *PersonPictures {
        if t == nil {
                t, _ = PersonPicturesPointer(PersonPictures{})
        }
        /*
        if t.personpictures == nil {
          t.personpictures = personpictures{PersonPicture: make([]personpicture, 0)}
        }
        */
        if t.personpictures.PersonPicture == nil {
                t.personpictures.PersonPicture = make([]personpicture, 0)
        }
        for _, value := range values {
        t.personpictures.PersonPicture = append(t.personpictures.PersonPicture, value.personpicture)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PersonPictures) AddNew() *PersonPictures {
        if t == nil {
                t, _ = PersonPicturesPointer(PersonPictures{})
        }
        /*
        if t.personpictures == nil {
          t.personpictures = personpictures{PersonPicture: make([]personpicture, 0)}
        }
        */
        if t.personpictures.PersonPicture == nil {
                t.personpictures.PersonPicture = make([]personpicture, 0)
        }
        t.personpictures.PersonPicture = append(t.personpictures.PersonPicture, personpicture{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PersonPictures) Last() *personpicture {
  /*
  if t.personpictures == nil {
    t = t.AddNew()
    }
    */
  if t.personpictures.PersonPicture == nil {
    t = t.AddNew()
    }
        return &(t.personpictures.PersonPicture[len(t.personpictures.PersonPicture)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *PersonPictures) Index(n int) *PersonPicture {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PersonPictures.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.personpictures == nil {
    t = t.AddNew()
    }
    */
  if t.personpictures.PersonPicture == nil {
    t = t.AddNew()
    }
        return &PersonPicture{(t.personpictures.PersonPicture[n])}
}

// Length of the list.
func (t *PersonPictures) Len() int {
  /*
  if t.personpictures == nil {
    t = t.AddNew()
    }
    */
  if t.personpictures.PersonPicture == nil {
    t = t.AddNew()
    }
        return len(t.personpictures.PersonPicture)
}

// Convert list object to slice
func (t *PersonPictures) ToSlice() []*PersonPicture {
    ret := make([]*PersonPicture, 0)
  for _, x:= range t.personpictures.PersonPicture {
    ret = append(ret, &PersonPicture{personpicture: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewPersonPrivacyObligationDocuments() *PersonPrivacyObligationDocuments {
  if out, ok := PersonPrivacyObligationDocumentsPointer(PersonPrivacyObligationDocuments{}); !ok {
                log.Fatalf("Could not create pointer to PersonPrivacyObligationDocuments\n")
                return nil
        } else {
          out.personprivacyobligationdocuments.PersonPrivacyObligationDocument = make([]personprivacyobligationdocument, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PersonPrivacyObligationDocuments) Append(values ...*PersonPrivacyObligationDocument) *PersonPrivacyObligationDocuments {
        if t == nil {
                t, _ = PersonPrivacyObligationDocumentsPointer(PersonPrivacyObligationDocuments{})
        }
        /*
        if t.personprivacyobligationdocuments == nil {
          t.personprivacyobligationdocuments = personprivacyobligationdocuments{PersonPrivacyObligationDocument: make([]personprivacyobligationdocument, 0)}
        }
        */
        if t.personprivacyobligationdocuments.PersonPrivacyObligationDocument == nil {
                t.personprivacyobligationdocuments.PersonPrivacyObligationDocument = make([]personprivacyobligationdocument, 0)
        }
        for _, value := range values {
        t.personprivacyobligationdocuments.PersonPrivacyObligationDocument = append(t.personprivacyobligationdocuments.PersonPrivacyObligationDocument, value.personprivacyobligationdocument)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PersonPrivacyObligationDocuments) AddNew() *PersonPrivacyObligationDocuments {
        if t == nil {
                t, _ = PersonPrivacyObligationDocumentsPointer(PersonPrivacyObligationDocuments{})
        }
        /*
        if t.personprivacyobligationdocuments == nil {
          t.personprivacyobligationdocuments = personprivacyobligationdocuments{PersonPrivacyObligationDocument: make([]personprivacyobligationdocument, 0)}
        }
        */
        if t.personprivacyobligationdocuments.PersonPrivacyObligationDocument == nil {
                t.personprivacyobligationdocuments.PersonPrivacyObligationDocument = make([]personprivacyobligationdocument, 0)
        }
        t.personprivacyobligationdocuments.PersonPrivacyObligationDocument = append(t.personprivacyobligationdocuments.PersonPrivacyObligationDocument, personprivacyobligationdocument{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PersonPrivacyObligationDocuments) Last() *personprivacyobligationdocument {
  /*
  if t.personprivacyobligationdocuments == nil {
    t = t.AddNew()
    }
    */
  if t.personprivacyobligationdocuments.PersonPrivacyObligationDocument == nil {
    t = t.AddNew()
    }
        return &(t.personprivacyobligationdocuments.PersonPrivacyObligationDocument[len(t.personprivacyobligationdocuments.PersonPrivacyObligationDocument)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *PersonPrivacyObligationDocuments) Index(n int) *PersonPrivacyObligationDocument {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PersonPrivacyObligationDocuments.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.personprivacyobligationdocuments == nil {
    t = t.AddNew()
    }
    */
  if t.personprivacyobligationdocuments.PersonPrivacyObligationDocument == nil {
    t = t.AddNew()
    }
        return &PersonPrivacyObligationDocument{(t.personprivacyobligationdocuments.PersonPrivacyObligationDocument[n])}
}

// Length of the list.
func (t *PersonPrivacyObligationDocuments) Len() int {
  /*
  if t.personprivacyobligationdocuments == nil {
    t = t.AddNew()
    }
    */
  if t.personprivacyobligationdocuments.PersonPrivacyObligationDocument == nil {
    t = t.AddNew()
    }
        return len(t.personprivacyobligationdocuments.PersonPrivacyObligationDocument)
}

// Convert list object to slice
func (t *PersonPrivacyObligationDocuments) ToSlice() []*PersonPrivacyObligationDocument {
    ret := make([]*PersonPrivacyObligationDocument, 0)
  for _, x:= range t.personprivacyobligationdocuments.PersonPrivacyObligationDocument {
    ret = append(ret, &PersonPrivacyObligationDocument{personprivacyobligationdocument: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewPersonalisedPlans() *PersonalisedPlans {
  if out, ok := PersonalisedPlansPointer(PersonalisedPlans{}); !ok {
                log.Fatalf("Could not create pointer to PersonalisedPlans\n")
                return nil
        } else {
          out.personalisedplans.PersonalisedPlan = make([]personalisedplan, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PersonalisedPlans) Append(values ...*PersonalisedPlan) *PersonalisedPlans {
        if t == nil {
                t, _ = PersonalisedPlansPointer(PersonalisedPlans{})
        }
        /*
        if t.personalisedplans == nil {
          t.personalisedplans = personalisedplans{PersonalisedPlan: make([]personalisedplan, 0)}
        }
        */
        if t.personalisedplans.PersonalisedPlan == nil {
                t.personalisedplans.PersonalisedPlan = make([]personalisedplan, 0)
        }
        for _, value := range values {
        t.personalisedplans.PersonalisedPlan = append(t.personalisedplans.PersonalisedPlan, value.personalisedplan)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PersonalisedPlans) AddNew() *PersonalisedPlans {
        if t == nil {
                t, _ = PersonalisedPlansPointer(PersonalisedPlans{})
        }
        /*
        if t.personalisedplans == nil {
          t.personalisedplans = personalisedplans{PersonalisedPlan: make([]personalisedplan, 0)}
        }
        */
        if t.personalisedplans.PersonalisedPlan == nil {
                t.personalisedplans.PersonalisedPlan = make([]personalisedplan, 0)
        }
        t.personalisedplans.PersonalisedPlan = append(t.personalisedplans.PersonalisedPlan, personalisedplan{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PersonalisedPlans) Last() *personalisedplan {
  /*
  if t.personalisedplans == nil {
    t = t.AddNew()
    }
    */
  if t.personalisedplans.PersonalisedPlan == nil {
    t = t.AddNew()
    }
        return &(t.personalisedplans.PersonalisedPlan[len(t.personalisedplans.PersonalisedPlan)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *PersonalisedPlans) Index(n int) *PersonalisedPlan {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PersonalisedPlans.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.personalisedplans == nil {
    t = t.AddNew()
    }
    */
  if t.personalisedplans.PersonalisedPlan == nil {
    t = t.AddNew()
    }
        return &PersonalisedPlan{(t.personalisedplans.PersonalisedPlan[n])}
}

// Length of the list.
func (t *PersonalisedPlans) Len() int {
  /*
  if t.personalisedplans == nil {
    t = t.AddNew()
    }
    */
  if t.personalisedplans.PersonalisedPlan == nil {
    t = t.AddNew()
    }
        return len(t.personalisedplans.PersonalisedPlan)
}

// Convert list object to slice
func (t *PersonalisedPlans) ToSlice() []*PersonalisedPlan {
    ret := make([]*PersonalisedPlan, 0)
  for _, x:= range t.personalisedplans.PersonalisedPlan {
    ret = append(ret, &PersonalisedPlan{personalisedplan: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewPurchaseOrders() *PurchaseOrders {
  if out, ok := PurchaseOrdersPointer(PurchaseOrders{}); !ok {
                log.Fatalf("Could not create pointer to PurchaseOrders\n")
                return nil
        } else {
          out.purchaseorders.PurchaseOrder = make([]purchaseorder, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *PurchaseOrders) Append(values ...*PurchaseOrder) *PurchaseOrders {
        if t == nil {
                t, _ = PurchaseOrdersPointer(PurchaseOrders{})
        }
        /*
        if t.purchaseorders == nil {
          t.purchaseorders = purchaseorders{PurchaseOrder: make([]purchaseorder, 0)}
        }
        */
        if t.purchaseorders.PurchaseOrder == nil {
                t.purchaseorders.PurchaseOrder = make([]purchaseorder, 0)
        }
        for _, value := range values {
        t.purchaseorders.PurchaseOrder = append(t.purchaseorders.PurchaseOrder, value.purchaseorder)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *PurchaseOrders) AddNew() *PurchaseOrders {
        if t == nil {
                t, _ = PurchaseOrdersPointer(PurchaseOrders{})
        }
        /*
        if t.purchaseorders == nil {
          t.purchaseorders = purchaseorders{PurchaseOrder: make([]purchaseorder, 0)}
        }
        */
        if t.purchaseorders.PurchaseOrder == nil {
                t.purchaseorders.PurchaseOrder = make([]purchaseorder, 0)
        }
        t.purchaseorders.PurchaseOrder = append(t.purchaseorders.PurchaseOrder, purchaseorder{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *PurchaseOrders) Last() *purchaseorder {
  /*
  if t.purchaseorders == nil {
    t = t.AddNew()
    }
    */
  if t.purchaseorders.PurchaseOrder == nil {
    t = t.AddNew()
    }
        return &(t.purchaseorders.PurchaseOrder[len(t.purchaseorders.PurchaseOrder)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *PurchaseOrders) Index(n int) *PurchaseOrder {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("PurchaseOrders.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.purchaseorders == nil {
    t = t.AddNew()
    }
    */
  if t.purchaseorders.PurchaseOrder == nil {
    t = t.AddNew()
    }
        return &PurchaseOrder{(t.purchaseorders.PurchaseOrder[n])}
}

// Length of the list.
func (t *PurchaseOrders) Len() int {
  /*
  if t.purchaseorders == nil {
    t = t.AddNew()
    }
    */
  if t.purchaseorders.PurchaseOrder == nil {
    t = t.AddNew()
    }
        return len(t.purchaseorders.PurchaseOrder)
}

// Convert list object to slice
func (t *PurchaseOrders) ToSlice() []*PurchaseOrder {
    ret := make([]*PurchaseOrder, 0)
  for _, x:= range t.purchaseorders.PurchaseOrder {
    ret = append(ret, &PurchaseOrder{purchaseorder: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewResourceBookings() *ResourceBookings {
  if out, ok := ResourceBookingsPointer(ResourceBookings{}); !ok {
                log.Fatalf("Could not create pointer to ResourceBookings\n")
                return nil
        } else {
          out.resourcebookings.ResourceBooking = make([]resourcebooking, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ResourceBookings) Append(values ...*ResourceBooking) *ResourceBookings {
        if t == nil {
                t, _ = ResourceBookingsPointer(ResourceBookings{})
        }
        /*
        if t.resourcebookings == nil {
          t.resourcebookings = resourcebookings{ResourceBooking: make([]resourcebooking, 0)}
        }
        */
        if t.resourcebookings.ResourceBooking == nil {
                t.resourcebookings.ResourceBooking = make([]resourcebooking, 0)
        }
        for _, value := range values {
        t.resourcebookings.ResourceBooking = append(t.resourcebookings.ResourceBooking, value.resourcebooking)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ResourceBookings) AddNew() *ResourceBookings {
        if t == nil {
                t, _ = ResourceBookingsPointer(ResourceBookings{})
        }
        /*
        if t.resourcebookings == nil {
          t.resourcebookings = resourcebookings{ResourceBooking: make([]resourcebooking, 0)}
        }
        */
        if t.resourcebookings.ResourceBooking == nil {
                t.resourcebookings.ResourceBooking = make([]resourcebooking, 0)
        }
        t.resourcebookings.ResourceBooking = append(t.resourcebookings.ResourceBooking, resourcebooking{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ResourceBookings) Last() *resourcebooking {
  /*
  if t.resourcebookings == nil {
    t = t.AddNew()
    }
    */
  if t.resourcebookings.ResourceBooking == nil {
    t = t.AddNew()
    }
        return &(t.resourcebookings.ResourceBooking[len(t.resourcebookings.ResourceBooking)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *ResourceBookings) Index(n int) *ResourceBooking {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ResourceBookings.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.resourcebookings == nil {
    t = t.AddNew()
    }
    */
  if t.resourcebookings.ResourceBooking == nil {
    t = t.AddNew()
    }
        return &ResourceBooking{(t.resourcebookings.ResourceBooking[n])}
}

// Length of the list.
func (t *ResourceBookings) Len() int {
  /*
  if t.resourcebookings == nil {
    t = t.AddNew()
    }
    */
  if t.resourcebookings.ResourceBooking == nil {
    t = t.AddNew()
    }
        return len(t.resourcebookings.ResourceBooking)
}

// Convert list object to slice
func (t *ResourceBookings) ToSlice() []*ResourceBooking {
    ret := make([]*ResourceBooking, 0)
  for _, x:= range t.resourcebookings.ResourceBooking {
    ret = append(ret, &ResourceBooking{resourcebooking: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewRoomInfos() *RoomInfos {
  if out, ok := RoomInfosPointer(RoomInfos{}); !ok {
                log.Fatalf("Could not create pointer to RoomInfos\n")
                return nil
        } else {
          out.roominfos.RoomInfo = make([]roominfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *RoomInfos) Append(values ...*RoomInfo) *RoomInfos {
        if t == nil {
                t, _ = RoomInfosPointer(RoomInfos{})
        }
        /*
        if t.roominfos == nil {
          t.roominfos = roominfos{RoomInfo: make([]roominfo, 0)}
        }
        */
        if t.roominfos.RoomInfo == nil {
                t.roominfos.RoomInfo = make([]roominfo, 0)
        }
        for _, value := range values {
        t.roominfos.RoomInfo = append(t.roominfos.RoomInfo, value.roominfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *RoomInfos) AddNew() *RoomInfos {
        if t == nil {
                t, _ = RoomInfosPointer(RoomInfos{})
        }
        /*
        if t.roominfos == nil {
          t.roominfos = roominfos{RoomInfo: make([]roominfo, 0)}
        }
        */
        if t.roominfos.RoomInfo == nil {
                t.roominfos.RoomInfo = make([]roominfo, 0)
        }
        t.roominfos.RoomInfo = append(t.roominfos.RoomInfo, roominfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *RoomInfos) Last() *roominfo {
  /*
  if t.roominfos == nil {
    t = t.AddNew()
    }
    */
  if t.roominfos.RoomInfo == nil {
    t = t.AddNew()
    }
        return &(t.roominfos.RoomInfo[len(t.roominfos.RoomInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *RoomInfos) Index(n int) *RoomInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("RoomInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.roominfos == nil {
    t = t.AddNew()
    }
    */
  if t.roominfos.RoomInfo == nil {
    t = t.AddNew()
    }
        return &RoomInfo{(t.roominfos.RoomInfo[n])}
}

// Length of the list.
func (t *RoomInfos) Len() int {
  /*
  if t.roominfos == nil {
    t = t.AddNew()
    }
    */
  if t.roominfos.RoomInfo == nil {
    t = t.AddNew()
    }
        return len(t.roominfos.RoomInfo)
}

// Convert list object to slice
func (t *RoomInfos) ToSlice() []*RoomInfo {
    ret := make([]*RoomInfo, 0)
  for _, x:= range t.roominfos.RoomInfo {
    ret = append(ret, &RoomInfo{roominfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewScheduledActivitys() *ScheduledActivitys {
  if out, ok := ScheduledActivitysPointer(ScheduledActivitys{}); !ok {
                log.Fatalf("Could not create pointer to ScheduledActivitys\n")
                return nil
        } else {
          out.scheduledactivitys.ScheduledActivity = make([]scheduledactivity, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *ScheduledActivitys) Append(values ...*ScheduledActivity) *ScheduledActivitys {
        if t == nil {
                t, _ = ScheduledActivitysPointer(ScheduledActivitys{})
        }
        /*
        if t.scheduledactivitys == nil {
          t.scheduledactivitys = scheduledactivitys{ScheduledActivity: make([]scheduledactivity, 0)}
        }
        */
        if t.scheduledactivitys.ScheduledActivity == nil {
                t.scheduledactivitys.ScheduledActivity = make([]scheduledactivity, 0)
        }
        for _, value := range values {
        t.scheduledactivitys.ScheduledActivity = append(t.scheduledactivitys.ScheduledActivity, value.scheduledactivity)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *ScheduledActivitys) AddNew() *ScheduledActivitys {
        if t == nil {
                t, _ = ScheduledActivitysPointer(ScheduledActivitys{})
        }
        /*
        if t.scheduledactivitys == nil {
          t.scheduledactivitys = scheduledactivitys{ScheduledActivity: make([]scheduledactivity, 0)}
        }
        */
        if t.scheduledactivitys.ScheduledActivity == nil {
                t.scheduledactivitys.ScheduledActivity = make([]scheduledactivity, 0)
        }
        t.scheduledactivitys.ScheduledActivity = append(t.scheduledactivitys.ScheduledActivity, scheduledactivity{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *ScheduledActivitys) Last() *scheduledactivity {
  /*
  if t.scheduledactivitys == nil {
    t = t.AddNew()
    }
    */
  if t.scheduledactivitys.ScheduledActivity == nil {
    t = t.AddNew()
    }
        return &(t.scheduledactivitys.ScheduledActivity[len(t.scheduledactivitys.ScheduledActivity)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *ScheduledActivitys) Index(n int) *ScheduledActivity {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("ScheduledActivitys.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.scheduledactivitys == nil {
    t = t.AddNew()
    }
    */
  if t.scheduledactivitys.ScheduledActivity == nil {
    t = t.AddNew()
    }
        return &ScheduledActivity{(t.scheduledactivitys.ScheduledActivity[n])}
}

// Length of the list.
func (t *ScheduledActivitys) Len() int {
  /*
  if t.scheduledactivitys == nil {
    t = t.AddNew()
    }
    */
  if t.scheduledactivitys.ScheduledActivity == nil {
    t = t.AddNew()
    }
        return len(t.scheduledactivitys.ScheduledActivity)
}

// Convert list object to slice
func (t *ScheduledActivitys) ToSlice() []*ScheduledActivity {
    ret := make([]*ScheduledActivity, 0)
  for _, x:= range t.scheduledactivitys.ScheduledActivity {
    ret = append(ret, &ScheduledActivity{scheduledactivity: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewSchoolCourseInfos() *SchoolCourseInfos {
  if out, ok := SchoolCourseInfosPointer(SchoolCourseInfos{}); !ok {
                log.Fatalf("Could not create pointer to SchoolCourseInfos\n")
                return nil
        } else {
          out.schoolcourseinfos.SchoolCourseInfo = make([]schoolcourseinfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SchoolCourseInfos) Append(values ...*SchoolCourseInfo) *SchoolCourseInfos {
        if t == nil {
                t, _ = SchoolCourseInfosPointer(SchoolCourseInfos{})
        }
        /*
        if t.schoolcourseinfos == nil {
          t.schoolcourseinfos = schoolcourseinfos{SchoolCourseInfo: make([]schoolcourseinfo, 0)}
        }
        */
        if t.schoolcourseinfos.SchoolCourseInfo == nil {
                t.schoolcourseinfos.SchoolCourseInfo = make([]schoolcourseinfo, 0)
        }
        for _, value := range values {
        t.schoolcourseinfos.SchoolCourseInfo = append(t.schoolcourseinfos.SchoolCourseInfo, value.schoolcourseinfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SchoolCourseInfos) AddNew() *SchoolCourseInfos {
        if t == nil {
                t, _ = SchoolCourseInfosPointer(SchoolCourseInfos{})
        }
        /*
        if t.schoolcourseinfos == nil {
          t.schoolcourseinfos = schoolcourseinfos{SchoolCourseInfo: make([]schoolcourseinfo, 0)}
        }
        */
        if t.schoolcourseinfos.SchoolCourseInfo == nil {
                t.schoolcourseinfos.SchoolCourseInfo = make([]schoolcourseinfo, 0)
        }
        t.schoolcourseinfos.SchoolCourseInfo = append(t.schoolcourseinfos.SchoolCourseInfo, schoolcourseinfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SchoolCourseInfos) Last() *schoolcourseinfo {
  /*
  if t.schoolcourseinfos == nil {
    t = t.AddNew()
    }
    */
  if t.schoolcourseinfos.SchoolCourseInfo == nil {
    t = t.AddNew()
    }
        return &(t.schoolcourseinfos.SchoolCourseInfo[len(t.schoolcourseinfos.SchoolCourseInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *SchoolCourseInfos) Index(n int) *SchoolCourseInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SchoolCourseInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.schoolcourseinfos == nil {
    t = t.AddNew()
    }
    */
  if t.schoolcourseinfos.SchoolCourseInfo == nil {
    t = t.AddNew()
    }
        return &SchoolCourseInfo{(t.schoolcourseinfos.SchoolCourseInfo[n])}
}

// Length of the list.
func (t *SchoolCourseInfos) Len() int {
  /*
  if t.schoolcourseinfos == nil {
    t = t.AddNew()
    }
    */
  if t.schoolcourseinfos.SchoolCourseInfo == nil {
    t = t.AddNew()
    }
        return len(t.schoolcourseinfos.SchoolCourseInfo)
}

// Convert list object to slice
func (t *SchoolCourseInfos) ToSlice() []*SchoolCourseInfo {
    ret := make([]*SchoolCourseInfo, 0)
  for _, x:= range t.schoolcourseinfos.SchoolCourseInfo {
    ret = append(ret, &SchoolCourseInfo{schoolcourseinfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewSchoolInfos() *SchoolInfos {
  if out, ok := SchoolInfosPointer(SchoolInfos{}); !ok {
                log.Fatalf("Could not create pointer to SchoolInfos\n")
                return nil
        } else {
          out.schoolinfos.SchoolInfo = make([]schoolinfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SchoolInfos) Append(values ...*SchoolInfo) *SchoolInfos {
        if t == nil {
                t, _ = SchoolInfosPointer(SchoolInfos{})
        }
        /*
        if t.schoolinfos == nil {
          t.schoolinfos = schoolinfos{SchoolInfo: make([]schoolinfo, 0)}
        }
        */
        if t.schoolinfos.SchoolInfo == nil {
                t.schoolinfos.SchoolInfo = make([]schoolinfo, 0)
        }
        for _, value := range values {
        t.schoolinfos.SchoolInfo = append(t.schoolinfos.SchoolInfo, value.schoolinfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SchoolInfos) AddNew() *SchoolInfos {
        if t == nil {
                t, _ = SchoolInfosPointer(SchoolInfos{})
        }
        /*
        if t.schoolinfos == nil {
          t.schoolinfos = schoolinfos{SchoolInfo: make([]schoolinfo, 0)}
        }
        */
        if t.schoolinfos.SchoolInfo == nil {
                t.schoolinfos.SchoolInfo = make([]schoolinfo, 0)
        }
        t.schoolinfos.SchoolInfo = append(t.schoolinfos.SchoolInfo, schoolinfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SchoolInfos) Last() *schoolinfo {
  /*
  if t.schoolinfos == nil {
    t = t.AddNew()
    }
    */
  if t.schoolinfos.SchoolInfo == nil {
    t = t.AddNew()
    }
        return &(t.schoolinfos.SchoolInfo[len(t.schoolinfos.SchoolInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *SchoolInfos) Index(n int) *SchoolInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SchoolInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.schoolinfos == nil {
    t = t.AddNew()
    }
    */
  if t.schoolinfos.SchoolInfo == nil {
    t = t.AddNew()
    }
        return &SchoolInfo{(t.schoolinfos.SchoolInfo[n])}
}

// Length of the list.
func (t *SchoolInfos) Len() int {
  /*
  if t.schoolinfos == nil {
    t = t.AddNew()
    }
    */
  if t.schoolinfos.SchoolInfo == nil {
    t = t.AddNew()
    }
        return len(t.schoolinfos.SchoolInfo)
}

// Convert list object to slice
func (t *SchoolInfos) ToSlice() []*SchoolInfo {
    ret := make([]*SchoolInfo, 0)
  for _, x:= range t.schoolinfos.SchoolInfo {
    ret = append(ret, &SchoolInfo{schoolinfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewSchoolProgramss() *SchoolProgramss {
  if out, ok := SchoolProgramssPointer(SchoolProgramss{}); !ok {
                log.Fatalf("Could not create pointer to SchoolProgramss\n")
                return nil
        } else {
          out.schoolprogramss.SchoolPrograms = make([]schoolprograms, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SchoolProgramss) Append(values ...*SchoolPrograms) *SchoolProgramss {
        if t == nil {
                t, _ = SchoolProgramssPointer(SchoolProgramss{})
        }
        /*
        if t.schoolprogramss == nil {
          t.schoolprogramss = schoolprogramss{SchoolPrograms: make([]schoolprograms, 0)}
        }
        */
        if t.schoolprogramss.SchoolPrograms == nil {
                t.schoolprogramss.SchoolPrograms = make([]schoolprograms, 0)
        }
        for _, value := range values {
        t.schoolprogramss.SchoolPrograms = append(t.schoolprogramss.SchoolPrograms, value.schoolprograms)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SchoolProgramss) AddNew() *SchoolProgramss {
        if t == nil {
                t, _ = SchoolProgramssPointer(SchoolProgramss{})
        }
        /*
        if t.schoolprogramss == nil {
          t.schoolprogramss = schoolprogramss{SchoolPrograms: make([]schoolprograms, 0)}
        }
        */
        if t.schoolprogramss.SchoolPrograms == nil {
                t.schoolprogramss.SchoolPrograms = make([]schoolprograms, 0)
        }
        t.schoolprogramss.SchoolPrograms = append(t.schoolprogramss.SchoolPrograms, schoolprograms{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SchoolProgramss) Last() *schoolprograms {
  /*
  if t.schoolprogramss == nil {
    t = t.AddNew()
    }
    */
  if t.schoolprogramss.SchoolPrograms == nil {
    t = t.AddNew()
    }
        return &(t.schoolprogramss.SchoolPrograms[len(t.schoolprogramss.SchoolPrograms)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *SchoolProgramss) Index(n int) *SchoolPrograms {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SchoolProgramss.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.schoolprogramss == nil {
    t = t.AddNew()
    }
    */
  if t.schoolprogramss.SchoolPrograms == nil {
    t = t.AddNew()
    }
        return &SchoolPrograms{(t.schoolprogramss.SchoolPrograms[n])}
}

// Length of the list.
func (t *SchoolProgramss) Len() int {
  /*
  if t.schoolprogramss == nil {
    t = t.AddNew()
    }
    */
  if t.schoolprogramss.SchoolPrograms == nil {
    t = t.AddNew()
    }
        return len(t.schoolprogramss.SchoolPrograms)
}

// Convert list object to slice
func (t *SchoolProgramss) ToSlice() []*SchoolPrograms {
    ret := make([]*SchoolPrograms, 0)
  for _, x:= range t.schoolprogramss.SchoolPrograms {
    ret = append(ret, &SchoolPrograms{schoolprograms: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewSectionInfos() *SectionInfos {
  if out, ok := SectionInfosPointer(SectionInfos{}); !ok {
                log.Fatalf("Could not create pointer to SectionInfos\n")
                return nil
        } else {
          out.sectioninfos.SectionInfo = make([]sectioninfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SectionInfos) Append(values ...*SectionInfo) *SectionInfos {
        if t == nil {
                t, _ = SectionInfosPointer(SectionInfos{})
        }
        /*
        if t.sectioninfos == nil {
          t.sectioninfos = sectioninfos{SectionInfo: make([]sectioninfo, 0)}
        }
        */
        if t.sectioninfos.SectionInfo == nil {
                t.sectioninfos.SectionInfo = make([]sectioninfo, 0)
        }
        for _, value := range values {
        t.sectioninfos.SectionInfo = append(t.sectioninfos.SectionInfo, value.sectioninfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SectionInfos) AddNew() *SectionInfos {
        if t == nil {
                t, _ = SectionInfosPointer(SectionInfos{})
        }
        /*
        if t.sectioninfos == nil {
          t.sectioninfos = sectioninfos{SectionInfo: make([]sectioninfo, 0)}
        }
        */
        if t.sectioninfos.SectionInfo == nil {
                t.sectioninfos.SectionInfo = make([]sectioninfo, 0)
        }
        t.sectioninfos.SectionInfo = append(t.sectioninfos.SectionInfo, sectioninfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SectionInfos) Last() *sectioninfo {
  /*
  if t.sectioninfos == nil {
    t = t.AddNew()
    }
    */
  if t.sectioninfos.SectionInfo == nil {
    t = t.AddNew()
    }
        return &(t.sectioninfos.SectionInfo[len(t.sectioninfos.SectionInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *SectionInfos) Index(n int) *SectionInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SectionInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.sectioninfos == nil {
    t = t.AddNew()
    }
    */
  if t.sectioninfos.SectionInfo == nil {
    t = t.AddNew()
    }
        return &SectionInfo{(t.sectioninfos.SectionInfo[n])}
}

// Length of the list.
func (t *SectionInfos) Len() int {
  /*
  if t.sectioninfos == nil {
    t = t.AddNew()
    }
    */
  if t.sectioninfos.SectionInfo == nil {
    t = t.AddNew()
    }
        return len(t.sectioninfos.SectionInfo)
}

// Convert list object to slice
func (t *SectionInfos) ToSlice() []*SectionInfo {
    ret := make([]*SectionInfo, 0)
  for _, x:= range t.sectioninfos.SectionInfo {
    ret = append(ret, &SectionInfo{sectioninfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewSessionInfos() *SessionInfos {
  if out, ok := SessionInfosPointer(SessionInfos{}); !ok {
                log.Fatalf("Could not create pointer to SessionInfos\n")
                return nil
        } else {
          out.sessioninfos.SessionInfo = make([]sessioninfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *SessionInfos) Append(values ...*SessionInfo) *SessionInfos {
        if t == nil {
                t, _ = SessionInfosPointer(SessionInfos{})
        }
        /*
        if t.sessioninfos == nil {
          t.sessioninfos = sessioninfos{SessionInfo: make([]sessioninfo, 0)}
        }
        */
        if t.sessioninfos.SessionInfo == nil {
                t.sessioninfos.SessionInfo = make([]sessioninfo, 0)
        }
        for _, value := range values {
        t.sessioninfos.SessionInfo = append(t.sessioninfos.SessionInfo, value.sessioninfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *SessionInfos) AddNew() *SessionInfos {
        if t == nil {
                t, _ = SessionInfosPointer(SessionInfos{})
        }
        /*
        if t.sessioninfos == nil {
          t.sessioninfos = sessioninfos{SessionInfo: make([]sessioninfo, 0)}
        }
        */
        if t.sessioninfos.SessionInfo == nil {
                t.sessioninfos.SessionInfo = make([]sessioninfo, 0)
        }
        t.sessioninfos.SessionInfo = append(t.sessioninfos.SessionInfo, sessioninfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *SessionInfos) Last() *sessioninfo {
  /*
  if t.sessioninfos == nil {
    t = t.AddNew()
    }
    */
  if t.sessioninfos.SessionInfo == nil {
    t = t.AddNew()
    }
        return &(t.sessioninfos.SessionInfo[len(t.sessioninfos.SessionInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *SessionInfos) Index(n int) *SessionInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("SessionInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.sessioninfos == nil {
    t = t.AddNew()
    }
    */
  if t.sessioninfos.SessionInfo == nil {
    t = t.AddNew()
    }
        return &SessionInfo{(t.sessioninfos.SessionInfo[n])}
}

// Length of the list.
func (t *SessionInfos) Len() int {
  /*
  if t.sessioninfos == nil {
    t = t.AddNew()
    }
    */
  if t.sessioninfos.SessionInfo == nil {
    t = t.AddNew()
    }
        return len(t.sessioninfos.SessionInfo)
}

// Convert list object to slice
func (t *SessionInfos) ToSlice() []*SessionInfo {
    ret := make([]*SessionInfo, 0)
  for _, x:= range t.sessioninfos.SessionInfo {
    ret = append(ret, &SessionInfo{sessioninfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStaffAssignments() *StaffAssignments {
  if out, ok := StaffAssignmentsPointer(StaffAssignments{}); !ok {
                log.Fatalf("Could not create pointer to StaffAssignments\n")
                return nil
        } else {
          out.staffassignments.StaffAssignment = make([]staffassignment, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StaffAssignments) Append(values ...*StaffAssignment) *StaffAssignments {
        if t == nil {
                t, _ = StaffAssignmentsPointer(StaffAssignments{})
        }
        /*
        if t.staffassignments == nil {
          t.staffassignments = staffassignments{StaffAssignment: make([]staffassignment, 0)}
        }
        */
        if t.staffassignments.StaffAssignment == nil {
                t.staffassignments.StaffAssignment = make([]staffassignment, 0)
        }
        for _, value := range values {
        t.staffassignments.StaffAssignment = append(t.staffassignments.StaffAssignment, value.staffassignment)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StaffAssignments) AddNew() *StaffAssignments {
        if t == nil {
                t, _ = StaffAssignmentsPointer(StaffAssignments{})
        }
        /*
        if t.staffassignments == nil {
          t.staffassignments = staffassignments{StaffAssignment: make([]staffassignment, 0)}
        }
        */
        if t.staffassignments.StaffAssignment == nil {
                t.staffassignments.StaffAssignment = make([]staffassignment, 0)
        }
        t.staffassignments.StaffAssignment = append(t.staffassignments.StaffAssignment, staffassignment{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StaffAssignments) Last() *staffassignment {
  /*
  if t.staffassignments == nil {
    t = t.AddNew()
    }
    */
  if t.staffassignments.StaffAssignment == nil {
    t = t.AddNew()
    }
        return &(t.staffassignments.StaffAssignment[len(t.staffassignments.StaffAssignment)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StaffAssignments) Index(n int) *StaffAssignment {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StaffAssignments.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.staffassignments == nil {
    t = t.AddNew()
    }
    */
  if t.staffassignments.StaffAssignment == nil {
    t = t.AddNew()
    }
        return &StaffAssignment{(t.staffassignments.StaffAssignment[n])}
}

// Length of the list.
func (t *StaffAssignments) Len() int {
  /*
  if t.staffassignments == nil {
    t = t.AddNew()
    }
    */
  if t.staffassignments.StaffAssignment == nil {
    t = t.AddNew()
    }
        return len(t.staffassignments.StaffAssignment)
}

// Convert list object to slice
func (t *StaffAssignments) ToSlice() []*StaffAssignment {
    ret := make([]*StaffAssignment, 0)
  for _, x:= range t.staffassignments.StaffAssignment {
    ret = append(ret, &StaffAssignment{staffassignment: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStaffPersonals() *StaffPersonals {
  if out, ok := StaffPersonalsPointer(StaffPersonals{}); !ok {
                log.Fatalf("Could not create pointer to StaffPersonals\n")
                return nil
        } else {
          out.staffpersonals.StaffPersonal = make([]staffpersonal, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StaffPersonals) Append(values ...*StaffPersonal) *StaffPersonals {
        if t == nil {
                t, _ = StaffPersonalsPointer(StaffPersonals{})
        }
        /*
        if t.staffpersonals == nil {
          t.staffpersonals = staffpersonals{StaffPersonal: make([]staffpersonal, 0)}
        }
        */
        if t.staffpersonals.StaffPersonal == nil {
                t.staffpersonals.StaffPersonal = make([]staffpersonal, 0)
        }
        for _, value := range values {
        t.staffpersonals.StaffPersonal = append(t.staffpersonals.StaffPersonal, value.staffpersonal)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StaffPersonals) AddNew() *StaffPersonals {
        if t == nil {
                t, _ = StaffPersonalsPointer(StaffPersonals{})
        }
        /*
        if t.staffpersonals == nil {
          t.staffpersonals = staffpersonals{StaffPersonal: make([]staffpersonal, 0)}
        }
        */
        if t.staffpersonals.StaffPersonal == nil {
                t.staffpersonals.StaffPersonal = make([]staffpersonal, 0)
        }
        t.staffpersonals.StaffPersonal = append(t.staffpersonals.StaffPersonal, staffpersonal{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StaffPersonals) Last() *staffpersonal {
  /*
  if t.staffpersonals == nil {
    t = t.AddNew()
    }
    */
  if t.staffpersonals.StaffPersonal == nil {
    t = t.AddNew()
    }
        return &(t.staffpersonals.StaffPersonal[len(t.staffpersonals.StaffPersonal)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StaffPersonals) Index(n int) *StaffPersonal {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StaffPersonals.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.staffpersonals == nil {
    t = t.AddNew()
    }
    */
  if t.staffpersonals.StaffPersonal == nil {
    t = t.AddNew()
    }
        return &StaffPersonal{(t.staffpersonals.StaffPersonal[n])}
}

// Length of the list.
func (t *StaffPersonals) Len() int {
  /*
  if t.staffpersonals == nil {
    t = t.AddNew()
    }
    */
  if t.staffpersonals.StaffPersonal == nil {
    t = t.AddNew()
    }
        return len(t.staffpersonals.StaffPersonal)
}

// Convert list object to slice
func (t *StaffPersonals) ToSlice() []*StaffPersonal {
    ret := make([]*StaffPersonal, 0)
  for _, x:= range t.staffpersonals.StaffPersonal {
    ret = append(ret, &StaffPersonal{staffpersonal: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentActivityInfos() *StudentActivityInfos {
  if out, ok := StudentActivityInfosPointer(StudentActivityInfos{}); !ok {
                log.Fatalf("Could not create pointer to StudentActivityInfos\n")
                return nil
        } else {
          out.studentactivityinfos.StudentActivityInfo = make([]studentactivityinfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentActivityInfos) Append(values ...*StudentActivityInfo) *StudentActivityInfos {
        if t == nil {
                t, _ = StudentActivityInfosPointer(StudentActivityInfos{})
        }
        /*
        if t.studentactivityinfos == nil {
          t.studentactivityinfos = studentactivityinfos{StudentActivityInfo: make([]studentactivityinfo, 0)}
        }
        */
        if t.studentactivityinfos.StudentActivityInfo == nil {
                t.studentactivityinfos.StudentActivityInfo = make([]studentactivityinfo, 0)
        }
        for _, value := range values {
        t.studentactivityinfos.StudentActivityInfo = append(t.studentactivityinfos.StudentActivityInfo, value.studentactivityinfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentActivityInfos) AddNew() *StudentActivityInfos {
        if t == nil {
                t, _ = StudentActivityInfosPointer(StudentActivityInfos{})
        }
        /*
        if t.studentactivityinfos == nil {
          t.studentactivityinfos = studentactivityinfos{StudentActivityInfo: make([]studentactivityinfo, 0)}
        }
        */
        if t.studentactivityinfos.StudentActivityInfo == nil {
                t.studentactivityinfos.StudentActivityInfo = make([]studentactivityinfo, 0)
        }
        t.studentactivityinfos.StudentActivityInfo = append(t.studentactivityinfos.StudentActivityInfo, studentactivityinfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentActivityInfos) Last() *studentactivityinfo {
  /*
  if t.studentactivityinfos == nil {
    t = t.AddNew()
    }
    */
  if t.studentactivityinfos.StudentActivityInfo == nil {
    t = t.AddNew()
    }
        return &(t.studentactivityinfos.StudentActivityInfo[len(t.studentactivityinfos.StudentActivityInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentActivityInfos) Index(n int) *StudentActivityInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentActivityInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentactivityinfos == nil {
    t = t.AddNew()
    }
    */
  if t.studentactivityinfos.StudentActivityInfo == nil {
    t = t.AddNew()
    }
        return &StudentActivityInfo{(t.studentactivityinfos.StudentActivityInfo[n])}
}

// Length of the list.
func (t *StudentActivityInfos) Len() int {
  /*
  if t.studentactivityinfos == nil {
    t = t.AddNew()
    }
    */
  if t.studentactivityinfos.StudentActivityInfo == nil {
    t = t.AddNew()
    }
        return len(t.studentactivityinfos.StudentActivityInfo)
}

// Convert list object to slice
func (t *StudentActivityInfos) ToSlice() []*StudentActivityInfo {
    ret := make([]*StudentActivityInfo, 0)
  for _, x:= range t.studentactivityinfos.StudentActivityInfo {
    ret = append(ret, &StudentActivityInfo{studentactivityinfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentActivityParticipations() *StudentActivityParticipations {
  if out, ok := StudentActivityParticipationsPointer(StudentActivityParticipations{}); !ok {
                log.Fatalf("Could not create pointer to StudentActivityParticipations\n")
                return nil
        } else {
          out.studentactivityparticipations.StudentActivityParticipation = make([]studentactivityparticipation, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentActivityParticipations) Append(values ...*StudentActivityParticipation) *StudentActivityParticipations {
        if t == nil {
                t, _ = StudentActivityParticipationsPointer(StudentActivityParticipations{})
        }
        /*
        if t.studentactivityparticipations == nil {
          t.studentactivityparticipations = studentactivityparticipations{StudentActivityParticipation: make([]studentactivityparticipation, 0)}
        }
        */
        if t.studentactivityparticipations.StudentActivityParticipation == nil {
                t.studentactivityparticipations.StudentActivityParticipation = make([]studentactivityparticipation, 0)
        }
        for _, value := range values {
        t.studentactivityparticipations.StudentActivityParticipation = append(t.studentactivityparticipations.StudentActivityParticipation, value.studentactivityparticipation)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentActivityParticipations) AddNew() *StudentActivityParticipations {
        if t == nil {
                t, _ = StudentActivityParticipationsPointer(StudentActivityParticipations{})
        }
        /*
        if t.studentactivityparticipations == nil {
          t.studentactivityparticipations = studentactivityparticipations{StudentActivityParticipation: make([]studentactivityparticipation, 0)}
        }
        */
        if t.studentactivityparticipations.StudentActivityParticipation == nil {
                t.studentactivityparticipations.StudentActivityParticipation = make([]studentactivityparticipation, 0)
        }
        t.studentactivityparticipations.StudentActivityParticipation = append(t.studentactivityparticipations.StudentActivityParticipation, studentactivityparticipation{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentActivityParticipations) Last() *studentactivityparticipation {
  /*
  if t.studentactivityparticipations == nil {
    t = t.AddNew()
    }
    */
  if t.studentactivityparticipations.StudentActivityParticipation == nil {
    t = t.AddNew()
    }
        return &(t.studentactivityparticipations.StudentActivityParticipation[len(t.studentactivityparticipations.StudentActivityParticipation)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentActivityParticipations) Index(n int) *StudentActivityParticipation {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentActivityParticipations.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentactivityparticipations == nil {
    t = t.AddNew()
    }
    */
  if t.studentactivityparticipations.StudentActivityParticipation == nil {
    t = t.AddNew()
    }
        return &StudentActivityParticipation{(t.studentactivityparticipations.StudentActivityParticipation[n])}
}

// Length of the list.
func (t *StudentActivityParticipations) Len() int {
  /*
  if t.studentactivityparticipations == nil {
    t = t.AddNew()
    }
    */
  if t.studentactivityparticipations.StudentActivityParticipation == nil {
    t = t.AddNew()
    }
        return len(t.studentactivityparticipations.StudentActivityParticipation)
}

// Convert list object to slice
func (t *StudentActivityParticipations) ToSlice() []*StudentActivityParticipation {
    ret := make([]*StudentActivityParticipation, 0)
  for _, x:= range t.studentactivityparticipations.StudentActivityParticipation {
    ret = append(ret, &StudentActivityParticipation{studentactivityparticipation: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentAttendanceCollections() *StudentAttendanceCollections {
  if out, ok := StudentAttendanceCollectionsPointer(StudentAttendanceCollections{}); !ok {
                log.Fatalf("Could not create pointer to StudentAttendanceCollections\n")
                return nil
        } else {
          out.studentattendancecollections.StudentAttendanceCollection = make([]studentattendancecollection, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentAttendanceCollections) Append(values ...*StudentAttendanceCollection) *StudentAttendanceCollections {
        if t == nil {
                t, _ = StudentAttendanceCollectionsPointer(StudentAttendanceCollections{})
        }
        /*
        if t.studentattendancecollections == nil {
          t.studentattendancecollections = studentattendancecollections{StudentAttendanceCollection: make([]studentattendancecollection, 0)}
        }
        */
        if t.studentattendancecollections.StudentAttendanceCollection == nil {
                t.studentattendancecollections.StudentAttendanceCollection = make([]studentattendancecollection, 0)
        }
        for _, value := range values {
        t.studentattendancecollections.StudentAttendanceCollection = append(t.studentattendancecollections.StudentAttendanceCollection, value.studentattendancecollection)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentAttendanceCollections) AddNew() *StudentAttendanceCollections {
        if t == nil {
                t, _ = StudentAttendanceCollectionsPointer(StudentAttendanceCollections{})
        }
        /*
        if t.studentattendancecollections == nil {
          t.studentattendancecollections = studentattendancecollections{StudentAttendanceCollection: make([]studentattendancecollection, 0)}
        }
        */
        if t.studentattendancecollections.StudentAttendanceCollection == nil {
                t.studentattendancecollections.StudentAttendanceCollection = make([]studentattendancecollection, 0)
        }
        t.studentattendancecollections.StudentAttendanceCollection = append(t.studentattendancecollections.StudentAttendanceCollection, studentattendancecollection{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentAttendanceCollections) Last() *studentattendancecollection {
  /*
  if t.studentattendancecollections == nil {
    t = t.AddNew()
    }
    */
  if t.studentattendancecollections.StudentAttendanceCollection == nil {
    t = t.AddNew()
    }
        return &(t.studentattendancecollections.StudentAttendanceCollection[len(t.studentattendancecollections.StudentAttendanceCollection)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentAttendanceCollections) Index(n int) *StudentAttendanceCollection {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentAttendanceCollections.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentattendancecollections == nil {
    t = t.AddNew()
    }
    */
  if t.studentattendancecollections.StudentAttendanceCollection == nil {
    t = t.AddNew()
    }
        return &StudentAttendanceCollection{(t.studentattendancecollections.StudentAttendanceCollection[n])}
}

// Length of the list.
func (t *StudentAttendanceCollections) Len() int {
  /*
  if t.studentattendancecollections == nil {
    t = t.AddNew()
    }
    */
  if t.studentattendancecollections.StudentAttendanceCollection == nil {
    t = t.AddNew()
    }
        return len(t.studentattendancecollections.StudentAttendanceCollection)
}

// Convert list object to slice
func (t *StudentAttendanceCollections) ToSlice() []*StudentAttendanceCollection {
    ret := make([]*StudentAttendanceCollection, 0)
  for _, x:= range t.studentattendancecollections.StudentAttendanceCollection {
    ret = append(ret, &StudentAttendanceCollection{studentattendancecollection: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentAttendanceSummarys() *StudentAttendanceSummarys {
  if out, ok := StudentAttendanceSummarysPointer(StudentAttendanceSummarys{}); !ok {
                log.Fatalf("Could not create pointer to StudentAttendanceSummarys\n")
                return nil
        } else {
          out.studentattendancesummarys.StudentAttendanceSummary = make([]studentattendancesummary, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentAttendanceSummarys) Append(values ...*StudentAttendanceSummary) *StudentAttendanceSummarys {
        if t == nil {
                t, _ = StudentAttendanceSummarysPointer(StudentAttendanceSummarys{})
        }
        /*
        if t.studentattendancesummarys == nil {
          t.studentattendancesummarys = studentattendancesummarys{StudentAttendanceSummary: make([]studentattendancesummary, 0)}
        }
        */
        if t.studentattendancesummarys.StudentAttendanceSummary == nil {
                t.studentattendancesummarys.StudentAttendanceSummary = make([]studentattendancesummary, 0)
        }
        for _, value := range values {
        t.studentattendancesummarys.StudentAttendanceSummary = append(t.studentattendancesummarys.StudentAttendanceSummary, value.studentattendancesummary)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentAttendanceSummarys) AddNew() *StudentAttendanceSummarys {
        if t == nil {
                t, _ = StudentAttendanceSummarysPointer(StudentAttendanceSummarys{})
        }
        /*
        if t.studentattendancesummarys == nil {
          t.studentattendancesummarys = studentattendancesummarys{StudentAttendanceSummary: make([]studentattendancesummary, 0)}
        }
        */
        if t.studentattendancesummarys.StudentAttendanceSummary == nil {
                t.studentattendancesummarys.StudentAttendanceSummary = make([]studentattendancesummary, 0)
        }
        t.studentattendancesummarys.StudentAttendanceSummary = append(t.studentattendancesummarys.StudentAttendanceSummary, studentattendancesummary{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentAttendanceSummarys) Last() *studentattendancesummary {
  /*
  if t.studentattendancesummarys == nil {
    t = t.AddNew()
    }
    */
  if t.studentattendancesummarys.StudentAttendanceSummary == nil {
    t = t.AddNew()
    }
        return &(t.studentattendancesummarys.StudentAttendanceSummary[len(t.studentattendancesummarys.StudentAttendanceSummary)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentAttendanceSummarys) Index(n int) *StudentAttendanceSummary {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentAttendanceSummarys.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentattendancesummarys == nil {
    t = t.AddNew()
    }
    */
  if t.studentattendancesummarys.StudentAttendanceSummary == nil {
    t = t.AddNew()
    }
        return &StudentAttendanceSummary{(t.studentattendancesummarys.StudentAttendanceSummary[n])}
}

// Length of the list.
func (t *StudentAttendanceSummarys) Len() int {
  /*
  if t.studentattendancesummarys == nil {
    t = t.AddNew()
    }
    */
  if t.studentattendancesummarys.StudentAttendanceSummary == nil {
    t = t.AddNew()
    }
        return len(t.studentattendancesummarys.StudentAttendanceSummary)
}

// Convert list object to slice
func (t *StudentAttendanceSummarys) ToSlice() []*StudentAttendanceSummary {
    ret := make([]*StudentAttendanceSummary, 0)
  for _, x:= range t.studentattendancesummarys.StudentAttendanceSummary {
    ret = append(ret, &StudentAttendanceSummary{studentattendancesummary: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentAttendanceTimeLists() *StudentAttendanceTimeLists {
  if out, ok := StudentAttendanceTimeListsPointer(StudentAttendanceTimeLists{}); !ok {
                log.Fatalf("Could not create pointer to StudentAttendanceTimeLists\n")
                return nil
        } else {
          out.studentattendancetimelists.StudentAttendanceTimeList = make([]studentattendancetimelist, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentAttendanceTimeLists) Append(values ...*StudentAttendanceTimeList) *StudentAttendanceTimeLists {
        if t == nil {
                t, _ = StudentAttendanceTimeListsPointer(StudentAttendanceTimeLists{})
        }
        /*
        if t.studentattendancetimelists == nil {
          t.studentattendancetimelists = studentattendancetimelists{StudentAttendanceTimeList: make([]studentattendancetimelist, 0)}
        }
        */
        if t.studentattendancetimelists.StudentAttendanceTimeList == nil {
                t.studentattendancetimelists.StudentAttendanceTimeList = make([]studentattendancetimelist, 0)
        }
        for _, value := range values {
        t.studentattendancetimelists.StudentAttendanceTimeList = append(t.studentattendancetimelists.StudentAttendanceTimeList, value.studentattendancetimelist)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentAttendanceTimeLists) AddNew() *StudentAttendanceTimeLists {
        if t == nil {
                t, _ = StudentAttendanceTimeListsPointer(StudentAttendanceTimeLists{})
        }
        /*
        if t.studentattendancetimelists == nil {
          t.studentattendancetimelists = studentattendancetimelists{StudentAttendanceTimeList: make([]studentattendancetimelist, 0)}
        }
        */
        if t.studentattendancetimelists.StudentAttendanceTimeList == nil {
                t.studentattendancetimelists.StudentAttendanceTimeList = make([]studentattendancetimelist, 0)
        }
        t.studentattendancetimelists.StudentAttendanceTimeList = append(t.studentattendancetimelists.StudentAttendanceTimeList, studentattendancetimelist{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentAttendanceTimeLists) Last() *studentattendancetimelist {
  /*
  if t.studentattendancetimelists == nil {
    t = t.AddNew()
    }
    */
  if t.studentattendancetimelists.StudentAttendanceTimeList == nil {
    t = t.AddNew()
    }
        return &(t.studentattendancetimelists.StudentAttendanceTimeList[len(t.studentattendancetimelists.StudentAttendanceTimeList)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentAttendanceTimeLists) Index(n int) *StudentAttendanceTimeList {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentAttendanceTimeLists.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentattendancetimelists == nil {
    t = t.AddNew()
    }
    */
  if t.studentattendancetimelists.StudentAttendanceTimeList == nil {
    t = t.AddNew()
    }
        return &StudentAttendanceTimeList{(t.studentattendancetimelists.StudentAttendanceTimeList[n])}
}

// Length of the list.
func (t *StudentAttendanceTimeLists) Len() int {
  /*
  if t.studentattendancetimelists == nil {
    t = t.AddNew()
    }
    */
  if t.studentattendancetimelists.StudentAttendanceTimeList == nil {
    t = t.AddNew()
    }
        return len(t.studentattendancetimelists.StudentAttendanceTimeList)
}

// Convert list object to slice
func (t *StudentAttendanceTimeLists) ToSlice() []*StudentAttendanceTimeList {
    ret := make([]*StudentAttendanceTimeList, 0)
  for _, x:= range t.studentattendancetimelists.StudentAttendanceTimeList {
    ret = append(ret, &StudentAttendanceTimeList{studentattendancetimelist: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentContactPersonals() *StudentContactPersonals {
  if out, ok := StudentContactPersonalsPointer(StudentContactPersonals{}); !ok {
                log.Fatalf("Could not create pointer to StudentContactPersonals\n")
                return nil
        } else {
          out.studentcontactpersonals.StudentContactPersonal = make([]studentcontactpersonal, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentContactPersonals) Append(values ...*StudentContactPersonal) *StudentContactPersonals {
        if t == nil {
                t, _ = StudentContactPersonalsPointer(StudentContactPersonals{})
        }
        /*
        if t.studentcontactpersonals == nil {
          t.studentcontactpersonals = studentcontactpersonals{StudentContactPersonal: make([]studentcontactpersonal, 0)}
        }
        */
        if t.studentcontactpersonals.StudentContactPersonal == nil {
                t.studentcontactpersonals.StudentContactPersonal = make([]studentcontactpersonal, 0)
        }
        for _, value := range values {
        t.studentcontactpersonals.StudentContactPersonal = append(t.studentcontactpersonals.StudentContactPersonal, value.studentcontactpersonal)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentContactPersonals) AddNew() *StudentContactPersonals {
        if t == nil {
                t, _ = StudentContactPersonalsPointer(StudentContactPersonals{})
        }
        /*
        if t.studentcontactpersonals == nil {
          t.studentcontactpersonals = studentcontactpersonals{StudentContactPersonal: make([]studentcontactpersonal, 0)}
        }
        */
        if t.studentcontactpersonals.StudentContactPersonal == nil {
                t.studentcontactpersonals.StudentContactPersonal = make([]studentcontactpersonal, 0)
        }
        t.studentcontactpersonals.StudentContactPersonal = append(t.studentcontactpersonals.StudentContactPersonal, studentcontactpersonal{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentContactPersonals) Last() *studentcontactpersonal {
  /*
  if t.studentcontactpersonals == nil {
    t = t.AddNew()
    }
    */
  if t.studentcontactpersonals.StudentContactPersonal == nil {
    t = t.AddNew()
    }
        return &(t.studentcontactpersonals.StudentContactPersonal[len(t.studentcontactpersonals.StudentContactPersonal)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentContactPersonals) Index(n int) *StudentContactPersonal {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentContactPersonals.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentcontactpersonals == nil {
    t = t.AddNew()
    }
    */
  if t.studentcontactpersonals.StudentContactPersonal == nil {
    t = t.AddNew()
    }
        return &StudentContactPersonal{(t.studentcontactpersonals.StudentContactPersonal[n])}
}

// Length of the list.
func (t *StudentContactPersonals) Len() int {
  /*
  if t.studentcontactpersonals == nil {
    t = t.AddNew()
    }
    */
  if t.studentcontactpersonals.StudentContactPersonal == nil {
    t = t.AddNew()
    }
        return len(t.studentcontactpersonals.StudentContactPersonal)
}

// Convert list object to slice
func (t *StudentContactPersonals) ToSlice() []*StudentContactPersonal {
    ret := make([]*StudentContactPersonal, 0)
  for _, x:= range t.studentcontactpersonals.StudentContactPersonal {
    ret = append(ret, &StudentContactPersonal{studentcontactpersonal: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentContactRelationships() *StudentContactRelationships {
  if out, ok := StudentContactRelationshipsPointer(StudentContactRelationships{}); !ok {
                log.Fatalf("Could not create pointer to StudentContactRelationships\n")
                return nil
        } else {
          out.studentcontactrelationships.StudentContactRelationship = make([]studentcontactrelationship, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentContactRelationships) Append(values ...*StudentContactRelationship) *StudentContactRelationships {
        if t == nil {
                t, _ = StudentContactRelationshipsPointer(StudentContactRelationships{})
        }
        /*
        if t.studentcontactrelationships == nil {
          t.studentcontactrelationships = studentcontactrelationships{StudentContactRelationship: make([]studentcontactrelationship, 0)}
        }
        */
        if t.studentcontactrelationships.StudentContactRelationship == nil {
                t.studentcontactrelationships.StudentContactRelationship = make([]studentcontactrelationship, 0)
        }
        for _, value := range values {
        t.studentcontactrelationships.StudentContactRelationship = append(t.studentcontactrelationships.StudentContactRelationship, value.studentcontactrelationship)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentContactRelationships) AddNew() *StudentContactRelationships {
        if t == nil {
                t, _ = StudentContactRelationshipsPointer(StudentContactRelationships{})
        }
        /*
        if t.studentcontactrelationships == nil {
          t.studentcontactrelationships = studentcontactrelationships{StudentContactRelationship: make([]studentcontactrelationship, 0)}
        }
        */
        if t.studentcontactrelationships.StudentContactRelationship == nil {
                t.studentcontactrelationships.StudentContactRelationship = make([]studentcontactrelationship, 0)
        }
        t.studentcontactrelationships.StudentContactRelationship = append(t.studentcontactrelationships.StudentContactRelationship, studentcontactrelationship{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentContactRelationships) Last() *studentcontactrelationship {
  /*
  if t.studentcontactrelationships == nil {
    t = t.AddNew()
    }
    */
  if t.studentcontactrelationships.StudentContactRelationship == nil {
    t = t.AddNew()
    }
        return &(t.studentcontactrelationships.StudentContactRelationship[len(t.studentcontactrelationships.StudentContactRelationship)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentContactRelationships) Index(n int) *StudentContactRelationship {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentContactRelationships.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentcontactrelationships == nil {
    t = t.AddNew()
    }
    */
  if t.studentcontactrelationships.StudentContactRelationship == nil {
    t = t.AddNew()
    }
        return &StudentContactRelationship{(t.studentcontactrelationships.StudentContactRelationship[n])}
}

// Length of the list.
func (t *StudentContactRelationships) Len() int {
  /*
  if t.studentcontactrelationships == nil {
    t = t.AddNew()
    }
    */
  if t.studentcontactrelationships.StudentContactRelationship == nil {
    t = t.AddNew()
    }
        return len(t.studentcontactrelationships.StudentContactRelationship)
}

// Convert list object to slice
func (t *StudentContactRelationships) ToSlice() []*StudentContactRelationship {
    ret := make([]*StudentContactRelationship, 0)
  for _, x:= range t.studentcontactrelationships.StudentContactRelationship {
    ret = append(ret, &StudentContactRelationship{studentcontactrelationship: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentDailyAttendances() *StudentDailyAttendances {
  if out, ok := StudentDailyAttendancesPointer(StudentDailyAttendances{}); !ok {
                log.Fatalf("Could not create pointer to StudentDailyAttendances\n")
                return nil
        } else {
          out.studentdailyattendances.StudentDailyAttendance = make([]studentdailyattendance, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentDailyAttendances) Append(values ...*StudentDailyAttendance) *StudentDailyAttendances {
        if t == nil {
                t, _ = StudentDailyAttendancesPointer(StudentDailyAttendances{})
        }
        /*
        if t.studentdailyattendances == nil {
          t.studentdailyattendances = studentdailyattendances{StudentDailyAttendance: make([]studentdailyattendance, 0)}
        }
        */
        if t.studentdailyattendances.StudentDailyAttendance == nil {
                t.studentdailyattendances.StudentDailyAttendance = make([]studentdailyattendance, 0)
        }
        for _, value := range values {
        t.studentdailyattendances.StudentDailyAttendance = append(t.studentdailyattendances.StudentDailyAttendance, value.studentdailyattendance)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentDailyAttendances) AddNew() *StudentDailyAttendances {
        if t == nil {
                t, _ = StudentDailyAttendancesPointer(StudentDailyAttendances{})
        }
        /*
        if t.studentdailyattendances == nil {
          t.studentdailyattendances = studentdailyattendances{StudentDailyAttendance: make([]studentdailyattendance, 0)}
        }
        */
        if t.studentdailyattendances.StudentDailyAttendance == nil {
                t.studentdailyattendances.StudentDailyAttendance = make([]studentdailyattendance, 0)
        }
        t.studentdailyattendances.StudentDailyAttendance = append(t.studentdailyattendances.StudentDailyAttendance, studentdailyattendance{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentDailyAttendances) Last() *studentdailyattendance {
  /*
  if t.studentdailyattendances == nil {
    t = t.AddNew()
    }
    */
  if t.studentdailyattendances.StudentDailyAttendance == nil {
    t = t.AddNew()
    }
        return &(t.studentdailyattendances.StudentDailyAttendance[len(t.studentdailyattendances.StudentDailyAttendance)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentDailyAttendances) Index(n int) *StudentDailyAttendance {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentDailyAttendances.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentdailyattendances == nil {
    t = t.AddNew()
    }
    */
  if t.studentdailyattendances.StudentDailyAttendance == nil {
    t = t.AddNew()
    }
        return &StudentDailyAttendance{(t.studentdailyattendances.StudentDailyAttendance[n])}
}

// Length of the list.
func (t *StudentDailyAttendances) Len() int {
  /*
  if t.studentdailyattendances == nil {
    t = t.AddNew()
    }
    */
  if t.studentdailyattendances.StudentDailyAttendance == nil {
    t = t.AddNew()
    }
        return len(t.studentdailyattendances.StudentDailyAttendance)
}

// Convert list object to slice
func (t *StudentDailyAttendances) ToSlice() []*StudentDailyAttendance {
    ret := make([]*StudentDailyAttendance, 0)
  for _, x:= range t.studentdailyattendances.StudentDailyAttendance {
    ret = append(ret, &StudentDailyAttendance{studentdailyattendance: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentDataTransferNotes() *StudentDataTransferNotes {
  if out, ok := StudentDataTransferNotesPointer(StudentDataTransferNotes{}); !ok {
                log.Fatalf("Could not create pointer to StudentDataTransferNotes\n")
                return nil
        } else {
          out.studentdatatransfernotes.StudentDataTransferNote = make([]studentdatatransfernote, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentDataTransferNotes) Append(values ...*StudentDataTransferNote) *StudentDataTransferNotes {
        if t == nil {
                t, _ = StudentDataTransferNotesPointer(StudentDataTransferNotes{})
        }
        /*
        if t.studentdatatransfernotes == nil {
          t.studentdatatransfernotes = studentdatatransfernotes{StudentDataTransferNote: make([]studentdatatransfernote, 0)}
        }
        */
        if t.studentdatatransfernotes.StudentDataTransferNote == nil {
                t.studentdatatransfernotes.StudentDataTransferNote = make([]studentdatatransfernote, 0)
        }
        for _, value := range values {
        t.studentdatatransfernotes.StudentDataTransferNote = append(t.studentdatatransfernotes.StudentDataTransferNote, value.studentdatatransfernote)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentDataTransferNotes) AddNew() *StudentDataTransferNotes {
        if t == nil {
                t, _ = StudentDataTransferNotesPointer(StudentDataTransferNotes{})
        }
        /*
        if t.studentdatatransfernotes == nil {
          t.studentdatatransfernotes = studentdatatransfernotes{StudentDataTransferNote: make([]studentdatatransfernote, 0)}
        }
        */
        if t.studentdatatransfernotes.StudentDataTransferNote == nil {
                t.studentdatatransfernotes.StudentDataTransferNote = make([]studentdatatransfernote, 0)
        }
        t.studentdatatransfernotes.StudentDataTransferNote = append(t.studentdatatransfernotes.StudentDataTransferNote, studentdatatransfernote{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentDataTransferNotes) Last() *studentdatatransfernote {
  /*
  if t.studentdatatransfernotes == nil {
    t = t.AddNew()
    }
    */
  if t.studentdatatransfernotes.StudentDataTransferNote == nil {
    t = t.AddNew()
    }
        return &(t.studentdatatransfernotes.StudentDataTransferNote[len(t.studentdatatransfernotes.StudentDataTransferNote)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentDataTransferNotes) Index(n int) *StudentDataTransferNote {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentDataTransferNotes.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentdatatransfernotes == nil {
    t = t.AddNew()
    }
    */
  if t.studentdatatransfernotes.StudentDataTransferNote == nil {
    t = t.AddNew()
    }
        return &StudentDataTransferNote{(t.studentdatatransfernotes.StudentDataTransferNote[n])}
}

// Length of the list.
func (t *StudentDataTransferNotes) Len() int {
  /*
  if t.studentdatatransfernotes == nil {
    t = t.AddNew()
    }
    */
  if t.studentdatatransfernotes.StudentDataTransferNote == nil {
    t = t.AddNew()
    }
        return len(t.studentdatatransfernotes.StudentDataTransferNote)
}

// Convert list object to slice
func (t *StudentDataTransferNotes) ToSlice() []*StudentDataTransferNote {
    ret := make([]*StudentDataTransferNote, 0)
  for _, x:= range t.studentdatatransfernotes.StudentDataTransferNote {
    ret = append(ret, &StudentDataTransferNote{studentdatatransfernote: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentGrades() *StudentGrades {
  if out, ok := StudentGradesPointer(StudentGrades{}); !ok {
                log.Fatalf("Could not create pointer to StudentGrades\n")
                return nil
        } else {
          out.studentgrades.StudentGrade = make([]studentgrade, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentGrades) Append(values ...*StudentGrade) *StudentGrades {
        if t == nil {
                t, _ = StudentGradesPointer(StudentGrades{})
        }
        /*
        if t.studentgrades == nil {
          t.studentgrades = studentgrades{StudentGrade: make([]studentgrade, 0)}
        }
        */
        if t.studentgrades.StudentGrade == nil {
                t.studentgrades.StudentGrade = make([]studentgrade, 0)
        }
        for _, value := range values {
        t.studentgrades.StudentGrade = append(t.studentgrades.StudentGrade, value.studentgrade)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentGrades) AddNew() *StudentGrades {
        if t == nil {
                t, _ = StudentGradesPointer(StudentGrades{})
        }
        /*
        if t.studentgrades == nil {
          t.studentgrades = studentgrades{StudentGrade: make([]studentgrade, 0)}
        }
        */
        if t.studentgrades.StudentGrade == nil {
                t.studentgrades.StudentGrade = make([]studentgrade, 0)
        }
        t.studentgrades.StudentGrade = append(t.studentgrades.StudentGrade, studentgrade{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentGrades) Last() *studentgrade {
  /*
  if t.studentgrades == nil {
    t = t.AddNew()
    }
    */
  if t.studentgrades.StudentGrade == nil {
    t = t.AddNew()
    }
        return &(t.studentgrades.StudentGrade[len(t.studentgrades.StudentGrade)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentGrades) Index(n int) *StudentGrade {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentGrades.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentgrades == nil {
    t = t.AddNew()
    }
    */
  if t.studentgrades.StudentGrade == nil {
    t = t.AddNew()
    }
        return &StudentGrade{(t.studentgrades.StudentGrade[n])}
}

// Length of the list.
func (t *StudentGrades) Len() int {
  /*
  if t.studentgrades == nil {
    t = t.AddNew()
    }
    */
  if t.studentgrades.StudentGrade == nil {
    t = t.AddNew()
    }
        return len(t.studentgrades.StudentGrade)
}

// Convert list object to slice
func (t *StudentGrades) ToSlice() []*StudentGrade {
    ret := make([]*StudentGrade, 0)
  for _, x:= range t.studentgrades.StudentGrade {
    ret = append(ret, &StudentGrade{studentgrade: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentParticipations() *StudentParticipations {
  if out, ok := StudentParticipationsPointer(StudentParticipations{}); !ok {
                log.Fatalf("Could not create pointer to StudentParticipations\n")
                return nil
        } else {
          out.studentparticipations.StudentParticipation = make([]studentparticipation, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentParticipations) Append(values ...*StudentParticipation) *StudentParticipations {
        if t == nil {
                t, _ = StudentParticipationsPointer(StudentParticipations{})
        }
        /*
        if t.studentparticipations == nil {
          t.studentparticipations = studentparticipations{StudentParticipation: make([]studentparticipation, 0)}
        }
        */
        if t.studentparticipations.StudentParticipation == nil {
                t.studentparticipations.StudentParticipation = make([]studentparticipation, 0)
        }
        for _, value := range values {
        t.studentparticipations.StudentParticipation = append(t.studentparticipations.StudentParticipation, value.studentparticipation)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentParticipations) AddNew() *StudentParticipations {
        if t == nil {
                t, _ = StudentParticipationsPointer(StudentParticipations{})
        }
        /*
        if t.studentparticipations == nil {
          t.studentparticipations = studentparticipations{StudentParticipation: make([]studentparticipation, 0)}
        }
        */
        if t.studentparticipations.StudentParticipation == nil {
                t.studentparticipations.StudentParticipation = make([]studentparticipation, 0)
        }
        t.studentparticipations.StudentParticipation = append(t.studentparticipations.StudentParticipation, studentparticipation{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentParticipations) Last() *studentparticipation {
  /*
  if t.studentparticipations == nil {
    t = t.AddNew()
    }
    */
  if t.studentparticipations.StudentParticipation == nil {
    t = t.AddNew()
    }
        return &(t.studentparticipations.StudentParticipation[len(t.studentparticipations.StudentParticipation)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentParticipations) Index(n int) *StudentParticipation {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentParticipations.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentparticipations == nil {
    t = t.AddNew()
    }
    */
  if t.studentparticipations.StudentParticipation == nil {
    t = t.AddNew()
    }
        return &StudentParticipation{(t.studentparticipations.StudentParticipation[n])}
}

// Length of the list.
func (t *StudentParticipations) Len() int {
  /*
  if t.studentparticipations == nil {
    t = t.AddNew()
    }
    */
  if t.studentparticipations.StudentParticipation == nil {
    t = t.AddNew()
    }
        return len(t.studentparticipations.StudentParticipation)
}

// Convert list object to slice
func (t *StudentParticipations) ToSlice() []*StudentParticipation {
    ret := make([]*StudentParticipation, 0)
  for _, x:= range t.studentparticipations.StudentParticipation {
    ret = append(ret, &StudentParticipation{studentparticipation: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentPeriodAttendances() *StudentPeriodAttendances {
  if out, ok := StudentPeriodAttendancesPointer(StudentPeriodAttendances{}); !ok {
                log.Fatalf("Could not create pointer to StudentPeriodAttendances\n")
                return nil
        } else {
          out.studentperiodattendances.StudentPeriodAttendance = make([]studentperiodattendance, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentPeriodAttendances) Append(values ...*StudentPeriodAttendance) *StudentPeriodAttendances {
        if t == nil {
                t, _ = StudentPeriodAttendancesPointer(StudentPeriodAttendances{})
        }
        /*
        if t.studentperiodattendances == nil {
          t.studentperiodattendances = studentperiodattendances{StudentPeriodAttendance: make([]studentperiodattendance, 0)}
        }
        */
        if t.studentperiodattendances.StudentPeriodAttendance == nil {
                t.studentperiodattendances.StudentPeriodAttendance = make([]studentperiodattendance, 0)
        }
        for _, value := range values {
        t.studentperiodattendances.StudentPeriodAttendance = append(t.studentperiodattendances.StudentPeriodAttendance, value.studentperiodattendance)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentPeriodAttendances) AddNew() *StudentPeriodAttendances {
        if t == nil {
                t, _ = StudentPeriodAttendancesPointer(StudentPeriodAttendances{})
        }
        /*
        if t.studentperiodattendances == nil {
          t.studentperiodattendances = studentperiodattendances{StudentPeriodAttendance: make([]studentperiodattendance, 0)}
        }
        */
        if t.studentperiodattendances.StudentPeriodAttendance == nil {
                t.studentperiodattendances.StudentPeriodAttendance = make([]studentperiodattendance, 0)
        }
        t.studentperiodattendances.StudentPeriodAttendance = append(t.studentperiodattendances.StudentPeriodAttendance, studentperiodattendance{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentPeriodAttendances) Last() *studentperiodattendance {
  /*
  if t.studentperiodattendances == nil {
    t = t.AddNew()
    }
    */
  if t.studentperiodattendances.StudentPeriodAttendance == nil {
    t = t.AddNew()
    }
        return &(t.studentperiodattendances.StudentPeriodAttendance[len(t.studentperiodattendances.StudentPeriodAttendance)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentPeriodAttendances) Index(n int) *StudentPeriodAttendance {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentPeriodAttendances.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentperiodattendances == nil {
    t = t.AddNew()
    }
    */
  if t.studentperiodattendances.StudentPeriodAttendance == nil {
    t = t.AddNew()
    }
        return &StudentPeriodAttendance{(t.studentperiodattendances.StudentPeriodAttendance[n])}
}

// Length of the list.
func (t *StudentPeriodAttendances) Len() int {
  /*
  if t.studentperiodattendances == nil {
    t = t.AddNew()
    }
    */
  if t.studentperiodattendances.StudentPeriodAttendance == nil {
    t = t.AddNew()
    }
        return len(t.studentperiodattendances.StudentPeriodAttendance)
}

// Convert list object to slice
func (t *StudentPeriodAttendances) ToSlice() []*StudentPeriodAttendance {
    ret := make([]*StudentPeriodAttendance, 0)
  for _, x:= range t.studentperiodattendances.StudentPeriodAttendance {
    ret = append(ret, &StudentPeriodAttendance{studentperiodattendance: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentPersonals() *StudentPersonals {
  if out, ok := StudentPersonalsPointer(StudentPersonals{}); !ok {
                log.Fatalf("Could not create pointer to StudentPersonals\n")
                return nil
        } else {
          out.studentpersonals.StudentPersonal = make([]studentpersonal, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentPersonals) Append(values ...*StudentPersonal) *StudentPersonals {
        if t == nil {
                t, _ = StudentPersonalsPointer(StudentPersonals{})
        }
        /*
        if t.studentpersonals == nil {
          t.studentpersonals = studentpersonals{StudentPersonal: make([]studentpersonal, 0)}
        }
        */
        if t.studentpersonals.StudentPersonal == nil {
                t.studentpersonals.StudentPersonal = make([]studentpersonal, 0)
        }
        for _, value := range values {
        t.studentpersonals.StudentPersonal = append(t.studentpersonals.StudentPersonal, value.studentpersonal)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentPersonals) AddNew() *StudentPersonals {
        if t == nil {
                t, _ = StudentPersonalsPointer(StudentPersonals{})
        }
        /*
        if t.studentpersonals == nil {
          t.studentpersonals = studentpersonals{StudentPersonal: make([]studentpersonal, 0)}
        }
        */
        if t.studentpersonals.StudentPersonal == nil {
                t.studentpersonals.StudentPersonal = make([]studentpersonal, 0)
        }
        t.studentpersonals.StudentPersonal = append(t.studentpersonals.StudentPersonal, studentpersonal{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentPersonals) Last() *studentpersonal {
  /*
  if t.studentpersonals == nil {
    t = t.AddNew()
    }
    */
  if t.studentpersonals.StudentPersonal == nil {
    t = t.AddNew()
    }
        return &(t.studentpersonals.StudentPersonal[len(t.studentpersonals.StudentPersonal)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentPersonals) Index(n int) *StudentPersonal {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentPersonals.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentpersonals == nil {
    t = t.AddNew()
    }
    */
  if t.studentpersonals.StudentPersonal == nil {
    t = t.AddNew()
    }
        return &StudentPersonal{(t.studentpersonals.StudentPersonal[n])}
}

// Length of the list.
func (t *StudentPersonals) Len() int {
  /*
  if t.studentpersonals == nil {
    t = t.AddNew()
    }
    */
  if t.studentpersonals.StudentPersonal == nil {
    t = t.AddNew()
    }
        return len(t.studentpersonals.StudentPersonal)
}

// Convert list object to slice
func (t *StudentPersonals) ToSlice() []*StudentPersonal {
    ret := make([]*StudentPersonal, 0)
  for _, x:= range t.studentpersonals.StudentPersonal {
    ret = append(ret, &StudentPersonal{studentpersonal: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentSchoolEnrollments() *StudentSchoolEnrollments {
  if out, ok := StudentSchoolEnrollmentsPointer(StudentSchoolEnrollments{}); !ok {
                log.Fatalf("Could not create pointer to StudentSchoolEnrollments\n")
                return nil
        } else {
          out.studentschoolenrollments.StudentSchoolEnrollment = make([]studentschoolenrollment, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentSchoolEnrollments) Append(values ...*StudentSchoolEnrollment) *StudentSchoolEnrollments {
        if t == nil {
                t, _ = StudentSchoolEnrollmentsPointer(StudentSchoolEnrollments{})
        }
        /*
        if t.studentschoolenrollments == nil {
          t.studentschoolenrollments = studentschoolenrollments{StudentSchoolEnrollment: make([]studentschoolenrollment, 0)}
        }
        */
        if t.studentschoolenrollments.StudentSchoolEnrollment == nil {
                t.studentschoolenrollments.StudentSchoolEnrollment = make([]studentschoolenrollment, 0)
        }
        for _, value := range values {
        t.studentschoolenrollments.StudentSchoolEnrollment = append(t.studentschoolenrollments.StudentSchoolEnrollment, value.studentschoolenrollment)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentSchoolEnrollments) AddNew() *StudentSchoolEnrollments {
        if t == nil {
                t, _ = StudentSchoolEnrollmentsPointer(StudentSchoolEnrollments{})
        }
        /*
        if t.studentschoolenrollments == nil {
          t.studentschoolenrollments = studentschoolenrollments{StudentSchoolEnrollment: make([]studentschoolenrollment, 0)}
        }
        */
        if t.studentschoolenrollments.StudentSchoolEnrollment == nil {
                t.studentschoolenrollments.StudentSchoolEnrollment = make([]studentschoolenrollment, 0)
        }
        t.studentschoolenrollments.StudentSchoolEnrollment = append(t.studentschoolenrollments.StudentSchoolEnrollment, studentschoolenrollment{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentSchoolEnrollments) Last() *studentschoolenrollment {
  /*
  if t.studentschoolenrollments == nil {
    t = t.AddNew()
    }
    */
  if t.studentschoolenrollments.StudentSchoolEnrollment == nil {
    t = t.AddNew()
    }
        return &(t.studentschoolenrollments.StudentSchoolEnrollment[len(t.studentschoolenrollments.StudentSchoolEnrollment)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentSchoolEnrollments) Index(n int) *StudentSchoolEnrollment {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentSchoolEnrollments.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentschoolenrollments == nil {
    t = t.AddNew()
    }
    */
  if t.studentschoolenrollments.StudentSchoolEnrollment == nil {
    t = t.AddNew()
    }
        return &StudentSchoolEnrollment{(t.studentschoolenrollments.StudentSchoolEnrollment[n])}
}

// Length of the list.
func (t *StudentSchoolEnrollments) Len() int {
  /*
  if t.studentschoolenrollments == nil {
    t = t.AddNew()
    }
    */
  if t.studentschoolenrollments.StudentSchoolEnrollment == nil {
    t = t.AddNew()
    }
        return len(t.studentschoolenrollments.StudentSchoolEnrollment)
}

// Convert list object to slice
func (t *StudentSchoolEnrollments) ToSlice() []*StudentSchoolEnrollment {
    ret := make([]*StudentSchoolEnrollment, 0)
  for _, x:= range t.studentschoolenrollments.StudentSchoolEnrollment {
    ret = append(ret, &StudentSchoolEnrollment{studentschoolenrollment: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentScoreJudgementAgainstStandards() *StudentScoreJudgementAgainstStandards {
  if out, ok := StudentScoreJudgementAgainstStandardsPointer(StudentScoreJudgementAgainstStandards{}); !ok {
                log.Fatalf("Could not create pointer to StudentScoreJudgementAgainstStandards\n")
                return nil
        } else {
          out.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard = make([]studentscorejudgementagainststandard, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentScoreJudgementAgainstStandards) Append(values ...*StudentScoreJudgementAgainstStandard) *StudentScoreJudgementAgainstStandards {
        if t == nil {
                t, _ = StudentScoreJudgementAgainstStandardsPointer(StudentScoreJudgementAgainstStandards{})
        }
        /*
        if t.studentscorejudgementagainststandards == nil {
          t.studentscorejudgementagainststandards = studentscorejudgementagainststandards{StudentScoreJudgementAgainstStandard: make([]studentscorejudgementagainststandard, 0)}
        }
        */
        if t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard == nil {
                t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard = make([]studentscorejudgementagainststandard, 0)
        }
        for _, value := range values {
        t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard = append(t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard, value.studentscorejudgementagainststandard)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentScoreJudgementAgainstStandards) AddNew() *StudentScoreJudgementAgainstStandards {
        if t == nil {
                t, _ = StudentScoreJudgementAgainstStandardsPointer(StudentScoreJudgementAgainstStandards{})
        }
        /*
        if t.studentscorejudgementagainststandards == nil {
          t.studentscorejudgementagainststandards = studentscorejudgementagainststandards{StudentScoreJudgementAgainstStandard: make([]studentscorejudgementagainststandard, 0)}
        }
        */
        if t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard == nil {
                t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard = make([]studentscorejudgementagainststandard, 0)
        }
        t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard = append(t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard, studentscorejudgementagainststandard{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentScoreJudgementAgainstStandards) Last() *studentscorejudgementagainststandard {
  /*
  if t.studentscorejudgementagainststandards == nil {
    t = t.AddNew()
    }
    */
  if t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard == nil {
    t = t.AddNew()
    }
        return &(t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard[len(t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentScoreJudgementAgainstStandards) Index(n int) *StudentScoreJudgementAgainstStandard {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentScoreJudgementAgainstStandards.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentscorejudgementagainststandards == nil {
    t = t.AddNew()
    }
    */
  if t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard == nil {
    t = t.AddNew()
    }
        return &StudentScoreJudgementAgainstStandard{(t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard[n])}
}

// Length of the list.
func (t *StudentScoreJudgementAgainstStandards) Len() int {
  /*
  if t.studentscorejudgementagainststandards == nil {
    t = t.AddNew()
    }
    */
  if t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard == nil {
    t = t.AddNew()
    }
        return len(t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard)
}

// Convert list object to slice
func (t *StudentScoreJudgementAgainstStandards) ToSlice() []*StudentScoreJudgementAgainstStandard {
    ret := make([]*StudentScoreJudgementAgainstStandard, 0)
  for _, x:= range t.studentscorejudgementagainststandards.StudentScoreJudgementAgainstStandard {
    ret = append(ret, &StudentScoreJudgementAgainstStandard{studentscorejudgementagainststandard: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewStudentSectionEnrollments() *StudentSectionEnrollments {
  if out, ok := StudentSectionEnrollmentsPointer(StudentSectionEnrollments{}); !ok {
                log.Fatalf("Could not create pointer to StudentSectionEnrollments\n")
                return nil
        } else {
          out.studentsectionenrollments.StudentSectionEnrollment = make([]studentsectionenrollment, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *StudentSectionEnrollments) Append(values ...*StudentSectionEnrollment) *StudentSectionEnrollments {
        if t == nil {
                t, _ = StudentSectionEnrollmentsPointer(StudentSectionEnrollments{})
        }
        /*
        if t.studentsectionenrollments == nil {
          t.studentsectionenrollments = studentsectionenrollments{StudentSectionEnrollment: make([]studentsectionenrollment, 0)}
        }
        */
        if t.studentsectionenrollments.StudentSectionEnrollment == nil {
                t.studentsectionenrollments.StudentSectionEnrollment = make([]studentsectionenrollment, 0)
        }
        for _, value := range values {
        t.studentsectionenrollments.StudentSectionEnrollment = append(t.studentsectionenrollments.StudentSectionEnrollment, value.studentsectionenrollment)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *StudentSectionEnrollments) AddNew() *StudentSectionEnrollments {
        if t == nil {
                t, _ = StudentSectionEnrollmentsPointer(StudentSectionEnrollments{})
        }
        /*
        if t.studentsectionenrollments == nil {
          t.studentsectionenrollments = studentsectionenrollments{StudentSectionEnrollment: make([]studentsectionenrollment, 0)}
        }
        */
        if t.studentsectionenrollments.StudentSectionEnrollment == nil {
                t.studentsectionenrollments.StudentSectionEnrollment = make([]studentsectionenrollment, 0)
        }
        t.studentsectionenrollments.StudentSectionEnrollment = append(t.studentsectionenrollments.StudentSectionEnrollment, studentsectionenrollment{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *StudentSectionEnrollments) Last() *studentsectionenrollment {
  /*
  if t.studentsectionenrollments == nil {
    t = t.AddNew()
    }
    */
  if t.studentsectionenrollments.StudentSectionEnrollment == nil {
    t = t.AddNew()
    }
        return &(t.studentsectionenrollments.StudentSectionEnrollment[len(t.studentsectionenrollments.StudentSectionEnrollment)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *StudentSectionEnrollments) Index(n int) *StudentSectionEnrollment {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("StudentSectionEnrollments.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.studentsectionenrollments == nil {
    t = t.AddNew()
    }
    */
  if t.studentsectionenrollments.StudentSectionEnrollment == nil {
    t = t.AddNew()
    }
        return &StudentSectionEnrollment{(t.studentsectionenrollments.StudentSectionEnrollment[n])}
}

// Length of the list.
func (t *StudentSectionEnrollments) Len() int {
  /*
  if t.studentsectionenrollments == nil {
    t = t.AddNew()
    }
    */
  if t.studentsectionenrollments.StudentSectionEnrollment == nil {
    t = t.AddNew()
    }
        return len(t.studentsectionenrollments.StudentSectionEnrollment)
}

// Convert list object to slice
func (t *StudentSectionEnrollments) ToSlice() []*StudentSectionEnrollment {
    ret := make([]*StudentSectionEnrollment, 0)
  for _, x:= range t.studentsectionenrollments.StudentSectionEnrollment {
    ret = append(ret, &StudentSectionEnrollment{studentsectionenrollment: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewTeachingGroups() *TeachingGroups {
  if out, ok := TeachingGroupsPointer(TeachingGroups{}); !ok {
                log.Fatalf("Could not create pointer to TeachingGroups\n")
                return nil
        } else {
          out.teachinggroups.TeachingGroup = make([]teachinggroup, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TeachingGroups) Append(values ...*TeachingGroup) *TeachingGroups {
        if t == nil {
                t, _ = TeachingGroupsPointer(TeachingGroups{})
        }
        /*
        if t.teachinggroups == nil {
          t.teachinggroups = teachinggroups{TeachingGroup: make([]teachinggroup, 0)}
        }
        */
        if t.teachinggroups.TeachingGroup == nil {
                t.teachinggroups.TeachingGroup = make([]teachinggroup, 0)
        }
        for _, value := range values {
        t.teachinggroups.TeachingGroup = append(t.teachinggroups.TeachingGroup, value.teachinggroup)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TeachingGroups) AddNew() *TeachingGroups {
        if t == nil {
                t, _ = TeachingGroupsPointer(TeachingGroups{})
        }
        /*
        if t.teachinggroups == nil {
          t.teachinggroups = teachinggroups{TeachingGroup: make([]teachinggroup, 0)}
        }
        */
        if t.teachinggroups.TeachingGroup == nil {
                t.teachinggroups.TeachingGroup = make([]teachinggroup, 0)
        }
        t.teachinggroups.TeachingGroup = append(t.teachinggroups.TeachingGroup, teachinggroup{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TeachingGroups) Last() *teachinggroup {
  /*
  if t.teachinggroups == nil {
    t = t.AddNew()
    }
    */
  if t.teachinggroups.TeachingGroup == nil {
    t = t.AddNew()
    }
        return &(t.teachinggroups.TeachingGroup[len(t.teachinggroups.TeachingGroup)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *TeachingGroups) Index(n int) *TeachingGroup {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TeachingGroups.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.teachinggroups == nil {
    t = t.AddNew()
    }
    */
  if t.teachinggroups.TeachingGroup == nil {
    t = t.AddNew()
    }
        return &TeachingGroup{(t.teachinggroups.TeachingGroup[n])}
}

// Length of the list.
func (t *TeachingGroups) Len() int {
  /*
  if t.teachinggroups == nil {
    t = t.AddNew()
    }
    */
  if t.teachinggroups.TeachingGroup == nil {
    t = t.AddNew()
    }
        return len(t.teachinggroups.TeachingGroup)
}

// Convert list object to slice
func (t *TeachingGroups) ToSlice() []*TeachingGroup {
    ret := make([]*TeachingGroup, 0)
  for _, x:= range t.teachinggroups.TeachingGroup {
    ret = append(ret, &TeachingGroup{teachinggroup: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewTermInfos() *TermInfos {
  if out, ok := TermInfosPointer(TermInfos{}); !ok {
                log.Fatalf("Could not create pointer to TermInfos\n")
                return nil
        } else {
          out.terminfos.TermInfo = make([]terminfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TermInfos) Append(values ...*TermInfo) *TermInfos {
        if t == nil {
                t, _ = TermInfosPointer(TermInfos{})
        }
        /*
        if t.terminfos == nil {
          t.terminfos = terminfos{TermInfo: make([]terminfo, 0)}
        }
        */
        if t.terminfos.TermInfo == nil {
                t.terminfos.TermInfo = make([]terminfo, 0)
        }
        for _, value := range values {
        t.terminfos.TermInfo = append(t.terminfos.TermInfo, value.terminfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TermInfos) AddNew() *TermInfos {
        if t == nil {
                t, _ = TermInfosPointer(TermInfos{})
        }
        /*
        if t.terminfos == nil {
          t.terminfos = terminfos{TermInfo: make([]terminfo, 0)}
        }
        */
        if t.terminfos.TermInfo == nil {
                t.terminfos.TermInfo = make([]terminfo, 0)
        }
        t.terminfos.TermInfo = append(t.terminfos.TermInfo, terminfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TermInfos) Last() *terminfo {
  /*
  if t.terminfos == nil {
    t = t.AddNew()
    }
    */
  if t.terminfos.TermInfo == nil {
    t = t.AddNew()
    }
        return &(t.terminfos.TermInfo[len(t.terminfos.TermInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *TermInfos) Index(n int) *TermInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TermInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.terminfos == nil {
    t = t.AddNew()
    }
    */
  if t.terminfos.TermInfo == nil {
    t = t.AddNew()
    }
        return &TermInfo{(t.terminfos.TermInfo[n])}
}

// Length of the list.
func (t *TermInfos) Len() int {
  /*
  if t.terminfos == nil {
    t = t.AddNew()
    }
    */
  if t.terminfos.TermInfo == nil {
    t = t.AddNew()
    }
        return len(t.terminfos.TermInfo)
}

// Convert list object to slice
func (t *TermInfos) ToSlice() []*TermInfo {
    ret := make([]*TermInfo, 0)
  for _, x:= range t.terminfos.TermInfo {
    ret = append(ret, &TermInfo{terminfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewTimeTableCells() *TimeTableCells {
  if out, ok := TimeTableCellsPointer(TimeTableCells{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableCells\n")
                return nil
        } else {
          out.timetablecells.TimeTableCell = make([]timetablecell, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TimeTableCells) Append(values ...*TimeTableCell) *TimeTableCells {
        if t == nil {
                t, _ = TimeTableCellsPointer(TimeTableCells{})
        }
        /*
        if t.timetablecells == nil {
          t.timetablecells = timetablecells{TimeTableCell: make([]timetablecell, 0)}
        }
        */
        if t.timetablecells.TimeTableCell == nil {
                t.timetablecells.TimeTableCell = make([]timetablecell, 0)
        }
        for _, value := range values {
        t.timetablecells.TimeTableCell = append(t.timetablecells.TimeTableCell, value.timetablecell)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TimeTableCells) AddNew() *TimeTableCells {
        if t == nil {
                t, _ = TimeTableCellsPointer(TimeTableCells{})
        }
        /*
        if t.timetablecells == nil {
          t.timetablecells = timetablecells{TimeTableCell: make([]timetablecell, 0)}
        }
        */
        if t.timetablecells.TimeTableCell == nil {
                t.timetablecells.TimeTableCell = make([]timetablecell, 0)
        }
        t.timetablecells.TimeTableCell = append(t.timetablecells.TimeTableCell, timetablecell{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TimeTableCells) Last() *timetablecell {
  /*
  if t.timetablecells == nil {
    t = t.AddNew()
    }
    */
  if t.timetablecells.TimeTableCell == nil {
    t = t.AddNew()
    }
        return &(t.timetablecells.TimeTableCell[len(t.timetablecells.TimeTableCell)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *TimeTableCells) Index(n int) *TimeTableCell {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TimeTableCells.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.timetablecells == nil {
    t = t.AddNew()
    }
    */
  if t.timetablecells.TimeTableCell == nil {
    t = t.AddNew()
    }
        return &TimeTableCell{(t.timetablecells.TimeTableCell[n])}
}

// Length of the list.
func (t *TimeTableCells) Len() int {
  /*
  if t.timetablecells == nil {
    t = t.AddNew()
    }
    */
  if t.timetablecells.TimeTableCell == nil {
    t = t.AddNew()
    }
        return len(t.timetablecells.TimeTableCell)
}

// Convert list object to slice
func (t *TimeTableCells) ToSlice() []*TimeTableCell {
    ret := make([]*TimeTableCell, 0)
  for _, x:= range t.timetablecells.TimeTableCell {
    ret = append(ret, &TimeTableCell{timetablecell: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewTimeTableContainers() *TimeTableContainers {
  if out, ok := TimeTableContainersPointer(TimeTableContainers{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableContainers\n")
                return nil
        } else {
          out.timetablecontainers.TimeTableContainer = make([]timetablecontainer, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TimeTableContainers) Append(values ...*TimeTableContainer) *TimeTableContainers {
        if t == nil {
                t, _ = TimeTableContainersPointer(TimeTableContainers{})
        }
        /*
        if t.timetablecontainers == nil {
          t.timetablecontainers = timetablecontainers{TimeTableContainer: make([]timetablecontainer, 0)}
        }
        */
        if t.timetablecontainers.TimeTableContainer == nil {
                t.timetablecontainers.TimeTableContainer = make([]timetablecontainer, 0)
        }
        for _, value := range values {
        t.timetablecontainers.TimeTableContainer = append(t.timetablecontainers.TimeTableContainer, value.timetablecontainer)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TimeTableContainers) AddNew() *TimeTableContainers {
        if t == nil {
                t, _ = TimeTableContainersPointer(TimeTableContainers{})
        }
        /*
        if t.timetablecontainers == nil {
          t.timetablecontainers = timetablecontainers{TimeTableContainer: make([]timetablecontainer, 0)}
        }
        */
        if t.timetablecontainers.TimeTableContainer == nil {
                t.timetablecontainers.TimeTableContainer = make([]timetablecontainer, 0)
        }
        t.timetablecontainers.TimeTableContainer = append(t.timetablecontainers.TimeTableContainer, timetablecontainer{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TimeTableContainers) Last() *timetablecontainer {
  /*
  if t.timetablecontainers == nil {
    t = t.AddNew()
    }
    */
  if t.timetablecontainers.TimeTableContainer == nil {
    t = t.AddNew()
    }
        return &(t.timetablecontainers.TimeTableContainer[len(t.timetablecontainers.TimeTableContainer)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *TimeTableContainers) Index(n int) *TimeTableContainer {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TimeTableContainers.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.timetablecontainers == nil {
    t = t.AddNew()
    }
    */
  if t.timetablecontainers.TimeTableContainer == nil {
    t = t.AddNew()
    }
        return &TimeTableContainer{(t.timetablecontainers.TimeTableContainer[n])}
}

// Length of the list.
func (t *TimeTableContainers) Len() int {
  /*
  if t.timetablecontainers == nil {
    t = t.AddNew()
    }
    */
  if t.timetablecontainers.TimeTableContainer == nil {
    t = t.AddNew()
    }
        return len(t.timetablecontainers.TimeTableContainer)
}

// Convert list object to slice
func (t *TimeTableContainers) ToSlice() []*TimeTableContainer {
    ret := make([]*TimeTableContainer, 0)
  for _, x:= range t.timetablecontainers.TimeTableContainer {
    ret = append(ret, &TimeTableContainer{timetablecontainer: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewTimeTableSubjects() *TimeTableSubjects {
  if out, ok := TimeTableSubjectsPointer(TimeTableSubjects{}); !ok {
                log.Fatalf("Could not create pointer to TimeTableSubjects\n")
                return nil
        } else {
          out.timetablesubjects.TimeTableSubject = make([]timetablesubject, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TimeTableSubjects) Append(values ...*TimeTableSubject) *TimeTableSubjects {
        if t == nil {
                t, _ = TimeTableSubjectsPointer(TimeTableSubjects{})
        }
        /*
        if t.timetablesubjects == nil {
          t.timetablesubjects = timetablesubjects{TimeTableSubject: make([]timetablesubject, 0)}
        }
        */
        if t.timetablesubjects.TimeTableSubject == nil {
                t.timetablesubjects.TimeTableSubject = make([]timetablesubject, 0)
        }
        for _, value := range values {
        t.timetablesubjects.TimeTableSubject = append(t.timetablesubjects.TimeTableSubject, value.timetablesubject)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TimeTableSubjects) AddNew() *TimeTableSubjects {
        if t == nil {
                t, _ = TimeTableSubjectsPointer(TimeTableSubjects{})
        }
        /*
        if t.timetablesubjects == nil {
          t.timetablesubjects = timetablesubjects{TimeTableSubject: make([]timetablesubject, 0)}
        }
        */
        if t.timetablesubjects.TimeTableSubject == nil {
                t.timetablesubjects.TimeTableSubject = make([]timetablesubject, 0)
        }
        t.timetablesubjects.TimeTableSubject = append(t.timetablesubjects.TimeTableSubject, timetablesubject{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TimeTableSubjects) Last() *timetablesubject {
  /*
  if t.timetablesubjects == nil {
    t = t.AddNew()
    }
    */
  if t.timetablesubjects.TimeTableSubject == nil {
    t = t.AddNew()
    }
        return &(t.timetablesubjects.TimeTableSubject[len(t.timetablesubjects.TimeTableSubject)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *TimeTableSubjects) Index(n int) *TimeTableSubject {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TimeTableSubjects.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.timetablesubjects == nil {
    t = t.AddNew()
    }
    */
  if t.timetablesubjects.TimeTableSubject == nil {
    t = t.AddNew()
    }
        return &TimeTableSubject{(t.timetablesubjects.TimeTableSubject[n])}
}

// Length of the list.
func (t *TimeTableSubjects) Len() int {
  /*
  if t.timetablesubjects == nil {
    t = t.AddNew()
    }
    */
  if t.timetablesubjects.TimeTableSubject == nil {
    t = t.AddNew()
    }
        return len(t.timetablesubjects.TimeTableSubject)
}

// Convert list object to slice
func (t *TimeTableSubjects) ToSlice() []*TimeTableSubject {
    ret := make([]*TimeTableSubject, 0)
  for _, x:= range t.timetablesubjects.TimeTableSubject {
    ret = append(ret, &TimeTableSubject{timetablesubject: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewTimeTables() *TimeTables {
  if out, ok := TimeTablesPointer(TimeTables{}); !ok {
                log.Fatalf("Could not create pointer to TimeTables\n")
                return nil
        } else {
          out.timetables.TimeTable = make([]timetable, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *TimeTables) Append(values ...*TimeTable) *TimeTables {
        if t == nil {
                t, _ = TimeTablesPointer(TimeTables{})
        }
        /*
        if t.timetables == nil {
          t.timetables = timetables{TimeTable: make([]timetable, 0)}
        }
        */
        if t.timetables.TimeTable == nil {
                t.timetables.TimeTable = make([]timetable, 0)
        }
        for _, value := range values {
        t.timetables.TimeTable = append(t.timetables.TimeTable, value.timetable)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *TimeTables) AddNew() *TimeTables {
        if t == nil {
                t, _ = TimeTablesPointer(TimeTables{})
        }
        /*
        if t.timetables == nil {
          t.timetables = timetables{TimeTable: make([]timetable, 0)}
        }
        */
        if t.timetables.TimeTable == nil {
                t.timetables.TimeTable = make([]timetable, 0)
        }
        t.timetables.TimeTable = append(t.timetables.TimeTable, timetable{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *TimeTables) Last() *timetable {
  /*
  if t.timetables == nil {
    t = t.AddNew()
    }
    */
  if t.timetables.TimeTable == nil {
    t = t.AddNew()
    }
        return &(t.timetables.TimeTable[len(t.timetables.TimeTable)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *TimeTables) Index(n int) *TimeTable {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("TimeTables.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.timetables == nil {
    t = t.AddNew()
    }
    */
  if t.timetables.TimeTable == nil {
    t = t.AddNew()
    }
        return &TimeTable{(t.timetables.TimeTable[n])}
}

// Length of the list.
func (t *TimeTables) Len() int {
  /*
  if t.timetables == nil {
    t = t.AddNew()
    }
    */
  if t.timetables.TimeTable == nil {
    t = t.AddNew()
    }
        return len(t.timetables.TimeTable)
}

// Convert list object to slice
func (t *TimeTables) ToSlice() []*TimeTable {
    ret := make([]*TimeTable, 0)
  for _, x:= range t.timetables.TimeTable {
    ret = append(ret, &TimeTable{timetable: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewVendorInfos() *VendorInfos {
  if out, ok := VendorInfosPointer(VendorInfos{}); !ok {
                log.Fatalf("Could not create pointer to VendorInfos\n")
                return nil
        } else {
          out.vendorinfos.VendorInfo = make([]vendorinfo, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *VendorInfos) Append(values ...*VendorInfo) *VendorInfos {
        if t == nil {
                t, _ = VendorInfosPointer(VendorInfos{})
        }
        /*
        if t.vendorinfos == nil {
          t.vendorinfos = vendorinfos{VendorInfo: make([]vendorinfo, 0)}
        }
        */
        if t.vendorinfos.VendorInfo == nil {
                t.vendorinfos.VendorInfo = make([]vendorinfo, 0)
        }
        for _, value := range values {
        t.vendorinfos.VendorInfo = append(t.vendorinfos.VendorInfo, value.vendorinfo)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *VendorInfos) AddNew() *VendorInfos {
        if t == nil {
                t, _ = VendorInfosPointer(VendorInfos{})
        }
        /*
        if t.vendorinfos == nil {
          t.vendorinfos = vendorinfos{VendorInfo: make([]vendorinfo, 0)}
        }
        */
        if t.vendorinfos.VendorInfo == nil {
                t.vendorinfos.VendorInfo = make([]vendorinfo, 0)
        }
        t.vendorinfos.VendorInfo = append(t.vendorinfos.VendorInfo, vendorinfo{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *VendorInfos) Last() *vendorinfo {
  /*
  if t.vendorinfos == nil {
    t = t.AddNew()
    }
    */
  if t.vendorinfos.VendorInfo == nil {
    t = t.AddNew()
    }
        return &(t.vendorinfos.VendorInfo[len(t.vendorinfos.VendorInfo)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *VendorInfos) Index(n int) *VendorInfo {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("VendorInfos.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.vendorinfos == nil {
    t = t.AddNew()
    }
    */
  if t.vendorinfos.VendorInfo == nil {
    t = t.AddNew()
    }
        return &VendorInfo{(t.vendorinfos.VendorInfo[n])}
}

// Length of the list.
func (t *VendorInfos) Len() int {
  /*
  if t.vendorinfos == nil {
    t = t.AddNew()
    }
    */
  if t.vendorinfos.VendorInfo == nil {
    t = t.AddNew()
    }
        return len(t.vendorinfos.VendorInfo)
}

// Convert list object to slice
func (t *VendorInfos) ToSlice() []*VendorInfo {
    ret := make([]*VendorInfo, 0)
  for _, x:= range t.vendorinfos.VendorInfo {
    ret = append(ret, &VendorInfo{vendorinfo: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewWellbeingAlerts() *WellbeingAlerts {
  if out, ok := WellbeingAlertsPointer(WellbeingAlerts{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingAlerts\n")
                return nil
        } else {
          out.wellbeingalerts.WellbeingAlert = make([]wellbeingalert, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WellbeingAlerts) Append(values ...*WellbeingAlert) *WellbeingAlerts {
        if t == nil {
                t, _ = WellbeingAlertsPointer(WellbeingAlerts{})
        }
        /*
        if t.wellbeingalerts == nil {
          t.wellbeingalerts = wellbeingalerts{WellbeingAlert: make([]wellbeingalert, 0)}
        }
        */
        if t.wellbeingalerts.WellbeingAlert == nil {
                t.wellbeingalerts.WellbeingAlert = make([]wellbeingalert, 0)
        }
        for _, value := range values {
        t.wellbeingalerts.WellbeingAlert = append(t.wellbeingalerts.WellbeingAlert, value.wellbeingalert)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WellbeingAlerts) AddNew() *WellbeingAlerts {
        if t == nil {
                t, _ = WellbeingAlertsPointer(WellbeingAlerts{})
        }
        /*
        if t.wellbeingalerts == nil {
          t.wellbeingalerts = wellbeingalerts{WellbeingAlert: make([]wellbeingalert, 0)}
        }
        */
        if t.wellbeingalerts.WellbeingAlert == nil {
                t.wellbeingalerts.WellbeingAlert = make([]wellbeingalert, 0)
        }
        t.wellbeingalerts.WellbeingAlert = append(t.wellbeingalerts.WellbeingAlert, wellbeingalert{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WellbeingAlerts) Last() *wellbeingalert {
  /*
  if t.wellbeingalerts == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingalerts.WellbeingAlert == nil {
    t = t.AddNew()
    }
        return &(t.wellbeingalerts.WellbeingAlert[len(t.wellbeingalerts.WellbeingAlert)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *WellbeingAlerts) Index(n int) *WellbeingAlert {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WellbeingAlerts.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.wellbeingalerts == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingalerts.WellbeingAlert == nil {
    t = t.AddNew()
    }
        return &WellbeingAlert{(t.wellbeingalerts.WellbeingAlert[n])}
}

// Length of the list.
func (t *WellbeingAlerts) Len() int {
  /*
  if t.wellbeingalerts == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingalerts.WellbeingAlert == nil {
    t = t.AddNew()
    }
        return len(t.wellbeingalerts.WellbeingAlert)
}

// Convert list object to slice
func (t *WellbeingAlerts) ToSlice() []*WellbeingAlert {
    ret := make([]*WellbeingAlert, 0)
  for _, x:= range t.wellbeingalerts.WellbeingAlert {
    ret = append(ret, &WellbeingAlert{wellbeingalert: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewWellbeingAppeals() *WellbeingAppeals {
  if out, ok := WellbeingAppealsPointer(WellbeingAppeals{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingAppeals\n")
                return nil
        } else {
          out.wellbeingappeals.WellbeingAppeal = make([]wellbeingappeal, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WellbeingAppeals) Append(values ...*WellbeingAppeal) *WellbeingAppeals {
        if t == nil {
                t, _ = WellbeingAppealsPointer(WellbeingAppeals{})
        }
        /*
        if t.wellbeingappeals == nil {
          t.wellbeingappeals = wellbeingappeals{WellbeingAppeal: make([]wellbeingappeal, 0)}
        }
        */
        if t.wellbeingappeals.WellbeingAppeal == nil {
                t.wellbeingappeals.WellbeingAppeal = make([]wellbeingappeal, 0)
        }
        for _, value := range values {
        t.wellbeingappeals.WellbeingAppeal = append(t.wellbeingappeals.WellbeingAppeal, value.wellbeingappeal)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WellbeingAppeals) AddNew() *WellbeingAppeals {
        if t == nil {
                t, _ = WellbeingAppealsPointer(WellbeingAppeals{})
        }
        /*
        if t.wellbeingappeals == nil {
          t.wellbeingappeals = wellbeingappeals{WellbeingAppeal: make([]wellbeingappeal, 0)}
        }
        */
        if t.wellbeingappeals.WellbeingAppeal == nil {
                t.wellbeingappeals.WellbeingAppeal = make([]wellbeingappeal, 0)
        }
        t.wellbeingappeals.WellbeingAppeal = append(t.wellbeingappeals.WellbeingAppeal, wellbeingappeal{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WellbeingAppeals) Last() *wellbeingappeal {
  /*
  if t.wellbeingappeals == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingappeals.WellbeingAppeal == nil {
    t = t.AddNew()
    }
        return &(t.wellbeingappeals.WellbeingAppeal[len(t.wellbeingappeals.WellbeingAppeal)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *WellbeingAppeals) Index(n int) *WellbeingAppeal {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WellbeingAppeals.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.wellbeingappeals == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingappeals.WellbeingAppeal == nil {
    t = t.AddNew()
    }
        return &WellbeingAppeal{(t.wellbeingappeals.WellbeingAppeal[n])}
}

// Length of the list.
func (t *WellbeingAppeals) Len() int {
  /*
  if t.wellbeingappeals == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingappeals.WellbeingAppeal == nil {
    t = t.AddNew()
    }
        return len(t.wellbeingappeals.WellbeingAppeal)
}

// Convert list object to slice
func (t *WellbeingAppeals) ToSlice() []*WellbeingAppeal {
    ret := make([]*WellbeingAppeal, 0)
  for _, x:= range t.wellbeingappeals.WellbeingAppeal {
    ret = append(ret, &WellbeingAppeal{wellbeingappeal: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewWellbeingCharacteristics() *WellbeingCharacteristics {
  if out, ok := WellbeingCharacteristicsPointer(WellbeingCharacteristics{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingCharacteristics\n")
                return nil
        } else {
          out.wellbeingcharacteristics.WellbeingCharacteristic = make([]wellbeingcharacteristic, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WellbeingCharacteristics) Append(values ...*WellbeingCharacteristic) *WellbeingCharacteristics {
        if t == nil {
                t, _ = WellbeingCharacteristicsPointer(WellbeingCharacteristics{})
        }
        /*
        if t.wellbeingcharacteristics == nil {
          t.wellbeingcharacteristics = wellbeingcharacteristics{WellbeingCharacteristic: make([]wellbeingcharacteristic, 0)}
        }
        */
        if t.wellbeingcharacteristics.WellbeingCharacteristic == nil {
                t.wellbeingcharacteristics.WellbeingCharacteristic = make([]wellbeingcharacteristic, 0)
        }
        for _, value := range values {
        t.wellbeingcharacteristics.WellbeingCharacteristic = append(t.wellbeingcharacteristics.WellbeingCharacteristic, value.wellbeingcharacteristic)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WellbeingCharacteristics) AddNew() *WellbeingCharacteristics {
        if t == nil {
                t, _ = WellbeingCharacteristicsPointer(WellbeingCharacteristics{})
        }
        /*
        if t.wellbeingcharacteristics == nil {
          t.wellbeingcharacteristics = wellbeingcharacteristics{WellbeingCharacteristic: make([]wellbeingcharacteristic, 0)}
        }
        */
        if t.wellbeingcharacteristics.WellbeingCharacteristic == nil {
                t.wellbeingcharacteristics.WellbeingCharacteristic = make([]wellbeingcharacteristic, 0)
        }
        t.wellbeingcharacteristics.WellbeingCharacteristic = append(t.wellbeingcharacteristics.WellbeingCharacteristic, wellbeingcharacteristic{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WellbeingCharacteristics) Last() *wellbeingcharacteristic {
  /*
  if t.wellbeingcharacteristics == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingcharacteristics.WellbeingCharacteristic == nil {
    t = t.AddNew()
    }
        return &(t.wellbeingcharacteristics.WellbeingCharacteristic[len(t.wellbeingcharacteristics.WellbeingCharacteristic)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *WellbeingCharacteristics) Index(n int) *WellbeingCharacteristic {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WellbeingCharacteristics.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.wellbeingcharacteristics == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingcharacteristics.WellbeingCharacteristic == nil {
    t = t.AddNew()
    }
        return &WellbeingCharacteristic{(t.wellbeingcharacteristics.WellbeingCharacteristic[n])}
}

// Length of the list.
func (t *WellbeingCharacteristics) Len() int {
  /*
  if t.wellbeingcharacteristics == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingcharacteristics.WellbeingCharacteristic == nil {
    t = t.AddNew()
    }
        return len(t.wellbeingcharacteristics.WellbeingCharacteristic)
}

// Convert list object to slice
func (t *WellbeingCharacteristics) ToSlice() []*WellbeingCharacteristic {
    ret := make([]*WellbeingCharacteristic, 0)
  for _, x:= range t.wellbeingcharacteristics.WellbeingCharacteristic {
    ret = append(ret, &WellbeingCharacteristic{wellbeingcharacteristic: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewWellbeingEvents() *WellbeingEvents {
  if out, ok := WellbeingEventsPointer(WellbeingEvents{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingEvents\n")
                return nil
        } else {
          out.wellbeingevents.WellbeingEvent = make([]wellbeingevent, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WellbeingEvents) Append(values ...*WellbeingEvent) *WellbeingEvents {
        if t == nil {
                t, _ = WellbeingEventsPointer(WellbeingEvents{})
        }
        /*
        if t.wellbeingevents == nil {
          t.wellbeingevents = wellbeingevents{WellbeingEvent: make([]wellbeingevent, 0)}
        }
        */
        if t.wellbeingevents.WellbeingEvent == nil {
                t.wellbeingevents.WellbeingEvent = make([]wellbeingevent, 0)
        }
        for _, value := range values {
        t.wellbeingevents.WellbeingEvent = append(t.wellbeingevents.WellbeingEvent, value.wellbeingevent)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WellbeingEvents) AddNew() *WellbeingEvents {
        if t == nil {
                t, _ = WellbeingEventsPointer(WellbeingEvents{})
        }
        /*
        if t.wellbeingevents == nil {
          t.wellbeingevents = wellbeingevents{WellbeingEvent: make([]wellbeingevent, 0)}
        }
        */
        if t.wellbeingevents.WellbeingEvent == nil {
                t.wellbeingevents.WellbeingEvent = make([]wellbeingevent, 0)
        }
        t.wellbeingevents.WellbeingEvent = append(t.wellbeingevents.WellbeingEvent, wellbeingevent{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WellbeingEvents) Last() *wellbeingevent {
  /*
  if t.wellbeingevents == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingevents.WellbeingEvent == nil {
    t = t.AddNew()
    }
        return &(t.wellbeingevents.WellbeingEvent[len(t.wellbeingevents.WellbeingEvent)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *WellbeingEvents) Index(n int) *WellbeingEvent {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WellbeingEvents.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.wellbeingevents == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingevents.WellbeingEvent == nil {
    t = t.AddNew()
    }
        return &WellbeingEvent{(t.wellbeingevents.WellbeingEvent[n])}
}

// Length of the list.
func (t *WellbeingEvents) Len() int {
  /*
  if t.wellbeingevents == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingevents.WellbeingEvent == nil {
    t = t.AddNew()
    }
        return len(t.wellbeingevents.WellbeingEvent)
}

// Convert list object to slice
func (t *WellbeingEvents) ToSlice() []*WellbeingEvent {
    ret := make([]*WellbeingEvent, 0)
  for _, x:= range t.wellbeingevents.WellbeingEvent {
    ret = append(ret, &WellbeingEvent{wellbeingevent: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewWellbeingPersonLinks() *WellbeingPersonLinks {
  if out, ok := WellbeingPersonLinksPointer(WellbeingPersonLinks{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingPersonLinks\n")
                return nil
        } else {
          out.wellbeingpersonlinks.WellbeingPersonLink = make([]wellbeingpersonlink, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WellbeingPersonLinks) Append(values ...*WellbeingPersonLink) *WellbeingPersonLinks {
        if t == nil {
                t, _ = WellbeingPersonLinksPointer(WellbeingPersonLinks{})
        }
        /*
        if t.wellbeingpersonlinks == nil {
          t.wellbeingpersonlinks = wellbeingpersonlinks{WellbeingPersonLink: make([]wellbeingpersonlink, 0)}
        }
        */
        if t.wellbeingpersonlinks.WellbeingPersonLink == nil {
                t.wellbeingpersonlinks.WellbeingPersonLink = make([]wellbeingpersonlink, 0)
        }
        for _, value := range values {
        t.wellbeingpersonlinks.WellbeingPersonLink = append(t.wellbeingpersonlinks.WellbeingPersonLink, value.wellbeingpersonlink)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WellbeingPersonLinks) AddNew() *WellbeingPersonLinks {
        if t == nil {
                t, _ = WellbeingPersonLinksPointer(WellbeingPersonLinks{})
        }
        /*
        if t.wellbeingpersonlinks == nil {
          t.wellbeingpersonlinks = wellbeingpersonlinks{WellbeingPersonLink: make([]wellbeingpersonlink, 0)}
        }
        */
        if t.wellbeingpersonlinks.WellbeingPersonLink == nil {
                t.wellbeingpersonlinks.WellbeingPersonLink = make([]wellbeingpersonlink, 0)
        }
        t.wellbeingpersonlinks.WellbeingPersonLink = append(t.wellbeingpersonlinks.WellbeingPersonLink, wellbeingpersonlink{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WellbeingPersonLinks) Last() *wellbeingpersonlink {
  /*
  if t.wellbeingpersonlinks == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingpersonlinks.WellbeingPersonLink == nil {
    t = t.AddNew()
    }
        return &(t.wellbeingpersonlinks.WellbeingPersonLink[len(t.wellbeingpersonlinks.WellbeingPersonLink)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *WellbeingPersonLinks) Index(n int) *WellbeingPersonLink {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WellbeingPersonLinks.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.wellbeingpersonlinks == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingpersonlinks.WellbeingPersonLink == nil {
    t = t.AddNew()
    }
        return &WellbeingPersonLink{(t.wellbeingpersonlinks.WellbeingPersonLink[n])}
}

// Length of the list.
func (t *WellbeingPersonLinks) Len() int {
  /*
  if t.wellbeingpersonlinks == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingpersonlinks.WellbeingPersonLink == nil {
    t = t.AddNew()
    }
        return len(t.wellbeingpersonlinks.WellbeingPersonLink)
}

// Convert list object to slice
func (t *WellbeingPersonLinks) ToSlice() []*WellbeingPersonLink {
    ret := make([]*WellbeingPersonLink, 0)
  for _, x:= range t.wellbeingpersonlinks.WellbeingPersonLink {
    ret = append(ret, &WellbeingPersonLink{wellbeingpersonlink: x})
  }
  return ret

}


  // Generates a new object as a pointer to a struct
func NewWellbeingResponses() *WellbeingResponses {
  if out, ok := WellbeingResponsesPointer(WellbeingResponses{}); !ok {
                log.Fatalf("Could not create pointer to WellbeingResponses\n")
                return nil
        } else {
          out.wellbeingresponses.WellbeingResponse = make([]wellbeingresponse, 0)
                return out
        }
  }

// Appends value to the list. Creates list if it is empty. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
  func (t *WellbeingResponses) Append(values ...*WellbeingResponse) *WellbeingResponses {
        if t == nil {
                t, _ = WellbeingResponsesPointer(WellbeingResponses{})
        }
        /*
        if t.wellbeingresponses == nil {
          t.wellbeingresponses = wellbeingresponses{WellbeingResponse: make([]wellbeingresponse, 0)}
        }
        */
        if t.wellbeingresponses.WellbeingResponse == nil {
                t.wellbeingresponses.WellbeingResponse = make([]wellbeingresponse, 0)
        }
        for _, value := range values {
        t.wellbeingresponses.WellbeingResponse = append(t.wellbeingresponses.WellbeingResponse, value.wellbeingresponse)
        }
        return t
}

// Appends an empty value to the list. This value can then be populated through accessors on Last().
func (t *WellbeingResponses) AddNew() *WellbeingResponses {
        if t == nil {
                t, _ = WellbeingResponsesPointer(WellbeingResponses{})
        }
        /*
        if t.wellbeingresponses == nil {
          t.wellbeingresponses = wellbeingresponses{WellbeingResponse: make([]wellbeingresponse, 0)}
        }
        */
        if t.wellbeingresponses.WellbeingResponse == nil {
                t.wellbeingresponses.WellbeingResponse = make([]wellbeingresponse, 0)
        }
        t.wellbeingresponses.WellbeingResponse = append(t.wellbeingresponses.WellbeingResponse, wellbeingresponse{})
        return t
}

// Retrieve the last value of the list. Calls AddNew() if the list is empty.
func (t *WellbeingResponses) Last() *wellbeingresponse {
  /*
  if t.wellbeingresponses == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingresponses.WellbeingResponse == nil {
    t = t.AddNew()
    }
        return &(t.wellbeingresponses.WellbeingResponse[len(t.wellbeingresponses.WellbeingResponse)-1])
}

// Retrieves the nth value in the list. Aborts if index is out of bounds. Returns copy of value.
func (t *WellbeingResponses) Index(n int) *WellbeingResponse {
  if (n >= t.Len() || n < 0) {
    log.Fatalf("WellbeingResponses.Index(): subscript %d out of range on list\n", n)
    }
    /*
  if t.wellbeingresponses == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingresponses.WellbeingResponse == nil {
    t = t.AddNew()
    }
        return &WellbeingResponse{(t.wellbeingresponses.WellbeingResponse[n])}
}

// Length of the list.
func (t *WellbeingResponses) Len() int {
  /*
  if t.wellbeingresponses == nil {
    t = t.AddNew()
    }
    */
  if t.wellbeingresponses.WellbeingResponse == nil {
    t = t.AddNew()
    }
        return len(t.wellbeingresponses.WellbeingResponse)
}

// Convert list object to slice
func (t *WellbeingResponses) ToSlice() []*WellbeingResponse {
    ret := make([]*WellbeingResponse, 0)
  for _, x:= range t.wellbeingresponses.WellbeingResponse {
    ret = append(ret, &WellbeingResponse{wellbeingresponse: x})
  }
  return ret

}

// Return string value
func (t *AUCodeSets0211ProgramAvailabilityType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSets0211ProgramAvailabilityType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSets0211ProgramAvailabilityTypePointer(value interface{}) (*AUCodeSets0211ProgramAvailabilityType, bool) {
switch t := value.(type) {
 	case *AUCodeSets0211ProgramAvailabilityType:
 		return value.(*AUCodeSets0211ProgramAvailabilityType), true
        case AUCodeSets0211ProgramAvailabilityType:
 		v, _ := value.(AUCodeSets0211ProgramAvailabilityType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSets0211ProgramAvailabilityType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSets0211ProgramAvailabilityType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSets0211ProgramAvailabilityType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSets0792IdentificationProcedureType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSets0792IdentificationProcedureType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSets0792IdentificationProcedureTypePointer(value interface{}) (*AUCodeSets0792IdentificationProcedureType, bool) {
switch t := value.(type) {
 	case *AUCodeSets0792IdentificationProcedureType:
 		return value.(*AUCodeSets0792IdentificationProcedureType), true
        case AUCodeSets0792IdentificationProcedureType:
 		v, _ := value.(AUCodeSets0792IdentificationProcedureType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSets0792IdentificationProcedureType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSets0792IdentificationProcedureType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSets0792IdentificationProcedureType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsACStrandType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsACStrandType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsACStrandTypePointer(value interface{}) (*AUCodeSetsACStrandType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsACStrandType:
 		return value.(*AUCodeSetsACStrandType), true
        case AUCodeSetsACStrandType:
 		v, _ := value.(AUCodeSetsACStrandType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsACStrandType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsACStrandType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsACStrandType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAGCollectionType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAGCollectionType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAGCollectionTypePointer(value interface{}) (*AUCodeSetsAGCollectionType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAGCollectionType:
 		return value.(*AUCodeSetsAGCollectionType), true
        case AUCodeSetsAGCollectionType:
 		v, _ := value.(AUCodeSetsAGCollectionType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAGCollectionType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAGCollectionType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAGCollectionType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAGContextQuestionType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAGContextQuestionType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAGContextQuestionTypePointer(value interface{}) (*AUCodeSetsAGContextQuestionType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAGContextQuestionType:
 		return value.(*AUCodeSetsAGContextQuestionType), true
        case AUCodeSetsAGContextQuestionType:
 		v, _ := value.(AUCodeSetsAGContextQuestionType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAGContextQuestionType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAGContextQuestionType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAGContextQuestionType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAGSubmissionStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAGSubmissionStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAGSubmissionStatusTypePointer(value interface{}) (*AUCodeSetsAGSubmissionStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAGSubmissionStatusType:
 		return value.(*AUCodeSetsAGSubmissionStatusType), true
        case AUCodeSetsAGSubmissionStatusType:
 		v, _ := value.(AUCodeSetsAGSubmissionStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAGSubmissionStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAGSubmissionStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAGSubmissionStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAccompanimentType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAccompanimentType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAccompanimentTypePointer(value interface{}) (*AUCodeSetsAccompanimentType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAccompanimentType:
 		return value.(*AUCodeSetsAccompanimentType), true
        case AUCodeSetsAccompanimentType:
 		v, _ := value.(AUCodeSetsAccompanimentType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAccompanimentType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAccompanimentType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAccompanimentType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsActivityInvolvementCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsActivityInvolvementCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsActivityInvolvementCodeTypePointer(value interface{}) (*AUCodeSetsActivityInvolvementCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsActivityInvolvementCodeType:
 		return value.(*AUCodeSetsActivityInvolvementCodeType), true
        case AUCodeSetsActivityInvolvementCodeType:
 		v, _ := value.(AUCodeSetsActivityInvolvementCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsActivityInvolvementCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsActivityInvolvementCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsActivityInvolvementCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsActivityTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsActivityTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsActivityTypeTypePointer(value interface{}) (*AUCodeSetsActivityTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsActivityTypeType:
 		return value.(*AUCodeSetsActivityTypeType), true
        case AUCodeSetsActivityTypeType:
 		v, _ := value.(AUCodeSetsActivityTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsActivityTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsActivityTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsActivityTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAddressRoleType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAddressRoleType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAddressRoleTypePointer(value interface{}) (*AUCodeSetsAddressRoleType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAddressRoleType:
 		return value.(*AUCodeSetsAddressRoleType), true
        case AUCodeSetsAddressRoleType:
 		v, _ := value.(AUCodeSetsAddressRoleType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAddressRoleType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAddressRoleType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAddressRoleType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAddressTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAddressTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAddressTypeTypePointer(value interface{}) (*AUCodeSetsAddressTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAddressTypeType:
 		return value.(*AUCodeSetsAddressTypeType), true
        case AUCodeSetsAddressTypeType:
 		v, _ := value.(AUCodeSetsAddressTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAddressTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAddressTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAddressTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAssessmentReportingMethodType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAssessmentReportingMethodType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAssessmentReportingMethodTypePointer(value interface{}) (*AUCodeSetsAssessmentReportingMethodType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAssessmentReportingMethodType:
 		return value.(*AUCodeSetsAssessmentReportingMethodType), true
        case AUCodeSetsAssessmentReportingMethodType:
 		v, _ := value.(AUCodeSetsAssessmentReportingMethodType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAssessmentReportingMethodType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAssessmentReportingMethodType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAssessmentReportingMethodType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAssessmentTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAssessmentTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAssessmentTypeTypePointer(value interface{}) (*AUCodeSetsAssessmentTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAssessmentTypeType:
 		return value.(*AUCodeSetsAssessmentTypeType), true
        case AUCodeSetsAssessmentTypeType:
 		v, _ := value.(AUCodeSetsAssessmentTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAssessmentTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAssessmentTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAssessmentTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAttendanceCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAttendanceCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAttendanceCodeTypePointer(value interface{}) (*AUCodeSetsAttendanceCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAttendanceCodeType:
 		return value.(*AUCodeSetsAttendanceCodeType), true
        case AUCodeSetsAttendanceCodeType:
 		v, _ := value.(AUCodeSetsAttendanceCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAttendanceCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAttendanceCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAttendanceCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAttendanceStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAttendanceStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAttendanceStatusTypePointer(value interface{}) (*AUCodeSetsAttendanceStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAttendanceStatusType:
 		return value.(*AUCodeSetsAttendanceStatusType), true
        case AUCodeSetsAttendanceStatusType:
 		v, _ := value.(AUCodeSetsAttendanceStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAttendanceStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAttendanceStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAttendanceStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAustralianCitizenshipStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAustralianCitizenshipStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAustralianCitizenshipStatusTypePointer(value interface{}) (*AUCodeSetsAustralianCitizenshipStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAustralianCitizenshipStatusType:
 		return value.(*AUCodeSetsAustralianCitizenshipStatusType), true
        case AUCodeSetsAustralianCitizenshipStatusType:
 		v, _ := value.(AUCodeSetsAustralianCitizenshipStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAustralianCitizenshipStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAustralianCitizenshipStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAustralianCitizenshipStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGTypePointer(value interface{}) (*AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType:
 		return value.(*AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType), true
        case AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType:
 		v, _ := value.(AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAustralianStandardClassificationOfLanguagesASCLTypePointer(value interface{}) (*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType:
 		return value.(*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType), true
        case AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType:
 		v, _ := value.(AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGTypePointer(value interface{}) (*AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType:
 		return value.(*AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType), true
        case AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType:
 		v, _ := value.(AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsAustralianTimeZoneType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsAustralianTimeZoneType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsAustralianTimeZoneTypePointer(value interface{}) (*AUCodeSetsAustralianTimeZoneType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsAustralianTimeZoneType:
 		return value.(*AUCodeSetsAustralianTimeZoneType), true
        case AUCodeSetsAustralianTimeZoneType:
 		v, _ := value.(AUCodeSetsAustralianTimeZoneType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsAustralianTimeZoneType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsAustralianTimeZoneType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsAustralianTimeZoneType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsBirthdateVerificationType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsBirthdateVerificationType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsBirthdateVerificationTypePointer(value interface{}) (*AUCodeSetsBirthdateVerificationType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsBirthdateVerificationType:
 		return value.(*AUCodeSetsBirthdateVerificationType), true
        case AUCodeSetsBirthdateVerificationType:
 		v, _ := value.(AUCodeSetsBirthdateVerificationType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsBirthdateVerificationType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsBirthdateVerificationType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsBirthdateVerificationType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsBoardingType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsBoardingType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsBoardingTypePointer(value interface{}) (*AUCodeSetsBoardingType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsBoardingType:
 		return value.(*AUCodeSetsBoardingType), true
        case AUCodeSetsBoardingType:
 		v, _ := value.(AUCodeSetsBoardingType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsBoardingType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsBoardingType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsBoardingType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsCalendarEventType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsCalendarEventType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsCalendarEventTypePointer(value interface{}) (*AUCodeSetsCalendarEventType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsCalendarEventType:
 		return value.(*AUCodeSetsCalendarEventType), true
        case AUCodeSetsCalendarEventType:
 		v, _ := value.(AUCodeSetsCalendarEventType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsCalendarEventType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsCalendarEventType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsCalendarEventType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsContactMethodType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsContactMethodType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsContactMethodTypePointer(value interface{}) (*AUCodeSetsContactMethodType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsContactMethodType:
 		return value.(*AUCodeSetsContactMethodType), true
        case AUCodeSetsContactMethodType:
 		v, _ := value.(AUCodeSetsContactMethodType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsContactMethodType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsContactMethodType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsContactMethodType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsDayValueCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsDayValueCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsDayValueCodeTypePointer(value interface{}) (*AUCodeSetsDayValueCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsDayValueCodeType:
 		return value.(*AUCodeSetsDayValueCodeType), true
        case AUCodeSetsDayValueCodeType:
 		v, _ := value.(AUCodeSetsDayValueCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsDayValueCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsDayValueCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsDayValueCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsDetentionCategoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsDetentionCategoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsDetentionCategoryTypePointer(value interface{}) (*AUCodeSetsDetentionCategoryType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsDetentionCategoryType:
 		return value.(*AUCodeSetsDetentionCategoryType), true
        case AUCodeSetsDetentionCategoryType:
 		v, _ := value.(AUCodeSetsDetentionCategoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsDetentionCategoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsDetentionCategoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsDetentionCategoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsDwellingArrangementType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsDwellingArrangementType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsDwellingArrangementTypePointer(value interface{}) (*AUCodeSetsDwellingArrangementType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsDwellingArrangementType:
 		return value.(*AUCodeSetsDwellingArrangementType), true
        case AUCodeSetsDwellingArrangementType:
 		v, _ := value.(AUCodeSetsDwellingArrangementType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsDwellingArrangementType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsDwellingArrangementType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsDwellingArrangementType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEarlyChildhoodProviderTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEarlyChildhoodProviderTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEarlyChildhoodProviderTypeTypePointer(value interface{}) (*AUCodeSetsEarlyChildhoodProviderTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEarlyChildhoodProviderTypeType:
 		return value.(*AUCodeSetsEarlyChildhoodProviderTypeType), true
        case AUCodeSetsEarlyChildhoodProviderTypeType:
 		v, _ := value.(AUCodeSetsEarlyChildhoodProviderTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEarlyChildhoodProviderTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEarlyChildhoodProviderTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEarlyChildhoodProviderTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEducationAgencyTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEducationAgencyTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEducationAgencyTypeTypePointer(value interface{}) (*AUCodeSetsEducationAgencyTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEducationAgencyTypeType:
 		return value.(*AUCodeSetsEducationAgencyTypeType), true
        case AUCodeSetsEducationAgencyTypeType:
 		v, _ := value.(AUCodeSetsEducationAgencyTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEducationAgencyTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEducationAgencyTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEducationAgencyTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEducationLevelType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEducationLevelType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEducationLevelTypePointer(value interface{}) (*AUCodeSetsEducationLevelType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEducationLevelType:
 		return value.(*AUCodeSetsEducationLevelType), true
        case AUCodeSetsEducationLevelType:
 		v, _ := value.(AUCodeSetsEducationLevelType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEducationLevelType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEducationLevelType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEducationLevelType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsElectronicIdTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsElectronicIdTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsElectronicIdTypeTypePointer(value interface{}) (*AUCodeSetsElectronicIdTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsElectronicIdTypeType:
 		return value.(*AUCodeSetsElectronicIdTypeType), true
        case AUCodeSetsElectronicIdTypeType:
 		v, _ := value.(AUCodeSetsElectronicIdTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsElectronicIdTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsElectronicIdTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsElectronicIdTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEmailTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEmailTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEmailTypeTypePointer(value interface{}) (*AUCodeSetsEmailTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEmailTypeType:
 		return value.(*AUCodeSetsEmailTypeType), true
        case AUCodeSetsEmailTypeType:
 		v, _ := value.(AUCodeSetsEmailTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEmailTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEmailTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEmailTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEmploymentTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEmploymentTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEmploymentTypeTypePointer(value interface{}) (*AUCodeSetsEmploymentTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEmploymentTypeType:
 		return value.(*AUCodeSetsEmploymentTypeType), true
        case AUCodeSetsEmploymentTypeType:
 		v, _ := value.(AUCodeSetsEmploymentTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEmploymentTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEmploymentTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEmploymentTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEnglishProficiencyType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEnglishProficiencyType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEnglishProficiencyTypePointer(value interface{}) (*AUCodeSetsEnglishProficiencyType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEnglishProficiencyType:
 		return value.(*AUCodeSetsEnglishProficiencyType), true
        case AUCodeSetsEnglishProficiencyType:
 		v, _ := value.(AUCodeSetsEnglishProficiencyType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEnglishProficiencyType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEnglishProficiencyType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEnglishProficiencyType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEnrollmentTimeFrameType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEnrollmentTimeFrameType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEnrollmentTimeFrameTypePointer(value interface{}) (*AUCodeSetsEnrollmentTimeFrameType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEnrollmentTimeFrameType:
 		return value.(*AUCodeSetsEnrollmentTimeFrameType), true
        case AUCodeSetsEnrollmentTimeFrameType:
 		v, _ := value.(AUCodeSetsEnrollmentTimeFrameType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEnrollmentTimeFrameType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEnrollmentTimeFrameType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEnrollmentTimeFrameType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEntryTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEntryTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEntryTypeTypePointer(value interface{}) (*AUCodeSetsEntryTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEntryTypeType:
 		return value.(*AUCodeSetsEntryTypeType), true
        case AUCodeSetsEntryTypeType:
 		v, _ := value.(AUCodeSetsEntryTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEntryTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEntryTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEntryTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEquipmentTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEquipmentTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEquipmentTypeTypePointer(value interface{}) (*AUCodeSetsEquipmentTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEquipmentTypeType:
 		return value.(*AUCodeSetsEquipmentTypeType), true
        case AUCodeSetsEquipmentTypeType:
 		v, _ := value.(AUCodeSetsEquipmentTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEquipmentTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEquipmentTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEquipmentTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEventCategoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEventCategoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEventCategoryTypePointer(value interface{}) (*AUCodeSetsEventCategoryType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEventCategoryType:
 		return value.(*AUCodeSetsEventCategoryType), true
        case AUCodeSetsEventCategoryType:
 		v, _ := value.(AUCodeSetsEventCategoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEventCategoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEventCategoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEventCategoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsEventSubCategoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsEventSubCategoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsEventSubCategoryTypePointer(value interface{}) (*AUCodeSetsEventSubCategoryType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsEventSubCategoryType:
 		return value.(*AUCodeSetsEventSubCategoryType), true
        case AUCodeSetsEventSubCategoryType:
 		v, _ := value.(AUCodeSetsEventSubCategoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsEventSubCategoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsEventSubCategoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsEventSubCategoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsExitWithdrawalStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsExitWithdrawalStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsExitWithdrawalStatusTypePointer(value interface{}) (*AUCodeSetsExitWithdrawalStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsExitWithdrawalStatusType:
 		return value.(*AUCodeSetsExitWithdrawalStatusType), true
        case AUCodeSetsExitWithdrawalStatusType:
 		v, _ := value.(AUCodeSetsExitWithdrawalStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsExitWithdrawalStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsExitWithdrawalStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsExitWithdrawalStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsExitWithdrawalTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsExitWithdrawalTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsExitWithdrawalTypeTypePointer(value interface{}) (*AUCodeSetsExitWithdrawalTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsExitWithdrawalTypeType:
 		return value.(*AUCodeSetsExitWithdrawalTypeType), true
        case AUCodeSetsExitWithdrawalTypeType:
 		v, _ := value.(AUCodeSetsExitWithdrawalTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsExitWithdrawalTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsExitWithdrawalTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsExitWithdrawalTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsFFPOSStatusCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsFFPOSStatusCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsFFPOSStatusCodeTypePointer(value interface{}) (*AUCodeSetsFFPOSStatusCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsFFPOSStatusCodeType:
 		return value.(*AUCodeSetsFFPOSStatusCodeType), true
        case AUCodeSetsFFPOSStatusCodeType:
 		v, _ := value.(AUCodeSetsFFPOSStatusCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsFFPOSStatusCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsFFPOSStatusCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsFFPOSStatusCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsFTPTStatusCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsFTPTStatusCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsFTPTStatusCodeTypePointer(value interface{}) (*AUCodeSetsFTPTStatusCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsFTPTStatusCodeType:
 		return value.(*AUCodeSetsFTPTStatusCodeType), true
        case AUCodeSetsFTPTStatusCodeType:
 		v, _ := value.(AUCodeSetsFTPTStatusCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsFTPTStatusCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsFTPTStatusCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsFTPTStatusCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsFederalElectorateType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsFederalElectorateType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsFederalElectorateTypePointer(value interface{}) (*AUCodeSetsFederalElectorateType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsFederalElectorateType:
 		return value.(*AUCodeSetsFederalElectorateType), true
        case AUCodeSetsFederalElectorateType:
 		v, _ := value.(AUCodeSetsFederalElectorateType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsFederalElectorateType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsFederalElectorateType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsFederalElectorateType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsGradeProgressLevelType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsGradeProgressLevelType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsGradeProgressLevelTypePointer(value interface{}) (*AUCodeSetsGradeProgressLevelType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsGradeProgressLevelType:
 		return value.(*AUCodeSetsGradeProgressLevelType), true
        case AUCodeSetsGradeProgressLevelType:
 		v, _ := value.(AUCodeSetsGradeProgressLevelType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsGradeProgressLevelType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsGradeProgressLevelType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsGradeProgressLevelType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsGroupCategoryCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsGroupCategoryCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsGroupCategoryCodeTypePointer(value interface{}) (*AUCodeSetsGroupCategoryCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsGroupCategoryCodeType:
 		return value.(*AUCodeSetsGroupCategoryCodeType), true
        case AUCodeSetsGroupCategoryCodeType:
 		v, _ := value.(AUCodeSetsGroupCategoryCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsGroupCategoryCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsGroupCategoryCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsGroupCategoryCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsImmunisationCertificateStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsImmunisationCertificateStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsImmunisationCertificateStatusTypePointer(value interface{}) (*AUCodeSetsImmunisationCertificateStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsImmunisationCertificateStatusType:
 		return value.(*AUCodeSetsImmunisationCertificateStatusType), true
        case AUCodeSetsImmunisationCertificateStatusType:
 		v, _ := value.(AUCodeSetsImmunisationCertificateStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsImmunisationCertificateStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsImmunisationCertificateStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsImmunisationCertificateStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsIndigenousStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsIndigenousStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsIndigenousStatusTypePointer(value interface{}) (*AUCodeSetsIndigenousStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsIndigenousStatusType:
 		return value.(*AUCodeSetsIndigenousStatusType), true
        case AUCodeSetsIndigenousStatusType:
 		v, _ := value.(AUCodeSetsIndigenousStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsIndigenousStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsIndigenousStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsIndigenousStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsLanguageTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsLanguageTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsLanguageTypeTypePointer(value interface{}) (*AUCodeSetsLanguageTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsLanguageTypeType:
 		return value.(*AUCodeSetsLanguageTypeType), true
        case AUCodeSetsLanguageTypeType:
 		v, _ := value.(AUCodeSetsLanguageTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsLanguageTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsLanguageTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsLanguageTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsLearningStandardItemRelationshipTypesType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsLearningStandardItemRelationshipTypesType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsLearningStandardItemRelationshipTypesTypePointer(value interface{}) (*AUCodeSetsLearningStandardItemRelationshipTypesType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsLearningStandardItemRelationshipTypesType:
 		return value.(*AUCodeSetsLearningStandardItemRelationshipTypesType), true
        case AUCodeSetsLearningStandardItemRelationshipTypesType:
 		v, _ := value.(AUCodeSetsLearningStandardItemRelationshipTypesType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsLearningStandardItemRelationshipTypesType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsLearningStandardItemRelationshipTypesType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsLearningStandardItemRelationshipTypesType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsMaritalStatusAIHWType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsMaritalStatusAIHWType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsMaritalStatusAIHWTypePointer(value interface{}) (*AUCodeSetsMaritalStatusAIHWType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsMaritalStatusAIHWType:
 		return value.(*AUCodeSetsMaritalStatusAIHWType), true
        case AUCodeSetsMaritalStatusAIHWType:
 		v, _ := value.(AUCodeSetsMaritalStatusAIHWType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsMaritalStatusAIHWType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsMaritalStatusAIHWType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsMaritalStatusAIHWType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsMediumOfInstructionType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsMediumOfInstructionType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsMediumOfInstructionTypePointer(value interface{}) (*AUCodeSetsMediumOfInstructionType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsMediumOfInstructionType:
 		return value.(*AUCodeSetsMediumOfInstructionType), true
        case AUCodeSetsMediumOfInstructionType:
 		v, _ := value.(AUCodeSetsMediumOfInstructionType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsMediumOfInstructionType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsMediumOfInstructionType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsMediumOfInstructionType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNAPJurisdictionType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNAPJurisdictionType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNAPJurisdictionTypePointer(value interface{}) (*AUCodeSetsNAPJurisdictionType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNAPJurisdictionType:
 		return value.(*AUCodeSetsNAPJurisdictionType), true
        case AUCodeSetsNAPJurisdictionType:
 		v, _ := value.(AUCodeSetsNAPJurisdictionType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNAPJurisdictionType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNAPJurisdictionType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNAPJurisdictionType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNAPParticipationCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNAPParticipationCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNAPParticipationCodeTypePointer(value interface{}) (*AUCodeSetsNAPParticipationCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNAPParticipationCodeType:
 		return value.(*AUCodeSetsNAPParticipationCodeType), true
        case AUCodeSetsNAPParticipationCodeType:
 		v, _ := value.(AUCodeSetsNAPParticipationCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNAPParticipationCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNAPParticipationCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNAPParticipationCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNAPResponseCorrectnessType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNAPResponseCorrectnessType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNAPResponseCorrectnessTypePointer(value interface{}) (*AUCodeSetsNAPResponseCorrectnessType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNAPResponseCorrectnessType:
 		return value.(*AUCodeSetsNAPResponseCorrectnessType), true
        case AUCodeSetsNAPResponseCorrectnessType:
 		v, _ := value.(AUCodeSetsNAPResponseCorrectnessType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNAPResponseCorrectnessType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNAPResponseCorrectnessType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNAPResponseCorrectnessType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNAPTestDomainType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNAPTestDomainType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNAPTestDomainTypePointer(value interface{}) (*AUCodeSetsNAPTestDomainType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNAPTestDomainType:
 		return value.(*AUCodeSetsNAPTestDomainType), true
        case AUCodeSetsNAPTestDomainType:
 		v, _ := value.(AUCodeSetsNAPTestDomainType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNAPTestDomainType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNAPTestDomainType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNAPTestDomainType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNAPTestItemMarkingTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNAPTestItemMarkingTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNAPTestItemMarkingTypeTypePointer(value interface{}) (*AUCodeSetsNAPTestItemMarkingTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNAPTestItemMarkingTypeType:
 		return value.(*AUCodeSetsNAPTestItemMarkingTypeType), true
        case AUCodeSetsNAPTestItemMarkingTypeType:
 		v, _ := value.(AUCodeSetsNAPTestItemMarkingTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNAPTestItemMarkingTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNAPTestItemMarkingTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNAPTestItemMarkingTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNAPTestItemTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNAPTestItemTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNAPTestItemTypeTypePointer(value interface{}) (*AUCodeSetsNAPTestItemTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNAPTestItemTypeType:
 		return value.(*AUCodeSetsNAPTestItemTypeType), true
        case AUCodeSetsNAPTestItemTypeType:
 		v, _ := value.(AUCodeSetsNAPTestItemTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNAPTestItemTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNAPTestItemTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNAPTestItemTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNAPTestTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNAPTestTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNAPTestTypeTypePointer(value interface{}) (*AUCodeSetsNAPTestTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNAPTestTypeType:
 		return value.(*AUCodeSetsNAPTestTypeType), true
        case AUCodeSetsNAPTestTypeType:
 		v, _ := value.(AUCodeSetsNAPTestTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNAPTestTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNAPTestTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNAPTestTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNAPWritingGenreType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNAPWritingGenreType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNAPWritingGenreTypePointer(value interface{}) (*AUCodeSetsNAPWritingGenreType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNAPWritingGenreType:
 		return value.(*AUCodeSetsNAPWritingGenreType), true
        case AUCodeSetsNAPWritingGenreType:
 		v, _ := value.(AUCodeSetsNAPWritingGenreType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNAPWritingGenreType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNAPWritingGenreType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNAPWritingGenreType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNCCDAdjustmentType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNCCDAdjustmentType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNCCDAdjustmentTypePointer(value interface{}) (*AUCodeSetsNCCDAdjustmentType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNCCDAdjustmentType:
 		return value.(*AUCodeSetsNCCDAdjustmentType), true
        case AUCodeSetsNCCDAdjustmentType:
 		v, _ := value.(AUCodeSetsNCCDAdjustmentType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNCCDAdjustmentType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNCCDAdjustmentType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNCCDAdjustmentType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNCCDDisabilityType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNCCDDisabilityType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNCCDDisabilityTypePointer(value interface{}) (*AUCodeSetsNCCDDisabilityType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNCCDDisabilityType:
 		return value.(*AUCodeSetsNCCDDisabilityType), true
        case AUCodeSetsNCCDDisabilityType:
 		v, _ := value.(AUCodeSetsNCCDDisabilityType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNCCDDisabilityType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNCCDDisabilityType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNCCDDisabilityType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNameUsageTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNameUsageTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNameUsageTypeTypePointer(value interface{}) (*AUCodeSetsNameUsageTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNameUsageTypeType:
 		return value.(*AUCodeSetsNameUsageTypeType), true
        case AUCodeSetsNameUsageTypeType:
 		v, _ := value.(AUCodeSetsNameUsageTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNameUsageTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNameUsageTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNameUsageTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsNonSchoolEducationType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsNonSchoolEducationType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsNonSchoolEducationTypePointer(value interface{}) (*AUCodeSetsNonSchoolEducationType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsNonSchoolEducationType:
 		return value.(*AUCodeSetsNonSchoolEducationType), true
        case AUCodeSetsNonSchoolEducationType:
 		v, _ := value.(AUCodeSetsNonSchoolEducationType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsNonSchoolEducationType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsNonSchoolEducationType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsNonSchoolEducationType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsOperationalStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsOperationalStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsOperationalStatusTypePointer(value interface{}) (*AUCodeSetsOperationalStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsOperationalStatusType:
 		return value.(*AUCodeSetsOperationalStatusType), true
        case AUCodeSetsOperationalStatusType:
 		v, _ := value.(AUCodeSetsOperationalStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsOperationalStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsOperationalStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsOperationalStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsPNPCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsPNPCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsPNPCodeTypePointer(value interface{}) (*AUCodeSetsPNPCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsPNPCodeType:
 		return value.(*AUCodeSetsPNPCodeType), true
        case AUCodeSetsPNPCodeType:
 		v, _ := value.(AUCodeSetsPNPCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsPNPCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsPNPCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsPNPCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsPermanentResidentStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsPermanentResidentStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsPermanentResidentStatusTypePointer(value interface{}) (*AUCodeSetsPermanentResidentStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsPermanentResidentStatusType:
 		return value.(*AUCodeSetsPermanentResidentStatusType), true
        case AUCodeSetsPermanentResidentStatusType:
 		v, _ := value.(AUCodeSetsPermanentResidentStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsPermanentResidentStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsPermanentResidentStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsPermanentResidentStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsPermissionCategoryCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsPermissionCategoryCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsPermissionCategoryCodeTypePointer(value interface{}) (*AUCodeSetsPermissionCategoryCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsPermissionCategoryCodeType:
 		return value.(*AUCodeSetsPermissionCategoryCodeType), true
        case AUCodeSetsPermissionCategoryCodeType:
 		v, _ := value.(AUCodeSetsPermissionCategoryCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsPermissionCategoryCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsPermissionCategoryCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsPermissionCategoryCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsPersonalisedPlanType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsPersonalisedPlanType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsPersonalisedPlanTypePointer(value interface{}) (*AUCodeSetsPersonalisedPlanType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsPersonalisedPlanType:
 		return value.(*AUCodeSetsPersonalisedPlanType), true
        case AUCodeSetsPersonalisedPlanType:
 		v, _ := value.(AUCodeSetsPersonalisedPlanType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsPersonalisedPlanType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsPersonalisedPlanType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsPersonalisedPlanType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsPictureSourceType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsPictureSourceType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsPictureSourceTypePointer(value interface{}) (*AUCodeSetsPictureSourceType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsPictureSourceType:
 		return value.(*AUCodeSetsPictureSourceType), true
        case AUCodeSetsPictureSourceType:
 		v, _ := value.(AUCodeSetsPictureSourceType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsPictureSourceType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsPictureSourceType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsPictureSourceType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsPrePrimaryHoursType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsPrePrimaryHoursType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsPrePrimaryHoursTypePointer(value interface{}) (*AUCodeSetsPrePrimaryHoursType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsPrePrimaryHoursType:
 		return value.(*AUCodeSetsPrePrimaryHoursType), true
        case AUCodeSetsPrePrimaryHoursType:
 		v, _ := value.(AUCodeSetsPrePrimaryHoursType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsPrePrimaryHoursType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsPrePrimaryHoursType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsPrePrimaryHoursType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsProgramFundingSourceCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsProgramFundingSourceCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsProgramFundingSourceCodeTypePointer(value interface{}) (*AUCodeSetsProgramFundingSourceCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsProgramFundingSourceCodeType:
 		return value.(*AUCodeSetsProgramFundingSourceCodeType), true
        case AUCodeSetsProgramFundingSourceCodeType:
 		v, _ := value.(AUCodeSetsProgramFundingSourceCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsProgramFundingSourceCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsProgramFundingSourceCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsProgramFundingSourceCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsProgressLevelType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsProgressLevelType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsProgressLevelTypePointer(value interface{}) (*AUCodeSetsProgressLevelType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsProgressLevelType:
 		return value.(*AUCodeSetsProgressLevelType), true
        case AUCodeSetsProgressLevelType:
 		v, _ := value.(AUCodeSetsProgressLevelType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsProgressLevelType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsProgressLevelType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsProgressLevelType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsPublicSchoolCatchmentStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsPublicSchoolCatchmentStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsPublicSchoolCatchmentStatusTypePointer(value interface{}) (*AUCodeSetsPublicSchoolCatchmentStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsPublicSchoolCatchmentStatusType:
 		return value.(*AUCodeSetsPublicSchoolCatchmentStatusType), true
        case AUCodeSetsPublicSchoolCatchmentStatusType:
 		v, _ := value.(AUCodeSetsPublicSchoolCatchmentStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsPublicSchoolCatchmentStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsPublicSchoolCatchmentStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsPublicSchoolCatchmentStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsReceivingLocationOfInstructionType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsReceivingLocationOfInstructionType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsReceivingLocationOfInstructionTypePointer(value interface{}) (*AUCodeSetsReceivingLocationOfInstructionType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsReceivingLocationOfInstructionType:
 		return value.(*AUCodeSetsReceivingLocationOfInstructionType), true
        case AUCodeSetsReceivingLocationOfInstructionType:
 		v, _ := value.(AUCodeSetsReceivingLocationOfInstructionType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsReceivingLocationOfInstructionType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsReceivingLocationOfInstructionType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsReceivingLocationOfInstructionType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsRelationshipToStudentType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsRelationshipToStudentType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsRelationshipToStudentTypePointer(value interface{}) (*AUCodeSetsRelationshipToStudentType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsRelationshipToStudentType:
 		return value.(*AUCodeSetsRelationshipToStudentType), true
        case AUCodeSetsRelationshipToStudentType:
 		v, _ := value.(AUCodeSetsRelationshipToStudentType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsRelationshipToStudentType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsRelationshipToStudentType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsRelationshipToStudentType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsResourceUsageContentTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsResourceUsageContentTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsResourceUsageContentTypeTypePointer(value interface{}) (*AUCodeSetsResourceUsageContentTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsResourceUsageContentTypeType:
 		return value.(*AUCodeSetsResourceUsageContentTypeType), true
        case AUCodeSetsResourceUsageContentTypeType:
 		v, _ := value.(AUCodeSetsResourceUsageContentTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsResourceUsageContentTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsResourceUsageContentTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsResourceUsageContentTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsScheduledActivityTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsScheduledActivityTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsScheduledActivityTypeTypePointer(value interface{}) (*AUCodeSetsScheduledActivityTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsScheduledActivityTypeType:
 		return value.(*AUCodeSetsScheduledActivityTypeType), true
        case AUCodeSetsScheduledActivityTypeType:
 		v, _ := value.(AUCodeSetsScheduledActivityTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsScheduledActivityTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsScheduledActivityTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsScheduledActivityTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSchoolCoEdStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSchoolCoEdStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSchoolCoEdStatusTypePointer(value interface{}) (*AUCodeSetsSchoolCoEdStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSchoolCoEdStatusType:
 		return value.(*AUCodeSetsSchoolCoEdStatusType), true
        case AUCodeSetsSchoolCoEdStatusType:
 		v, _ := value.(AUCodeSetsSchoolCoEdStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSchoolCoEdStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSchoolCoEdStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSchoolCoEdStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSchoolEducationLevelTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSchoolEducationLevelTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSchoolEducationLevelTypeTypePointer(value interface{}) (*AUCodeSetsSchoolEducationLevelTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSchoolEducationLevelTypeType:
 		return value.(*AUCodeSetsSchoolEducationLevelTypeType), true
        case AUCodeSetsSchoolEducationLevelTypeType:
 		v, _ := value.(AUCodeSetsSchoolEducationLevelTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSchoolEducationLevelTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSchoolEducationLevelTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSchoolEducationLevelTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSchoolEnrollmentTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSchoolEnrollmentTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSchoolEnrollmentTypeTypePointer(value interface{}) (*AUCodeSetsSchoolEnrollmentTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSchoolEnrollmentTypeType:
 		return value.(*AUCodeSetsSchoolEnrollmentTypeType), true
        case AUCodeSetsSchoolEnrollmentTypeType:
 		v, _ := value.(AUCodeSetsSchoolEnrollmentTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSchoolEnrollmentTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSchoolEnrollmentTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSchoolEnrollmentTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSchoolFocusCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSchoolFocusCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSchoolFocusCodeTypePointer(value interface{}) (*AUCodeSetsSchoolFocusCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSchoolFocusCodeType:
 		return value.(*AUCodeSetsSchoolFocusCodeType), true
        case AUCodeSetsSchoolFocusCodeType:
 		v, _ := value.(AUCodeSetsSchoolFocusCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSchoolFocusCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSchoolFocusCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSchoolFocusCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSchoolLevelType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSchoolLevelType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSchoolLevelTypePointer(value interface{}) (*AUCodeSetsSchoolLevelType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSchoolLevelType:
 		return value.(*AUCodeSetsSchoolLevelType), true
        case AUCodeSetsSchoolLevelType:
 		v, _ := value.(AUCodeSetsSchoolLevelType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSchoolLevelType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSchoolLevelType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSchoolLevelType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSchoolLocationType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSchoolLocationType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSchoolLocationTypePointer(value interface{}) (*AUCodeSetsSchoolLocationType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSchoolLocationType:
 		return value.(*AUCodeSetsSchoolLocationType), true
        case AUCodeSetsSchoolLocationType:
 		v, _ := value.(AUCodeSetsSchoolLocationType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSchoolLocationType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSchoolLocationType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSchoolLocationType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSchoolSectorCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSchoolSectorCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSchoolSectorCodeTypePointer(value interface{}) (*AUCodeSetsSchoolSectorCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSchoolSectorCodeType:
 		return value.(*AUCodeSetsSchoolSectorCodeType), true
        case AUCodeSetsSchoolSectorCodeType:
 		v, _ := value.(AUCodeSetsSchoolSectorCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSchoolSectorCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSchoolSectorCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSchoolSectorCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSchoolSystemType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSchoolSystemType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSchoolSystemTypePointer(value interface{}) (*AUCodeSetsSchoolSystemType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSchoolSystemType:
 		return value.(*AUCodeSetsSchoolSystemType), true
        case AUCodeSetsSchoolSystemType:
 		v, _ := value.(AUCodeSetsSchoolSystemType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSchoolSystemType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSchoolSystemType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSchoolSystemType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSessionTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSessionTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSessionTypeTypePointer(value interface{}) (*AUCodeSetsSessionTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSessionTypeType:
 		return value.(*AUCodeSetsSessionTypeType), true
        case AUCodeSetsSessionTypeType:
 		v, _ := value.(AUCodeSetsSessionTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSessionTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSessionTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSessionTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSexCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSexCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSexCodeTypePointer(value interface{}) (*AUCodeSetsSexCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSexCodeType:
 		return value.(*AUCodeSetsSexCodeType), true
        case AUCodeSetsSexCodeType:
 		v, _ := value.(AUCodeSetsSexCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSexCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSexCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSexCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSourceCodeTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSourceCodeTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSourceCodeTypeTypePointer(value interface{}) (*AUCodeSetsSourceCodeTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSourceCodeTypeType:
 		return value.(*AUCodeSetsSourceCodeTypeType), true
        case AUCodeSetsSourceCodeTypeType:
 		v, _ := value.(AUCodeSetsSourceCodeTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSourceCodeTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSourceCodeTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSourceCodeTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsStaffActivityType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsStaffActivityType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsStaffActivityTypePointer(value interface{}) (*AUCodeSetsStaffActivityType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsStaffActivityType:
 		return value.(*AUCodeSetsStaffActivityType), true
        case AUCodeSetsStaffActivityType:
 		v, _ := value.(AUCodeSetsStaffActivityType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsStaffActivityType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsStaffActivityType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsStaffActivityType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsStaffStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsStaffStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsStaffStatusTypePointer(value interface{}) (*AUCodeSetsStaffStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsStaffStatusType:
 		return value.(*AUCodeSetsStaffStatusType), true
        case AUCodeSetsStaffStatusType:
 		v, _ := value.(AUCodeSetsStaffStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsStaffStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsStaffStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsStaffStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsStandardAustralianClassificationOfCountriesSACCType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsStandardAustralianClassificationOfCountriesSACCType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsStandardAustralianClassificationOfCountriesSACCTypePointer(value interface{}) (*AUCodeSetsStandardAustralianClassificationOfCountriesSACCType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsStandardAustralianClassificationOfCountriesSACCType:
 		return value.(*AUCodeSetsStandardAustralianClassificationOfCountriesSACCType), true
        case AUCodeSetsStandardAustralianClassificationOfCountriesSACCType:
 		v, _ := value.(AUCodeSetsStandardAustralianClassificationOfCountriesSACCType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsStandardAustralianClassificationOfCountriesSACCType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsStandardAustralianClassificationOfCountriesSACCType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsStandardAustralianClassificationOfCountriesSACCType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsStateTerritoryCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsStateTerritoryCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsStateTerritoryCodeTypePointer(value interface{}) (*AUCodeSetsStateTerritoryCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsStateTerritoryCodeType:
 		return value.(*AUCodeSetsStateTerritoryCodeType), true
        case AUCodeSetsStateTerritoryCodeType:
 		v, _ := value.(AUCodeSetsStateTerritoryCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsStateTerritoryCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsStateTerritoryCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsStateTerritoryCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsStudentFamilyProgramTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsStudentFamilyProgramTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsStudentFamilyProgramTypeTypePointer(value interface{}) (*AUCodeSetsStudentFamilyProgramTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsStudentFamilyProgramTypeType:
 		return value.(*AUCodeSetsStudentFamilyProgramTypeType), true
        case AUCodeSetsStudentFamilyProgramTypeType:
 		v, _ := value.(AUCodeSetsStudentFamilyProgramTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsStudentFamilyProgramTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsStudentFamilyProgramTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsStudentFamilyProgramTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSuspensionCategoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSuspensionCategoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSuspensionCategoryTypePointer(value interface{}) (*AUCodeSetsSuspensionCategoryType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSuspensionCategoryType:
 		return value.(*AUCodeSetsSuspensionCategoryType), true
        case AUCodeSetsSuspensionCategoryType:
 		v, _ := value.(AUCodeSetsSuspensionCategoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSuspensionCategoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSuspensionCategoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSuspensionCategoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsSystemicStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsSystemicStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsSystemicStatusTypePointer(value interface{}) (*AUCodeSetsSystemicStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsSystemicStatusType:
 		return value.(*AUCodeSetsSystemicStatusType), true
        case AUCodeSetsSystemicStatusType:
 		v, _ := value.(AUCodeSetsSystemicStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsSystemicStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsSystemicStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsSystemicStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsTeacherCoverCreditType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsTeacherCoverCreditType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsTeacherCoverCreditTypePointer(value interface{}) (*AUCodeSetsTeacherCoverCreditType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsTeacherCoverCreditType:
 		return value.(*AUCodeSetsTeacherCoverCreditType), true
        case AUCodeSetsTeacherCoverCreditType:
 		v, _ := value.(AUCodeSetsTeacherCoverCreditType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsTeacherCoverCreditType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsTeacherCoverCreditType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsTeacherCoverCreditType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsTeacherCoverSupervisionType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsTeacherCoverSupervisionType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsTeacherCoverSupervisionTypePointer(value interface{}) (*AUCodeSetsTeacherCoverSupervisionType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsTeacherCoverSupervisionType:
 		return value.(*AUCodeSetsTeacherCoverSupervisionType), true
        case AUCodeSetsTeacherCoverSupervisionType:
 		v, _ := value.(AUCodeSetsTeacherCoverSupervisionType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsTeacherCoverSupervisionType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsTeacherCoverSupervisionType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsTeacherCoverSupervisionType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsTelephoneNumberTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsTelephoneNumberTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsTelephoneNumberTypeTypePointer(value interface{}) (*AUCodeSetsTelephoneNumberTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsTelephoneNumberTypeType:
 		return value.(*AUCodeSetsTelephoneNumberTypeType), true
        case AUCodeSetsTelephoneNumberTypeType:
 		v, _ := value.(AUCodeSetsTelephoneNumberTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsTelephoneNumberTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsTelephoneNumberTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsTelephoneNumberTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsTimeTableChangeTypeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsTimeTableChangeTypeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsTimeTableChangeTypeTypePointer(value interface{}) (*AUCodeSetsTimeTableChangeTypeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsTimeTableChangeTypeType:
 		return value.(*AUCodeSetsTimeTableChangeTypeType), true
        case AUCodeSetsTimeTableChangeTypeType:
 		v, _ := value.(AUCodeSetsTimeTableChangeTypeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsTimeTableChangeTypeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsTimeTableChangeTypeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsTimeTableChangeTypeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsTravelModeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsTravelModeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsTravelModeTypePointer(value interface{}) (*AUCodeSetsTravelModeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsTravelModeType:
 		return value.(*AUCodeSetsTravelModeType), true
        case AUCodeSetsTravelModeType:
 		v, _ := value.(AUCodeSetsTravelModeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsTravelModeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsTravelModeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsTravelModeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsVisaStudyEntitlementType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsVisaStudyEntitlementType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsVisaStudyEntitlementTypePointer(value interface{}) (*AUCodeSetsVisaStudyEntitlementType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsVisaStudyEntitlementType:
 		return value.(*AUCodeSetsVisaStudyEntitlementType), true
        case AUCodeSetsVisaStudyEntitlementType:
 		v, _ := value.(AUCodeSetsVisaStudyEntitlementType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsVisaStudyEntitlementType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsVisaStudyEntitlementType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsVisaStudyEntitlementType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsVisaSubClassType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsVisaSubClassType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsVisaSubClassTypePointer(value interface{}) (*AUCodeSetsVisaSubClassType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsVisaSubClassType:
 		return value.(*AUCodeSetsVisaSubClassType), true
        case AUCodeSetsVisaSubClassType:
 		v, _ := value.(AUCodeSetsVisaSubClassType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsVisaSubClassType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsVisaSubClassType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsVisaSubClassType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingAlertCategoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingAlertCategoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingAlertCategoryTypePointer(value interface{}) (*AUCodeSetsWellbeingAlertCategoryType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingAlertCategoryType:
 		return value.(*AUCodeSetsWellbeingAlertCategoryType), true
        case AUCodeSetsWellbeingAlertCategoryType:
 		v, _ := value.(AUCodeSetsWellbeingAlertCategoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingAlertCategoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingAlertCategoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingAlertCategoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingAppealStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingAppealStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingAppealStatusTypePointer(value interface{}) (*AUCodeSetsWellbeingAppealStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingAppealStatusType:
 		return value.(*AUCodeSetsWellbeingAppealStatusType), true
        case AUCodeSetsWellbeingAppealStatusType:
 		v, _ := value.(AUCodeSetsWellbeingAppealStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingAppealStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingAppealStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingAppealStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingCharacteristicCategoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingCharacteristicCategoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingCharacteristicCategoryTypePointer(value interface{}) (*AUCodeSetsWellbeingCharacteristicCategoryType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingCharacteristicCategoryType:
 		return value.(*AUCodeSetsWellbeingCharacteristicCategoryType), true
        case AUCodeSetsWellbeingCharacteristicCategoryType:
 		v, _ := value.(AUCodeSetsWellbeingCharacteristicCategoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingCharacteristicCategoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingCharacteristicCategoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingCharacteristicCategoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingCharacteristicClassificationType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingCharacteristicClassificationType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingCharacteristicClassificationTypePointer(value interface{}) (*AUCodeSetsWellbeingCharacteristicClassificationType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingCharacteristicClassificationType:
 		return value.(*AUCodeSetsWellbeingCharacteristicClassificationType), true
        case AUCodeSetsWellbeingCharacteristicClassificationType:
 		v, _ := value.(AUCodeSetsWellbeingCharacteristicClassificationType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingCharacteristicClassificationType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingCharacteristicClassificationType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingCharacteristicClassificationType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingCharacteristicSubCategoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingCharacteristicSubCategoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingCharacteristicSubCategoryTypePointer(value interface{}) (*AUCodeSetsWellbeingCharacteristicSubCategoryType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingCharacteristicSubCategoryType:
 		return value.(*AUCodeSetsWellbeingCharacteristicSubCategoryType), true
        case AUCodeSetsWellbeingCharacteristicSubCategoryType:
 		v, _ := value.(AUCodeSetsWellbeingCharacteristicSubCategoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingCharacteristicSubCategoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingCharacteristicSubCategoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingCharacteristicSubCategoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingEventCategoryClassType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingEventCategoryClassType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingEventCategoryClassTypePointer(value interface{}) (*AUCodeSetsWellbeingEventCategoryClassType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingEventCategoryClassType:
 		return value.(*AUCodeSetsWellbeingEventCategoryClassType), true
        case AUCodeSetsWellbeingEventCategoryClassType:
 		v, _ := value.(AUCodeSetsWellbeingEventCategoryClassType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingEventCategoryClassType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingEventCategoryClassType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingEventCategoryClassType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingEventLocationType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingEventLocationType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingEventLocationTypePointer(value interface{}) (*AUCodeSetsWellbeingEventLocationType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingEventLocationType:
 		return value.(*AUCodeSetsWellbeingEventLocationType), true
        case AUCodeSetsWellbeingEventLocationType:
 		v, _ := value.(AUCodeSetsWellbeingEventLocationType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingEventLocationType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingEventLocationType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingEventLocationType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingEventTimePeriodType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingEventTimePeriodType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingEventTimePeriodTypePointer(value interface{}) (*AUCodeSetsWellbeingEventTimePeriodType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingEventTimePeriodType:
 		return value.(*AUCodeSetsWellbeingEventTimePeriodType), true
        case AUCodeSetsWellbeingEventTimePeriodType:
 		v, _ := value.(AUCodeSetsWellbeingEventTimePeriodType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingEventTimePeriodType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingEventTimePeriodType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingEventTimePeriodType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingResponseCategoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingResponseCategoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingResponseCategoryTypePointer(value interface{}) (*AUCodeSetsWellbeingResponseCategoryType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingResponseCategoryType:
 		return value.(*AUCodeSetsWellbeingResponseCategoryType), true
        case AUCodeSetsWellbeingResponseCategoryType:
 		v, _ := value.(AUCodeSetsWellbeingResponseCategoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingResponseCategoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingResponseCategoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingResponseCategoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsWellbeingStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsWellbeingStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsWellbeingStatusTypePointer(value interface{}) (*AUCodeSetsWellbeingStatusType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsWellbeingStatusType:
 		return value.(*AUCodeSetsWellbeingStatusType), true
        case AUCodeSetsWellbeingStatusType:
 		v, _ := value.(AUCodeSetsWellbeingStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsWellbeingStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsWellbeingStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsWellbeingStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsYearLevelCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsYearLevelCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsYearLevelCodeTypePointer(value interface{}) (*AUCodeSetsYearLevelCodeType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsYearLevelCodeType:
 		return value.(*AUCodeSetsYearLevelCodeType), true
        case AUCodeSetsYearLevelCodeType:
 		v, _ := value.(AUCodeSetsYearLevelCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsYearLevelCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsYearLevelCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsYearLevelCodeType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *AUCodeSetsYesOrNoCategoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches AUCodeSetsYesOrNoCategoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func AUCodeSetsYesOrNoCategoryTypePointer(value interface{}) (*AUCodeSetsYesOrNoCategoryType, bool) {
switch t := value.(type) {
 	case *AUCodeSetsYesOrNoCategoryType:
 		return value.(*AUCodeSetsYesOrNoCategoryType), true
        case AUCodeSetsYesOrNoCategoryType:
 		v, _ := value.(AUCodeSetsYesOrNoCategoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := AUCodeSetsYesOrNoCategoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := AUCodeSetsYesOrNoCategoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to AUCodeSetsYesOrNoCategoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *BirthDateType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches BirthDateType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func BirthDateTypePointer(value interface{}) (*BirthDateType, bool) {
switch t := value.(type) {
 	case *BirthDateType:
 		return value.(*BirthDateType), true
        case BirthDateType:
 		v, _ := value.(BirthDateType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := BirthDateType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := BirthDateType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to BirthDateType\n", t, value)
 	}
 	return nil, false
  }


// 
// Returns bool value
func (t *Bool) Bool() bool {
  return bool((reflect.ValueOf(*t).Interface()).(Bool))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches Bool. In the case of aliased types, accepts primitive values and converts them to the required alias.
  func BoolPointer(value interface{}) (*Bool, bool) {
switch t := value.(type) {
        case *Bool:
                return value.(*Bool), true
        case Bool:
                v, _ := value.(Bool)
                return &v, true
        case *bool:
                vstr, _ := value.(*bool)
                v := Bool(*vstr)
                return &v, true
        case bool:
                vstr, _ := value.(bool)
                v := Bool(vstr)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Bool\n", t, value)
        }
        return nil, false
  }

// Return string value
func (t *CountryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches CountryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func CountryTypePointer(value interface{}) (*CountryType, bool) {
switch t := value.(type) {
 	case *CountryType:
 		return value.(*CountryType), true
        case CountryType:
 		v, _ := value.(CountryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := CountryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := CountryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to CountryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *DefinedProtocolsType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches DefinedProtocolsType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func DefinedProtocolsTypePointer(value interface{}) (*DefinedProtocolsType, bool) {
switch t := value.(type) {
 	case *DefinedProtocolsType:
 		return value.(*DefinedProtocolsType), true
        case DefinedProtocolsType:
 		v, _ := value.(DefinedProtocolsType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := DefinedProtocolsType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := DefinedProtocolsType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to DefinedProtocolsType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *EducationalLevelType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches EducationalLevelType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func EducationalLevelTypePointer(value interface{}) (*EducationalLevelType, bool) {
switch t := value.(type) {
 	case *EducationalLevelType:
 		return value.(*EducationalLevelType), true
        case EducationalLevelType:
 		v, _ := value.(EducationalLevelType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := EducationalLevelType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := EducationalLevelType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to EducationalLevelType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *ExtendedContentType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches ExtendedContentType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func ExtendedContentTypePointer(value interface{}) (*ExtendedContentType, bool) {
switch t := value.(type) {
 	case *ExtendedContentType:
 		return value.(*ExtendedContentType), true
        case ExtendedContentType:
 		v, _ := value.(ExtendedContentType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := ExtendedContentType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := ExtendedContentType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to ExtendedContentType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *FTEType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches FTEType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func FTETypePointer(value interface{}) (*FTEType, bool) {
switch t := value.(type) {
 	case *FTEType:
 		return value.(*FTEType), true
        case FTEType:
 		v, _ := value.(FTEType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := FTEType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := FTEType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to FTEType\n", t, value)
 	}
 	return nil, false
  }


// Returns float64 value
func (t *Float) Float() float64 {
  return float64((reflect.ValueOf(*t).Interface()).(Float))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches Float. In the case of aliased types, accepts primitive values and converts them to the required alias.
// Also deals with both Float32 and Float64 values.
   func FloatPointer(value interface{}) (*Float, bool) {
switch t := value.(type) {
        case *Float:
                return value.(*Float), true
        case Float:
                v, _ := value.(Float)
                return &v, true
        case *float64:
                vstr, _ := value.(*float64)
                v := Float(*vstr)
                return &v, true
        case float64:
                vstr, _ := value.(float64)
                v := Float(vstr)
                return &v, true
        case *float32:
                vstr, _ := value.(*float32)
                v := Float(float64(*vstr))
                return &v, true
        case float32:
                vstr, _ := value.(float32)
                v := Float(float64(vstr))
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Float\n", t, value)
        }
        return nil, false
  }
// Return string value
func (t *GUIDType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches GUIDType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func GUIDTypePointer(value interface{}) (*GUIDType, bool) {
switch t := value.(type) {
 	case *GUIDType:
 		return value.(*GUIDType), true
        case GUIDType:
 		v, _ := value.(GUIDType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := GUIDType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := GUIDType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to GUIDType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *GenericYesNoType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches GenericYesNoType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func GenericYesNoTypePointer(value interface{}) (*GenericYesNoType, bool) {
switch t := value.(type) {
 	case *GenericYesNoType:
 		return value.(*GenericYesNoType), true
        case GenericYesNoType:
 		v, _ := value.(GenericYesNoType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := GenericYesNoType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := GenericYesNoType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to GenericYesNoType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *GraduationDateType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches GraduationDateType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func GraduationDateTypePointer(value interface{}) (*GraduationDateType, bool) {
switch t := value.(type) {
 	case *GraduationDateType:
 		return value.(*GraduationDateType), true
        case GraduationDateType:
 		v, _ := value.(GraduationDateType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := GraduationDateType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := GraduationDateType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to GraduationDateType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *HomeroomNumberType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches HomeroomNumberType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func HomeroomNumberTypePointer(value interface{}) (*HomeroomNumberType, bool) {
switch t := value.(type) {
 	case *HomeroomNumberType:
 		return value.(*HomeroomNumberType), true
        case HomeroomNumberType:
 		v, _ := value.(HomeroomNumberType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := HomeroomNumberType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := HomeroomNumberType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to HomeroomNumberType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *ISO4217CurrencyNamesAndCodeElementsType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches ISO4217CurrencyNamesAndCodeElementsType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func ISO4217CurrencyNamesAndCodeElementsTypePointer(value interface{}) (*ISO4217CurrencyNamesAndCodeElementsType, bool) {
switch t := value.(type) {
 	case *ISO4217CurrencyNamesAndCodeElementsType:
 		return value.(*ISO4217CurrencyNamesAndCodeElementsType), true
        case ISO4217CurrencyNamesAndCodeElementsType:
 		v, _ := value.(ISO4217CurrencyNamesAndCodeElementsType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := ISO4217CurrencyNamesAndCodeElementsType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := ISO4217CurrencyNamesAndCodeElementsType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to ISO4217CurrencyNamesAndCodeElementsType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *IdRefType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches IdRefType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func IdRefTypePointer(value interface{}) (*IdRefType, bool) {
switch t := value.(type) {
 	case *IdRefType:
 		return value.(*IdRefType), true
        case IdRefType:
 		v, _ := value.(IdRefType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := IdRefType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := IdRefType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to IdRefType\n", t, value)
 	}
 	return nil, false
  }


// Returns int value
func (t *Int) Int() int {
  return int((reflect.ValueOf(*t).Interface()).(Int))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches Int. In the case of aliased types, accepts primitive values and converts them to the required alias.
func IntPointer(value interface{}) (*Int, bool) {
switch t := value.(type) {
        case *Int:
                return value.(*Int), true
        case Int:
                v, _ := value.(Int)
                return &v, true
        case *int:
 		vstr, _ := value.(*int)
 		v := Int(*vstr)
 		return &v, true
        case int:
                vstr, _ := value.(int)
                v := Int(vstr)
                return &v, true
        default:
                fmt.Printf("Warning: cannot resolve %T (%v) to Int\n", t, value)
        }
        return nil, false
  }

// Return string value
func (t *LocalIdType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches LocalIdType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func LocalIdTypePointer(value interface{}) (*LocalIdType, bool) {
switch t := value.(type) {
 	case *LocalIdType:
 		return value.(*LocalIdType), true
        case LocalIdType:
 		v, _ := value.(LocalIdType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := LocalIdType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := LocalIdType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to LocalIdType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *ObjectNameType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches ObjectNameType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func ObjectNameTypePointer(value interface{}) (*ObjectNameType, bool) {
switch t := value.(type) {
 	case *ObjectNameType:
 		return value.(*ObjectNameType), true
        case ObjectNameType:
 		v, _ := value.(ObjectNameType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := ObjectNameType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := ObjectNameType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to ObjectNameType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *ObjectType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches ObjectType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func ObjectTypePointer(value interface{}) (*ObjectType, bool) {
switch t := value.(type) {
 	case *ObjectType:
 		return value.(*ObjectType), true
        case ObjectType:
 		v, _ := value.(ObjectType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := ObjectType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := ObjectType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to ObjectType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *OnTimeGraduationYearType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches OnTimeGraduationYearType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func OnTimeGraduationYearTypePointer(value interface{}) (*OnTimeGraduationYearType, bool) {
switch t := value.(type) {
 	case *OnTimeGraduationYearType:
 		return value.(*OnTimeGraduationYearType), true
        case OnTimeGraduationYearType:
 		v, _ := value.(OnTimeGraduationYearType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := OnTimeGraduationYearType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := OnTimeGraduationYearType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to OnTimeGraduationYearType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *OperationalStatusType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches OperationalStatusType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func OperationalStatusTypePointer(value interface{}) (*OperationalStatusType, bool) {
switch t := value.(type) {
 	case *OperationalStatusType:
 		return value.(*OperationalStatusType), true
        case OperationalStatusType:
 		v, _ := value.(OperationalStatusType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := OperationalStatusType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := OperationalStatusType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to OperationalStatusType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *PartialDateType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches PartialDateType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func PartialDateTypePointer(value interface{}) (*PartialDateType, bool) {
switch t := value.(type) {
 	case *PartialDateType:
 		return value.(*PartialDateType), true
        case PartialDateType:
 		v, _ := value.(PartialDateType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := PartialDateType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := PartialDateType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to PartialDateType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *ProjectedGraduationYearType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches ProjectedGraduationYearType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func ProjectedGraduationYearTypePointer(value interface{}) (*ProjectedGraduationYearType, bool) {
switch t := value.(type) {
 	case *ProjectedGraduationYearType:
 		return value.(*ProjectedGraduationYearType), true
        case ProjectedGraduationYearType:
 		v, _ := value.(ProjectedGraduationYearType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := ProjectedGraduationYearType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := ProjectedGraduationYearType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to ProjectedGraduationYearType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *PublishInDirectoryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches PublishInDirectoryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func PublishInDirectoryTypePointer(value interface{}) (*PublishInDirectoryType, bool) {
switch t := value.(type) {
 	case *PublishInDirectoryType:
 		return value.(*PublishInDirectoryType), true
        case PublishInDirectoryType:
 		v, _ := value.(PublishInDirectoryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := PublishInDirectoryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := PublishInDirectoryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to PublishInDirectoryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *RefIdType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches RefIdType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func RefIdTypePointer(value interface{}) (*RefIdType, bool) {
switch t := value.(type) {
 	case *RefIdType:
 		return value.(*RefIdType), true
        case RefIdType:
 		v, _ := value.(RefIdType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := RefIdType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := RefIdType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to RefIdType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *ReportDataObjectType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches ReportDataObjectType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func ReportDataObjectTypePointer(value interface{}) (*ReportDataObjectType, bool) {
switch t := value.(type) {
 	case *ReportDataObjectType:
 		return value.(*ReportDataObjectType), true
        case ReportDataObjectType:
 		v, _ := value.(ReportDataObjectType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := ReportDataObjectType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := ReportDataObjectType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to ReportDataObjectType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *SchoolURLType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches SchoolURLType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func SchoolURLTypePointer(value interface{}) (*SchoolURLType, bool) {
switch t := value.(type) {
 	case *SchoolURLType:
 		return value.(*SchoolURLType), true
        case SchoolURLType:
 		v, _ := value.(SchoolURLType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := SchoolURLType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := SchoolURLType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to SchoolURLType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *SchoolYearType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches SchoolYearType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func SchoolYearTypePointer(value interface{}) (*SchoolYearType, bool) {
switch t := value.(type) {
 	case *SchoolYearType:
 		return value.(*SchoolYearType), true
        case SchoolYearType:
 		v, _ := value.(SchoolYearType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := SchoolYearType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := SchoolYearType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to SchoolYearType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *SelectedContentType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches SelectedContentType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func SelectedContentTypePointer(value interface{}) (*SelectedContentType, bool) {
switch t := value.(type) {
 	case *SelectedContentType:
 		return value.(*SelectedContentType), true
        case SelectedContentType:
 		v, _ := value.(SelectedContentType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := SelectedContentType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := SelectedContentType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to SelectedContentType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *ServiceNameType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches ServiceNameType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func ServiceNameTypePointer(value interface{}) (*ServiceNameType, bool) {
switch t := value.(type) {
 	case *ServiceNameType:
 		return value.(*ServiceNameType), true
        case ServiceNameType:
 		v, _ := value.(ServiceNameType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := ServiceNameType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := ServiceNameType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to ServiceNameType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *StateProvinceIdType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches StateProvinceIdType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func StateProvinceIdTypePointer(value interface{}) (*StateProvinceIdType, bool) {
switch t := value.(type) {
 	case *StateProvinceIdType:
 		return value.(*StateProvinceIdType), true
        case StateProvinceIdType:
 		v, _ := value.(StateProvinceIdType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := StateProvinceIdType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := StateProvinceIdType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to StateProvinceIdType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *StateProvinceType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches StateProvinceType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func StateProvinceTypePointer(value interface{}) (*StateProvinceType, bool) {
switch t := value.(type) {
 	case *StateProvinceType:
 		return value.(*StateProvinceType), true
        case StateProvinceType:
 		v, _ := value.(StateProvinceType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := StateProvinceType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := StateProvinceType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to StateProvinceType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *String) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches String. In the case of aliased types, accepts primitive values and converts them to the required alias.
func StringPointer(value interface{}) (*String, bool) {
switch t := value.(type) {
 	case *String:
 		return value.(*String), true
        case String:
 		v, _ := value.(String)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := String(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := String(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to String\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *URIOrBinaryType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches URIOrBinaryType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func URIOrBinaryTypePointer(value interface{}) (*URIOrBinaryType, bool) {
switch t := value.(type) {
 	case *URIOrBinaryType:
 		return value.(*URIOrBinaryType), true
        case URIOrBinaryType:
 		v, _ := value.(URIOrBinaryType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := URIOrBinaryType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := URIOrBinaryType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to URIOrBinaryType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *VersionType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches VersionType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func VersionTypePointer(value interface{}) (*VersionType, bool) {
switch t := value.(type) {
 	case *VersionType:
 		return value.(*VersionType), true
        case VersionType:
 		v, _ := value.(VersionType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := VersionType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := VersionType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to VersionType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *VersionWithWildcardsType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches VersionWithWildcardsType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func VersionWithWildcardsTypePointer(value interface{}) (*VersionWithWildcardsType, bool) {
switch t := value.(type) {
 	case *VersionWithWildcardsType:
 		return value.(*VersionWithWildcardsType), true
        case VersionWithWildcardsType:
 		v, _ := value.(VersionWithWildcardsType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := VersionWithWildcardsType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := VersionWithWildcardsType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to VersionWithWildcardsType\n", t, value)
 	}
 	return nil, false
  }


// Return string value
func (t *VisaSubClassCodeType) String() string {
  return fmt.Sprint(reflect.ValueOf(*t))
  }

// Generates a pointer to the given value (unless it already is a pointer), and returns an error in case
// the value mismatches VisaSubClassCodeType. In the case of aliased types, accepts primitive values and converts them to the required alias.
func VisaSubClassCodeTypePointer(value interface{}) (*VisaSubClassCodeType, bool) {
switch t := value.(type) {
 	case *VisaSubClassCodeType:
 		return value.(*VisaSubClassCodeType), true
        case VisaSubClassCodeType:
 		v, _ := value.(VisaSubClassCodeType)
 		return &v, true
 	case *string:
 		vstr, _ := value.(*string)
 		v := VisaSubClassCodeType(*vstr)
 		return &v, true
 	case string:
 		vstr, _ := value.(string)
 		v := VisaSubClassCodeType(vstr)
 		return &v, true
 	default:
 		fmt.Printf("Warning: cannot resolve %T (%v) to VisaSubClassCodeType\n", t, value)
 	}
 	return nil, false
  }



// Set the value of a property to nil
func (n *ACStrandSubjectAreaType) Unset(key string) *ACStrandSubjectAreaType {
        switch key {
  case "ACStrand":
   n.acstrandsubjectareatype.ACStrand = nil
  case "SubjectArea":
   n.acstrandsubjectareatype.SubjectArea = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ACStrandSubjectAreaType")
        }
        return n
}

// Set a sequence of properties
func (n *ACStrandSubjectAreaType) SetProperties(props ...Prop) *ACStrandSubjectAreaType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ACStrandSubjectAreaType) SetProperty(key string, value interface{}) *ACStrandSubjectAreaType {
        if n == nil {
                n, _ = ACStrandSubjectAreaTypePointer(ACStrandSubjectAreaType{})
        }
        switch key {
    case "ACStrand":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsACStrandType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsACStrandType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.acstrandsubjectareatype.ACStrand = ((*AUCodeSetsACStrandType)(v))
      }
    case "SubjectArea":
    if v, ok:= SubjectAreaTypePointer(value); ok {
      n.acstrandsubjectareatype.SubjectArea = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ACStrandSubjectAreaType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ACStrandSubjectAreaType) ACStrand() *AUCodeSetsACStrandType {
    if s.acstrandsubjectareatype.ACStrand == nil {
    if v, ok:= StringPointer(""); ok {
      s.acstrandsubjectareatype.ACStrand = ((*AUCodeSetsACStrandType)(v))
      }
      }
      return s.acstrandsubjectareatype.ACStrand
    }
// Returns whether the element value for ACStrand is nil in the container ACStrandSubjectAreaType.
  func (s *ACStrandSubjectAreaType) ACStrand_IsNil() bool {
    return s.acstrandsubjectareatype.ACStrand == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ACStrandSubjectAreaType) SubjectArea() *SubjectAreaType {
    if s.acstrandsubjectareatype.SubjectArea == nil {
     if v, ok:= SubjectAreaTypePointer(SubjectAreaType{}); ok {
      s.acstrandsubjectareatype.SubjectArea = v
      }
      }
      return s.acstrandsubjectareatype.SubjectArea
    }
// Returns whether the element value for SubjectArea is nil in the container ACStrandSubjectAreaType.
  func (s *ACStrandSubjectAreaType) SubjectArea_IsNil() bool {
    return s.acstrandsubjectareatype.SubjectArea == nil
    }

// Set the value of a property to nil
func (n *AGContextualQuestionType) Unset(key string) *AGContextualQuestionType {
        switch key {
  case "AGAnswer":
   n.agcontextualquestiontype.AGAnswer = nil
  case "AGContextCode":
   n.agcontextualquestiontype.AGContextCode = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGContextualQuestionType")
        }
        return n
}

// Set a sequence of properties
func (n *AGContextualQuestionType) SetProperties(props ...Prop) *AGContextualQuestionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AGContextualQuestionType) SetProperty(key string, value interface{}) *AGContextualQuestionType {
        if n == nil {
                n, _ = AGContextualQuestionTypePointer(AGContextualQuestionType{})
        }
        switch key {
    case "AGAnswer":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agcontextualquestiontype.AGAnswer = ((*String)(v))
      }
    case "AGContextCode":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAGContextQuestionType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAGContextQuestionType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.agcontextualquestiontype.AGContextCode = ((*AUCodeSetsAGContextQuestionType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGContextualQuestionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGContextualQuestionType) AGAnswer() *String {
    if s.agcontextualquestiontype.AGAnswer == nil {
    if v, ok:= StringPointer(""); ok {
      s.agcontextualquestiontype.AGAnswer = ((*String)(v))
      }
      }
      return s.agcontextualquestiontype.AGAnswer
    }
// Returns whether the element value for AGAnswer is nil in the container AGContextualQuestionType.
  func (s *AGContextualQuestionType) AGAnswer_IsNil() bool {
    return s.agcontextualquestiontype.AGAnswer == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGContextualQuestionType) AGContextCode() *AUCodeSetsAGContextQuestionType {
    if s.agcontextualquestiontype.AGContextCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.agcontextualquestiontype.AGContextCode = ((*AUCodeSetsAGContextQuestionType)(v))
      }
      }
      return s.agcontextualquestiontype.AGContextCode
    }
// Returns whether the element value for AGContextCode is nil in the container AGContextualQuestionType.
  func (s *AGContextualQuestionType) AGContextCode_IsNil() bool {
    return s.agcontextualquestiontype.AGContextCode == nil
    }

// Set the value of a property to nil
func (n *AGParentType) Unset(key string) *AGParentType {
        switch key {
  case "AddressSameAsStudent":
   n.agparenttype.AddressSameAsStudent = nil
  case "ParentAddress":
   n.agparenttype.ParentAddress = nil
  case "ParentName":
   n.agparenttype.ParentName = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGParentType")
        }
        return n
}

// Set a sequence of properties
func (n *AGParentType) SetProperties(props ...Prop) *AGParentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AGParentType) SetProperty(key string, value interface{}) *AGParentType {
        if n == nil {
                n, _ = AGParentTypePointer(AGParentType{})
        }
        switch key {
    case "AddressSameAsStudent":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.agparenttype.AddressSameAsStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "ParentAddress":
    if v, ok:= AddressTypePointer(value); ok {
      n.agparenttype.ParentAddress = v
      }
    case "ParentName":
    if v, ok:= NameOfRecordTypePointer(value); ok {
      n.agparenttype.ParentName = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGParentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGParentType) AddressSameAsStudent() *AUCodeSetsYesOrNoCategoryType {
    if s.agparenttype.AddressSameAsStudent == nil {
    if v, ok:= StringPointer(""); ok {
      s.agparenttype.AddressSameAsStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.agparenttype.AddressSameAsStudent
    }
// Returns whether the element value for AddressSameAsStudent is nil in the container AGParentType.
  func (s *AGParentType) AddressSameAsStudent_IsNil() bool {
    return s.agparenttype.AddressSameAsStudent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGParentType) ParentAddress() *AddressType {
    if s.agparenttype.ParentAddress == nil {
     if v, ok:= AddressTypePointer(AddressType{}); ok {
      s.agparenttype.ParentAddress = v
      }
      }
      return s.agparenttype.ParentAddress
    }
// Returns whether the element value for ParentAddress is nil in the container AGParentType.
  func (s *AGParentType) ParentAddress_IsNil() bool {
    return s.agparenttype.ParentAddress == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGParentType) ParentName() *NameOfRecordType {
    if s.agparenttype.ParentName == nil {
     if v, ok:= NameOfRecordTypePointer(NameOfRecordType{}); ok {
      s.agparenttype.ParentName = v
      }
      }
      return s.agparenttype.ParentName
    }
// Returns whether the element value for ParentName is nil in the container AGParentType.
  func (s *AGParentType) ParentName_IsNil() bool {
    return s.agparenttype.ParentName == nil
    }

// Set the value of a property to nil
func (n *AGReportingObjectResponseType) Unset(key string) *AGReportingObjectResponseType {
        switch key {
  case "AGRuleList":
   n.agreportingobjectresponsetype.AGRuleList = nil
  case "AGSubmissionStatusCode":
   n.agreportingobjectresponsetype.AGSubmissionStatusCode = nil
  case "CommonwealthId":
   n.agreportingobjectresponsetype.CommonwealthId = nil
  case "EntityName":
   n.agreportingobjectresponsetype.EntityName = nil
  case "ErrorText":
   n.agreportingobjectresponsetype.ErrorText = nil
  case "HTTPStatusCode":
   n.agreportingobjectresponsetype.HTTPStatusCode = nil
  case "SIFRefId":
   n.agreportingobjectresponsetype.SIFRefId = nil
  case "SubmittedRefId":
   n.agreportingobjectresponsetype.SubmittedRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGReportingObjectResponseType")
        }
        return n
}

// Set a sequence of properties
func (n *AGReportingObjectResponseType) SetProperties(props ...Prop) *AGReportingObjectResponseType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AGReportingObjectResponseType) SetProperty(key string, value interface{}) *AGReportingObjectResponseType {
        if n == nil {
                n, _ = AGReportingObjectResponseTypePointer(AGReportingObjectResponseType{})
        }
        switch key {
    case "AGRuleList":
    if v, ok:= AGRuleListTypePointer(value); ok {
      n.agreportingobjectresponsetype.AGRuleList = v
      }
    case "AGSubmissionStatusCode":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAGSubmissionStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAGSubmissionStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.agreportingobjectresponsetype.AGSubmissionStatusCode = ((*AUCodeSetsAGSubmissionStatusType)(v))
      }
    case "CommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agreportingobjectresponsetype.CommonwealthId = ((*String)(v))
      }
    case "EntityName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agreportingobjectresponsetype.EntityName = ((*String)(v))
      }
    case "ErrorText":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agreportingobjectresponsetype.ErrorText = ((*String)(v))
      }
    case "HTTPStatusCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agreportingobjectresponsetype.HTTPStatusCode = ((*String)(v))
      }
    case "SIFRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agreportingobjectresponsetype.SIFRefId = ((*String)(v))
      }
    case "SubmittedRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agreportingobjectresponsetype.SubmittedRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGReportingObjectResponseType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGReportingObjectResponseType) AGRuleList() *AGRuleListType {
    if s.agreportingobjectresponsetype.AGRuleList == nil {
     if v, ok:= AGRuleListTypePointer(AGRuleListType{}); ok {
      s.agreportingobjectresponsetype.AGRuleList = v
      }
      }
      return s.agreportingobjectresponsetype.AGRuleList
    }
// Returns whether the element value for AGRuleList is nil in the container AGReportingObjectResponseType.
  func (s *AGReportingObjectResponseType) AGRuleList_IsNil() bool {
    return s.agreportingobjectresponsetype.AGRuleList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGReportingObjectResponseType) AGSubmissionStatusCode() *AUCodeSetsAGSubmissionStatusType {
    if s.agreportingobjectresponsetype.AGSubmissionStatusCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.agreportingobjectresponsetype.AGSubmissionStatusCode = ((*AUCodeSetsAGSubmissionStatusType)(v))
      }
      }
      return s.agreportingobjectresponsetype.AGSubmissionStatusCode
    }
// Returns whether the element value for AGSubmissionStatusCode is nil in the container AGReportingObjectResponseType.
  func (s *AGReportingObjectResponseType) AGSubmissionStatusCode_IsNil() bool {
    return s.agreportingobjectresponsetype.AGSubmissionStatusCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGReportingObjectResponseType) CommonwealthId() *String {
    if s.agreportingobjectresponsetype.CommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.agreportingobjectresponsetype.CommonwealthId = ((*String)(v))
      }
      }
      return s.agreportingobjectresponsetype.CommonwealthId
    }
// Returns whether the element value for CommonwealthId is nil in the container AGReportingObjectResponseType.
  func (s *AGReportingObjectResponseType) CommonwealthId_IsNil() bool {
    return s.agreportingobjectresponsetype.CommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGReportingObjectResponseType) EntityName() *String {
    if s.agreportingobjectresponsetype.EntityName == nil {
    if v, ok:= StringPointer(""); ok {
      s.agreportingobjectresponsetype.EntityName = ((*String)(v))
      }
      }
      return s.agreportingobjectresponsetype.EntityName
    }
// Returns whether the element value for EntityName is nil in the container AGReportingObjectResponseType.
  func (s *AGReportingObjectResponseType) EntityName_IsNil() bool {
    return s.agreportingobjectresponsetype.EntityName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGReportingObjectResponseType) ErrorText() *String {
    if s.agreportingobjectresponsetype.ErrorText == nil {
    if v, ok:= StringPointer(""); ok {
      s.agreportingobjectresponsetype.ErrorText = ((*String)(v))
      }
      }
      return s.agreportingobjectresponsetype.ErrorText
    }
// Returns whether the element value for ErrorText is nil in the container AGReportingObjectResponseType.
  func (s *AGReportingObjectResponseType) ErrorText_IsNil() bool {
    return s.agreportingobjectresponsetype.ErrorText == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGReportingObjectResponseType) HTTPStatusCode() *String {
    if s.agreportingobjectresponsetype.HTTPStatusCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.agreportingobjectresponsetype.HTTPStatusCode = ((*String)(v))
      }
      }
      return s.agreportingobjectresponsetype.HTTPStatusCode
    }
// Returns whether the element value for HTTPStatusCode is nil in the container AGReportingObjectResponseType.
  func (s *AGReportingObjectResponseType) HTTPStatusCode_IsNil() bool {
    return s.agreportingobjectresponsetype.HTTPStatusCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGReportingObjectResponseType) SIFRefId() *String {
    if s.agreportingobjectresponsetype.SIFRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.agreportingobjectresponsetype.SIFRefId = ((*String)(v))
      }
      }
      return s.agreportingobjectresponsetype.SIFRefId
    }
// Returns whether the element value for SIFRefId is nil in the container AGReportingObjectResponseType.
  func (s *AGReportingObjectResponseType) SIFRefId_IsNil() bool {
    return s.agreportingobjectresponsetype.SIFRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGReportingObjectResponseType) SubmittedRefId() *String {
    if s.agreportingobjectresponsetype.SubmittedRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.agreportingobjectresponsetype.SubmittedRefId = ((*String)(v))
      }
      }
      return s.agreportingobjectresponsetype.SubmittedRefId
    }
// Returns whether the element value for SubmittedRefId is nil in the container AGReportingObjectResponseType.
  func (s *AGReportingObjectResponseType) SubmittedRefId_IsNil() bool {
    return s.agreportingobjectresponsetype.SubmittedRefId == nil
    }

// Set the value of a property to nil
func (n *AGRoundType) Unset(key string) *AGRoundType {
        switch key {
  case "DueDate":
   n.agroundtype.DueDate = nil
  case "EndDate":
   n.agroundtype.EndDate = nil
  case "RoundCode":
   n.agroundtype.RoundCode = nil
  case "RoundName":
   n.agroundtype.RoundName = nil
  case "StartDate":
   n.agroundtype.StartDate = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGRoundType")
        }
        return n
}

// Set a sequence of properties
func (n *AGRoundType) SetProperties(props ...Prop) *AGRoundType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AGRoundType) SetProperty(key string, value interface{}) *AGRoundType {
        if n == nil {
                n, _ = AGRoundTypePointer(AGRoundType{})
        }
        switch key {
    case "DueDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agroundtype.DueDate = ((*String)(v))
      }
    case "EndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agroundtype.EndDate = ((*String)(v))
      }
    case "RoundCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agroundtype.RoundCode = ((*String)(v))
      }
    case "RoundName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agroundtype.RoundName = ((*String)(v))
      }
    case "StartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agroundtype.StartDate = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGRoundType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGRoundType) DueDate() *String {
    if s.agroundtype.DueDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.agroundtype.DueDate = ((*String)(v))
      }
      }
      return s.agroundtype.DueDate
    }
// Returns whether the element value for DueDate is nil in the container AGRoundType.
  func (s *AGRoundType) DueDate_IsNil() bool {
    return s.agroundtype.DueDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGRoundType) EndDate() *String {
    if s.agroundtype.EndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.agroundtype.EndDate = ((*String)(v))
      }
      }
      return s.agroundtype.EndDate
    }
// Returns whether the element value for EndDate is nil in the container AGRoundType.
  func (s *AGRoundType) EndDate_IsNil() bool {
    return s.agroundtype.EndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGRoundType) RoundCode() *String {
    if s.agroundtype.RoundCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.agroundtype.RoundCode = ((*String)(v))
      }
      }
      return s.agroundtype.RoundCode
    }
// Returns whether the element value for RoundCode is nil in the container AGRoundType.
  func (s *AGRoundType) RoundCode_IsNil() bool {
    return s.agroundtype.RoundCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGRoundType) RoundName() *String {
    if s.agroundtype.RoundName == nil {
    if v, ok:= StringPointer(""); ok {
      s.agroundtype.RoundName = ((*String)(v))
      }
      }
      return s.agroundtype.RoundName
    }
// Returns whether the element value for RoundName is nil in the container AGRoundType.
  func (s *AGRoundType) RoundName_IsNil() bool {
    return s.agroundtype.RoundName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGRoundType) StartDate() *String {
    if s.agroundtype.StartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.agroundtype.StartDate = ((*String)(v))
      }
      }
      return s.agroundtype.StartDate
    }
// Returns whether the element value for StartDate is nil in the container AGRoundType.
  func (s *AGRoundType) StartDate_IsNil() bool {
    return s.agroundtype.StartDate == nil
    }

// Set the value of a property to nil
func (n *AGRuleType) Unset(key string) *AGRuleType {
        switch key {
  case "AGRuleCode":
   n.agruletype.AGRuleCode = nil
  case "AGRuleComment":
   n.agruletype.AGRuleComment = nil
  case "AGRuleResponse":
   n.agruletype.AGRuleResponse = nil
  case "AGRuleStatus":
   n.agruletype.AGRuleStatus = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGRuleType")
        }
        return n
}

// Set a sequence of properties
func (n *AGRuleType) SetProperties(props ...Prop) *AGRuleType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AGRuleType) SetProperty(key string, value interface{}) *AGRuleType {
        if n == nil {
                n, _ = AGRuleTypePointer(AGRuleType{})
        }
        switch key {
    case "AGRuleCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agruletype.AGRuleCode = ((*String)(v))
      }
    case "AGRuleComment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agruletype.AGRuleComment = ((*String)(v))
      }
    case "AGRuleResponse":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agruletype.AGRuleResponse = ((*String)(v))
      }
    case "AGRuleStatus":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.agruletype.AGRuleStatus = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AGRuleType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGRuleType) AGRuleCode() *String {
    if s.agruletype.AGRuleCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.agruletype.AGRuleCode = ((*String)(v))
      }
      }
      return s.agruletype.AGRuleCode
    }
// Returns whether the element value for AGRuleCode is nil in the container AGRuleType.
  func (s *AGRuleType) AGRuleCode_IsNil() bool {
    return s.agruletype.AGRuleCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGRuleType) AGRuleComment() *String {
    if s.agruletype.AGRuleComment == nil {
    if v, ok:= StringPointer(""); ok {
      s.agruletype.AGRuleComment = ((*String)(v))
      }
      }
      return s.agruletype.AGRuleComment
    }
// Returns whether the element value for AGRuleComment is nil in the container AGRuleType.
  func (s *AGRuleType) AGRuleComment_IsNil() bool {
    return s.agruletype.AGRuleComment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGRuleType) AGRuleResponse() *String {
    if s.agruletype.AGRuleResponse == nil {
    if v, ok:= StringPointer(""); ok {
      s.agruletype.AGRuleResponse = ((*String)(v))
      }
      }
      return s.agruletype.AGRuleResponse
    }
// Returns whether the element value for AGRuleResponse is nil in the container AGRuleType.
  func (s *AGRuleType) AGRuleResponse_IsNil() bool {
    return s.agruletype.AGRuleResponse == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AGRuleType) AGRuleStatus() *String {
    if s.agruletype.AGRuleStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.agruletype.AGRuleStatus = ((*String)(v))
      }
      }
      return s.agruletype.AGRuleStatus
    }
// Returns whether the element value for AGRuleStatus is nil in the container AGRuleType.
  func (s *AGRuleType) AGRuleStatus_IsNil() bool {
    return s.agruletype.AGRuleStatus == nil
    }

// Set the value of a property to nil
func (n *AbstractContentElementType) Unset(key string) *AbstractContentElementType {
        switch key {
  case "BinaryData":
   n.abstractcontentelementtype.BinaryData = nil
  case "RefId":
   n.abstractcontentelementtype.RefId = nil
  case "Reference":
   n.abstractcontentelementtype.Reference = nil
  case "TextData":
   n.abstractcontentelementtype.TextData = nil
  case "XMLData":
   n.abstractcontentelementtype.XMLData = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AbstractContentElementType")
        }
        return n
}

// Set a sequence of properties
func (n *AbstractContentElementType) SetProperties(props ...Prop) *AbstractContentElementType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AbstractContentElementType) SetProperty(key string, value interface{}) *AbstractContentElementType {
        if n == nil {
                n, _ = AbstractContentElementTypePointer(AbstractContentElementType{})
        }
        switch key {
    case "BinaryData":
    if v, ok:= BinaryDataTypePointer(value); ok {
      n.abstractcontentelementtype.BinaryData = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.abstractcontentelementtype.RefId = ((*RefIdType)(v))
      }
    case "Reference":
    if v, ok:= ReferenceDataTypePointer(value); ok {
      n.abstractcontentelementtype.Reference = v
      }
    case "TextData":
    if v, ok:= TextDataTypePointer(value); ok {
      n.abstractcontentelementtype.TextData = v
      }
    case "XMLData":
    if v, ok:= XMLDataTypePointer(value); ok {
      n.abstractcontentelementtype.XMLData = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AbstractContentElementType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AbstractContentElementType) BinaryData() *BinaryDataType {
    if s.abstractcontentelementtype.BinaryData == nil {
     if v, ok:= BinaryDataTypePointer(BinaryDataType{}); ok {
      s.abstractcontentelementtype.BinaryData = v
      }
      }
      return s.abstractcontentelementtype.BinaryData
    }
// Returns whether the element value for BinaryData is nil in the container AbstractContentElementType.
  func (s *AbstractContentElementType) BinaryData_IsNil() bool {
    return s.abstractcontentelementtype.BinaryData == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AbstractContentElementType) RefId() *RefIdType {
    if s.abstractcontentelementtype.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.abstractcontentelementtype.RefId = ((*RefIdType)(v))
      }
      }
      return s.abstractcontentelementtype.RefId
    }
// Returns whether the element value for RefId is nil in the container AbstractContentElementType.
  func (s *AbstractContentElementType) RefId_IsNil() bool {
    return s.abstractcontentelementtype.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AbstractContentElementType) Reference() *ReferenceDataType {
    if s.abstractcontentelementtype.Reference == nil {
     if v, ok:= ReferenceDataTypePointer(ReferenceDataType{}); ok {
      s.abstractcontentelementtype.Reference = v
      }
      }
      return s.abstractcontentelementtype.Reference
    }
// Returns whether the element value for Reference is nil in the container AbstractContentElementType.
  func (s *AbstractContentElementType) Reference_IsNil() bool {
    return s.abstractcontentelementtype.Reference == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AbstractContentElementType) TextData() *TextDataType {
    if s.abstractcontentelementtype.TextData == nil {
     if v, ok:= TextDataTypePointer(TextDataType{}); ok {
      s.abstractcontentelementtype.TextData = v
      }
      }
      return s.abstractcontentelementtype.TextData
    }
// Returns whether the element value for TextData is nil in the container AbstractContentElementType.
  func (s *AbstractContentElementType) TextData_IsNil() bool {
    return s.abstractcontentelementtype.TextData == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AbstractContentElementType) XMLData() *XMLDataType {
    if s.abstractcontentelementtype.XMLData == nil {
     if v, ok:= XMLDataTypePointer(XMLDataType{}); ok {
      s.abstractcontentelementtype.XMLData = v
      }
      }
      return s.abstractcontentelementtype.XMLData
    }
// Returns whether the element value for XMLData is nil in the container AbstractContentElementType.
  func (s *AbstractContentElementType) XMLData_IsNil() bool {
    return s.abstractcontentelementtype.XMLData == nil
    }

// Set the value of a property to nil
func (n *Activity) Unset(key string) *Activity {
        switch key {
  case "ActivityTime":
   n.activity.ActivityTime = nil
  case "ActivityWeight":
   n.activity.ActivityWeight = nil
  case "AssessmentRefId":
   n.activity.AssessmentRefId = nil
  case "EssentialMaterials":
   n.activity.EssentialMaterials = nil
  case "Evaluation":
   n.activity.Evaluation = nil
  case "LearningObjectives":
   n.activity.LearningObjectives = nil
  case "LearningResources":
   n.activity.LearningResources = nil
  case "LearningStandards":
   n.activity.LearningStandards = nil
  case "LocalCodeList":
   n.activity.LocalCodeList = nil
  case "MaxAttemptsAllowed":
   n.activity.MaxAttemptsAllowed = nil
  case "Points":
   n.activity.Points = nil
  case "Preamble":
   n.activity.Preamble = nil
  case "Prerequisites":
   n.activity.Prerequisites = nil
  case "RefId":
   n.activity.RefId = nil
  case "SIF_ExtendedElements":
   n.activity.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.activity.SIF_Metadata = nil
  case "SoftwareRequirementList":
   n.activity.SoftwareRequirementList = nil
  case "SourceObjects":
   n.activity.SourceObjects = nil
  case "Students":
   n.activity.Students = nil
  case "SubjectArea":
   n.activity.SubjectArea = nil
  case "TechnicalRequirements":
   n.activity.TechnicalRequirements = nil
  case "Title":
   n.activity.Title = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Activity")
        }
        return n
}

// Set a sequence of properties
func (n *Activity) SetProperties(props ...Prop) *Activity {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *Activity) SetProperty(key string, value interface{}) *Activity {
        if n == nil {
                n, _ = ActivityPointer(Activity{})
        }
        switch key {
    case "ActivityTime":
    if v, ok:= ActivityTimeTypePointer(value); ok {
      n.activity.ActivityTime = v
      }
    case "ActivityWeight":
    
    if v, ok:= FloatPointer(value); ok {
      n.activity.ActivityWeight = ((*Float)(v))
      }
    case "AssessmentRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activity.AssessmentRefId = ((*String)(v))
      }
    case "EssentialMaterials":
    if v, ok:= EssentialMaterialsTypePointer(value); ok {
      n.activity.EssentialMaterials = v
      }
    case "Evaluation":
    if v, ok:= ActivityEvaluationTypePointer(value); ok {
      n.activity.Evaluation = v
      }
    case "LearningObjectives":
    if v, ok:= LearningObjectivesTypePointer(value); ok {
      n.activity.LearningObjectives = v
      }
    case "LearningResources":
    if v, ok:= LearningResourcesTypePointer(value); ok {
      n.activity.LearningResources = v
      }
    case "LearningStandards":
    if v, ok:= LearningStandardsTypePointer(value); ok {
      n.activity.LearningStandards = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.activity.LocalCodeList = v
      }
    case "MaxAttemptsAllowed":
    
    if v, ok:= IntPointer(value); ok {
      n.activity.MaxAttemptsAllowed = ((*Int)(v))
      }
    case "Points":
    
    if v, ok:= IntPointer(value); ok {
      n.activity.Points = ((*Int)(v))
      }
    case "Preamble":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activity.Preamble = ((*String)(v))
      }
    case "Prerequisites":
    if v, ok:= PrerequisitesTypePointer(value); ok {
      n.activity.Prerequisites = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activity.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.activity.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.activity.SIF_Metadata = v
      }
    case "SoftwareRequirementList":
    if v, ok:= SoftwareRequirementListTypePointer(value); ok {
      n.activity.SoftwareRequirementList = v
      }
    case "SourceObjects":
    if v, ok:= SourceObjectsTypePointer(value); ok {
      n.activity.SourceObjects = v
      }
    case "Students":
    if v, ok:= StudentsTypePointer(value); ok {
      n.activity.Students = v
      }
    case "SubjectArea":
    if v, ok:= SubjectAreaTypePointer(value); ok {
      n.activity.SubjectArea = v
      }
    case "TechnicalRequirements":
    if v, ok:= TechnicalRequirementsTypePointer(value); ok {
      n.activity.TechnicalRequirements = v
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activity.Title = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Activity")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) ActivityTime() *ActivityTimeType {
    if s.activity.ActivityTime == nil {
     if v, ok:= ActivityTimeTypePointer(ActivityTimeType{}); ok {
      s.activity.ActivityTime = v
      }
      }
      return s.activity.ActivityTime
    }
// Returns whether the element value for ActivityTime is nil in the container Activity.
  func (s *Activity) ActivityTime_IsNil() bool {
    return s.activity.ActivityTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) ActivityWeight() *Float {
    if s.activity.ActivityWeight == nil {
    if v, ok:= FloatPointer(0); ok {
      s.activity.ActivityWeight = ((*Float)(v))
      }
      }
      return s.activity.ActivityWeight
    }
// Returns whether the element value for ActivityWeight is nil in the container Activity.
  func (s *Activity) ActivityWeight_IsNil() bool {
    return s.activity.ActivityWeight == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) AssessmentRefId() *String {
    if s.activity.AssessmentRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.activity.AssessmentRefId = ((*String)(v))
      }
      }
      return s.activity.AssessmentRefId
    }
// Returns whether the element value for AssessmentRefId is nil in the container Activity.
  func (s *Activity) AssessmentRefId_IsNil() bool {
    return s.activity.AssessmentRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) EssentialMaterials() *EssentialMaterialsType {
    if s.activity.EssentialMaterials == nil {
     if v, ok:= EssentialMaterialsTypePointer(EssentialMaterialsType{}); ok {
      s.activity.EssentialMaterials = v
      }
      }
      return s.activity.EssentialMaterials
    }
// Returns whether the element value for EssentialMaterials is nil in the container Activity.
  func (s *Activity) EssentialMaterials_IsNil() bool {
    return s.activity.EssentialMaterials == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) Evaluation() *ActivityEvaluationType {
    if s.activity.Evaluation == nil {
     if v, ok:= ActivityEvaluationTypePointer(ActivityEvaluationType{}); ok {
      s.activity.Evaluation = v
      }
      }
      return s.activity.Evaluation
    }
// Returns whether the element value for Evaluation is nil in the container Activity.
  func (s *Activity) Evaluation_IsNil() bool {
    return s.activity.Evaluation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) LearningObjectives() *LearningObjectivesType {
    if s.activity.LearningObjectives == nil {
     if v, ok:= LearningObjectivesTypePointer(LearningObjectivesType{}); ok {
      s.activity.LearningObjectives = v
      }
      }
      return s.activity.LearningObjectives
    }
// Returns whether the element value for LearningObjectives is nil in the container Activity.
  func (s *Activity) LearningObjectives_IsNil() bool {
    return s.activity.LearningObjectives == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) LearningResources() *LearningResourcesType {
    if s.activity.LearningResources == nil {
     if v, ok:= LearningResourcesTypePointer(LearningResourcesType{}); ok {
      s.activity.LearningResources = v
      }
      }
      return s.activity.LearningResources
    }
// Returns whether the element value for LearningResources is nil in the container Activity.
  func (s *Activity) LearningResources_IsNil() bool {
    return s.activity.LearningResources == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) LearningStandards() *LearningStandardsType {
    if s.activity.LearningStandards == nil {
     if v, ok:= LearningStandardsTypePointer(LearningStandardsType{}); ok {
      s.activity.LearningStandards = v
      }
      }
      return s.activity.LearningStandards
    }
// Returns whether the element value for LearningStandards is nil in the container Activity.
  func (s *Activity) LearningStandards_IsNil() bool {
    return s.activity.LearningStandards == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) LocalCodeList() *LocalCodeListType {
    if s.activity.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.activity.LocalCodeList = v
      }
      }
      return s.activity.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container Activity.
  func (s *Activity) LocalCodeList_IsNil() bool {
    return s.activity.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) MaxAttemptsAllowed() *Int {
    if s.activity.MaxAttemptsAllowed == nil {
    if v, ok:= IntPointer(0); ok {
      s.activity.MaxAttemptsAllowed = ((*Int)(v))
      }
      }
      return s.activity.MaxAttemptsAllowed
    }
// Returns whether the element value for MaxAttemptsAllowed is nil in the container Activity.
  func (s *Activity) MaxAttemptsAllowed_IsNil() bool {
    return s.activity.MaxAttemptsAllowed == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) Points() *Int {
    if s.activity.Points == nil {
    if v, ok:= IntPointer(0); ok {
      s.activity.Points = ((*Int)(v))
      }
      }
      return s.activity.Points
    }
// Returns whether the element value for Points is nil in the container Activity.
  func (s *Activity) Points_IsNil() bool {
    return s.activity.Points == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) Preamble() *String {
    if s.activity.Preamble == nil {
    if v, ok:= StringPointer(""); ok {
      s.activity.Preamble = ((*String)(v))
      }
      }
      return s.activity.Preamble
    }
// Returns whether the element value for Preamble is nil in the container Activity.
  func (s *Activity) Preamble_IsNil() bool {
    return s.activity.Preamble == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) Prerequisites() *PrerequisitesType {
    if s.activity.Prerequisites == nil {
     if v, ok:= PrerequisitesTypePointer(PrerequisitesType{}); ok {
      s.activity.Prerequisites = v
      }
      }
      return s.activity.Prerequisites
    }
// Returns whether the element value for Prerequisites is nil in the container Activity.
  func (s *Activity) Prerequisites_IsNil() bool {
    return s.activity.Prerequisites == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) RefId() *RefIdType {
    if s.activity.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.activity.RefId = ((*RefIdType)(v))
      }
      }
      return s.activity.RefId
    }
// Returns whether the element value for RefId is nil in the container Activity.
  func (s *Activity) RefId_IsNil() bool {
    return s.activity.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.activity.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.activity.SIF_ExtendedElements = v
      }
      }
      return s.activity.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container Activity.
  func (s *Activity) SIF_ExtendedElements_IsNil() bool {
    return s.activity.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) SIF_Metadata() *SIF_MetadataType {
    if s.activity.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.activity.SIF_Metadata = v
      }
      }
      return s.activity.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container Activity.
  func (s *Activity) SIF_Metadata_IsNil() bool {
    return s.activity.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) SoftwareRequirementList() *SoftwareRequirementListType {
    if s.activity.SoftwareRequirementList == nil {
     if v, ok:= SoftwareRequirementListTypePointer(SoftwareRequirementListType{}); ok {
      s.activity.SoftwareRequirementList = v
      }
      }
      return s.activity.SoftwareRequirementList
    }
// Returns whether the element value for SoftwareRequirementList is nil in the container Activity.
  func (s *Activity) SoftwareRequirementList_IsNil() bool {
    return s.activity.SoftwareRequirementList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) SourceObjects() *SourceObjectsType {
    if s.activity.SourceObjects == nil {
     if v, ok:= SourceObjectsTypePointer(SourceObjectsType{}); ok {
      s.activity.SourceObjects = v
      }
      }
      return s.activity.SourceObjects
    }
// Returns whether the element value for SourceObjects is nil in the container Activity.
  func (s *Activity) SourceObjects_IsNil() bool {
    return s.activity.SourceObjects == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) Students() *StudentsType {
    if s.activity.Students == nil {
     if v, ok:= StudentsTypePointer(StudentsType{}); ok {
      s.activity.Students = v
      }
      }
      return s.activity.Students
    }
// Returns whether the element value for Students is nil in the container Activity.
  func (s *Activity) Students_IsNil() bool {
    return s.activity.Students == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) SubjectArea() *SubjectAreaType {
    if s.activity.SubjectArea == nil {
     if v, ok:= SubjectAreaTypePointer(SubjectAreaType{}); ok {
      s.activity.SubjectArea = v
      }
      }
      return s.activity.SubjectArea
    }
// Returns whether the element value for SubjectArea is nil in the container Activity.
  func (s *Activity) SubjectArea_IsNil() bool {
    return s.activity.SubjectArea == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) TechnicalRequirements() *TechnicalRequirementsType {
    if s.activity.TechnicalRequirements == nil {
     if v, ok:= TechnicalRequirementsTypePointer(TechnicalRequirementsType{}); ok {
      s.activity.TechnicalRequirements = v
      }
      }
      return s.activity.TechnicalRequirements
    }
// Returns whether the element value for TechnicalRequirements is nil in the container Activity.
  func (s *Activity) TechnicalRequirements_IsNil() bool {
    return s.activity.TechnicalRequirements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Activity) Title() *String {
    if s.activity.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.activity.Title = ((*String)(v))
      }
      }
      return s.activity.Title
    }
// Returns whether the element value for Title is nil in the container Activity.
  func (s *Activity) Title_IsNil() bool {
    return s.activity.Title == nil
    }

// Set the value of a property to nil
func (n *ActivityEvaluationType) Unset(key string) *ActivityEvaluationType {
        switch key {
  case "Description":
   n.activityevaluationtype.Description = nil
  case "EvaluationType":
   n.activityevaluationtype.EvaluationType = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ActivityEvaluationType")
        }
        return n
}

// Set a sequence of properties
func (n *ActivityEvaluationType) SetProperties(props ...Prop) *ActivityEvaluationType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ActivityEvaluationType) SetProperty(key string, value interface{}) *ActivityEvaluationType {
        if n == nil {
                n, _ = ActivityEvaluationTypePointer(ActivityEvaluationType{})
        }
        switch key {
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activityevaluationtype.Description = ((*String)(v))
      }
    case "EvaluationType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activityevaluationtype.EvaluationType = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ActivityEvaluationType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ActivityEvaluationType) Description() *String {
    if s.activityevaluationtype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.activityevaluationtype.Description = ((*String)(v))
      }
      }
      return s.activityevaluationtype.Description
    }
// Returns whether the element value for Description is nil in the container ActivityEvaluationType.
  func (s *ActivityEvaluationType) Description_IsNil() bool {
    return s.activityevaluationtype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ActivityEvaluationType) EvaluationType() *String {
    if s.activityevaluationtype.EvaluationType == nil {
    if v, ok:= StringPointer(""); ok {
      s.activityevaluationtype.EvaluationType = ((*String)(v))
      }
      }
      return s.activityevaluationtype.EvaluationType
    }
// Returns whether the element value for EvaluationType is nil in the container ActivityEvaluationType.
  func (s *ActivityEvaluationType) EvaluationType_IsNil() bool {
    return s.activityevaluationtype.EvaluationType == nil
    }

// Set the value of a property to nil
func (n *ActivityTimeType) Unset(key string) *ActivityTimeType {
        switch key {
  case "CreationDate":
   n.activitytimetype.CreationDate = nil
  case "DueDate":
   n.activitytimetype.DueDate = nil
  case "Duration":
   n.activitytimetype.Duration = nil
  case "FinishDate":
   n.activitytimetype.FinishDate = nil
  case "StartDate":
   n.activitytimetype.StartDate = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ActivityTimeType")
        }
        return n
}

// Set a sequence of properties
func (n *ActivityTimeType) SetProperties(props ...Prop) *ActivityTimeType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ActivityTimeType) SetProperty(key string, value interface{}) *ActivityTimeType {
        if n == nil {
                n, _ = ActivityTimeTypePointer(ActivityTimeType{})
        }
        switch key {
    case "CreationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activitytimetype.CreationDate = ((*String)(v))
      }
    case "DueDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activitytimetype.DueDate = ((*String)(v))
      }
    case "Duration":
    if v, ok:= DurationTypePointer(value); ok {
      n.activitytimetype.Duration = v
      }
    case "FinishDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activitytimetype.FinishDate = ((*String)(v))
      }
    case "StartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.activitytimetype.StartDate = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ActivityTimeType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ActivityTimeType) CreationDate() *String {
    if s.activitytimetype.CreationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.activitytimetype.CreationDate = ((*String)(v))
      }
      }
      return s.activitytimetype.CreationDate
    }
// Returns whether the element value for CreationDate is nil in the container ActivityTimeType.
  func (s *ActivityTimeType) CreationDate_IsNil() bool {
    return s.activitytimetype.CreationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ActivityTimeType) DueDate() *String {
    if s.activitytimetype.DueDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.activitytimetype.DueDate = ((*String)(v))
      }
      }
      return s.activitytimetype.DueDate
    }
// Returns whether the element value for DueDate is nil in the container ActivityTimeType.
  func (s *ActivityTimeType) DueDate_IsNil() bool {
    return s.activitytimetype.DueDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ActivityTimeType) Duration() *DurationType {
    if s.activitytimetype.Duration == nil {
     if v, ok:= DurationTypePointer(DurationType{}); ok {
      s.activitytimetype.Duration = v
      }
      }
      return s.activitytimetype.Duration
    }
// Returns whether the element value for Duration is nil in the container ActivityTimeType.
  func (s *ActivityTimeType) Duration_IsNil() bool {
    return s.activitytimetype.Duration == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ActivityTimeType) FinishDate() *String {
    if s.activitytimetype.FinishDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.activitytimetype.FinishDate = ((*String)(v))
      }
      }
      return s.activitytimetype.FinishDate
    }
// Returns whether the element value for FinishDate is nil in the container ActivityTimeType.
  func (s *ActivityTimeType) FinishDate_IsNil() bool {
    return s.activitytimetype.FinishDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ActivityTimeType) StartDate() *String {
    if s.activitytimetype.StartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.activitytimetype.StartDate = ((*String)(v))
      }
      }
      return s.activitytimetype.StartDate
    }
// Returns whether the element value for StartDate is nil in the container ActivityTimeType.
  func (s *ActivityTimeType) StartDate_IsNil() bool {
    return s.activitytimetype.StartDate == nil
    }

// Set the value of a property to nil
func (n *AddressCollection) Unset(key string) *AddressCollection {
        switch key {
  case "AddressCollectionReportingList":
   n.addresscollection.AddressCollectionReportingList = nil
  case "AddressCollectionYear":
   n.addresscollection.AddressCollectionYear = nil
  case "LocalCodeList":
   n.addresscollection.LocalCodeList = nil
  case "RefId":
   n.addresscollection.RefId = nil
  case "RoundCode":
   n.addresscollection.RoundCode = nil
  case "SIF_ExtendedElements":
   n.addresscollection.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.addresscollection.SIF_Metadata = nil
  case "SoftwareVendorInfo":
   n.addresscollection.SoftwareVendorInfo = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressCollection")
        }
        return n
}

// Set a sequence of properties
func (n *AddressCollection) SetProperties(props ...Prop) *AddressCollection {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AddressCollection) SetProperty(key string, value interface{}) *AddressCollection {
        if n == nil {
                n, _ = AddressCollectionPointer(AddressCollection{})
        }
        switch key {
    case "AddressCollectionReportingList":
    if v, ok:= AddressCollectionReportingListTypePointer(value); ok {
      n.addresscollection.AddressCollectionReportingList = v
      }
    case "AddressCollectionYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresscollection.AddressCollectionYear = ((*SchoolYearType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.addresscollection.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresscollection.RefId = ((*RefIdType)(v))
      }
    case "RoundCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresscollection.RoundCode = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.addresscollection.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.addresscollection.SIF_Metadata = v
      }
    case "SoftwareVendorInfo":
    if v, ok:= SoftwareVendorInfoContainerTypePointer(value); ok {
      n.addresscollection.SoftwareVendorInfo = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressCollection")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollection) AddressCollectionReportingList() *AddressCollectionReportingListType {
    if s.addresscollection.AddressCollectionReportingList == nil {
     if v, ok:= AddressCollectionReportingListTypePointer(AddressCollectionReportingListType{}); ok {
      s.addresscollection.AddressCollectionReportingList = v
      }
      }
      return s.addresscollection.AddressCollectionReportingList
    }
// Returns whether the element value for AddressCollectionReportingList is nil in the container AddressCollection.
  func (s *AddressCollection) AddressCollectionReportingList_IsNil() bool {
    return s.addresscollection.AddressCollectionReportingList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollection) AddressCollectionYear() *SchoolYearType {
    if s.addresscollection.AddressCollectionYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresscollection.AddressCollectionYear = ((*SchoolYearType)(v))
      }
      }
      return s.addresscollection.AddressCollectionYear
    }
// Returns whether the element value for AddressCollectionYear is nil in the container AddressCollection.
  func (s *AddressCollection) AddressCollectionYear_IsNil() bool {
    return s.addresscollection.AddressCollectionYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollection) LocalCodeList() *LocalCodeListType {
    if s.addresscollection.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.addresscollection.LocalCodeList = v
      }
      }
      return s.addresscollection.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container AddressCollection.
  func (s *AddressCollection) LocalCodeList_IsNil() bool {
    return s.addresscollection.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollection) RefId() *RefIdType {
    if s.addresscollection.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresscollection.RefId = ((*RefIdType)(v))
      }
      }
      return s.addresscollection.RefId
    }
// Returns whether the element value for RefId is nil in the container AddressCollection.
  func (s *AddressCollection) RefId_IsNil() bool {
    return s.addresscollection.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollection) RoundCode() *String {
    if s.addresscollection.RoundCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresscollection.RoundCode = ((*String)(v))
      }
      }
      return s.addresscollection.RoundCode
    }
// Returns whether the element value for RoundCode is nil in the container AddressCollection.
  func (s *AddressCollection) RoundCode_IsNil() bool {
    return s.addresscollection.RoundCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollection) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.addresscollection.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.addresscollection.SIF_ExtendedElements = v
      }
      }
      return s.addresscollection.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container AddressCollection.
  func (s *AddressCollection) SIF_ExtendedElements_IsNil() bool {
    return s.addresscollection.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollection) SIF_Metadata() *SIF_MetadataType {
    if s.addresscollection.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.addresscollection.SIF_Metadata = v
      }
      }
      return s.addresscollection.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container AddressCollection.
  func (s *AddressCollection) SIF_Metadata_IsNil() bool {
    return s.addresscollection.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollection) SoftwareVendorInfo() *SoftwareVendorInfoContainerType {
    if s.addresscollection.SoftwareVendorInfo == nil {
     if v, ok:= SoftwareVendorInfoContainerTypePointer(SoftwareVendorInfoContainerType{}); ok {
      s.addresscollection.SoftwareVendorInfo = v
      }
      }
      return s.addresscollection.SoftwareVendorInfo
    }
// Returns whether the element value for SoftwareVendorInfo is nil in the container AddressCollection.
  func (s *AddressCollection) SoftwareVendorInfo_IsNil() bool {
    return s.addresscollection.SoftwareVendorInfo == nil
    }

// Set the value of a property to nil
func (n *AddressCollectionReportingType) Unset(key string) *AddressCollectionReportingType {
        switch key {
  case "AGContextualQuestionList":
   n.addresscollectionreportingtype.AGContextualQuestionList = nil
  case "AddressCollectionStudentList":
   n.addresscollectionreportingtype.AddressCollectionStudentList = nil
  case "CommonwealthId":
   n.addresscollectionreportingtype.CommonwealthId = nil
  case "EntityContact":
   n.addresscollectionreportingtype.EntityContact = nil
  case "EntityName":
   n.addresscollectionreportingtype.EntityName = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressCollectionReportingType")
        }
        return n
}

// Set a sequence of properties
func (n *AddressCollectionReportingType) SetProperties(props ...Prop) *AddressCollectionReportingType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AddressCollectionReportingType) SetProperty(key string, value interface{}) *AddressCollectionReportingType {
        if n == nil {
                n, _ = AddressCollectionReportingTypePointer(AddressCollectionReportingType{})
        }
        switch key {
    case "AGContextualQuestionList":
    if v, ok:= AGContextualQuestionListTypePointer(value); ok {
      n.addresscollectionreportingtype.AGContextualQuestionList = v
      }
    case "AddressCollectionStudentList":
    if v, ok:= AddressCollectionStudentListTypePointer(value); ok {
      n.addresscollectionreportingtype.AddressCollectionStudentList = v
      }
    case "CommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresscollectionreportingtype.CommonwealthId = ((*String)(v))
      }
    case "EntityContact":
    if v, ok:= EntityContactInfoTypePointer(value); ok {
      n.addresscollectionreportingtype.EntityContact = v
      }
    case "EntityName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresscollectionreportingtype.EntityName = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressCollectionReportingType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionReportingType) AGContextualQuestionList() *AGContextualQuestionListType {
    if s.addresscollectionreportingtype.AGContextualQuestionList == nil {
     if v, ok:= AGContextualQuestionListTypePointer(AGContextualQuestionListType{}); ok {
      s.addresscollectionreportingtype.AGContextualQuestionList = v
      }
      }
      return s.addresscollectionreportingtype.AGContextualQuestionList
    }
// Returns whether the element value for AGContextualQuestionList is nil in the container AddressCollectionReportingType.
  func (s *AddressCollectionReportingType) AGContextualQuestionList_IsNil() bool {
    return s.addresscollectionreportingtype.AGContextualQuestionList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionReportingType) AddressCollectionStudentList() *AddressCollectionStudentListType {
    if s.addresscollectionreportingtype.AddressCollectionStudentList == nil {
     if v, ok:= AddressCollectionStudentListTypePointer(AddressCollectionStudentListType{}); ok {
      s.addresscollectionreportingtype.AddressCollectionStudentList = v
      }
      }
      return s.addresscollectionreportingtype.AddressCollectionStudentList
    }
// Returns whether the element value for AddressCollectionStudentList is nil in the container AddressCollectionReportingType.
  func (s *AddressCollectionReportingType) AddressCollectionStudentList_IsNil() bool {
    return s.addresscollectionreportingtype.AddressCollectionStudentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionReportingType) CommonwealthId() *String {
    if s.addresscollectionreportingtype.CommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresscollectionreportingtype.CommonwealthId = ((*String)(v))
      }
      }
      return s.addresscollectionreportingtype.CommonwealthId
    }
// Returns whether the element value for CommonwealthId is nil in the container AddressCollectionReportingType.
  func (s *AddressCollectionReportingType) CommonwealthId_IsNil() bool {
    return s.addresscollectionreportingtype.CommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionReportingType) EntityContact() *EntityContactInfoType {
    if s.addresscollectionreportingtype.EntityContact == nil {
     if v, ok:= EntityContactInfoTypePointer(EntityContactInfoType{}); ok {
      s.addresscollectionreportingtype.EntityContact = v
      }
      }
      return s.addresscollectionreportingtype.EntityContact
    }
// Returns whether the element value for EntityContact is nil in the container AddressCollectionReportingType.
  func (s *AddressCollectionReportingType) EntityContact_IsNil() bool {
    return s.addresscollectionreportingtype.EntityContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionReportingType) EntityName() *String {
    if s.addresscollectionreportingtype.EntityName == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresscollectionreportingtype.EntityName = ((*String)(v))
      }
      }
      return s.addresscollectionreportingtype.EntityName
    }
// Returns whether the element value for EntityName is nil in the container AddressCollectionReportingType.
  func (s *AddressCollectionReportingType) EntityName_IsNil() bool {
    return s.addresscollectionreportingtype.EntityName == nil
    }

// Set the value of a property to nil
func (n *AddressCollectionStudentType) Unset(key string) *AddressCollectionStudentType {
        switch key {
  case "BoardingStatus":
   n.addresscollectionstudenttype.BoardingStatus = nil
  case "EducationLevel":
   n.addresscollectionstudenttype.EducationLevel = nil
  case "LocalId":
   n.addresscollectionstudenttype.LocalId = nil
  case "Parent1":
   n.addresscollectionstudenttype.Parent1 = nil
  case "Parent2":
   n.addresscollectionstudenttype.Parent2 = nil
  case "ReportingParent2":
   n.addresscollectionstudenttype.ReportingParent2 = nil
  case "StudentAddress":
   n.addresscollectionstudenttype.StudentAddress = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressCollectionStudentType")
        }
        return n
}

// Set a sequence of properties
func (n *AddressCollectionStudentType) SetProperties(props ...Prop) *AddressCollectionStudentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AddressCollectionStudentType) SetProperty(key string, value interface{}) *AddressCollectionStudentType {
        if n == nil {
                n, _ = AddressCollectionStudentTypePointer(AddressCollectionStudentType{})
        }
        switch key {
    case "BoardingStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsBoardingType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsBoardingType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.addresscollectionstudenttype.BoardingStatus = ((*AUCodeSetsBoardingType)(v))
      }
    case "EducationLevel":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEducationLevelType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEducationLevelType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.addresscollectionstudenttype.EducationLevel = ((*AUCodeSetsEducationLevelType)(v))
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresscollectionstudenttype.LocalId = ((*LocalIdType)(v))
      }
    case "Parent1":
    if v, ok:= AGParentTypePointer(value); ok {
      n.addresscollectionstudenttype.Parent1 = v
      }
    case "Parent2":
    if v, ok:= AGParentTypePointer(value); ok {
      n.addresscollectionstudenttype.Parent2 = v
      }
    case "ReportingParent2":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresscollectionstudenttype.ReportingParent2 = ((*String)(v))
      }
    case "StudentAddress":
    if v, ok:= AddressTypePointer(value); ok {
      n.addresscollectionstudenttype.StudentAddress = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressCollectionStudentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionStudentType) BoardingStatus() *AUCodeSetsBoardingType {
    if s.addresscollectionstudenttype.BoardingStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresscollectionstudenttype.BoardingStatus = ((*AUCodeSetsBoardingType)(v))
      }
      }
      return s.addresscollectionstudenttype.BoardingStatus
    }
// Returns whether the element value for BoardingStatus is nil in the container AddressCollectionStudentType.
  func (s *AddressCollectionStudentType) BoardingStatus_IsNil() bool {
    return s.addresscollectionstudenttype.BoardingStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionStudentType) EducationLevel() *AUCodeSetsEducationLevelType {
    if s.addresscollectionstudenttype.EducationLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresscollectionstudenttype.EducationLevel = ((*AUCodeSetsEducationLevelType)(v))
      }
      }
      return s.addresscollectionstudenttype.EducationLevel
    }
// Returns whether the element value for EducationLevel is nil in the container AddressCollectionStudentType.
  func (s *AddressCollectionStudentType) EducationLevel_IsNil() bool {
    return s.addresscollectionstudenttype.EducationLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionStudentType) LocalId() *LocalIdType {
    if s.addresscollectionstudenttype.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresscollectionstudenttype.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.addresscollectionstudenttype.LocalId
    }
// Returns whether the element value for LocalId is nil in the container AddressCollectionStudentType.
  func (s *AddressCollectionStudentType) LocalId_IsNil() bool {
    return s.addresscollectionstudenttype.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionStudentType) Parent1() *AGParentType {
    if s.addresscollectionstudenttype.Parent1 == nil {
     if v, ok:= AGParentTypePointer(AGParentType{}); ok {
      s.addresscollectionstudenttype.Parent1 = v
      }
      }
      return s.addresscollectionstudenttype.Parent1
    }
// Returns whether the element value for Parent1 is nil in the container AddressCollectionStudentType.
  func (s *AddressCollectionStudentType) Parent1_IsNil() bool {
    return s.addresscollectionstudenttype.Parent1 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionStudentType) Parent2() *AGParentType {
    if s.addresscollectionstudenttype.Parent2 == nil {
     if v, ok:= AGParentTypePointer(AGParentType{}); ok {
      s.addresscollectionstudenttype.Parent2 = v
      }
      }
      return s.addresscollectionstudenttype.Parent2
    }
// Returns whether the element value for Parent2 is nil in the container AddressCollectionStudentType.
  func (s *AddressCollectionStudentType) Parent2_IsNil() bool {
    return s.addresscollectionstudenttype.Parent2 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionStudentType) ReportingParent2() *String {
    if s.addresscollectionstudenttype.ReportingParent2 == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresscollectionstudenttype.ReportingParent2 = ((*String)(v))
      }
      }
      return s.addresscollectionstudenttype.ReportingParent2
    }
// Returns whether the element value for ReportingParent2 is nil in the container AddressCollectionStudentType.
  func (s *AddressCollectionStudentType) ReportingParent2_IsNil() bool {
    return s.addresscollectionstudenttype.ReportingParent2 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressCollectionStudentType) StudentAddress() *AddressType {
    if s.addresscollectionstudenttype.StudentAddress == nil {
     if v, ok:= AddressTypePointer(AddressType{}); ok {
      s.addresscollectionstudenttype.StudentAddress = v
      }
      }
      return s.addresscollectionstudenttype.StudentAddress
    }
// Returns whether the element value for StudentAddress is nil in the container AddressCollectionStudentType.
  func (s *AddressCollectionStudentType) StudentAddress_IsNil() bool {
    return s.addresscollectionstudenttype.StudentAddress == nil
    }

// Set the value of a property to nil
func (n *AddressStreetType) Unset(key string) *AddressStreetType {
        switch key {
  case "ApartmentNumber":
   n.addressstreettype.ApartmentNumber = nil
  case "ApartmentNumberPrefix":
   n.addressstreettype.ApartmentNumberPrefix = nil
  case "ApartmentNumberSuffix":
   n.addressstreettype.ApartmentNumberSuffix = nil
  case "ApartmentType":
   n.addressstreettype.ApartmentType = nil
  case "Complex":
   n.addressstreettype.Complex = nil
  case "Line1":
   n.addressstreettype.Line1 = nil
  case "Line2":
   n.addressstreettype.Line2 = nil
  case "Line3":
   n.addressstreettype.Line3 = nil
  case "StreetName":
   n.addressstreettype.StreetName = nil
  case "StreetNumber":
   n.addressstreettype.StreetNumber = nil
  case "StreetPrefix":
   n.addressstreettype.StreetPrefix = nil
  case "StreetSuffix":
   n.addressstreettype.StreetSuffix = nil
  case "StreetType":
   n.addressstreettype.StreetType = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressStreetType")
        }
        return n
}

// Set a sequence of properties
func (n *AddressStreetType) SetProperties(props ...Prop) *AddressStreetType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AddressStreetType) SetProperty(key string, value interface{}) *AddressStreetType {
        if n == nil {
                n, _ = AddressStreetTypePointer(AddressStreetType{})
        }
        switch key {
    case "ApartmentNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.ApartmentNumber = ((*String)(v))
      }
    case "ApartmentNumberPrefix":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.ApartmentNumberPrefix = ((*String)(v))
      }
    case "ApartmentNumberSuffix":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.ApartmentNumberSuffix = ((*String)(v))
      }
    case "ApartmentType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.ApartmentType = ((*String)(v))
      }
    case "Complex":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.Complex = ((*String)(v))
      }
    case "Line1":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.Line1 = ((*String)(v))
      }
    case "Line2":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.Line2 = ((*String)(v))
      }
    case "Line3":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.Line3 = ((*String)(v))
      }
    case "StreetName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.StreetName = ((*String)(v))
      }
    case "StreetNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.StreetNumber = ((*String)(v))
      }
    case "StreetPrefix":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.StreetPrefix = ((*String)(v))
      }
    case "StreetSuffix":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.StreetSuffix = ((*String)(v))
      }
    case "StreetType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addressstreettype.StreetType = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressStreetType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) ApartmentNumber() *String {
    if s.addressstreettype.ApartmentNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.ApartmentNumber = ((*String)(v))
      }
      }
      return s.addressstreettype.ApartmentNumber
    }
// Returns whether the element value for ApartmentNumber is nil in the container AddressStreetType.
  func (s *AddressStreetType) ApartmentNumber_IsNil() bool {
    return s.addressstreettype.ApartmentNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) ApartmentNumberPrefix() *String {
    if s.addressstreettype.ApartmentNumberPrefix == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.ApartmentNumberPrefix = ((*String)(v))
      }
      }
      return s.addressstreettype.ApartmentNumberPrefix
    }
// Returns whether the element value for ApartmentNumberPrefix is nil in the container AddressStreetType.
  func (s *AddressStreetType) ApartmentNumberPrefix_IsNil() bool {
    return s.addressstreettype.ApartmentNumberPrefix == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) ApartmentNumberSuffix() *String {
    if s.addressstreettype.ApartmentNumberSuffix == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.ApartmentNumberSuffix = ((*String)(v))
      }
      }
      return s.addressstreettype.ApartmentNumberSuffix
    }
// Returns whether the element value for ApartmentNumberSuffix is nil in the container AddressStreetType.
  func (s *AddressStreetType) ApartmentNumberSuffix_IsNil() bool {
    return s.addressstreettype.ApartmentNumberSuffix == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) ApartmentType() *String {
    if s.addressstreettype.ApartmentType == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.ApartmentType = ((*String)(v))
      }
      }
      return s.addressstreettype.ApartmentType
    }
// Returns whether the element value for ApartmentType is nil in the container AddressStreetType.
  func (s *AddressStreetType) ApartmentType_IsNil() bool {
    return s.addressstreettype.ApartmentType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) Complex() *String {
    if s.addressstreettype.Complex == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.Complex = ((*String)(v))
      }
      }
      return s.addressstreettype.Complex
    }
// Returns whether the element value for Complex is nil in the container AddressStreetType.
  func (s *AddressStreetType) Complex_IsNil() bool {
    return s.addressstreettype.Complex == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) Line1() *String {
    if s.addressstreettype.Line1 == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.Line1 = ((*String)(v))
      }
      }
      return s.addressstreettype.Line1
    }
// Returns whether the element value for Line1 is nil in the container AddressStreetType.
  func (s *AddressStreetType) Line1_IsNil() bool {
    return s.addressstreettype.Line1 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) Line2() *String {
    if s.addressstreettype.Line2 == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.Line2 = ((*String)(v))
      }
      }
      return s.addressstreettype.Line2
    }
// Returns whether the element value for Line2 is nil in the container AddressStreetType.
  func (s *AddressStreetType) Line2_IsNil() bool {
    return s.addressstreettype.Line2 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) Line3() *String {
    if s.addressstreettype.Line3 == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.Line3 = ((*String)(v))
      }
      }
      return s.addressstreettype.Line3
    }
// Returns whether the element value for Line3 is nil in the container AddressStreetType.
  func (s *AddressStreetType) Line3_IsNil() bool {
    return s.addressstreettype.Line3 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) StreetName() *String {
    if s.addressstreettype.StreetName == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.StreetName = ((*String)(v))
      }
      }
      return s.addressstreettype.StreetName
    }
// Returns whether the element value for StreetName is nil in the container AddressStreetType.
  func (s *AddressStreetType) StreetName_IsNil() bool {
    return s.addressstreettype.StreetName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) StreetNumber() *String {
    if s.addressstreettype.StreetNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.StreetNumber = ((*String)(v))
      }
      }
      return s.addressstreettype.StreetNumber
    }
// Returns whether the element value for StreetNumber is nil in the container AddressStreetType.
  func (s *AddressStreetType) StreetNumber_IsNil() bool {
    return s.addressstreettype.StreetNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) StreetPrefix() *String {
    if s.addressstreettype.StreetPrefix == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.StreetPrefix = ((*String)(v))
      }
      }
      return s.addressstreettype.StreetPrefix
    }
// Returns whether the element value for StreetPrefix is nil in the container AddressStreetType.
  func (s *AddressStreetType) StreetPrefix_IsNil() bool {
    return s.addressstreettype.StreetPrefix == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) StreetSuffix() *String {
    if s.addressstreettype.StreetSuffix == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.StreetSuffix = ((*String)(v))
      }
      }
      return s.addressstreettype.StreetSuffix
    }
// Returns whether the element value for StreetSuffix is nil in the container AddressStreetType.
  func (s *AddressStreetType) StreetSuffix_IsNil() bool {
    return s.addressstreettype.StreetSuffix == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressStreetType) StreetType() *String {
    if s.addressstreettype.StreetType == nil {
    if v, ok:= StringPointer(""); ok {
      s.addressstreettype.StreetType = ((*String)(v))
      }
      }
      return s.addressstreettype.StreetType
    }
// Returns whether the element value for StreetType is nil in the container AddressStreetType.
  func (s *AddressStreetType) StreetType_IsNil() bool {
    return s.addressstreettype.StreetType == nil
    }

// Set the value of a property to nil
func (n *AddressType) Unset(key string) *AddressType {
        switch key {
  case "AddressGlobalUID":
   n.addresstype.AddressGlobalUID = nil
  case "City":
   n.addresstype.City = nil
  case "Community":
   n.addresstype.Community = nil
  case "Country":
   n.addresstype.Country = nil
  case "EffectiveFromDate":
   n.addresstype.EffectiveFromDate = nil
  case "EffectiveToDate":
   n.addresstype.EffectiveToDate = nil
  case "GridLocation":
   n.addresstype.GridLocation = nil
  case "LocalId":
   n.addresstype.LocalId = nil
  case "MapReference":
   n.addresstype.MapReference = nil
  case "PostalCode":
   n.addresstype.PostalCode = nil
  case "RadioContact":
   n.addresstype.RadioContact = nil
  case "Role":
   n.addresstype.Role = nil
  case "StateProvince":
   n.addresstype.StateProvince = nil
  case "StatisticalAreas":
   n.addresstype.StatisticalAreas = nil
  case "Street":
   n.addresstype.Street = nil
  case "Type":
   n.addresstype.Type = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressType")
        }
        return n
}

// Set a sequence of properties
func (n *AddressType) SetProperties(props ...Prop) *AddressType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AddressType) SetProperty(key string, value interface{}) *AddressType {
        if n == nil {
                n, _ = AddressTypePointer(AddressType{})
        }
        switch key {
    case "AddressGlobalUID":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresstype.AddressGlobalUID = ((*GUIDType)(v))
      }
    case "City":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresstype.City = ((*String)(v))
      }
    case "Community":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresstype.Community = ((*String)(v))
      }
    case "Country":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.addresstype.Country = ((*CountryType)(v))
      }
    case "EffectiveFromDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresstype.EffectiveFromDate = ((*String)(v))
      }
    case "EffectiveToDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresstype.EffectiveToDate = ((*String)(v))
      }
    case "GridLocation":
    if v, ok:= GridLocationTypePointer(value); ok {
      n.addresstype.GridLocation = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresstype.LocalId = ((*LocalIdType)(v))
      }
    case "MapReference":
    if v, ok:= MapReferenceTypePointer(value); ok {
      n.addresstype.MapReference = v
      }
    case "PostalCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresstype.PostalCode = ((*String)(v))
      }
    case "RadioContact":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresstype.RadioContact = ((*String)(v))
      }
    case "Role":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAddressRoleType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAddressRoleType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.addresstype.Role = ((*AUCodeSetsAddressRoleType)(v))
      }
    case "StateProvince":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.addresstype.StateProvince = ((*StateProvinceType)(v))
      }
    case "StatisticalAreas":
    if v, ok:= StatisticalAreasTypePointer(value); ok {
      n.addresstype.StatisticalAreas = v
      }
    case "Street":
    if v, ok:= AddressStreetTypePointer(value); ok {
      n.addresstype.Street = v
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAddressTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAddressTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.addresstype.Type = ((*AUCodeSetsAddressTypeType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AddressType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) AddressGlobalUID() *GUIDType {
    if s.addresstype.AddressGlobalUID == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.AddressGlobalUID = ((*GUIDType)(v))
      }
      }
      return s.addresstype.AddressGlobalUID
    }
// Returns whether the element value for AddressGlobalUID is nil in the container AddressType.
  func (s *AddressType) AddressGlobalUID_IsNil() bool {
    return s.addresstype.AddressGlobalUID == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) City() *String {
    if s.addresstype.City == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.City = ((*String)(v))
      }
      }
      return s.addresstype.City
    }
// Returns whether the element value for City is nil in the container AddressType.
  func (s *AddressType) City_IsNil() bool {
    return s.addresstype.City == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) Community() *String {
    if s.addresstype.Community == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.Community = ((*String)(v))
      }
      }
      return s.addresstype.Community
    }
// Returns whether the element value for Community is nil in the container AddressType.
  func (s *AddressType) Community_IsNil() bool {
    return s.addresstype.Community == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) Country() *CountryType {
    if s.addresstype.Country == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.Country = ((*CountryType)(v))
      }
      }
      return s.addresstype.Country
    }
// Returns whether the element value for Country is nil in the container AddressType.
  func (s *AddressType) Country_IsNil() bool {
    return s.addresstype.Country == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) EffectiveFromDate() *String {
    if s.addresstype.EffectiveFromDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.EffectiveFromDate = ((*String)(v))
      }
      }
      return s.addresstype.EffectiveFromDate
    }
// Returns whether the element value for EffectiveFromDate is nil in the container AddressType.
  func (s *AddressType) EffectiveFromDate_IsNil() bool {
    return s.addresstype.EffectiveFromDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) EffectiveToDate() *String {
    if s.addresstype.EffectiveToDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.EffectiveToDate = ((*String)(v))
      }
      }
      return s.addresstype.EffectiveToDate
    }
// Returns whether the element value for EffectiveToDate is nil in the container AddressType.
  func (s *AddressType) EffectiveToDate_IsNil() bool {
    return s.addresstype.EffectiveToDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) GridLocation() *GridLocationType {
    if s.addresstype.GridLocation == nil {
     if v, ok:= GridLocationTypePointer(GridLocationType{}); ok {
      s.addresstype.GridLocation = v
      }
      }
      return s.addresstype.GridLocation
    }
// Returns whether the element value for GridLocation is nil in the container AddressType.
  func (s *AddressType) GridLocation_IsNil() bool {
    return s.addresstype.GridLocation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) LocalId() *LocalIdType {
    if s.addresstype.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.addresstype.LocalId
    }
// Returns whether the element value for LocalId is nil in the container AddressType.
  func (s *AddressType) LocalId_IsNil() bool {
    return s.addresstype.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) MapReference() *MapReferenceType {
    if s.addresstype.MapReference == nil {
     if v, ok:= MapReferenceTypePointer(MapReferenceType{}); ok {
      s.addresstype.MapReference = v
      }
      }
      return s.addresstype.MapReference
    }
// Returns whether the element value for MapReference is nil in the container AddressType.
  func (s *AddressType) MapReference_IsNil() bool {
    return s.addresstype.MapReference == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) PostalCode() *String {
    if s.addresstype.PostalCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.PostalCode = ((*String)(v))
      }
      }
      return s.addresstype.PostalCode
    }
// Returns whether the element value for PostalCode is nil in the container AddressType.
  func (s *AddressType) PostalCode_IsNil() bool {
    return s.addresstype.PostalCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) RadioContact() *String {
    if s.addresstype.RadioContact == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.RadioContact = ((*String)(v))
      }
      }
      return s.addresstype.RadioContact
    }
// Returns whether the element value for RadioContact is nil in the container AddressType.
  func (s *AddressType) RadioContact_IsNil() bool {
    return s.addresstype.RadioContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) Role() *AUCodeSetsAddressRoleType {
    if s.addresstype.Role == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.Role = ((*AUCodeSetsAddressRoleType)(v))
      }
      }
      return s.addresstype.Role
    }
// Returns whether the element value for Role is nil in the container AddressType.
  func (s *AddressType) Role_IsNil() bool {
    return s.addresstype.Role == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) StateProvince() *StateProvinceType {
    if s.addresstype.StateProvince == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.StateProvince = ((*StateProvinceType)(v))
      }
      }
      return s.addresstype.StateProvince
    }
// Returns whether the element value for StateProvince is nil in the container AddressType.
  func (s *AddressType) StateProvince_IsNil() bool {
    return s.addresstype.StateProvince == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) StatisticalAreas() *StatisticalAreasType {
    if s.addresstype.StatisticalAreas == nil {
     if v, ok:= StatisticalAreasTypePointer(StatisticalAreasType{}); ok {
      s.addresstype.StatisticalAreas = v
      }
      }
      return s.addresstype.StatisticalAreas
    }
// Returns whether the element value for StatisticalAreas is nil in the container AddressType.
  func (s *AddressType) StatisticalAreas_IsNil() bool {
    return s.addresstype.StatisticalAreas == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) Street() *AddressStreetType {
    if s.addresstype.Street == nil {
     if v, ok:= AddressStreetTypePointer(AddressStreetType{}); ok {
      s.addresstype.Street = v
      }
      }
      return s.addresstype.Street
    }
// Returns whether the element value for Street is nil in the container AddressType.
  func (s *AddressType) Street_IsNil() bool {
    return s.addresstype.Street == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AddressType) Type() *AUCodeSetsAddressTypeType {
    if s.addresstype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.addresstype.Type = ((*AUCodeSetsAddressTypeType)(v))
      }
      }
      return s.addresstype.Type
    }
// Returns whether the element value for Type is nil in the container AddressType.
  func (s *AddressType) Type_IsNil() bool {
    return s.addresstype.Type == nil
    }

// Set the value of a property to nil
func (n *AdjustmentContainerType) Unset(key string) *AdjustmentContainerType {
        switch key {
  case "BookletType":
   n.adjustmentcontainertype.BookletType = nil
  case "PNPCodeList":
   n.adjustmentcontainertype.PNPCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AdjustmentContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *AdjustmentContainerType) SetProperties(props ...Prop) *AdjustmentContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AdjustmentContainerType) SetProperty(key string, value interface{}) *AdjustmentContainerType {
        if n == nil {
                n, _ = AdjustmentContainerTypePointer(AdjustmentContainerType{})
        }
        switch key {
    case "BookletType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.adjustmentcontainertype.BookletType = ((*String)(v))
      }
    case "PNPCodeList":
    if v, ok:= PNPCodeListTypePointer(value); ok {
      n.adjustmentcontainertype.PNPCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AdjustmentContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AdjustmentContainerType) BookletType() *String {
    if s.adjustmentcontainertype.BookletType == nil {
    if v, ok:= StringPointer(""); ok {
      s.adjustmentcontainertype.BookletType = ((*String)(v))
      }
      }
      return s.adjustmentcontainertype.BookletType
    }
// Returns whether the element value for BookletType is nil in the container AdjustmentContainerType.
  func (s *AdjustmentContainerType) BookletType_IsNil() bool {
    return s.adjustmentcontainertype.BookletType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AdjustmentContainerType) PNPCodeList() *PNPCodeListType {
    if s.adjustmentcontainertype.PNPCodeList == nil {
     if v, ok:= PNPCodeListTypePointer(PNPCodeListType{}); ok {
      s.adjustmentcontainertype.PNPCodeList = v
      }
      }
      return s.adjustmentcontainertype.PNPCodeList
    }
// Returns whether the element value for PNPCodeList is nil in the container AdjustmentContainerType.
  func (s *AdjustmentContainerType) PNPCodeList_IsNil() bool {
    return s.adjustmentcontainertype.PNPCodeList == nil
    }

// Set the value of a property to nil
func (n *AgencyType) Unset(key string) *AgencyType {
        switch key {
  case "Code":
   n.agencytype.Code = nil
  case "OtherCodeList":
   n.agencytype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AgencyType")
        }
        return n
}

// Set a sequence of properties
func (n *AgencyType) SetProperties(props ...Prop) *AgencyType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AgencyType) SetProperty(key string, value interface{}) *AgencyType {
        if n == nil {
                n, _ = AgencyTypePointer(AgencyType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEducationAgencyTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEducationAgencyTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.agencytype.Code = ((*AUCodeSetsEducationAgencyTypeType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.agencytype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AgencyType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AgencyType) Code() *AUCodeSetsEducationAgencyTypeType {
    if s.agencytype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.agencytype.Code = ((*AUCodeSetsEducationAgencyTypeType)(v))
      }
      }
      return s.agencytype.Code
    }
// Returns whether the element value for Code is nil in the container AgencyType.
  func (s *AgencyType) Code_IsNil() bool {
    return s.agencytype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AgencyType) OtherCodeList() *OtherCodeListType {
    if s.agencytype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.agencytype.OtherCodeList = v
      }
      }
      return s.agencytype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container AgencyType.
  func (s *AgencyType) OtherCodeList_IsNil() bool {
    return s.agencytype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *AggregateCharacteristicInfo) Unset(key string) *AggregateCharacteristicInfo {
        switch key {
  case "Definition":
   n.aggregatecharacteristicinfo.Definition = nil
  case "Description":
   n.aggregatecharacteristicinfo.Description = nil
  case "ElementName":
   n.aggregatecharacteristicinfo.ElementName = nil
  case "LocalCodeList":
   n.aggregatecharacteristicinfo.LocalCodeList = nil
  case "RefId":
   n.aggregatecharacteristicinfo.RefId = nil
  case "SIF_ExtendedElements":
   n.aggregatecharacteristicinfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.aggregatecharacteristicinfo.SIF_Metadata = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AggregateCharacteristicInfo")
        }
        return n
}

// Set a sequence of properties
func (n *AggregateCharacteristicInfo) SetProperties(props ...Prop) *AggregateCharacteristicInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AggregateCharacteristicInfo) SetProperty(key string, value interface{}) *AggregateCharacteristicInfo {
        if n == nil {
                n, _ = AggregateCharacteristicInfoPointer(AggregateCharacteristicInfo{})
        }
        switch key {
    case "Definition":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatecharacteristicinfo.Definition = ((*String)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatecharacteristicinfo.Description = ((*String)(v))
      }
    case "ElementName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatecharacteristicinfo.ElementName = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.aggregatecharacteristicinfo.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatecharacteristicinfo.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.aggregatecharacteristicinfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.aggregatecharacteristicinfo.SIF_Metadata = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AggregateCharacteristicInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateCharacteristicInfo) Definition() *String {
    if s.aggregatecharacteristicinfo.Definition == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatecharacteristicinfo.Definition = ((*String)(v))
      }
      }
      return s.aggregatecharacteristicinfo.Definition
    }
// Returns whether the element value for Definition is nil in the container AggregateCharacteristicInfo.
  func (s *AggregateCharacteristicInfo) Definition_IsNil() bool {
    return s.aggregatecharacteristicinfo.Definition == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateCharacteristicInfo) Description() *String {
    if s.aggregatecharacteristicinfo.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatecharacteristicinfo.Description = ((*String)(v))
      }
      }
      return s.aggregatecharacteristicinfo.Description
    }
// Returns whether the element value for Description is nil in the container AggregateCharacteristicInfo.
  func (s *AggregateCharacteristicInfo) Description_IsNil() bool {
    return s.aggregatecharacteristicinfo.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateCharacteristicInfo) ElementName() *String {
    if s.aggregatecharacteristicinfo.ElementName == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatecharacteristicinfo.ElementName = ((*String)(v))
      }
      }
      return s.aggregatecharacteristicinfo.ElementName
    }
// Returns whether the element value for ElementName is nil in the container AggregateCharacteristicInfo.
  func (s *AggregateCharacteristicInfo) ElementName_IsNil() bool {
    return s.aggregatecharacteristicinfo.ElementName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateCharacteristicInfo) LocalCodeList() *LocalCodeListType {
    if s.aggregatecharacteristicinfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.aggregatecharacteristicinfo.LocalCodeList = v
      }
      }
      return s.aggregatecharacteristicinfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container AggregateCharacteristicInfo.
  func (s *AggregateCharacteristicInfo) LocalCodeList_IsNil() bool {
    return s.aggregatecharacteristicinfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateCharacteristicInfo) RefId() *RefIdType {
    if s.aggregatecharacteristicinfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatecharacteristicinfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.aggregatecharacteristicinfo.RefId
    }
// Returns whether the element value for RefId is nil in the container AggregateCharacteristicInfo.
  func (s *AggregateCharacteristicInfo) RefId_IsNil() bool {
    return s.aggregatecharacteristicinfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateCharacteristicInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.aggregatecharacteristicinfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.aggregatecharacteristicinfo.SIF_ExtendedElements = v
      }
      }
      return s.aggregatecharacteristicinfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container AggregateCharacteristicInfo.
  func (s *AggregateCharacteristicInfo) SIF_ExtendedElements_IsNil() bool {
    return s.aggregatecharacteristicinfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateCharacteristicInfo) SIF_Metadata() *SIF_MetadataType {
    if s.aggregatecharacteristicinfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.aggregatecharacteristicinfo.SIF_Metadata = v
      }
      }
      return s.aggregatecharacteristicinfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container AggregateCharacteristicInfo.
  func (s *AggregateCharacteristicInfo) SIF_Metadata_IsNil() bool {
    return s.aggregatecharacteristicinfo.SIF_Metadata == nil
    }

// Set the value of a property to nil
func (n *AggregateStatisticFact) Unset(key string) *AggregateStatisticFact {
        switch key {
  case "AggregateStatisticInfoRefId":
   n.aggregatestatisticfact.AggregateStatisticInfoRefId = nil
  case "Characteristics":
   n.aggregatestatisticfact.Characteristics = nil
  case "Excluded":
   n.aggregatestatisticfact.Excluded = nil
  case "LocalCodeList":
   n.aggregatestatisticfact.LocalCodeList = nil
  case "RefId":
   n.aggregatestatisticfact.RefId = nil
  case "SIF_ExtendedElements":
   n.aggregatestatisticfact.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.aggregatestatisticfact.SIF_Metadata = nil
  case "Value":
   n.aggregatestatisticfact.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AggregateStatisticFact")
        }
        return n
}

// Set a sequence of properties
func (n *AggregateStatisticFact) SetProperties(props ...Prop) *AggregateStatisticFact {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AggregateStatisticFact) SetProperty(key string, value interface{}) *AggregateStatisticFact {
        if n == nil {
                n, _ = AggregateStatisticFactPointer(AggregateStatisticFact{})
        }
        switch key {
    case "AggregateStatisticInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticfact.AggregateStatisticInfoRefId = ((*String)(v))
      }
    case "Characteristics":
    if v, ok:= CharacteristicsTypePointer(value); ok {
      n.aggregatestatisticfact.Characteristics = v
      }
    case "Excluded":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticfact.Excluded = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.aggregatestatisticfact.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticfact.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.aggregatestatisticfact.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.aggregatestatisticfact.SIF_Metadata = v
      }
    case "Value":
    
    if v, ok:= FloatPointer(value); ok {
      n.aggregatestatisticfact.Value = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AggregateStatisticFact")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticFact) AggregateStatisticInfoRefId() *String {
    if s.aggregatestatisticfact.AggregateStatisticInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticfact.AggregateStatisticInfoRefId = ((*String)(v))
      }
      }
      return s.aggregatestatisticfact.AggregateStatisticInfoRefId
    }
// Returns whether the element value for AggregateStatisticInfoRefId is nil in the container AggregateStatisticFact.
  func (s *AggregateStatisticFact) AggregateStatisticInfoRefId_IsNil() bool {
    return s.aggregatestatisticfact.AggregateStatisticInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticFact) Characteristics() *CharacteristicsType {
    if s.aggregatestatisticfact.Characteristics == nil {
     if v, ok:= CharacteristicsTypePointer(CharacteristicsType{}); ok {
      s.aggregatestatisticfact.Characteristics = v
      }
      }
      return s.aggregatestatisticfact.Characteristics
    }
// Returns whether the element value for Characteristics is nil in the container AggregateStatisticFact.
  func (s *AggregateStatisticFact) Characteristics_IsNil() bool {
    return s.aggregatestatisticfact.Characteristics == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticFact) Excluded() *String {
    if s.aggregatestatisticfact.Excluded == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticfact.Excluded = ((*String)(v))
      }
      }
      return s.aggregatestatisticfact.Excluded
    }
// Returns whether the element value for Excluded is nil in the container AggregateStatisticFact.
  func (s *AggregateStatisticFact) Excluded_IsNil() bool {
    return s.aggregatestatisticfact.Excluded == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticFact) LocalCodeList() *LocalCodeListType {
    if s.aggregatestatisticfact.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.aggregatestatisticfact.LocalCodeList = v
      }
      }
      return s.aggregatestatisticfact.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container AggregateStatisticFact.
  func (s *AggregateStatisticFact) LocalCodeList_IsNil() bool {
    return s.aggregatestatisticfact.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticFact) RefId() *RefIdType {
    if s.aggregatestatisticfact.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticfact.RefId = ((*RefIdType)(v))
      }
      }
      return s.aggregatestatisticfact.RefId
    }
// Returns whether the element value for RefId is nil in the container AggregateStatisticFact.
  func (s *AggregateStatisticFact) RefId_IsNil() bool {
    return s.aggregatestatisticfact.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticFact) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.aggregatestatisticfact.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.aggregatestatisticfact.SIF_ExtendedElements = v
      }
      }
      return s.aggregatestatisticfact.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container AggregateStatisticFact.
  func (s *AggregateStatisticFact) SIF_ExtendedElements_IsNil() bool {
    return s.aggregatestatisticfact.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticFact) SIF_Metadata() *SIF_MetadataType {
    if s.aggregatestatisticfact.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.aggregatestatisticfact.SIF_Metadata = v
      }
      }
      return s.aggregatestatisticfact.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container AggregateStatisticFact.
  func (s *AggregateStatisticFact) SIF_Metadata_IsNil() bool {
    return s.aggregatestatisticfact.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticFact) Value() *Float {
    if s.aggregatestatisticfact.Value == nil {
    if v, ok:= FloatPointer(0); ok {
      s.aggregatestatisticfact.Value = ((*Float)(v))
      }
      }
      return s.aggregatestatisticfact.Value
    }
// Returns whether the element value for Value is nil in the container AggregateStatisticFact.
  func (s *AggregateStatisticFact) Value_IsNil() bool {
    return s.aggregatestatisticfact.Value == nil
    }

// Set the value of a property to nil
func (n *AggregateStatisticInfo) Unset(key string) *AggregateStatisticInfo {
        switch key {
  case "ApprovalDate":
   n.aggregatestatisticinfo.ApprovalDate = nil
  case "CalculationRule":
   n.aggregatestatisticinfo.CalculationRule = nil
  case "DiscontinueDate":
   n.aggregatestatisticinfo.DiscontinueDate = nil
  case "EffectiveDate":
   n.aggregatestatisticinfo.EffectiveDate = nil
  case "ExclusionRules":
   n.aggregatestatisticinfo.ExclusionRules = nil
  case "ExpirationDate":
   n.aggregatestatisticinfo.ExpirationDate = nil
  case "LocalCodeList":
   n.aggregatestatisticinfo.LocalCodeList = nil
  case "Location":
   n.aggregatestatisticinfo.Location = nil
  case "Measure":
   n.aggregatestatisticinfo.Measure = nil
  case "RefId":
   n.aggregatestatisticinfo.RefId = nil
  case "SIF_ExtendedElements":
   n.aggregatestatisticinfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.aggregatestatisticinfo.SIF_Metadata = nil
  case "Source":
   n.aggregatestatisticinfo.Source = nil
  case "StatisticName":
   n.aggregatestatisticinfo.StatisticName = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AggregateStatisticInfo")
        }
        return n
}

// Set a sequence of properties
func (n *AggregateStatisticInfo) SetProperties(props ...Prop) *AggregateStatisticInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AggregateStatisticInfo) SetProperty(key string, value interface{}) *AggregateStatisticInfo {
        if n == nil {
                n, _ = AggregateStatisticInfoPointer(AggregateStatisticInfo{})
        }
        switch key {
    case "ApprovalDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticinfo.ApprovalDate = ((*String)(v))
      }
    case "CalculationRule":
    if v, ok:= CalculationRuleTypePointer(value); ok {
      n.aggregatestatisticinfo.CalculationRule = v
      }
    case "DiscontinueDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticinfo.DiscontinueDate = ((*String)(v))
      }
    case "EffectiveDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticinfo.EffectiveDate = ((*String)(v))
      }
    case "ExclusionRules":
    if v, ok:= ExclusionRulesTypePointer(value); ok {
      n.aggregatestatisticinfo.ExclusionRules = v
      }
    case "ExpirationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticinfo.ExpirationDate = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.aggregatestatisticinfo.LocalCodeList = v
      }
    case "Location":
    if v, ok:= LocationTypePointer(value); ok {
      n.aggregatestatisticinfo.Location = v
      }
    case "Measure":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticinfo.Measure = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticinfo.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.aggregatestatisticinfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.aggregatestatisticinfo.SIF_Metadata = v
      }
    case "Source":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticinfo.Source = ((*String)(v))
      }
    case "StatisticName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.aggregatestatisticinfo.StatisticName = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AggregateStatisticInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) ApprovalDate() *String {
    if s.aggregatestatisticinfo.ApprovalDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticinfo.ApprovalDate = ((*String)(v))
      }
      }
      return s.aggregatestatisticinfo.ApprovalDate
    }
// Returns whether the element value for ApprovalDate is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) ApprovalDate_IsNil() bool {
    return s.aggregatestatisticinfo.ApprovalDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) CalculationRule() *CalculationRuleType {
    if s.aggregatestatisticinfo.CalculationRule == nil {
     if v, ok:= CalculationRuleTypePointer(CalculationRuleType{}); ok {
      s.aggregatestatisticinfo.CalculationRule = v
      }
      }
      return s.aggregatestatisticinfo.CalculationRule
    }
// Returns whether the element value for CalculationRule is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) CalculationRule_IsNil() bool {
    return s.aggregatestatisticinfo.CalculationRule == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) DiscontinueDate() *String {
    if s.aggregatestatisticinfo.DiscontinueDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticinfo.DiscontinueDate = ((*String)(v))
      }
      }
      return s.aggregatestatisticinfo.DiscontinueDate
    }
// Returns whether the element value for DiscontinueDate is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) DiscontinueDate_IsNil() bool {
    return s.aggregatestatisticinfo.DiscontinueDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) EffectiveDate() *String {
    if s.aggregatestatisticinfo.EffectiveDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticinfo.EffectiveDate = ((*String)(v))
      }
      }
      return s.aggregatestatisticinfo.EffectiveDate
    }
// Returns whether the element value for EffectiveDate is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) EffectiveDate_IsNil() bool {
    return s.aggregatestatisticinfo.EffectiveDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) ExclusionRules() *ExclusionRulesType {
    if s.aggregatestatisticinfo.ExclusionRules == nil {
     if v, ok:= ExclusionRulesTypePointer(ExclusionRulesType{}); ok {
      s.aggregatestatisticinfo.ExclusionRules = v
      }
      }
      return s.aggregatestatisticinfo.ExclusionRules
    }
// Returns whether the element value for ExclusionRules is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) ExclusionRules_IsNil() bool {
    return s.aggregatestatisticinfo.ExclusionRules == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) ExpirationDate() *String {
    if s.aggregatestatisticinfo.ExpirationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticinfo.ExpirationDate = ((*String)(v))
      }
      }
      return s.aggregatestatisticinfo.ExpirationDate
    }
// Returns whether the element value for ExpirationDate is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) ExpirationDate_IsNil() bool {
    return s.aggregatestatisticinfo.ExpirationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) LocalCodeList() *LocalCodeListType {
    if s.aggregatestatisticinfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.aggregatestatisticinfo.LocalCodeList = v
      }
      }
      return s.aggregatestatisticinfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) LocalCodeList_IsNil() bool {
    return s.aggregatestatisticinfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) Location() *LocationType {
    if s.aggregatestatisticinfo.Location == nil {
     if v, ok:= LocationTypePointer(LocationType{}); ok {
      s.aggregatestatisticinfo.Location = v
      }
      }
      return s.aggregatestatisticinfo.Location
    }
// Returns whether the element value for Location is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) Location_IsNil() bool {
    return s.aggregatestatisticinfo.Location == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) Measure() *String {
    if s.aggregatestatisticinfo.Measure == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticinfo.Measure = ((*String)(v))
      }
      }
      return s.aggregatestatisticinfo.Measure
    }
// Returns whether the element value for Measure is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) Measure_IsNil() bool {
    return s.aggregatestatisticinfo.Measure == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) RefId() *RefIdType {
    if s.aggregatestatisticinfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticinfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.aggregatestatisticinfo.RefId
    }
// Returns whether the element value for RefId is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) RefId_IsNil() bool {
    return s.aggregatestatisticinfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.aggregatestatisticinfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.aggregatestatisticinfo.SIF_ExtendedElements = v
      }
      }
      return s.aggregatestatisticinfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) SIF_ExtendedElements_IsNil() bool {
    return s.aggregatestatisticinfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) SIF_Metadata() *SIF_MetadataType {
    if s.aggregatestatisticinfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.aggregatestatisticinfo.SIF_Metadata = v
      }
      }
      return s.aggregatestatisticinfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) SIF_Metadata_IsNil() bool {
    return s.aggregatestatisticinfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) Source() *String {
    if s.aggregatestatisticinfo.Source == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticinfo.Source = ((*String)(v))
      }
      }
      return s.aggregatestatisticinfo.Source
    }
// Returns whether the element value for Source is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) Source_IsNil() bool {
    return s.aggregatestatisticinfo.Source == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AggregateStatisticInfo) StatisticName() *String {
    if s.aggregatestatisticinfo.StatisticName == nil {
    if v, ok:= StringPointer(""); ok {
      s.aggregatestatisticinfo.StatisticName = ((*String)(v))
      }
      }
      return s.aggregatestatisticinfo.StatisticName
    }
// Returns whether the element value for StatisticName is nil in the container AggregateStatisticInfo.
  func (s *AggregateStatisticInfo) StatisticName_IsNil() bool {
    return s.aggregatestatisticinfo.StatisticName == nil
    }

// Set the value of a property to nil
func (n *AlertMessageType) Unset(key string) *AlertMessageType {
        switch key {
  case "Type":
   n.alertmessagetype.Type = nil
  case "Value":
   n.alertmessagetype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AlertMessageType")
        }
        return n
}

// Set a sequence of properties
func (n *AlertMessageType) SetProperties(props ...Prop) *AlertMessageType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AlertMessageType) SetProperty(key string, value interface{}) *AlertMessageType {
        if n == nil {
                n, _ = AlertMessageTypePointer(AlertMessageType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.alertmessagetype.Type = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.alertmessagetype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AlertMessageType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AlertMessageType) Type() *String {
    if s.alertmessagetype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.alertmessagetype.Type = ((*String)(v))
      }
      }
      return s.alertmessagetype.Type
    }
// Returns whether the element value for Type is nil in the container AlertMessageType.
  func (s *AlertMessageType) Type_IsNil() bool {
    return s.alertmessagetype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AlertMessageType) Value() *String {
    if s.alertmessagetype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.alertmessagetype.Value = ((*String)(v))
      }
      }
      return s.alertmessagetype.Value
    }
// Returns whether the element value for Value is nil in the container AlertMessageType.
  func (s *AlertMessageType) Value_IsNil() bool {
    return s.alertmessagetype.Value == nil
    }

// Set the value of a property to nil
func (n *ApplicableLawType) Unset(key string) *ApplicableLawType {
        switch key {
  case "ApplicableCountry":
   n.applicablelawtype.ApplicableCountry = nil
  case "ApplicableLawName":
   n.applicablelawtype.ApplicableLawName = nil
  case "ApplicableLawURL":
   n.applicablelawtype.ApplicableLawURL = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ApplicableLawType")
        }
        return n
}

// Set a sequence of properties
func (n *ApplicableLawType) SetProperties(props ...Prop) *ApplicableLawType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ApplicableLawType) SetProperty(key string, value interface{}) *ApplicableLawType {
        if n == nil {
                n, _ = ApplicableLawTypePointer(ApplicableLawType{})
        }
        switch key {
    case "ApplicableCountry":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.applicablelawtype.ApplicableCountry = ((*String)(v))
      }
    case "ApplicableLawName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.applicablelawtype.ApplicableLawName = ((*String)(v))
      }
    case "ApplicableLawURL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.applicablelawtype.ApplicableLawURL = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ApplicableLawType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ApplicableLawType) ApplicableCountry() *String {
    if s.applicablelawtype.ApplicableCountry == nil {
    if v, ok:= StringPointer(""); ok {
      s.applicablelawtype.ApplicableCountry = ((*String)(v))
      }
      }
      return s.applicablelawtype.ApplicableCountry
    }
// Returns whether the element value for ApplicableCountry is nil in the container ApplicableLawType.
  func (s *ApplicableLawType) ApplicableCountry_IsNil() bool {
    return s.applicablelawtype.ApplicableCountry == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ApplicableLawType) ApplicableLawName() *String {
    if s.applicablelawtype.ApplicableLawName == nil {
    if v, ok:= StringPointer(""); ok {
      s.applicablelawtype.ApplicableLawName = ((*String)(v))
      }
      }
      return s.applicablelawtype.ApplicableLawName
    }
// Returns whether the element value for ApplicableLawName is nil in the container ApplicableLawType.
  func (s *ApplicableLawType) ApplicableLawName_IsNil() bool {
    return s.applicablelawtype.ApplicableLawName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ApplicableLawType) ApplicableLawURL() *String {
    if s.applicablelawtype.ApplicableLawURL == nil {
    if v, ok:= StringPointer(""); ok {
      s.applicablelawtype.ApplicableLawURL = ((*String)(v))
      }
      }
      return s.applicablelawtype.ApplicableLawURL
    }
// Returns whether the element value for ApplicableLawURL is nil in the container ApplicableLawType.
  func (s *ApplicableLawType) ApplicableLawURL_IsNil() bool {
    return s.applicablelawtype.ApplicableLawURL == nil
    }

// Set the value of a property to nil
func (n *ApprovalType) Unset(key string) *ApprovalType {
        switch key {
  case "Date":
   n.approvaltype.Date = nil
  case "Organization":
   n.approvaltype.Organization = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ApprovalType")
        }
        return n
}

// Set a sequence of properties
func (n *ApprovalType) SetProperties(props ...Prop) *ApprovalType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ApprovalType) SetProperty(key string, value interface{}) *ApprovalType {
        if n == nil {
                n, _ = ApprovalTypePointer(ApprovalType{})
        }
        switch key {
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.approvaltype.Date = ((*String)(v))
      }
    case "Organization":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.approvaltype.Organization = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ApprovalType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ApprovalType) Date() *String {
    if s.approvaltype.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.approvaltype.Date = ((*String)(v))
      }
      }
      return s.approvaltype.Date
    }
// Returns whether the element value for Date is nil in the container ApprovalType.
  func (s *ApprovalType) Date_IsNil() bool {
    return s.approvaltype.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ApprovalType) Organization() *String {
    if s.approvaltype.Organization == nil {
    if v, ok:= StringPointer(""); ok {
      s.approvaltype.Organization = ((*String)(v))
      }
      }
      return s.approvaltype.Organization
    }
// Returns whether the element value for Organization is nil in the container ApprovalType.
  func (s *ApprovalType) Organization_IsNil() bool {
    return s.approvaltype.Organization == nil
    }

// Set the value of a property to nil
func (n *ArrivalSchoolType) Unset(key string) *ArrivalSchoolType {
        switch key {
  case "ACARAId":
   n.arrivalschooltype.ACARAId = nil
  case "City":
   n.arrivalschooltype.City = nil
  case "Name":
   n.arrivalschooltype.Name = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ArrivalSchoolType")
        }
        return n
}

// Set a sequence of properties
func (n *ArrivalSchoolType) SetProperties(props ...Prop) *ArrivalSchoolType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ArrivalSchoolType) SetProperty(key string, value interface{}) *ArrivalSchoolType {
        if n == nil {
                n, _ = ArrivalSchoolTypePointer(ArrivalSchoolType{})
        }
        switch key {
    case "ACARAId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.arrivalschooltype.ACARAId = ((*String)(v))
      }
    case "City":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.arrivalschooltype.City = ((*String)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.arrivalschooltype.Name = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ArrivalSchoolType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ArrivalSchoolType) ACARAId() *String {
    if s.arrivalschooltype.ACARAId == nil {
    if v, ok:= StringPointer(""); ok {
      s.arrivalschooltype.ACARAId = ((*String)(v))
      }
      }
      return s.arrivalschooltype.ACARAId
    }
// Returns whether the element value for ACARAId is nil in the container ArrivalSchoolType.
  func (s *ArrivalSchoolType) ACARAId_IsNil() bool {
    return s.arrivalschooltype.ACARAId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ArrivalSchoolType) City() *String {
    if s.arrivalschooltype.City == nil {
    if v, ok:= StringPointer(""); ok {
      s.arrivalschooltype.City = ((*String)(v))
      }
      }
      return s.arrivalschooltype.City
    }
// Returns whether the element value for City is nil in the container ArrivalSchoolType.
  func (s *ArrivalSchoolType) City_IsNil() bool {
    return s.arrivalschooltype.City == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ArrivalSchoolType) Name() *String {
    if s.arrivalschooltype.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.arrivalschooltype.Name = ((*String)(v))
      }
      }
      return s.arrivalschooltype.Name
    }
// Returns whether the element value for Name is nil in the container ArrivalSchoolType.
  func (s *ArrivalSchoolType) Name_IsNil() bool {
    return s.arrivalschooltype.Name == nil
    }

// Set the value of a property to nil
func (n *AssignmentScoreType) Unset(key string) *AssignmentScoreType {
        switch key {
  case "GradingAssignmentScoreRefId":
   n.assignmentscoretype.GradingAssignmentScoreRefId = nil
  case "Weight":
   n.assignmentscoretype.Weight = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AssignmentScoreType")
        }
        return n
}

// Set a sequence of properties
func (n *AssignmentScoreType) SetProperties(props ...Prop) *AssignmentScoreType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AssignmentScoreType) SetProperty(key string, value interface{}) *AssignmentScoreType {
        if n == nil {
                n, _ = AssignmentScoreTypePointer(AssignmentScoreType{})
        }
        switch key {
    case "GradingAssignmentScoreRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.assignmentscoretype.GradingAssignmentScoreRefId = ((*String)(v))
      }
    case "Weight":
    
    if v, ok:= FloatPointer(value); ok {
      n.assignmentscoretype.Weight = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AssignmentScoreType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AssignmentScoreType) GradingAssignmentScoreRefId() *String {
    if s.assignmentscoretype.GradingAssignmentScoreRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.assignmentscoretype.GradingAssignmentScoreRefId = ((*String)(v))
      }
      }
      return s.assignmentscoretype.GradingAssignmentScoreRefId
    }
// Returns whether the element value for GradingAssignmentScoreRefId is nil in the container AssignmentScoreType.
  func (s *AssignmentScoreType) GradingAssignmentScoreRefId_IsNil() bool {
    return s.assignmentscoretype.GradingAssignmentScoreRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AssignmentScoreType) Weight() *Float {
    if s.assignmentscoretype.Weight == nil {
    if v, ok:= FloatPointer(0); ok {
      s.assignmentscoretype.Weight = ((*Float)(v))
      }
      }
      return s.assignmentscoretype.Weight
    }
// Returns whether the element value for Weight is nil in the container AssignmentScoreType.
  func (s *AssignmentScoreType) Weight_IsNil() bool {
    return s.assignmentscoretype.Weight == nil
    }

// Set the value of a property to nil
func (n *AssociatedObjectsType_AssociatedObject) Unset(key string) *AssociatedObjectsType_AssociatedObject {
        switch key {
  case "SIF_RefObject":
   n.associatedobjectstype_associatedobject.SIF_RefObject = nil
  case "Value":
   n.associatedobjectstype_associatedobject.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AssociatedObjectsType_AssociatedObject")
        }
        return n
}

// Set a sequence of properties
func (n *AssociatedObjectsType_AssociatedObject) SetProperties(props ...Prop) *AssociatedObjectsType_AssociatedObject {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AssociatedObjectsType_AssociatedObject) SetProperty(key string, value interface{}) *AssociatedObjectsType_AssociatedObject {
        if n == nil {
                n, _ = AssociatedObjectsType_AssociatedObjectPointer(AssociatedObjectsType_AssociatedObject{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.associatedobjectstype_associatedobject.SIF_RefObject = ((*ObjectNameType)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.associatedobjectstype_associatedobject.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AssociatedObjectsType_AssociatedObject")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AssociatedObjectsType_AssociatedObject) SIF_RefObject() *ObjectNameType {
    if s.associatedobjectstype_associatedobject.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.associatedobjectstype_associatedobject.SIF_RefObject = ((*ObjectNameType)(v))
      }
      }
      return s.associatedobjectstype_associatedobject.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container AssociatedObjectsType_AssociatedObject.
  func (s *AssociatedObjectsType_AssociatedObject) SIF_RefObject_IsNil() bool {
    return s.associatedobjectstype_associatedobject.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AssociatedObjectsType_AssociatedObject) Value() *String {
    if s.associatedobjectstype_associatedobject.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.associatedobjectstype_associatedobject.Value = ((*String)(v))
      }
      }
      return s.associatedobjectstype_associatedobject.Value
    }
// Returns whether the element value for Value is nil in the container AssociatedObjectsType_AssociatedObject.
  func (s *AssociatedObjectsType_AssociatedObject) Value_IsNil() bool {
    return s.associatedobjectstype_associatedobject.Value == nil
    }

// Set the value of a property to nil
func (n *AttendanceCodeType) Unset(key string) *AttendanceCodeType {
        switch key {
  case "Code":
   n.attendancecodetype.Code = nil
  case "OtherCodeList":
   n.attendancecodetype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AttendanceCodeType")
        }
        return n
}

// Set a sequence of properties
func (n *AttendanceCodeType) SetProperties(props ...Prop) *AttendanceCodeType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AttendanceCodeType) SetProperty(key string, value interface{}) *AttendanceCodeType {
        if n == nil {
                n, _ = AttendanceCodeTypePointer(AttendanceCodeType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAttendanceCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAttendanceCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.attendancecodetype.Code = ((*AUCodeSetsAttendanceCodeType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.attendancecodetype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AttendanceCodeType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceCodeType) Code() *AUCodeSetsAttendanceCodeType {
    if s.attendancecodetype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.attendancecodetype.Code = ((*AUCodeSetsAttendanceCodeType)(v))
      }
      }
      return s.attendancecodetype.Code
    }
// Returns whether the element value for Code is nil in the container AttendanceCodeType.
  func (s *AttendanceCodeType) Code_IsNil() bool {
    return s.attendancecodetype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceCodeType) OtherCodeList() *OtherCodeListType {
    if s.attendancecodetype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.attendancecodetype.OtherCodeList = v
      }
      }
      return s.attendancecodetype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container AttendanceCodeType.
  func (s *AttendanceCodeType) OtherCodeList_IsNil() bool {
    return s.attendancecodetype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *AttendanceInfoType) Unset(key string) *AttendanceInfoType {
        switch key {
  case "AttendanceValue":
   n.attendanceinfotype.AttendanceValue = nil
  case "CountsTowardAttendance":
   n.attendanceinfotype.CountsTowardAttendance = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AttendanceInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *AttendanceInfoType) SetProperties(props ...Prop) *AttendanceInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AttendanceInfoType) SetProperty(key string, value interface{}) *AttendanceInfoType {
        if n == nil {
                n, _ = AttendanceInfoTypePointer(AttendanceInfoType{})
        }
        switch key {
    case "AttendanceValue":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.attendanceinfotype.AttendanceValue = ((*String)(v))
      }
    case "CountsTowardAttendance":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.attendanceinfotype.CountsTowardAttendance = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AttendanceInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceInfoType) AttendanceValue() *String {
    if s.attendanceinfotype.AttendanceValue == nil {
    if v, ok:= StringPointer(""); ok {
      s.attendanceinfotype.AttendanceValue = ((*String)(v))
      }
      }
      return s.attendanceinfotype.AttendanceValue
    }
// Returns whether the element value for AttendanceValue is nil in the container AttendanceInfoType.
  func (s *AttendanceInfoType) AttendanceValue_IsNil() bool {
    return s.attendanceinfotype.AttendanceValue == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceInfoType) CountsTowardAttendance() *String {
    if s.attendanceinfotype.CountsTowardAttendance == nil {
    if v, ok:= StringPointer(""); ok {
      s.attendanceinfotype.CountsTowardAttendance = ((*String)(v))
      }
      }
      return s.attendanceinfotype.CountsTowardAttendance
    }
// Returns whether the element value for CountsTowardAttendance is nil in the container AttendanceInfoType.
  func (s *AttendanceInfoType) CountsTowardAttendance_IsNil() bool {
    return s.attendanceinfotype.CountsTowardAttendance == nil
    }

// Set the value of a property to nil
func (n *AttendanceTimeType) Unset(key string) *AttendanceTimeType {
        switch key {
  case "AttendanceCode":
   n.attendancetimetype.AttendanceCode = nil
  case "AttendanceNote":
   n.attendancetimetype.AttendanceNote = nil
  case "AttendanceStatus":
   n.attendancetimetype.AttendanceStatus = nil
  case "AttendanceType":
   n.attendancetimetype.AttendanceType = nil
  case "DurationValue":
   n.attendancetimetype.DurationValue = nil
  case "EndTime":
   n.attendancetimetype.EndTime = nil
  case "StartTime":
   n.attendancetimetype.StartTime = nil
  case "TimeTableSubjectRefId":
   n.attendancetimetype.TimeTableSubjectRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AttendanceTimeType")
        }
        return n
}

// Set a sequence of properties
func (n *AttendanceTimeType) SetProperties(props ...Prop) *AttendanceTimeType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AttendanceTimeType) SetProperty(key string, value interface{}) *AttendanceTimeType {
        if n == nil {
                n, _ = AttendanceTimeTypePointer(AttendanceTimeType{})
        }
        switch key {
    case "AttendanceCode":
    if v, ok:= AttendanceCodeTypePointer(value); ok {
      n.attendancetimetype.AttendanceCode = v
      }
    case "AttendanceNote":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.attendancetimetype.AttendanceNote = ((*String)(v))
      }
    case "AttendanceStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAttendanceStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAttendanceStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.attendancetimetype.AttendanceStatus = ((*AUCodeSetsAttendanceStatusType)(v))
      }
    case "AttendanceType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.attendancetimetype.AttendanceType = ((*String)(v))
      }
    case "DurationValue":
    
    if v, ok:= FloatPointer(value); ok {
      n.attendancetimetype.DurationValue = ((*Float)(v))
      }
    case "EndTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.attendancetimetype.EndTime = ((*String)(v))
      }
    case "StartTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.attendancetimetype.StartTime = ((*String)(v))
      }
    case "TimeTableSubjectRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.attendancetimetype.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AttendanceTimeType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceTimeType) AttendanceCode() *AttendanceCodeType {
    if s.attendancetimetype.AttendanceCode == nil {
     if v, ok:= AttendanceCodeTypePointer(AttendanceCodeType{}); ok {
      s.attendancetimetype.AttendanceCode = v
      }
      }
      return s.attendancetimetype.AttendanceCode
    }
// Returns whether the element value for AttendanceCode is nil in the container AttendanceTimeType.
  func (s *AttendanceTimeType) AttendanceCode_IsNil() bool {
    return s.attendancetimetype.AttendanceCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceTimeType) AttendanceNote() *String {
    if s.attendancetimetype.AttendanceNote == nil {
    if v, ok:= StringPointer(""); ok {
      s.attendancetimetype.AttendanceNote = ((*String)(v))
      }
      }
      return s.attendancetimetype.AttendanceNote
    }
// Returns whether the element value for AttendanceNote is nil in the container AttendanceTimeType.
  func (s *AttendanceTimeType) AttendanceNote_IsNil() bool {
    return s.attendancetimetype.AttendanceNote == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceTimeType) AttendanceStatus() *AUCodeSetsAttendanceStatusType {
    if s.attendancetimetype.AttendanceStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.attendancetimetype.AttendanceStatus = ((*AUCodeSetsAttendanceStatusType)(v))
      }
      }
      return s.attendancetimetype.AttendanceStatus
    }
// Returns whether the element value for AttendanceStatus is nil in the container AttendanceTimeType.
  func (s *AttendanceTimeType) AttendanceStatus_IsNil() bool {
    return s.attendancetimetype.AttendanceStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceTimeType) AttendanceType() *String {
    if s.attendancetimetype.AttendanceType == nil {
    if v, ok:= StringPointer(""); ok {
      s.attendancetimetype.AttendanceType = ((*String)(v))
      }
      }
      return s.attendancetimetype.AttendanceType
    }
// Returns whether the element value for AttendanceType is nil in the container AttendanceTimeType.
  func (s *AttendanceTimeType) AttendanceType_IsNil() bool {
    return s.attendancetimetype.AttendanceType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceTimeType) DurationValue() *Float {
    if s.attendancetimetype.DurationValue == nil {
    if v, ok:= FloatPointer(0); ok {
      s.attendancetimetype.DurationValue = ((*Float)(v))
      }
      }
      return s.attendancetimetype.DurationValue
    }
// Returns whether the element value for DurationValue is nil in the container AttendanceTimeType.
  func (s *AttendanceTimeType) DurationValue_IsNil() bool {
    return s.attendancetimetype.DurationValue == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceTimeType) EndTime() *String {
    if s.attendancetimetype.EndTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.attendancetimetype.EndTime = ((*String)(v))
      }
      }
      return s.attendancetimetype.EndTime
    }
// Returns whether the element value for EndTime is nil in the container AttendanceTimeType.
  func (s *AttendanceTimeType) EndTime_IsNil() bool {
    return s.attendancetimetype.EndTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceTimeType) StartTime() *String {
    if s.attendancetimetype.StartTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.attendancetimetype.StartTime = ((*String)(v))
      }
      }
      return s.attendancetimetype.StartTime
    }
// Returns whether the element value for StartTime is nil in the container AttendanceTimeType.
  func (s *AttendanceTimeType) StartTime_IsNil() bool {
    return s.attendancetimetype.StartTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AttendanceTimeType) TimeTableSubjectRefId() *RefIdType {
    if s.attendancetimetype.TimeTableSubjectRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.attendancetimetype.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
      }
      return s.attendancetimetype.TimeTableSubjectRefId
    }
// Returns whether the element value for TimeTableSubjectRefId is nil in the container AttendanceTimeType.
  func (s *AttendanceTimeType) TimeTableSubjectRefId_IsNil() bool {
    return s.attendancetimetype.TimeTableSubjectRefId == nil
    }

// Set the value of a property to nil
func (n *AuditInfoType) Unset(key string) *AuditInfoType {
        switch key {
  case "CreationDateTime":
   n.auditinfotype.CreationDateTime = nil
  case "CreationUser":
   n.auditinfotype.CreationUser = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AuditInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *AuditInfoType) SetProperties(props ...Prop) *AuditInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AuditInfoType) SetProperty(key string, value interface{}) *AuditInfoType {
        if n == nil {
                n, _ = AuditInfoTypePointer(AuditInfoType{})
        }
        switch key {
    case "CreationDateTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.auditinfotype.CreationDateTime = ((*String)(v))
      }
    case "CreationUser":
    if v, ok:= CreationUserTypePointer(value); ok {
      n.auditinfotype.CreationUser = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AuditInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AuditInfoType) CreationDateTime() *String {
    if s.auditinfotype.CreationDateTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.auditinfotype.CreationDateTime = ((*String)(v))
      }
      }
      return s.auditinfotype.CreationDateTime
    }
// Returns whether the element value for CreationDateTime is nil in the container AuditInfoType.
  func (s *AuditInfoType) CreationDateTime_IsNil() bool {
    return s.auditinfotype.CreationDateTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AuditInfoType) CreationUser() *CreationUserType {
    if s.auditinfotype.CreationUser == nil {
     if v, ok:= CreationUserTypePointer(CreationUserType{}); ok {
      s.auditinfotype.CreationUser = v
      }
      }
      return s.auditinfotype.CreationUser
    }
// Returns whether the element value for CreationUser is nil in the container AuditInfoType.
  func (s *AuditInfoType) CreationUser_IsNil() bool {
    return s.auditinfotype.CreationUser == nil
    }

// Set the value of a property to nil
func (n *AwardContainerType) Unset(key string) *AwardContainerType {
        switch key {
  case "AwardDate":
   n.awardcontainertype.AwardDate = nil
  case "AwardDescription":
   n.awardcontainertype.AwardDescription = nil
  case "AwardNotes":
   n.awardcontainertype.AwardNotes = nil
  case "AwardType":
   n.awardcontainertype.AwardType = nil
  case "Status":
   n.awardcontainertype.Status = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AwardContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *AwardContainerType) SetProperties(props ...Prop) *AwardContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *AwardContainerType) SetProperty(key string, value interface{}) *AwardContainerType {
        if n == nil {
                n, _ = AwardContainerTypePointer(AwardContainerType{})
        }
        switch key {
    case "AwardDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.awardcontainertype.AwardDate = ((*String)(v))
      }
    case "AwardDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.awardcontainertype.AwardDescription = ((*String)(v))
      }
    case "AwardNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.awardcontainertype.AwardNotes = ((*String)(v))
      }
    case "AwardType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.awardcontainertype.AwardType = ((*String)(v))
      }
    case "Status":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.awardcontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "AwardContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AwardContainerType) AwardDate() *String {
    if s.awardcontainertype.AwardDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.awardcontainertype.AwardDate = ((*String)(v))
      }
      }
      return s.awardcontainertype.AwardDate
    }
// Returns whether the element value for AwardDate is nil in the container AwardContainerType.
  func (s *AwardContainerType) AwardDate_IsNil() bool {
    return s.awardcontainertype.AwardDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AwardContainerType) AwardDescription() *String {
    if s.awardcontainertype.AwardDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.awardcontainertype.AwardDescription = ((*String)(v))
      }
      }
      return s.awardcontainertype.AwardDescription
    }
// Returns whether the element value for AwardDescription is nil in the container AwardContainerType.
  func (s *AwardContainerType) AwardDescription_IsNil() bool {
    return s.awardcontainertype.AwardDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AwardContainerType) AwardNotes() *String {
    if s.awardcontainertype.AwardNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.awardcontainertype.AwardNotes = ((*String)(v))
      }
      }
      return s.awardcontainertype.AwardNotes
    }
// Returns whether the element value for AwardNotes is nil in the container AwardContainerType.
  func (s *AwardContainerType) AwardNotes_IsNil() bool {
    return s.awardcontainertype.AwardNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AwardContainerType) AwardType() *String {
    if s.awardcontainertype.AwardType == nil {
    if v, ok:= StringPointer(""); ok {
      s.awardcontainertype.AwardType = ((*String)(v))
      }
      }
      return s.awardcontainertype.AwardType
    }
// Returns whether the element value for AwardType is nil in the container AwardContainerType.
  func (s *AwardContainerType) AwardType_IsNil() bool {
    return s.awardcontainertype.AwardType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *AwardContainerType) Status() *AUCodeSetsWellbeingStatusType {
    if s.awardcontainertype.Status == nil {
    if v, ok:= StringPointer(""); ok {
      s.awardcontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
      }
      return s.awardcontainertype.Status
    }
// Returns whether the element value for Status is nil in the container AwardContainerType.
  func (s *AwardContainerType) Status_IsNil() bool {
    return s.awardcontainertype.Status == nil
    }

// Set the value of a property to nil
func (n *BaseNameType) Unset(key string) *BaseNameType {
        switch key {
  case "FamilyName":
   n.basenametype.FamilyName = nil
  case "FamilyNameFirst":
   n.basenametype.FamilyNameFirst = nil
  case "FullName":
   n.basenametype.FullName = nil
  case "GivenName":
   n.basenametype.GivenName = nil
  case "MiddleName":
   n.basenametype.MiddleName = nil
  case "PreferredFamilyName":
   n.basenametype.PreferredFamilyName = nil
  case "PreferredFamilyNameFirst":
   n.basenametype.PreferredFamilyNameFirst = nil
  case "PreferredGivenName":
   n.basenametype.PreferredGivenName = nil
  case "Suffix":
   n.basenametype.Suffix = nil
  case "Title":
   n.basenametype.Title = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "BaseNameType")
        }
        return n
}

// Set a sequence of properties
func (n *BaseNameType) SetProperties(props ...Prop) *BaseNameType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *BaseNameType) SetProperty(key string, value interface{}) *BaseNameType {
        if n == nil {
                n, _ = BaseNameTypePointer(BaseNameType{})
        }
        switch key {
    case "FamilyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.basenametype.FamilyName = ((*String)(v))
      }
    case "FamilyNameFirst":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.basenametype.FamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "FullName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.basenametype.FullName = ((*String)(v))
      }
    case "GivenName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.basenametype.GivenName = ((*String)(v))
      }
    case "MiddleName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.basenametype.MiddleName = ((*String)(v))
      }
    case "PreferredFamilyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.basenametype.PreferredFamilyName = ((*String)(v))
      }
    case "PreferredFamilyNameFirst":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.basenametype.PreferredFamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "PreferredGivenName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.basenametype.PreferredGivenName = ((*String)(v))
      }
    case "Suffix":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.basenametype.Suffix = ((*String)(v))
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.basenametype.Title = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "BaseNameType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) FamilyName() *String {
    if s.basenametype.FamilyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.FamilyName = ((*String)(v))
      }
      }
      return s.basenametype.FamilyName
    }
// Returns whether the element value for FamilyName is nil in the container BaseNameType.
  func (s *BaseNameType) FamilyName_IsNil() bool {
    return s.basenametype.FamilyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) FamilyNameFirst() *AUCodeSetsYesOrNoCategoryType {
    if s.basenametype.FamilyNameFirst == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.FamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.basenametype.FamilyNameFirst
    }
// Returns whether the element value for FamilyNameFirst is nil in the container BaseNameType.
  func (s *BaseNameType) FamilyNameFirst_IsNil() bool {
    return s.basenametype.FamilyNameFirst == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) FullName() *String {
    if s.basenametype.FullName == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.FullName = ((*String)(v))
      }
      }
      return s.basenametype.FullName
    }
// Returns whether the element value for FullName is nil in the container BaseNameType.
  func (s *BaseNameType) FullName_IsNil() bool {
    return s.basenametype.FullName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) GivenName() *String {
    if s.basenametype.GivenName == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.GivenName = ((*String)(v))
      }
      }
      return s.basenametype.GivenName
    }
// Returns whether the element value for GivenName is nil in the container BaseNameType.
  func (s *BaseNameType) GivenName_IsNil() bool {
    return s.basenametype.GivenName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) MiddleName() *String {
    if s.basenametype.MiddleName == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.MiddleName = ((*String)(v))
      }
      }
      return s.basenametype.MiddleName
    }
// Returns whether the element value for MiddleName is nil in the container BaseNameType.
  func (s *BaseNameType) MiddleName_IsNil() bool {
    return s.basenametype.MiddleName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) PreferredFamilyName() *String {
    if s.basenametype.PreferredFamilyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.PreferredFamilyName = ((*String)(v))
      }
      }
      return s.basenametype.PreferredFamilyName
    }
// Returns whether the element value for PreferredFamilyName is nil in the container BaseNameType.
  func (s *BaseNameType) PreferredFamilyName_IsNil() bool {
    return s.basenametype.PreferredFamilyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) PreferredFamilyNameFirst() *AUCodeSetsYesOrNoCategoryType {
    if s.basenametype.PreferredFamilyNameFirst == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.PreferredFamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.basenametype.PreferredFamilyNameFirst
    }
// Returns whether the element value for PreferredFamilyNameFirst is nil in the container BaseNameType.
  func (s *BaseNameType) PreferredFamilyNameFirst_IsNil() bool {
    return s.basenametype.PreferredFamilyNameFirst == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) PreferredGivenName() *String {
    if s.basenametype.PreferredGivenName == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.PreferredGivenName = ((*String)(v))
      }
      }
      return s.basenametype.PreferredGivenName
    }
// Returns whether the element value for PreferredGivenName is nil in the container BaseNameType.
  func (s *BaseNameType) PreferredGivenName_IsNil() bool {
    return s.basenametype.PreferredGivenName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) Suffix() *String {
    if s.basenametype.Suffix == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.Suffix = ((*String)(v))
      }
      }
      return s.basenametype.Suffix
    }
// Returns whether the element value for Suffix is nil in the container BaseNameType.
  func (s *BaseNameType) Suffix_IsNil() bool {
    return s.basenametype.Suffix == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BaseNameType) Title() *String {
    if s.basenametype.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.basenametype.Title = ((*String)(v))
      }
      }
      return s.basenametype.Title
    }
// Returns whether the element value for Title is nil in the container BaseNameType.
  func (s *BaseNameType) Title_IsNil() bool {
    return s.basenametype.Title == nil
    }

// Set the value of a property to nil
func (n *BinaryDataType) Unset(key string) *BinaryDataType {
        switch key {
  case "Description":
   n.binarydatatype.Description = nil
  case "FileName":
   n.binarydatatype.FileName = nil
  case "MIMEType":
   n.binarydatatype.MIMEType = nil
  case "Value":
   n.binarydatatype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "BinaryDataType")
        }
        return n
}

// Set a sequence of properties
func (n *BinaryDataType) SetProperties(props ...Prop) *BinaryDataType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *BinaryDataType) SetProperty(key string, value interface{}) *BinaryDataType {
        if n == nil {
                n, _ = BinaryDataTypePointer(BinaryDataType{})
        }
        switch key {
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.binarydatatype.Description = ((*String)(v))
      }
    case "FileName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.binarydatatype.FileName = ((*String)(v))
      }
    case "MIMEType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.binarydatatype.MIMEType = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.binarydatatype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "BinaryDataType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BinaryDataType) Description() *String {
    if s.binarydatatype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.binarydatatype.Description = ((*String)(v))
      }
      }
      return s.binarydatatype.Description
    }
// Returns whether the element value for Description is nil in the container BinaryDataType.
  func (s *BinaryDataType) Description_IsNil() bool {
    return s.binarydatatype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BinaryDataType) FileName() *String {
    if s.binarydatatype.FileName == nil {
    if v, ok:= StringPointer(""); ok {
      s.binarydatatype.FileName = ((*String)(v))
      }
      }
      return s.binarydatatype.FileName
    }
// Returns whether the element value for FileName is nil in the container BinaryDataType.
  func (s *BinaryDataType) FileName_IsNil() bool {
    return s.binarydatatype.FileName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BinaryDataType) MIMEType() *String {
    if s.binarydatatype.MIMEType == nil {
    if v, ok:= StringPointer(""); ok {
      s.binarydatatype.MIMEType = ((*String)(v))
      }
      }
      return s.binarydatatype.MIMEType
    }
// Returns whether the element value for MIMEType is nil in the container BinaryDataType.
  func (s *BinaryDataType) MIMEType_IsNil() bool {
    return s.binarydatatype.MIMEType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *BinaryDataType) Value() *String {
    if s.binarydatatype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.binarydatatype.Value = ((*String)(v))
      }
      }
      return s.binarydatatype.Value
    }
// Returns whether the element value for Value is nil in the container BinaryDataType.
  func (s *BinaryDataType) Value_IsNil() bool {
    return s.binarydatatype.Value == nil
    }

// Set the value of a property to nil
func (n *CalculationRuleType) Unset(key string) *CalculationRuleType {
        switch key {
  case "Type":
   n.calculationruletype.Type = nil
  case "Value":
   n.calculationruletype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CalculationRuleType")
        }
        return n
}

// Set a sequence of properties
func (n *CalculationRuleType) SetProperties(props ...Prop) *CalculationRuleType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CalculationRuleType) SetProperty(key string, value interface{}) *CalculationRuleType {
        if n == nil {
                n, _ = CalculationRuleTypePointer(CalculationRuleType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calculationruletype.Type = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calculationruletype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CalculationRuleType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalculationRuleType) Type() *String {
    if s.calculationruletype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.calculationruletype.Type = ((*String)(v))
      }
      }
      return s.calculationruletype.Type
    }
// Returns whether the element value for Type is nil in the container CalculationRuleType.
  func (s *CalculationRuleType) Type_IsNil() bool {
    return s.calculationruletype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalculationRuleType) Value() *String {
    if s.calculationruletype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.calculationruletype.Value = ((*String)(v))
      }
      }
      return s.calculationruletype.Value
    }
// Returns whether the element value for Value is nil in the container CalculationRuleType.
  func (s *CalculationRuleType) Value_IsNil() bool {
    return s.calculationruletype.Value == nil
    }

// Set the value of a property to nil
func (n *CalendarDate) Unset(key string) *CalendarDate {
        switch key {
  case "AdministratorAttendance":
   n.calendardate.AdministratorAttendance = nil
  case "CalendarDateNumber":
   n.calendardate.CalendarDateNumber = nil
  case "CalendarDateRefId":
   n.calendardate.CalendarDateRefId = nil
  case "CalendarDateType":
   n.calendardate.CalendarDateType = nil
  case "CalendarSummaryRefId":
   n.calendardate.CalendarSummaryRefId = nil
  case "Date":
   n.calendardate.Date = nil
  case "LocalCodeList":
   n.calendardate.LocalCodeList = nil
  case "SIF_ExtendedElements":
   n.calendardate.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.calendardate.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.calendardate.SchoolInfoRefId = nil
  case "SchoolYear":
   n.calendardate.SchoolYear = nil
  case "StudentAttendance":
   n.calendardate.StudentAttendance = nil
  case "TeacherAttendance":
   n.calendardate.TeacherAttendance = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CalendarDate")
        }
        return n
}

// Set a sequence of properties
func (n *CalendarDate) SetProperties(props ...Prop) *CalendarDate {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CalendarDate) SetProperty(key string, value interface{}) *CalendarDate {
        if n == nil {
                n, _ = CalendarDatePointer(CalendarDate{})
        }
        switch key {
    case "AdministratorAttendance":
    if v, ok:= AttendanceInfoTypePointer(value); ok {
      n.calendardate.AdministratorAttendance = v
      }
    case "CalendarDateNumber":
    
    if v, ok:= IntPointer(value); ok {
      n.calendardate.CalendarDateNumber = ((*Int)(v))
      }
    case "CalendarDateRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendardate.CalendarDateRefId = ((*String)(v))
      }
    case "CalendarDateType":
    if v, ok:= CalendarDateInfoTypePointer(value); ok {
      n.calendardate.CalendarDateType = v
      }
    case "CalendarSummaryRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendardate.CalendarSummaryRefId = ((*String)(v))
      }
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendardate.Date = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.calendardate.LocalCodeList = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.calendardate.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.calendardate.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendardate.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendardate.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StudentAttendance":
    if v, ok:= AttendanceInfoTypePointer(value); ok {
      n.calendardate.StudentAttendance = v
      }
    case "TeacherAttendance":
    if v, ok:= AttendanceInfoTypePointer(value); ok {
      n.calendardate.TeacherAttendance = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CalendarDate")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) AdministratorAttendance() *AttendanceInfoType {
    if s.calendardate.AdministratorAttendance == nil {
     if v, ok:= AttendanceInfoTypePointer(AttendanceInfoType{}); ok {
      s.calendardate.AdministratorAttendance = v
      }
      }
      return s.calendardate.AdministratorAttendance
    }
// Returns whether the element value for AdministratorAttendance is nil in the container CalendarDate.
  func (s *CalendarDate) AdministratorAttendance_IsNil() bool {
    return s.calendardate.AdministratorAttendance == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) CalendarDateNumber() *Int {
    if s.calendardate.CalendarDateNumber == nil {
    if v, ok:= IntPointer(0); ok {
      s.calendardate.CalendarDateNumber = ((*Int)(v))
      }
      }
      return s.calendardate.CalendarDateNumber
    }
// Returns whether the element value for CalendarDateNumber is nil in the container CalendarDate.
  func (s *CalendarDate) CalendarDateNumber_IsNil() bool {
    return s.calendardate.CalendarDateNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) CalendarDateRefId() *String {
    if s.calendardate.CalendarDateRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendardate.CalendarDateRefId = ((*String)(v))
      }
      }
      return s.calendardate.CalendarDateRefId
    }
// Returns whether the element value for CalendarDateRefId is nil in the container CalendarDate.
  func (s *CalendarDate) CalendarDateRefId_IsNil() bool {
    return s.calendardate.CalendarDateRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) CalendarDateType() *CalendarDateInfoType {
    if s.calendardate.CalendarDateType == nil {
     if v, ok:= CalendarDateInfoTypePointer(CalendarDateInfoType{}); ok {
      s.calendardate.CalendarDateType = v
      }
      }
      return s.calendardate.CalendarDateType
    }
// Returns whether the element value for CalendarDateType is nil in the container CalendarDate.
  func (s *CalendarDate) CalendarDateType_IsNil() bool {
    return s.calendardate.CalendarDateType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) CalendarSummaryRefId() *String {
    if s.calendardate.CalendarSummaryRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendardate.CalendarSummaryRefId = ((*String)(v))
      }
      }
      return s.calendardate.CalendarSummaryRefId
    }
// Returns whether the element value for CalendarSummaryRefId is nil in the container CalendarDate.
  func (s *CalendarDate) CalendarSummaryRefId_IsNil() bool {
    return s.calendardate.CalendarSummaryRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) Date() *String {
    if s.calendardate.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendardate.Date = ((*String)(v))
      }
      }
      return s.calendardate.Date
    }
// Returns whether the element value for Date is nil in the container CalendarDate.
  func (s *CalendarDate) Date_IsNil() bool {
    return s.calendardate.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) LocalCodeList() *LocalCodeListType {
    if s.calendardate.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.calendardate.LocalCodeList = v
      }
      }
      return s.calendardate.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container CalendarDate.
  func (s *CalendarDate) LocalCodeList_IsNil() bool {
    return s.calendardate.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.calendardate.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.calendardate.SIF_ExtendedElements = v
      }
      }
      return s.calendardate.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container CalendarDate.
  func (s *CalendarDate) SIF_ExtendedElements_IsNil() bool {
    return s.calendardate.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) SIF_Metadata() *SIF_MetadataType {
    if s.calendardate.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.calendardate.SIF_Metadata = v
      }
      }
      return s.calendardate.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container CalendarDate.
  func (s *CalendarDate) SIF_Metadata_IsNil() bool {
    return s.calendardate.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) SchoolInfoRefId() *String {
    if s.calendardate.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendardate.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.calendardate.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container CalendarDate.
  func (s *CalendarDate) SchoolInfoRefId_IsNil() bool {
    return s.calendardate.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) SchoolYear() *SchoolYearType {
    if s.calendardate.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendardate.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.calendardate.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container CalendarDate.
  func (s *CalendarDate) SchoolYear_IsNil() bool {
    return s.calendardate.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) StudentAttendance() *AttendanceInfoType {
    if s.calendardate.StudentAttendance == nil {
     if v, ok:= AttendanceInfoTypePointer(AttendanceInfoType{}); ok {
      s.calendardate.StudentAttendance = v
      }
      }
      return s.calendardate.StudentAttendance
    }
// Returns whether the element value for StudentAttendance is nil in the container CalendarDate.
  func (s *CalendarDate) StudentAttendance_IsNil() bool {
    return s.calendardate.StudentAttendance == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDate) TeacherAttendance() *AttendanceInfoType {
    if s.calendardate.TeacherAttendance == nil {
     if v, ok:= AttendanceInfoTypePointer(AttendanceInfoType{}); ok {
      s.calendardate.TeacherAttendance = v
      }
      }
      return s.calendardate.TeacherAttendance
    }
// Returns whether the element value for TeacherAttendance is nil in the container CalendarDate.
  func (s *CalendarDate) TeacherAttendance_IsNil() bool {
    return s.calendardate.TeacherAttendance == nil
    }

// Set the value of a property to nil
func (n *CalendarDateInfoType) Unset(key string) *CalendarDateInfoType {
        switch key {
  case "Code":
   n.calendardateinfotype.Code = nil
  case "OtherCodeList":
   n.calendardateinfotype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CalendarDateInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *CalendarDateInfoType) SetProperties(props ...Prop) *CalendarDateInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CalendarDateInfoType) SetProperty(key string, value interface{}) *CalendarDateInfoType {
        if n == nil {
                n, _ = CalendarDateInfoTypePointer(CalendarDateInfoType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsCalendarEventType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsCalendarEventType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.calendardateinfotype.Code = ((*AUCodeSetsCalendarEventType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.calendardateinfotype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CalendarDateInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDateInfoType) Code() *AUCodeSetsCalendarEventType {
    if s.calendardateinfotype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendardateinfotype.Code = ((*AUCodeSetsCalendarEventType)(v))
      }
      }
      return s.calendardateinfotype.Code
    }
// Returns whether the element value for Code is nil in the container CalendarDateInfoType.
  func (s *CalendarDateInfoType) Code_IsNil() bool {
    return s.calendardateinfotype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarDateInfoType) OtherCodeList() *OtherCodeListType {
    if s.calendardateinfotype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.calendardateinfotype.OtherCodeList = v
      }
      }
      return s.calendardateinfotype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container CalendarDateInfoType.
  func (s *CalendarDateInfoType) OtherCodeList_IsNil() bool {
    return s.calendardateinfotype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *CalendarSummary) Unset(key string) *CalendarSummary {
        switch key {
  case "DaysInSession":
   n.calendarsummary.DaysInSession = nil
  case "Description":
   n.calendarsummary.Description = nil
  case "EndDate":
   n.calendarsummary.EndDate = nil
  case "FirstInstructionDate":
   n.calendarsummary.FirstInstructionDate = nil
  case "GraduationDate":
   n.calendarsummary.GraduationDate = nil
  case "InstructionalMinutes":
   n.calendarsummary.InstructionalMinutes = nil
  case "LastInstructionDate":
   n.calendarsummary.LastInstructionDate = nil
  case "LocalCodeList":
   n.calendarsummary.LocalCodeList = nil
  case "LocalId":
   n.calendarsummary.LocalId = nil
  case "MinutesPerDay":
   n.calendarsummary.MinutesPerDay = nil
  case "RefId":
   n.calendarsummary.RefId = nil
  case "SIF_ExtendedElements":
   n.calendarsummary.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.calendarsummary.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.calendarsummary.SchoolInfoRefId = nil
  case "SchoolYear":
   n.calendarsummary.SchoolYear = nil
  case "StartDate":
   n.calendarsummary.StartDate = nil
  case "YearLevels":
   n.calendarsummary.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CalendarSummary")
        }
        return n
}

// Set a sequence of properties
func (n *CalendarSummary) SetProperties(props ...Prop) *CalendarSummary {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CalendarSummary) SetProperty(key string, value interface{}) *CalendarSummary {
        if n == nil {
                n, _ = CalendarSummaryPointer(CalendarSummary{})
        }
        switch key {
    case "DaysInSession":
    
    if v, ok:= IntPointer(value); ok {
      n.calendarsummary.DaysInSession = ((*Int)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.Description = ((*String)(v))
      }
    case "EndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.EndDate = ((*String)(v))
      }
    case "FirstInstructionDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.FirstInstructionDate = ((*String)(v))
      }
    case "GraduationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.GraduationDate = ((*GraduationDateType)(v))
      }
    case "InstructionalMinutes":
    
    if v, ok:= IntPointer(value); ok {
      n.calendarsummary.InstructionalMinutes = ((*Int)(v))
      }
    case "LastInstructionDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.LastInstructionDate = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.calendarsummary.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.LocalId = ((*LocalIdType)(v))
      }
    case "MinutesPerDay":
    
    if v, ok:= IntPointer(value); ok {
      n.calendarsummary.MinutesPerDay = ((*Int)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.calendarsummary.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.calendarsummary.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.calendarsummary.StartDate = ((*String)(v))
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.calendarsummary.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CalendarSummary")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) DaysInSession() *Int {
    if s.calendarsummary.DaysInSession == nil {
    if v, ok:= IntPointer(0); ok {
      s.calendarsummary.DaysInSession = ((*Int)(v))
      }
      }
      return s.calendarsummary.DaysInSession
    }
// Returns whether the element value for DaysInSession is nil in the container CalendarSummary.
  func (s *CalendarSummary) DaysInSession_IsNil() bool {
    return s.calendarsummary.DaysInSession == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) Description() *String {
    if s.calendarsummary.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.Description = ((*String)(v))
      }
      }
      return s.calendarsummary.Description
    }
// Returns whether the element value for Description is nil in the container CalendarSummary.
  func (s *CalendarSummary) Description_IsNil() bool {
    return s.calendarsummary.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) EndDate() *String {
    if s.calendarsummary.EndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.EndDate = ((*String)(v))
      }
      }
      return s.calendarsummary.EndDate
    }
// Returns whether the element value for EndDate is nil in the container CalendarSummary.
  func (s *CalendarSummary) EndDate_IsNil() bool {
    return s.calendarsummary.EndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) FirstInstructionDate() *String {
    if s.calendarsummary.FirstInstructionDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.FirstInstructionDate = ((*String)(v))
      }
      }
      return s.calendarsummary.FirstInstructionDate
    }
// Returns whether the element value for FirstInstructionDate is nil in the container CalendarSummary.
  func (s *CalendarSummary) FirstInstructionDate_IsNil() bool {
    return s.calendarsummary.FirstInstructionDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) GraduationDate() *GraduationDateType {
    if s.calendarsummary.GraduationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.GraduationDate = ((*GraduationDateType)(v))
      }
      }
      return s.calendarsummary.GraduationDate
    }
// Returns whether the element value for GraduationDate is nil in the container CalendarSummary.
  func (s *CalendarSummary) GraduationDate_IsNil() bool {
    return s.calendarsummary.GraduationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) InstructionalMinutes() *Int {
    if s.calendarsummary.InstructionalMinutes == nil {
    if v, ok:= IntPointer(0); ok {
      s.calendarsummary.InstructionalMinutes = ((*Int)(v))
      }
      }
      return s.calendarsummary.InstructionalMinutes
    }
// Returns whether the element value for InstructionalMinutes is nil in the container CalendarSummary.
  func (s *CalendarSummary) InstructionalMinutes_IsNil() bool {
    return s.calendarsummary.InstructionalMinutes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) LastInstructionDate() *String {
    if s.calendarsummary.LastInstructionDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.LastInstructionDate = ((*String)(v))
      }
      }
      return s.calendarsummary.LastInstructionDate
    }
// Returns whether the element value for LastInstructionDate is nil in the container CalendarSummary.
  func (s *CalendarSummary) LastInstructionDate_IsNil() bool {
    return s.calendarsummary.LastInstructionDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) LocalCodeList() *LocalCodeListType {
    if s.calendarsummary.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.calendarsummary.LocalCodeList = v
      }
      }
      return s.calendarsummary.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container CalendarSummary.
  func (s *CalendarSummary) LocalCodeList_IsNil() bool {
    return s.calendarsummary.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) LocalId() *LocalIdType {
    if s.calendarsummary.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.calendarsummary.LocalId
    }
// Returns whether the element value for LocalId is nil in the container CalendarSummary.
  func (s *CalendarSummary) LocalId_IsNil() bool {
    return s.calendarsummary.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) MinutesPerDay() *Int {
    if s.calendarsummary.MinutesPerDay == nil {
    if v, ok:= IntPointer(0); ok {
      s.calendarsummary.MinutesPerDay = ((*Int)(v))
      }
      }
      return s.calendarsummary.MinutesPerDay
    }
// Returns whether the element value for MinutesPerDay is nil in the container CalendarSummary.
  func (s *CalendarSummary) MinutesPerDay_IsNil() bool {
    return s.calendarsummary.MinutesPerDay == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) RefId() *RefIdType {
    if s.calendarsummary.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.RefId = ((*RefIdType)(v))
      }
      }
      return s.calendarsummary.RefId
    }
// Returns whether the element value for RefId is nil in the container CalendarSummary.
  func (s *CalendarSummary) RefId_IsNil() bool {
    return s.calendarsummary.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.calendarsummary.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.calendarsummary.SIF_ExtendedElements = v
      }
      }
      return s.calendarsummary.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container CalendarSummary.
  func (s *CalendarSummary) SIF_ExtendedElements_IsNil() bool {
    return s.calendarsummary.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) SIF_Metadata() *SIF_MetadataType {
    if s.calendarsummary.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.calendarsummary.SIF_Metadata = v
      }
      }
      return s.calendarsummary.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container CalendarSummary.
  func (s *CalendarSummary) SIF_Metadata_IsNil() bool {
    return s.calendarsummary.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) SchoolInfoRefId() *String {
    if s.calendarsummary.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.calendarsummary.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container CalendarSummary.
  func (s *CalendarSummary) SchoolInfoRefId_IsNil() bool {
    return s.calendarsummary.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) SchoolYear() *SchoolYearType {
    if s.calendarsummary.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.calendarsummary.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container CalendarSummary.
  func (s *CalendarSummary) SchoolYear_IsNil() bool {
    return s.calendarsummary.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) StartDate() *String {
    if s.calendarsummary.StartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.calendarsummary.StartDate = ((*String)(v))
      }
      }
      return s.calendarsummary.StartDate
    }
// Returns whether the element value for StartDate is nil in the container CalendarSummary.
  func (s *CalendarSummary) StartDate_IsNil() bool {
    return s.calendarsummary.StartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CalendarSummary) YearLevels() *YearLevelsType {
    if s.calendarsummary.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.calendarsummary.YearLevels = v
      }
      }
      return s.calendarsummary.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container CalendarSummary.
  func (s *CalendarSummary) YearLevels_IsNil() bool {
    return s.calendarsummary.YearLevels == nil
    }

// Set the value of a property to nil
func (n *CampusContainerType) Unset(key string) *CampusContainerType {
        switch key {
  case "AdminStatus":
   n.campuscontainertype.AdminStatus = nil
  case "CampusType":
   n.campuscontainertype.CampusType = nil
  case "ParentSchoolId":
   n.campuscontainertype.ParentSchoolId = nil
  case "ParentSchoolRefId":
   n.campuscontainertype.ParentSchoolRefId = nil
  case "SchoolCampusId":
   n.campuscontainertype.SchoolCampusId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CampusContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *CampusContainerType) SetProperties(props ...Prop) *CampusContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CampusContainerType) SetProperty(key string, value interface{}) *CampusContainerType {
        if n == nil {
                n, _ = CampusContainerTypePointer(CampusContainerType{})
        }
        switch key {
    case "AdminStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.campuscontainertype.AdminStatus = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "CampusType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolLevelType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolLevelType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.campuscontainertype.CampusType = ((*AUCodeSetsSchoolLevelType)(v))
      }
    case "ParentSchoolId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.campuscontainertype.ParentSchoolId = ((*String)(v))
      }
    case "ParentSchoolRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.campuscontainertype.ParentSchoolRefId = ((*String)(v))
      }
    case "SchoolCampusId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.campuscontainertype.SchoolCampusId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CampusContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CampusContainerType) AdminStatus() *AUCodeSetsYesOrNoCategoryType {
    if s.campuscontainertype.AdminStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.campuscontainertype.AdminStatus = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.campuscontainertype.AdminStatus
    }
// Returns whether the element value for AdminStatus is nil in the container CampusContainerType.
  func (s *CampusContainerType) AdminStatus_IsNil() bool {
    return s.campuscontainertype.AdminStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CampusContainerType) CampusType() *AUCodeSetsSchoolLevelType {
    if s.campuscontainertype.CampusType == nil {
    if v, ok:= StringPointer(""); ok {
      s.campuscontainertype.CampusType = ((*AUCodeSetsSchoolLevelType)(v))
      }
      }
      return s.campuscontainertype.CampusType
    }
// Returns whether the element value for CampusType is nil in the container CampusContainerType.
  func (s *CampusContainerType) CampusType_IsNil() bool {
    return s.campuscontainertype.CampusType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CampusContainerType) ParentSchoolId() *String {
    if s.campuscontainertype.ParentSchoolId == nil {
    if v, ok:= StringPointer(""); ok {
      s.campuscontainertype.ParentSchoolId = ((*String)(v))
      }
      }
      return s.campuscontainertype.ParentSchoolId
    }
// Returns whether the element value for ParentSchoolId is nil in the container CampusContainerType.
  func (s *CampusContainerType) ParentSchoolId_IsNil() bool {
    return s.campuscontainertype.ParentSchoolId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CampusContainerType) ParentSchoolRefId() *String {
    if s.campuscontainertype.ParentSchoolRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.campuscontainertype.ParentSchoolRefId = ((*String)(v))
      }
      }
      return s.campuscontainertype.ParentSchoolRefId
    }
// Returns whether the element value for ParentSchoolRefId is nil in the container CampusContainerType.
  func (s *CampusContainerType) ParentSchoolRefId_IsNil() bool {
    return s.campuscontainertype.ParentSchoolRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CampusContainerType) SchoolCampusId() *String {
    if s.campuscontainertype.SchoolCampusId == nil {
    if v, ok:= StringPointer(""); ok {
      s.campuscontainertype.SchoolCampusId = ((*String)(v))
      }
      }
      return s.campuscontainertype.SchoolCampusId
    }
// Returns whether the element value for SchoolCampusId is nil in the container CampusContainerType.
  func (s *CampusContainerType) SchoolCampusId_IsNil() bool {
    return s.campuscontainertype.SchoolCampusId == nil
    }

// Set the value of a property to nil
func (n *CatchmentStatusContainerType) Unset(key string) *CatchmentStatusContainerType {
        switch key {
  case "Code":
   n.catchmentstatuscontainertype.Code = nil
  case "OtherCodeList":
   n.catchmentstatuscontainertype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CatchmentStatusContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *CatchmentStatusContainerType) SetProperties(props ...Prop) *CatchmentStatusContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CatchmentStatusContainerType) SetProperty(key string, value interface{}) *CatchmentStatusContainerType {
        if n == nil {
                n, _ = CatchmentStatusContainerTypePointer(CatchmentStatusContainerType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsPublicSchoolCatchmentStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsPublicSchoolCatchmentStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.catchmentstatuscontainertype.Code = ((*AUCodeSetsPublicSchoolCatchmentStatusType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.catchmentstatuscontainertype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CatchmentStatusContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CatchmentStatusContainerType) Code() *AUCodeSetsPublicSchoolCatchmentStatusType {
    if s.catchmentstatuscontainertype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.catchmentstatuscontainertype.Code = ((*AUCodeSetsPublicSchoolCatchmentStatusType)(v))
      }
      }
      return s.catchmentstatuscontainertype.Code
    }
// Returns whether the element value for Code is nil in the container CatchmentStatusContainerType.
  func (s *CatchmentStatusContainerType) Code_IsNil() bool {
    return s.catchmentstatuscontainertype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CatchmentStatusContainerType) OtherCodeList() *OtherCodeListType {
    if s.catchmentstatuscontainertype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.catchmentstatuscontainertype.OtherCodeList = v
      }
      }
      return s.catchmentstatuscontainertype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container CatchmentStatusContainerType.
  func (s *CatchmentStatusContainerType) OtherCodeList_IsNil() bool {
    return s.catchmentstatuscontainertype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *CensusCollection) Unset(key string) *CensusCollection {
        switch key {
  case "CensusReportingList":
   n.censuscollection.CensusReportingList = nil
  case "CensusYear":
   n.censuscollection.CensusYear = nil
  case "LocalCodeList":
   n.censuscollection.LocalCodeList = nil
  case "RefId":
   n.censuscollection.RefId = nil
  case "RoundCode":
   n.censuscollection.RoundCode = nil
  case "SIF_ExtendedElements":
   n.censuscollection.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.censuscollection.SIF_Metadata = nil
  case "SoftwareVendorInfo":
   n.censuscollection.SoftwareVendorInfo = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CensusCollection")
        }
        return n
}

// Set a sequence of properties
func (n *CensusCollection) SetProperties(props ...Prop) *CensusCollection {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CensusCollection) SetProperty(key string, value interface{}) *CensusCollection {
        if n == nil {
                n, _ = CensusCollectionPointer(CensusCollection{})
        }
        switch key {
    case "CensusReportingList":
    if v, ok:= CensusReportingListTypePointer(value); ok {
      n.censuscollection.CensusReportingList = v
      }
    case "CensusYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censuscollection.CensusYear = ((*SchoolYearType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.censuscollection.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censuscollection.RefId = ((*RefIdType)(v))
      }
    case "RoundCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censuscollection.RoundCode = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.censuscollection.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.censuscollection.SIF_Metadata = v
      }
    case "SoftwareVendorInfo":
    if v, ok:= SoftwareVendorInfoContainerTypePointer(value); ok {
      n.censuscollection.SoftwareVendorInfo = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CensusCollection")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusCollection) CensusReportingList() *CensusReportingListType {
    if s.censuscollection.CensusReportingList == nil {
     if v, ok:= CensusReportingListTypePointer(CensusReportingListType{}); ok {
      s.censuscollection.CensusReportingList = v
      }
      }
      return s.censuscollection.CensusReportingList
    }
// Returns whether the element value for CensusReportingList is nil in the container CensusCollection.
  func (s *CensusCollection) CensusReportingList_IsNil() bool {
    return s.censuscollection.CensusReportingList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusCollection) CensusYear() *SchoolYearType {
    if s.censuscollection.CensusYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.censuscollection.CensusYear = ((*SchoolYearType)(v))
      }
      }
      return s.censuscollection.CensusYear
    }
// Returns whether the element value for CensusYear is nil in the container CensusCollection.
  func (s *CensusCollection) CensusYear_IsNil() bool {
    return s.censuscollection.CensusYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusCollection) LocalCodeList() *LocalCodeListType {
    if s.censuscollection.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.censuscollection.LocalCodeList = v
      }
      }
      return s.censuscollection.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container CensusCollection.
  func (s *CensusCollection) LocalCodeList_IsNil() bool {
    return s.censuscollection.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusCollection) RefId() *RefIdType {
    if s.censuscollection.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.censuscollection.RefId = ((*RefIdType)(v))
      }
      }
      return s.censuscollection.RefId
    }
// Returns whether the element value for RefId is nil in the container CensusCollection.
  func (s *CensusCollection) RefId_IsNil() bool {
    return s.censuscollection.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusCollection) RoundCode() *String {
    if s.censuscollection.RoundCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.censuscollection.RoundCode = ((*String)(v))
      }
      }
      return s.censuscollection.RoundCode
    }
// Returns whether the element value for RoundCode is nil in the container CensusCollection.
  func (s *CensusCollection) RoundCode_IsNil() bool {
    return s.censuscollection.RoundCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusCollection) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.censuscollection.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.censuscollection.SIF_ExtendedElements = v
      }
      }
      return s.censuscollection.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container CensusCollection.
  func (s *CensusCollection) SIF_ExtendedElements_IsNil() bool {
    return s.censuscollection.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusCollection) SIF_Metadata() *SIF_MetadataType {
    if s.censuscollection.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.censuscollection.SIF_Metadata = v
      }
      }
      return s.censuscollection.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container CensusCollection.
  func (s *CensusCollection) SIF_Metadata_IsNil() bool {
    return s.censuscollection.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusCollection) SoftwareVendorInfo() *SoftwareVendorInfoContainerType {
    if s.censuscollection.SoftwareVendorInfo == nil {
     if v, ok:= SoftwareVendorInfoContainerTypePointer(SoftwareVendorInfoContainerType{}); ok {
      s.censuscollection.SoftwareVendorInfo = v
      }
      }
      return s.censuscollection.SoftwareVendorInfo
    }
// Returns whether the element value for SoftwareVendorInfo is nil in the container CensusCollection.
  func (s *CensusCollection) SoftwareVendorInfo_IsNil() bool {
    return s.censuscollection.SoftwareVendorInfo == nil
    }

// Set the value of a property to nil
func (n *CensusReportingType) Unset(key string) *CensusReportingType {
        switch key {
  case "CensusStaffList":
   n.censusreportingtype.CensusStaffList = nil
  case "CensusStudentList":
   n.censusreportingtype.CensusStudentList = nil
  case "CommonwealthId":
   n.censusreportingtype.CommonwealthId = nil
  case "EntityContact":
   n.censusreportingtype.EntityContact = nil
  case "EntityLevel":
   n.censusreportingtype.EntityLevel = nil
  case "EntityName":
   n.censusreportingtype.EntityName = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CensusReportingType")
        }
        return n
}

// Set a sequence of properties
func (n *CensusReportingType) SetProperties(props ...Prop) *CensusReportingType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CensusReportingType) SetProperty(key string, value interface{}) *CensusReportingType {
        if n == nil {
                n, _ = CensusReportingTypePointer(CensusReportingType{})
        }
        switch key {
    case "CensusStaffList":
    if v, ok:= CensusStaffListTypePointer(value); ok {
      n.censusreportingtype.CensusStaffList = v
      }
    case "CensusStudentList":
    if v, ok:= CensusStudentListTypePointer(value); ok {
      n.censusreportingtype.CensusStudentList = v
      }
    case "CommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusreportingtype.CommonwealthId = ((*String)(v))
      }
    case "EntityContact":
    if v, ok:= EntityContactInfoTypePointer(value); ok {
      n.censusreportingtype.EntityContact = v
      }
    case "EntityLevel":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusreportingtype.EntityLevel = ((*String)(v))
      }
    case "EntityName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusreportingtype.EntityName = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CensusReportingType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusReportingType) CensusStaffList() *CensusStaffListType {
    if s.censusreportingtype.CensusStaffList == nil {
     if v, ok:= CensusStaffListTypePointer(CensusStaffListType{}); ok {
      s.censusreportingtype.CensusStaffList = v
      }
      }
      return s.censusreportingtype.CensusStaffList
    }
// Returns whether the element value for CensusStaffList is nil in the container CensusReportingType.
  func (s *CensusReportingType) CensusStaffList_IsNil() bool {
    return s.censusreportingtype.CensusStaffList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusReportingType) CensusStudentList() *CensusStudentListType {
    if s.censusreportingtype.CensusStudentList == nil {
     if v, ok:= CensusStudentListTypePointer(CensusStudentListType{}); ok {
      s.censusreportingtype.CensusStudentList = v
      }
      }
      return s.censusreportingtype.CensusStudentList
    }
// Returns whether the element value for CensusStudentList is nil in the container CensusReportingType.
  func (s *CensusReportingType) CensusStudentList_IsNil() bool {
    return s.censusreportingtype.CensusStudentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusReportingType) CommonwealthId() *String {
    if s.censusreportingtype.CommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusreportingtype.CommonwealthId = ((*String)(v))
      }
      }
      return s.censusreportingtype.CommonwealthId
    }
// Returns whether the element value for CommonwealthId is nil in the container CensusReportingType.
  func (s *CensusReportingType) CommonwealthId_IsNil() bool {
    return s.censusreportingtype.CommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusReportingType) EntityContact() *EntityContactInfoType {
    if s.censusreportingtype.EntityContact == nil {
     if v, ok:= EntityContactInfoTypePointer(EntityContactInfoType{}); ok {
      s.censusreportingtype.EntityContact = v
      }
      }
      return s.censusreportingtype.EntityContact
    }
// Returns whether the element value for EntityContact is nil in the container CensusReportingType.
  func (s *CensusReportingType) EntityContact_IsNil() bool {
    return s.censusreportingtype.EntityContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusReportingType) EntityLevel() *String {
    if s.censusreportingtype.EntityLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusreportingtype.EntityLevel = ((*String)(v))
      }
      }
      return s.censusreportingtype.EntityLevel
    }
// Returns whether the element value for EntityLevel is nil in the container CensusReportingType.
  func (s *CensusReportingType) EntityLevel_IsNil() bool {
    return s.censusreportingtype.EntityLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusReportingType) EntityName() *String {
    if s.censusreportingtype.EntityName == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusreportingtype.EntityName = ((*String)(v))
      }
      }
      return s.censusreportingtype.EntityName
    }
// Returns whether the element value for EntityName is nil in the container CensusReportingType.
  func (s *CensusReportingType) EntityName_IsNil() bool {
    return s.censusreportingtype.EntityName == nil
    }

// Set the value of a property to nil
func (n *CensusStaffType) Unset(key string) *CensusStaffType {
        switch key {
  case "CohortGender":
   n.censusstafftype.CohortGender = nil
  case "CohortIndigenousType":
   n.censusstafftype.CohortIndigenousType = nil
  case "Headcount":
   n.censusstafftype.Headcount = nil
  case "JobFTE":
   n.censusstafftype.JobFTE = nil
  case "PrimaryFTE":
   n.censusstafftype.PrimaryFTE = nil
  case "SecondaryFTE":
   n.censusstafftype.SecondaryFTE = nil
  case "StaffActivity":
   n.censusstafftype.StaffActivity = nil
  case "StaffCohortId":
   n.censusstafftype.StaffCohortId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CensusStaffType")
        }
        return n
}

// Set a sequence of properties
func (n *CensusStaffType) SetProperties(props ...Prop) *CensusStaffType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CensusStaffType) SetProperty(key string, value interface{}) *CensusStaffType {
        if n == nil {
                n, _ = CensusStaffTypePointer(CensusStaffType{})
        }
        switch key {
    case "CohortGender":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstafftype.CohortGender = ((*String)(v))
      }
    case "CohortIndigenousType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstafftype.CohortIndigenousType = ((*String)(v))
      }
    case "Headcount":
    
    if v, ok:= IntPointer(value); ok {
      n.censusstafftype.Headcount = ((*Int)(v))
      }
    case "JobFTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstafftype.JobFTE = ((*String)(v))
      }
    case "PrimaryFTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstafftype.PrimaryFTE = ((*String)(v))
      }
    case "SecondaryFTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstafftype.SecondaryFTE = ((*String)(v))
      }
    case "StaffActivity":
    if v, ok:= StaffActivityExtensionTypePointer(value); ok {
      n.censusstafftype.StaffActivity = v
      }
    case "StaffCohortId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstafftype.StaffCohortId = ((*LocalIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CensusStaffType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStaffType) CohortGender() *String {
    if s.censusstafftype.CohortGender == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstafftype.CohortGender = ((*String)(v))
      }
      }
      return s.censusstafftype.CohortGender
    }
// Returns whether the element value for CohortGender is nil in the container CensusStaffType.
  func (s *CensusStaffType) CohortGender_IsNil() bool {
    return s.censusstafftype.CohortGender == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStaffType) CohortIndigenousType() *String {
    if s.censusstafftype.CohortIndigenousType == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstafftype.CohortIndigenousType = ((*String)(v))
      }
      }
      return s.censusstafftype.CohortIndigenousType
    }
// Returns whether the element value for CohortIndigenousType is nil in the container CensusStaffType.
  func (s *CensusStaffType) CohortIndigenousType_IsNil() bool {
    return s.censusstafftype.CohortIndigenousType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStaffType) Headcount() *Int {
    if s.censusstafftype.Headcount == nil {
    if v, ok:= IntPointer(0); ok {
      s.censusstafftype.Headcount = ((*Int)(v))
      }
      }
      return s.censusstafftype.Headcount
    }
// Returns whether the element value for Headcount is nil in the container CensusStaffType.
  func (s *CensusStaffType) Headcount_IsNil() bool {
    return s.censusstafftype.Headcount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStaffType) JobFTE() *String {
    if s.censusstafftype.JobFTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstafftype.JobFTE = ((*String)(v))
      }
      }
      return s.censusstafftype.JobFTE
    }
// Returns whether the element value for JobFTE is nil in the container CensusStaffType.
  func (s *CensusStaffType) JobFTE_IsNil() bool {
    return s.censusstafftype.JobFTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStaffType) PrimaryFTE() *String {
    if s.censusstafftype.PrimaryFTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstafftype.PrimaryFTE = ((*String)(v))
      }
      }
      return s.censusstafftype.PrimaryFTE
    }
// Returns whether the element value for PrimaryFTE is nil in the container CensusStaffType.
  func (s *CensusStaffType) PrimaryFTE_IsNil() bool {
    return s.censusstafftype.PrimaryFTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStaffType) SecondaryFTE() *String {
    if s.censusstafftype.SecondaryFTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstafftype.SecondaryFTE = ((*String)(v))
      }
      }
      return s.censusstafftype.SecondaryFTE
    }
// Returns whether the element value for SecondaryFTE is nil in the container CensusStaffType.
  func (s *CensusStaffType) SecondaryFTE_IsNil() bool {
    return s.censusstafftype.SecondaryFTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStaffType) StaffActivity() *StaffActivityExtensionType {
    if s.censusstafftype.StaffActivity == nil {
     if v, ok:= StaffActivityExtensionTypePointer(StaffActivityExtensionType{}); ok {
      s.censusstafftype.StaffActivity = v
      }
      }
      return s.censusstafftype.StaffActivity
    }
// Returns whether the element value for StaffActivity is nil in the container CensusStaffType.
  func (s *CensusStaffType) StaffActivity_IsNil() bool {
    return s.censusstafftype.StaffActivity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStaffType) StaffCohortId() *LocalIdType {
    if s.censusstafftype.StaffCohortId == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstafftype.StaffCohortId = ((*LocalIdType)(v))
      }
      }
      return s.censusstafftype.StaffCohortId
    }
// Returns whether the element value for StaffCohortId is nil in the container CensusStaffType.
  func (s *CensusStaffType) StaffCohortId_IsNil() bool {
    return s.censusstafftype.StaffCohortId == nil
    }

// Set the value of a property to nil
func (n *CensusStudentType) Unset(key string) *CensusStudentType {
        switch key {
  case "CensusAge":
   n.censusstudenttype.CensusAge = nil
  case "CohortGender":
   n.censusstudenttype.CohortGender = nil
  case "CohortIndigenousType":
   n.censusstudenttype.CohortIndigenousType = nil
  case "DisabilityCategory":
   n.censusstudenttype.DisabilityCategory = nil
  case "DisabilityLevelOfAdjustment":
   n.censusstudenttype.DisabilityLevelOfAdjustment = nil
  case "EducationMode":
   n.censusstudenttype.EducationMode = nil
  case "FTE":
   n.censusstudenttype.FTE = nil
  case "Headcount":
   n.censusstudenttype.Headcount = nil
  case "OverseasStudent":
   n.censusstudenttype.OverseasStudent = nil
  case "StudentCohortId":
   n.censusstudenttype.StudentCohortId = nil
  case "StudentOnVisa":
   n.censusstudenttype.StudentOnVisa = nil
  case "YearLevel":
   n.censusstudenttype.YearLevel = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CensusStudentType")
        }
        return n
}

// Set a sequence of properties
func (n *CensusStudentType) SetProperties(props ...Prop) *CensusStudentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CensusStudentType) SetProperty(key string, value interface{}) *CensusStudentType {
        if n == nil {
                n, _ = CensusStudentTypePointer(CensusStudentType{})
        }
        switch key {
    case "CensusAge":
    
    if v, ok:= IntPointer(value); ok {
      n.censusstudenttype.CensusAge = ((*Int)(v))
      }
    case "CohortGender":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstudenttype.CohortGender = ((*String)(v))
      }
    case "CohortIndigenousType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstudenttype.CohortIndigenousType = ((*String)(v))
      }
    case "DisabilityCategory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNCCDDisabilityType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNCCDDisabilityType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.censusstudenttype.DisabilityCategory = ((*AUCodeSetsNCCDDisabilityType)(v))
      }
    case "DisabilityLevelOfAdjustment":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNCCDAdjustmentType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNCCDAdjustmentType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.censusstudenttype.DisabilityLevelOfAdjustment = ((*AUCodeSetsNCCDAdjustmentType)(v))
      }
    case "EducationMode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstudenttype.EducationMode = ((*String)(v))
      }
    case "FTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstudenttype.FTE = ((*FTEType)(v))
      }
    case "Headcount":
    
    if v, ok:= IntPointer(value); ok {
      n.censusstudenttype.Headcount = ((*Int)(v))
      }
    case "OverseasStudent":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstudenttype.OverseasStudent = ((*String)(v))
      }
    case "StudentCohortId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstudenttype.StudentCohortId = ((*LocalIdType)(v))
      }
    case "StudentOnVisa":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.censusstudenttype.StudentOnVisa = ((*String)(v))
      }
    case "YearLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.censusstudenttype.YearLevel = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CensusStudentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) CensusAge() *Int {
    if s.censusstudenttype.CensusAge == nil {
    if v, ok:= IntPointer(0); ok {
      s.censusstudenttype.CensusAge = ((*Int)(v))
      }
      }
      return s.censusstudenttype.CensusAge
    }
// Returns whether the element value for CensusAge is nil in the container CensusStudentType.
  func (s *CensusStudentType) CensusAge_IsNil() bool {
    return s.censusstudenttype.CensusAge == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) CohortGender() *String {
    if s.censusstudenttype.CohortGender == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstudenttype.CohortGender = ((*String)(v))
      }
      }
      return s.censusstudenttype.CohortGender
    }
// Returns whether the element value for CohortGender is nil in the container CensusStudentType.
  func (s *CensusStudentType) CohortGender_IsNil() bool {
    return s.censusstudenttype.CohortGender == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) CohortIndigenousType() *String {
    if s.censusstudenttype.CohortIndigenousType == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstudenttype.CohortIndigenousType = ((*String)(v))
      }
      }
      return s.censusstudenttype.CohortIndigenousType
    }
// Returns whether the element value for CohortIndigenousType is nil in the container CensusStudentType.
  func (s *CensusStudentType) CohortIndigenousType_IsNil() bool {
    return s.censusstudenttype.CohortIndigenousType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) DisabilityCategory() *AUCodeSetsNCCDDisabilityType {
    if s.censusstudenttype.DisabilityCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstudenttype.DisabilityCategory = ((*AUCodeSetsNCCDDisabilityType)(v))
      }
      }
      return s.censusstudenttype.DisabilityCategory
    }
// Returns whether the element value for DisabilityCategory is nil in the container CensusStudentType.
  func (s *CensusStudentType) DisabilityCategory_IsNil() bool {
    return s.censusstudenttype.DisabilityCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) DisabilityLevelOfAdjustment() *AUCodeSetsNCCDAdjustmentType {
    if s.censusstudenttype.DisabilityLevelOfAdjustment == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstudenttype.DisabilityLevelOfAdjustment = ((*AUCodeSetsNCCDAdjustmentType)(v))
      }
      }
      return s.censusstudenttype.DisabilityLevelOfAdjustment
    }
// Returns whether the element value for DisabilityLevelOfAdjustment is nil in the container CensusStudentType.
  func (s *CensusStudentType) DisabilityLevelOfAdjustment_IsNil() bool {
    return s.censusstudenttype.DisabilityLevelOfAdjustment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) EducationMode() *String {
    if s.censusstudenttype.EducationMode == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstudenttype.EducationMode = ((*String)(v))
      }
      }
      return s.censusstudenttype.EducationMode
    }
// Returns whether the element value for EducationMode is nil in the container CensusStudentType.
  func (s *CensusStudentType) EducationMode_IsNil() bool {
    return s.censusstudenttype.EducationMode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) FTE() *FTEType {
    if s.censusstudenttype.FTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstudenttype.FTE = ((*FTEType)(v))
      }
      }
      return s.censusstudenttype.FTE
    }
// Returns whether the element value for FTE is nil in the container CensusStudentType.
  func (s *CensusStudentType) FTE_IsNil() bool {
    return s.censusstudenttype.FTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) Headcount() *Int {
    if s.censusstudenttype.Headcount == nil {
    if v, ok:= IntPointer(0); ok {
      s.censusstudenttype.Headcount = ((*Int)(v))
      }
      }
      return s.censusstudenttype.Headcount
    }
// Returns whether the element value for Headcount is nil in the container CensusStudentType.
  func (s *CensusStudentType) Headcount_IsNil() bool {
    return s.censusstudenttype.Headcount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) OverseasStudent() *String {
    if s.censusstudenttype.OverseasStudent == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstudenttype.OverseasStudent = ((*String)(v))
      }
      }
      return s.censusstudenttype.OverseasStudent
    }
// Returns whether the element value for OverseasStudent is nil in the container CensusStudentType.
  func (s *CensusStudentType) OverseasStudent_IsNil() bool {
    return s.censusstudenttype.OverseasStudent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) StudentCohortId() *LocalIdType {
    if s.censusstudenttype.StudentCohortId == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstudenttype.StudentCohortId = ((*LocalIdType)(v))
      }
      }
      return s.censusstudenttype.StudentCohortId
    }
// Returns whether the element value for StudentCohortId is nil in the container CensusStudentType.
  func (s *CensusStudentType) StudentCohortId_IsNil() bool {
    return s.censusstudenttype.StudentCohortId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) StudentOnVisa() *String {
    if s.censusstudenttype.StudentOnVisa == nil {
    if v, ok:= StringPointer(""); ok {
      s.censusstudenttype.StudentOnVisa = ((*String)(v))
      }
      }
      return s.censusstudenttype.StudentOnVisa
    }
// Returns whether the element value for StudentOnVisa is nil in the container CensusStudentType.
  func (s *CensusStudentType) StudentOnVisa_IsNil() bool {
    return s.censusstudenttype.StudentOnVisa == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CensusStudentType) YearLevel() *YearLevelType {
    if s.censusstudenttype.YearLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.censusstudenttype.YearLevel = v
      }
      }
      return s.censusstudenttype.YearLevel
    }
// Returns whether the element value for YearLevel is nil in the container CensusStudentType.
  func (s *CensusStudentType) YearLevel_IsNil() bool {
    return s.censusstudenttype.YearLevel == nil
    }

// Set the value of a property to nil
func (n *ChargedLocationInfo) Unset(key string) *ChargedLocationInfo {
        switch key {
  case "AddressList":
   n.chargedlocationinfo.AddressList = nil
  case "Description":
   n.chargedlocationinfo.Description = nil
  case "LocalCodeList":
   n.chargedlocationinfo.LocalCodeList = nil
  case "LocalId":
   n.chargedlocationinfo.LocalId = nil
  case "LocationType":
   n.chargedlocationinfo.LocationType = nil
  case "Name":
   n.chargedlocationinfo.Name = nil
  case "ParentChargedLocationInfoRefId":
   n.chargedlocationinfo.ParentChargedLocationInfoRefId = nil
  case "PhoneNumberList":
   n.chargedlocationinfo.PhoneNumberList = nil
  case "RefId":
   n.chargedlocationinfo.RefId = nil
  case "SIF_ExtendedElements":
   n.chargedlocationinfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.chargedlocationinfo.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.chargedlocationinfo.SchoolInfoRefId = nil
  case "SiteCategory":
   n.chargedlocationinfo.SiteCategory = nil
  case "StateProvinceId":
   n.chargedlocationinfo.StateProvinceId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ChargedLocationInfo")
        }
        return n
}

// Set a sequence of properties
func (n *ChargedLocationInfo) SetProperties(props ...Prop) *ChargedLocationInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ChargedLocationInfo) SetProperty(key string, value interface{}) *ChargedLocationInfo {
        if n == nil {
                n, _ = ChargedLocationInfoPointer(ChargedLocationInfo{})
        }
        switch key {
    case "AddressList":
    if v, ok:= AddressListTypePointer(value); ok {
      n.chargedlocationinfo.AddressList = v
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.chargedlocationinfo.Description = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.chargedlocationinfo.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.chargedlocationinfo.LocalId = ((*LocalIdType)(v))
      }
    case "LocationType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.chargedlocationinfo.LocationType = ((*String)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.chargedlocationinfo.Name = ((*String)(v))
      }
    case "ParentChargedLocationInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.chargedlocationinfo.ParentChargedLocationInfoRefId = ((*String)(v))
      }
    case "PhoneNumberList":
    if v, ok:= PhoneNumberListTypePointer(value); ok {
      n.chargedlocationinfo.PhoneNumberList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.chargedlocationinfo.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.chargedlocationinfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.chargedlocationinfo.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.chargedlocationinfo.SchoolInfoRefId = ((*String)(v))
      }
    case "SiteCategory":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.chargedlocationinfo.SiteCategory = ((*String)(v))
      }
    case "StateProvinceId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.chargedlocationinfo.StateProvinceId = ((*StateProvinceIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ChargedLocationInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) AddressList() *AddressListType {
    if s.chargedlocationinfo.AddressList == nil {
     if v, ok:= AddressListTypePointer(AddressListType{}); ok {
      s.chargedlocationinfo.AddressList = v
      }
      }
      return s.chargedlocationinfo.AddressList
    }
// Returns whether the element value for AddressList is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) AddressList_IsNil() bool {
    return s.chargedlocationinfo.AddressList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) Description() *String {
    if s.chargedlocationinfo.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.chargedlocationinfo.Description = ((*String)(v))
      }
      }
      return s.chargedlocationinfo.Description
    }
// Returns whether the element value for Description is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) Description_IsNil() bool {
    return s.chargedlocationinfo.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) LocalCodeList() *LocalCodeListType {
    if s.chargedlocationinfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.chargedlocationinfo.LocalCodeList = v
      }
      }
      return s.chargedlocationinfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) LocalCodeList_IsNil() bool {
    return s.chargedlocationinfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) LocalId() *LocalIdType {
    if s.chargedlocationinfo.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.chargedlocationinfo.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.chargedlocationinfo.LocalId
    }
// Returns whether the element value for LocalId is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) LocalId_IsNil() bool {
    return s.chargedlocationinfo.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) LocationType() *String {
    if s.chargedlocationinfo.LocationType == nil {
    if v, ok:= StringPointer(""); ok {
      s.chargedlocationinfo.LocationType = ((*String)(v))
      }
      }
      return s.chargedlocationinfo.LocationType
    }
// Returns whether the element value for LocationType is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) LocationType_IsNil() bool {
    return s.chargedlocationinfo.LocationType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) Name() *String {
    if s.chargedlocationinfo.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.chargedlocationinfo.Name = ((*String)(v))
      }
      }
      return s.chargedlocationinfo.Name
    }
// Returns whether the element value for Name is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) Name_IsNil() bool {
    return s.chargedlocationinfo.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) ParentChargedLocationInfoRefId() *String {
    if s.chargedlocationinfo.ParentChargedLocationInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.chargedlocationinfo.ParentChargedLocationInfoRefId = ((*String)(v))
      }
      }
      return s.chargedlocationinfo.ParentChargedLocationInfoRefId
    }
// Returns whether the element value for ParentChargedLocationInfoRefId is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) ParentChargedLocationInfoRefId_IsNil() bool {
    return s.chargedlocationinfo.ParentChargedLocationInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) PhoneNumberList() *PhoneNumberListType {
    if s.chargedlocationinfo.PhoneNumberList == nil {
     if v, ok:= PhoneNumberListTypePointer(PhoneNumberListType{}); ok {
      s.chargedlocationinfo.PhoneNumberList = v
      }
      }
      return s.chargedlocationinfo.PhoneNumberList
    }
// Returns whether the element value for PhoneNumberList is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) PhoneNumberList_IsNil() bool {
    return s.chargedlocationinfo.PhoneNumberList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) RefId() *RefIdType {
    if s.chargedlocationinfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.chargedlocationinfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.chargedlocationinfo.RefId
    }
// Returns whether the element value for RefId is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) RefId_IsNil() bool {
    return s.chargedlocationinfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.chargedlocationinfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.chargedlocationinfo.SIF_ExtendedElements = v
      }
      }
      return s.chargedlocationinfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) SIF_ExtendedElements_IsNil() bool {
    return s.chargedlocationinfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) SIF_Metadata() *SIF_MetadataType {
    if s.chargedlocationinfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.chargedlocationinfo.SIF_Metadata = v
      }
      }
      return s.chargedlocationinfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) SIF_Metadata_IsNil() bool {
    return s.chargedlocationinfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) SchoolInfoRefId() *String {
    if s.chargedlocationinfo.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.chargedlocationinfo.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.chargedlocationinfo.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) SchoolInfoRefId_IsNil() bool {
    return s.chargedlocationinfo.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) SiteCategory() *String {
    if s.chargedlocationinfo.SiteCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.chargedlocationinfo.SiteCategory = ((*String)(v))
      }
      }
      return s.chargedlocationinfo.SiteCategory
    }
// Returns whether the element value for SiteCategory is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) SiteCategory_IsNil() bool {
    return s.chargedlocationinfo.SiteCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ChargedLocationInfo) StateProvinceId() *StateProvinceIdType {
    if s.chargedlocationinfo.StateProvinceId == nil {
    if v, ok:= StringPointer(""); ok {
      s.chargedlocationinfo.StateProvinceId = ((*StateProvinceIdType)(v))
      }
      }
      return s.chargedlocationinfo.StateProvinceId
    }
// Returns whether the element value for StateProvinceId is nil in the container ChargedLocationInfo.
  func (s *ChargedLocationInfo) StateProvinceId_IsNil() bool {
    return s.chargedlocationinfo.StateProvinceId == nil
    }

// Set the value of a property to nil
func (n *CheckoutInfoType) Unset(key string) *CheckoutInfoType {
        switch key {
  case "CheckedOutOn":
   n.checkoutinfotype.CheckedOutOn = nil
  case "RenewalCount":
   n.checkoutinfotype.RenewalCount = nil
  case "ReturnBy":
   n.checkoutinfotype.ReturnBy = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CheckoutInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *CheckoutInfoType) SetProperties(props ...Prop) *CheckoutInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CheckoutInfoType) SetProperty(key string, value interface{}) *CheckoutInfoType {
        if n == nil {
                n, _ = CheckoutInfoTypePointer(CheckoutInfoType{})
        }
        switch key {
    case "CheckedOutOn":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.checkoutinfotype.CheckedOutOn = ((*String)(v))
      }
    case "RenewalCount":
    
    if v, ok:= IntPointer(value); ok {
      n.checkoutinfotype.RenewalCount = ((*Int)(v))
      }
    case "ReturnBy":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.checkoutinfotype.ReturnBy = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CheckoutInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CheckoutInfoType) CheckedOutOn() *String {
    if s.checkoutinfotype.CheckedOutOn == nil {
    if v, ok:= StringPointer(""); ok {
      s.checkoutinfotype.CheckedOutOn = ((*String)(v))
      }
      }
      return s.checkoutinfotype.CheckedOutOn
    }
// Returns whether the element value for CheckedOutOn is nil in the container CheckoutInfoType.
  func (s *CheckoutInfoType) CheckedOutOn_IsNil() bool {
    return s.checkoutinfotype.CheckedOutOn == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CheckoutInfoType) RenewalCount() *Int {
    if s.checkoutinfotype.RenewalCount == nil {
    if v, ok:= IntPointer(0); ok {
      s.checkoutinfotype.RenewalCount = ((*Int)(v))
      }
      }
      return s.checkoutinfotype.RenewalCount
    }
// Returns whether the element value for RenewalCount is nil in the container CheckoutInfoType.
  func (s *CheckoutInfoType) RenewalCount_IsNil() bool {
    return s.checkoutinfotype.RenewalCount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CheckoutInfoType) ReturnBy() *String {
    if s.checkoutinfotype.ReturnBy == nil {
    if v, ok:= StringPointer(""); ok {
      s.checkoutinfotype.ReturnBy = ((*String)(v))
      }
      }
      return s.checkoutinfotype.ReturnBy
    }
// Returns whether the element value for ReturnBy is nil in the container CheckoutInfoType.
  func (s *CheckoutInfoType) ReturnBy_IsNil() bool {
    return s.checkoutinfotype.ReturnBy == nil
    }

// Set the value of a property to nil
func (n *CodeFrameTestItemType) Unset(key string) *CodeFrameTestItemType {
        switch key {
  case "SequenceNumber":
   n.codeframetestitemtype.SequenceNumber = nil
  case "TestItemContent":
   n.codeframetestitemtype.TestItemContent = nil
  case "TestItemRefId":
   n.codeframetestitemtype.TestItemRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CodeFrameTestItemType")
        }
        return n
}

// Set a sequence of properties
func (n *CodeFrameTestItemType) SetProperties(props ...Prop) *CodeFrameTestItemType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CodeFrameTestItemType) SetProperty(key string, value interface{}) *CodeFrameTestItemType {
        if n == nil {
                n, _ = CodeFrameTestItemTypePointer(CodeFrameTestItemType{})
        }
        switch key {
    case "SequenceNumber":
    
    if v, ok:= IntPointer(value); ok {
      n.codeframetestitemtype.SequenceNumber = ((*Int)(v))
      }
    case "TestItemContent":
    if v, ok:= NAPTestItemContentTypePointer(value); ok {
      n.codeframetestitemtype.TestItemContent = v
      }
    case "TestItemRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.codeframetestitemtype.TestItemRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CodeFrameTestItemType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CodeFrameTestItemType) SequenceNumber() *Int {
    if s.codeframetestitemtype.SequenceNumber == nil {
    if v, ok:= IntPointer(0); ok {
      s.codeframetestitemtype.SequenceNumber = ((*Int)(v))
      }
      }
      return s.codeframetestitemtype.SequenceNumber
    }
// Returns whether the element value for SequenceNumber is nil in the container CodeFrameTestItemType.
  func (s *CodeFrameTestItemType) SequenceNumber_IsNil() bool {
    return s.codeframetestitemtype.SequenceNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CodeFrameTestItemType) TestItemContent() *NAPTestItemContentType {
    if s.codeframetestitemtype.TestItemContent == nil {
     if v, ok:= NAPTestItemContentTypePointer(NAPTestItemContentType{}); ok {
      s.codeframetestitemtype.TestItemContent = v
      }
      }
      return s.codeframetestitemtype.TestItemContent
    }
// Returns whether the element value for TestItemContent is nil in the container CodeFrameTestItemType.
  func (s *CodeFrameTestItemType) TestItemContent_IsNil() bool {
    return s.codeframetestitemtype.TestItemContent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CodeFrameTestItemType) TestItemRefId() *String {
    if s.codeframetestitemtype.TestItemRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.codeframetestitemtype.TestItemRefId = ((*String)(v))
      }
      }
      return s.codeframetestitemtype.TestItemRefId
    }
// Returns whether the element value for TestItemRefId is nil in the container CodeFrameTestItemType.
  func (s *CodeFrameTestItemType) TestItemRefId_IsNil() bool {
    return s.codeframetestitemtype.TestItemRefId == nil
    }

// Set the value of a property to nil
func (n *CollectionAcquittal) Unset(key string) *CollectionAcquittal {
        switch key {
  case "AuditedBy":
   n.collectionacquittal.AuditedBy = nil
  case "AuditorASICNumber":
   n.collectionacquittal.AuditorASICNumber = nil
  case "AuditorStatement":
   n.collectionacquittal.AuditorStatement = nil
  case "Collection":
   n.collectionacquittal.Collection = nil
  case "CollectionYear":
   n.collectionacquittal.CollectionYear = nil
  case "Declaration":
   n.collectionacquittal.Declaration = nil
  case "LocalCodeList":
   n.collectionacquittal.LocalCodeList = nil
  case "Recipient":
   n.collectionacquittal.Recipient = nil
  case "RefId":
   n.collectionacquittal.RefId = nil
  case "ReportingAuthorityList":
   n.collectionacquittal.ReportingAuthorityList = nil
  case "RoundCode":
   n.collectionacquittal.RoundCode = nil
  case "SIF_ExtendedElements":
   n.collectionacquittal.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.collectionacquittal.SIF_Metadata = nil
  case "SubmittedBy":
   n.collectionacquittal.SubmittedBy = nil
  case "SubmittingAuthority":
   n.collectionacquittal.SubmittingAuthority = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CollectionAcquittal")
        }
        return n
}

// Set a sequence of properties
func (n *CollectionAcquittal) SetProperties(props ...Prop) *CollectionAcquittal {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CollectionAcquittal) SetProperty(key string, value interface{}) *CollectionAcquittal {
        if n == nil {
                n, _ = CollectionAcquittalPointer(CollectionAcquittal{})
        }
        switch key {
    case "AuditedBy":
    if v, ok:= SignatoryTypePointer(value); ok {
      n.collectionacquittal.AuditedBy = v
      }
    case "AuditorASICNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionacquittal.AuditorASICNumber = ((*String)(v))
      }
    case "AuditorStatement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionacquittal.AuditorStatement = ((*String)(v))
      }
    case "Collection":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionacquittal.Collection = ((*String)(v))
      }
    case "CollectionYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionacquittal.CollectionYear = ((*SchoolYearType)(v))
      }
    case "Declaration":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionacquittal.Declaration = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.collectionacquittal.LocalCodeList = v
      }
    case "Recipient":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionacquittal.Recipient = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionacquittal.RefId = ((*RefIdType)(v))
      }
    case "ReportingAuthorityList":
    if v, ok:= ReportingAuthorityListTypePointer(value); ok {
      n.collectionacquittal.ReportingAuthorityList = v
      }
    case "RoundCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionacquittal.RoundCode = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.collectionacquittal.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.collectionacquittal.SIF_Metadata = v
      }
    case "SubmittedBy":
    if v, ok:= SignatoryTypePointer(value); ok {
      n.collectionacquittal.SubmittedBy = v
      }
    case "SubmittingAuthority":
    if v, ok:= ReportingAuthorityTypePointer(value); ok {
      n.collectionacquittal.SubmittingAuthority = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CollectionAcquittal")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) AuditedBy() *SignatoryType {
    if s.collectionacquittal.AuditedBy == nil {
     if v, ok:= SignatoryTypePointer(SignatoryType{}); ok {
      s.collectionacquittal.AuditedBy = v
      }
      }
      return s.collectionacquittal.AuditedBy
    }
// Returns whether the element value for AuditedBy is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) AuditedBy_IsNil() bool {
    return s.collectionacquittal.AuditedBy == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) AuditorASICNumber() *String {
    if s.collectionacquittal.AuditorASICNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionacquittal.AuditorASICNumber = ((*String)(v))
      }
      }
      return s.collectionacquittal.AuditorASICNumber
    }
// Returns whether the element value for AuditorASICNumber is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) AuditorASICNumber_IsNil() bool {
    return s.collectionacquittal.AuditorASICNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) AuditorStatement() *String {
    if s.collectionacquittal.AuditorStatement == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionacquittal.AuditorStatement = ((*String)(v))
      }
      }
      return s.collectionacquittal.AuditorStatement
    }
// Returns whether the element value for AuditorStatement is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) AuditorStatement_IsNil() bool {
    return s.collectionacquittal.AuditorStatement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) Collection() *String {
    if s.collectionacquittal.Collection == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionacquittal.Collection = ((*String)(v))
      }
      }
      return s.collectionacquittal.Collection
    }
// Returns whether the element value for Collection is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) Collection_IsNil() bool {
    return s.collectionacquittal.Collection == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) CollectionYear() *SchoolYearType {
    if s.collectionacquittal.CollectionYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionacquittal.CollectionYear = ((*SchoolYearType)(v))
      }
      }
      return s.collectionacquittal.CollectionYear
    }
// Returns whether the element value for CollectionYear is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) CollectionYear_IsNil() bool {
    return s.collectionacquittal.CollectionYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) Declaration() *String {
    if s.collectionacquittal.Declaration == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionacquittal.Declaration = ((*String)(v))
      }
      }
      return s.collectionacquittal.Declaration
    }
// Returns whether the element value for Declaration is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) Declaration_IsNil() bool {
    return s.collectionacquittal.Declaration == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) LocalCodeList() *LocalCodeListType {
    if s.collectionacquittal.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.collectionacquittal.LocalCodeList = v
      }
      }
      return s.collectionacquittal.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) LocalCodeList_IsNil() bool {
    return s.collectionacquittal.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) Recipient() *String {
    if s.collectionacquittal.Recipient == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionacquittal.Recipient = ((*String)(v))
      }
      }
      return s.collectionacquittal.Recipient
    }
// Returns whether the element value for Recipient is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) Recipient_IsNil() bool {
    return s.collectionacquittal.Recipient == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) RefId() *RefIdType {
    if s.collectionacquittal.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionacquittal.RefId = ((*RefIdType)(v))
      }
      }
      return s.collectionacquittal.RefId
    }
// Returns whether the element value for RefId is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) RefId_IsNil() bool {
    return s.collectionacquittal.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) ReportingAuthorityList() *ReportingAuthorityListType {
    if s.collectionacquittal.ReportingAuthorityList == nil {
     if v, ok:= ReportingAuthorityListTypePointer(ReportingAuthorityListType{}); ok {
      s.collectionacquittal.ReportingAuthorityList = v
      }
      }
      return s.collectionacquittal.ReportingAuthorityList
    }
// Returns whether the element value for ReportingAuthorityList is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) ReportingAuthorityList_IsNil() bool {
    return s.collectionacquittal.ReportingAuthorityList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) RoundCode() *String {
    if s.collectionacquittal.RoundCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionacquittal.RoundCode = ((*String)(v))
      }
      }
      return s.collectionacquittal.RoundCode
    }
// Returns whether the element value for RoundCode is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) RoundCode_IsNil() bool {
    return s.collectionacquittal.RoundCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.collectionacquittal.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.collectionacquittal.SIF_ExtendedElements = v
      }
      }
      return s.collectionacquittal.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) SIF_ExtendedElements_IsNil() bool {
    return s.collectionacquittal.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) SIF_Metadata() *SIF_MetadataType {
    if s.collectionacquittal.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.collectionacquittal.SIF_Metadata = v
      }
      }
      return s.collectionacquittal.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) SIF_Metadata_IsNil() bool {
    return s.collectionacquittal.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) SubmittedBy() *SignatoryType {
    if s.collectionacquittal.SubmittedBy == nil {
     if v, ok:= SignatoryTypePointer(SignatoryType{}); ok {
      s.collectionacquittal.SubmittedBy = v
      }
      }
      return s.collectionacquittal.SubmittedBy
    }
// Returns whether the element value for SubmittedBy is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) SubmittedBy_IsNil() bool {
    return s.collectionacquittal.SubmittedBy == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionAcquittal) SubmittingAuthority() *ReportingAuthorityType {
    if s.collectionacquittal.SubmittingAuthority == nil {
     if v, ok:= ReportingAuthorityTypePointer(ReportingAuthorityType{}); ok {
      s.collectionacquittal.SubmittingAuthority = v
      }
      }
      return s.collectionacquittal.SubmittingAuthority
    }
// Returns whether the element value for SubmittingAuthority is nil in the container CollectionAcquittal.
  func (s *CollectionAcquittal) SubmittingAuthority_IsNil() bool {
    return s.collectionacquittal.SubmittingAuthority == nil
    }

// Set the value of a property to nil
func (n *CollectionDeclaration) Unset(key string) *CollectionDeclaration {
        switch key {
  case "Collection":
   n.collectiondeclaration.Collection = nil
  case "CollectionYear":
   n.collectiondeclaration.CollectionYear = nil
  case "Declaration":
   n.collectiondeclaration.Declaration = nil
  case "LocalCodeList":
   n.collectiondeclaration.LocalCodeList = nil
  case "Recipient":
   n.collectiondeclaration.Recipient = nil
  case "RefId":
   n.collectiondeclaration.RefId = nil
  case "ReportingAuthorityList":
   n.collectiondeclaration.ReportingAuthorityList = nil
  case "RoundCode":
   n.collectiondeclaration.RoundCode = nil
  case "SIF_ExtendedElements":
   n.collectiondeclaration.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.collectiondeclaration.SIF_Metadata = nil
  case "SubmittedBy":
   n.collectiondeclaration.SubmittedBy = nil
  case "SubmittingAuthority":
   n.collectiondeclaration.SubmittingAuthority = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CollectionDeclaration")
        }
        return n
}

// Set a sequence of properties
func (n *CollectionDeclaration) SetProperties(props ...Prop) *CollectionDeclaration {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CollectionDeclaration) SetProperty(key string, value interface{}) *CollectionDeclaration {
        if n == nil {
                n, _ = CollectionDeclarationPointer(CollectionDeclaration{})
        }
        switch key {
    case "Collection":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectiondeclaration.Collection = ((*String)(v))
      }
    case "CollectionYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectiondeclaration.CollectionYear = ((*SchoolYearType)(v))
      }
    case "Declaration":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectiondeclaration.Declaration = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.collectiondeclaration.LocalCodeList = v
      }
    case "Recipient":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectiondeclaration.Recipient = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectiondeclaration.RefId = ((*RefIdType)(v))
      }
    case "ReportingAuthorityList":
    if v, ok:= ReportingAuthorityListTypePointer(value); ok {
      n.collectiondeclaration.ReportingAuthorityList = v
      }
    case "RoundCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectiondeclaration.RoundCode = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.collectiondeclaration.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.collectiondeclaration.SIF_Metadata = v
      }
    case "SubmittedBy":
    if v, ok:= SignatoryTypePointer(value); ok {
      n.collectiondeclaration.SubmittedBy = v
      }
    case "SubmittingAuthority":
    if v, ok:= ReportingAuthorityTypePointer(value); ok {
      n.collectiondeclaration.SubmittingAuthority = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CollectionDeclaration")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) Collection() *String {
    if s.collectiondeclaration.Collection == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectiondeclaration.Collection = ((*String)(v))
      }
      }
      return s.collectiondeclaration.Collection
    }
// Returns whether the element value for Collection is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) Collection_IsNil() bool {
    return s.collectiondeclaration.Collection == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) CollectionYear() *SchoolYearType {
    if s.collectiondeclaration.CollectionYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectiondeclaration.CollectionYear = ((*SchoolYearType)(v))
      }
      }
      return s.collectiondeclaration.CollectionYear
    }
// Returns whether the element value for CollectionYear is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) CollectionYear_IsNil() bool {
    return s.collectiondeclaration.CollectionYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) Declaration() *String {
    if s.collectiondeclaration.Declaration == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectiondeclaration.Declaration = ((*String)(v))
      }
      }
      return s.collectiondeclaration.Declaration
    }
// Returns whether the element value for Declaration is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) Declaration_IsNil() bool {
    return s.collectiondeclaration.Declaration == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) LocalCodeList() *LocalCodeListType {
    if s.collectiondeclaration.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.collectiondeclaration.LocalCodeList = v
      }
      }
      return s.collectiondeclaration.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) LocalCodeList_IsNil() bool {
    return s.collectiondeclaration.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) Recipient() *String {
    if s.collectiondeclaration.Recipient == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectiondeclaration.Recipient = ((*String)(v))
      }
      }
      return s.collectiondeclaration.Recipient
    }
// Returns whether the element value for Recipient is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) Recipient_IsNil() bool {
    return s.collectiondeclaration.Recipient == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) RefId() *RefIdType {
    if s.collectiondeclaration.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectiondeclaration.RefId = ((*RefIdType)(v))
      }
      }
      return s.collectiondeclaration.RefId
    }
// Returns whether the element value for RefId is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) RefId_IsNil() bool {
    return s.collectiondeclaration.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) ReportingAuthorityList() *ReportingAuthorityListType {
    if s.collectiondeclaration.ReportingAuthorityList == nil {
     if v, ok:= ReportingAuthorityListTypePointer(ReportingAuthorityListType{}); ok {
      s.collectiondeclaration.ReportingAuthorityList = v
      }
      }
      return s.collectiondeclaration.ReportingAuthorityList
    }
// Returns whether the element value for ReportingAuthorityList is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) ReportingAuthorityList_IsNil() bool {
    return s.collectiondeclaration.ReportingAuthorityList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) RoundCode() *String {
    if s.collectiondeclaration.RoundCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectiondeclaration.RoundCode = ((*String)(v))
      }
      }
      return s.collectiondeclaration.RoundCode
    }
// Returns whether the element value for RoundCode is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) RoundCode_IsNil() bool {
    return s.collectiondeclaration.RoundCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.collectiondeclaration.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.collectiondeclaration.SIF_ExtendedElements = v
      }
      }
      return s.collectiondeclaration.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) SIF_ExtendedElements_IsNil() bool {
    return s.collectiondeclaration.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) SIF_Metadata() *SIF_MetadataType {
    if s.collectiondeclaration.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.collectiondeclaration.SIF_Metadata = v
      }
      }
      return s.collectiondeclaration.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) SIF_Metadata_IsNil() bool {
    return s.collectiondeclaration.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) SubmittedBy() *SignatoryType {
    if s.collectiondeclaration.SubmittedBy == nil {
     if v, ok:= SignatoryTypePointer(SignatoryType{}); ok {
      s.collectiondeclaration.SubmittedBy = v
      }
      }
      return s.collectiondeclaration.SubmittedBy
    }
// Returns whether the element value for SubmittedBy is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) SubmittedBy_IsNil() bool {
    return s.collectiondeclaration.SubmittedBy == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionDeclaration) SubmittingAuthority() *ReportingAuthorityType {
    if s.collectiondeclaration.SubmittingAuthority == nil {
     if v, ok:= ReportingAuthorityTypePointer(ReportingAuthorityType{}); ok {
      s.collectiondeclaration.SubmittingAuthority = v
      }
      }
      return s.collectiondeclaration.SubmittingAuthority
    }
// Returns whether the element value for SubmittingAuthority is nil in the container CollectionDeclaration.
  func (s *CollectionDeclaration) SubmittingAuthority_IsNil() bool {
    return s.collectiondeclaration.SubmittingAuthority == nil
    }

// Set the value of a property to nil
func (n *CollectionRound) Unset(key string) *CollectionRound {
        switch key {
  case "AGCollection":
   n.collectionround.AGCollection = nil
  case "AGRoundList":
   n.collectionround.AGRoundList = nil
  case "CollectionYear":
   n.collectionround.CollectionYear = nil
  case "LocalCodeList":
   n.collectionround.LocalCodeList = nil
  case "RefId":
   n.collectionround.RefId = nil
  case "SIF_ExtendedElements":
   n.collectionround.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.collectionround.SIF_Metadata = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CollectionRound")
        }
        return n
}

// Set a sequence of properties
func (n *CollectionRound) SetProperties(props ...Prop) *CollectionRound {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CollectionRound) SetProperty(key string, value interface{}) *CollectionRound {
        if n == nil {
                n, _ = CollectionRoundPointer(CollectionRound{})
        }
        switch key {
    case "AGCollection":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAGCollectionType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAGCollectionType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.collectionround.AGCollection = ((*AUCodeSetsAGCollectionType)(v))
      }
    case "AGRoundList":
    if v, ok:= AGRoundListTypePointer(value); ok {
      n.collectionround.AGRoundList = v
      }
    case "CollectionYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionround.CollectionYear = ((*SchoolYearType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.collectionround.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionround.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.collectionround.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.collectionround.SIF_Metadata = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CollectionRound")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionRound) AGCollection() *AUCodeSetsAGCollectionType {
    if s.collectionround.AGCollection == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionround.AGCollection = ((*AUCodeSetsAGCollectionType)(v))
      }
      }
      return s.collectionround.AGCollection
    }
// Returns whether the element value for AGCollection is nil in the container CollectionRound.
  func (s *CollectionRound) AGCollection_IsNil() bool {
    return s.collectionround.AGCollection == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionRound) AGRoundList() *AGRoundListType {
    if s.collectionround.AGRoundList == nil {
     if v, ok:= AGRoundListTypePointer(AGRoundListType{}); ok {
      s.collectionround.AGRoundList = v
      }
      }
      return s.collectionround.AGRoundList
    }
// Returns whether the element value for AGRoundList is nil in the container CollectionRound.
  func (s *CollectionRound) AGRoundList_IsNil() bool {
    return s.collectionround.AGRoundList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionRound) CollectionYear() *SchoolYearType {
    if s.collectionround.CollectionYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionround.CollectionYear = ((*SchoolYearType)(v))
      }
      }
      return s.collectionround.CollectionYear
    }
// Returns whether the element value for CollectionYear is nil in the container CollectionRound.
  func (s *CollectionRound) CollectionYear_IsNil() bool {
    return s.collectionround.CollectionYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionRound) LocalCodeList() *LocalCodeListType {
    if s.collectionround.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.collectionround.LocalCodeList = v
      }
      }
      return s.collectionround.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container CollectionRound.
  func (s *CollectionRound) LocalCodeList_IsNil() bool {
    return s.collectionround.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionRound) RefId() *RefIdType {
    if s.collectionround.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionround.RefId = ((*RefIdType)(v))
      }
      }
      return s.collectionround.RefId
    }
// Returns whether the element value for RefId is nil in the container CollectionRound.
  func (s *CollectionRound) RefId_IsNil() bool {
    return s.collectionround.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionRound) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.collectionround.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.collectionround.SIF_ExtendedElements = v
      }
      }
      return s.collectionround.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container CollectionRound.
  func (s *CollectionRound) SIF_ExtendedElements_IsNil() bool {
    return s.collectionround.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionRound) SIF_Metadata() *SIF_MetadataType {
    if s.collectionround.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.collectionround.SIF_Metadata = v
      }
      }
      return s.collectionround.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container CollectionRound.
  func (s *CollectionRound) SIF_Metadata_IsNil() bool {
    return s.collectionround.SIF_Metadata == nil
    }

// Set the value of a property to nil
func (n *CollectionStatus) Unset(key string) *CollectionStatus {
        switch key {
  case "AGCollection":
   n.collectionstatus.AGCollection = nil
  case "AGReportingObjectResponseList":
   n.collectionstatus.AGReportingObjectResponseList = nil
  case "CollectionYear":
   n.collectionstatus.CollectionYear = nil
  case "LocalCodeList":
   n.collectionstatus.LocalCodeList = nil
  case "RefId":
   n.collectionstatus.RefId = nil
  case "ReportingAuthority":
   n.collectionstatus.ReportingAuthority = nil
  case "ReportingAuthorityCommonwealthId":
   n.collectionstatus.ReportingAuthorityCommonwealthId = nil
  case "ReportingAuthoritySystem":
   n.collectionstatus.ReportingAuthoritySystem = nil
  case "RoundCode":
   n.collectionstatus.RoundCode = nil
  case "SIF_ExtendedElements":
   n.collectionstatus.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.collectionstatus.SIF_Metadata = nil
  case "SubmissionTimestamp":
   n.collectionstatus.SubmissionTimestamp = nil
  case "SubmittedBy":
   n.collectionstatus.SubmittedBy = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CollectionStatus")
        }
        return n
}

// Set a sequence of properties
func (n *CollectionStatus) SetProperties(props ...Prop) *CollectionStatus {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CollectionStatus) SetProperty(key string, value interface{}) *CollectionStatus {
        if n == nil {
                n, _ = CollectionStatusPointer(CollectionStatus{})
        }
        switch key {
    case "AGCollection":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionstatus.AGCollection = ((*String)(v))
      }
    case "AGReportingObjectResponseList":
    if v, ok:= AGReportingObjectResponseListTypePointer(value); ok {
      n.collectionstatus.AGReportingObjectResponseList = v
      }
    case "CollectionYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionstatus.CollectionYear = ((*SchoolYearType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.collectionstatus.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionstatus.RefId = ((*RefIdType)(v))
      }
    case "ReportingAuthority":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionstatus.ReportingAuthority = ((*String)(v))
      }
    case "ReportingAuthorityCommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionstatus.ReportingAuthorityCommonwealthId = ((*String)(v))
      }
    case "ReportingAuthoritySystem":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionstatus.ReportingAuthoritySystem = ((*String)(v))
      }
    case "RoundCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionstatus.RoundCode = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.collectionstatus.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.collectionstatus.SIF_Metadata = v
      }
    case "SubmissionTimestamp":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionstatus.SubmissionTimestamp = ((*String)(v))
      }
    case "SubmittedBy":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.collectionstatus.SubmittedBy = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CollectionStatus")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) AGCollection() *String {
    if s.collectionstatus.AGCollection == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionstatus.AGCollection = ((*String)(v))
      }
      }
      return s.collectionstatus.AGCollection
    }
// Returns whether the element value for AGCollection is nil in the container CollectionStatus.
  func (s *CollectionStatus) AGCollection_IsNil() bool {
    return s.collectionstatus.AGCollection == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) AGReportingObjectResponseList() *AGReportingObjectResponseListType {
    if s.collectionstatus.AGReportingObjectResponseList == nil {
     if v, ok:= AGReportingObjectResponseListTypePointer(AGReportingObjectResponseListType{}); ok {
      s.collectionstatus.AGReportingObjectResponseList = v
      }
      }
      return s.collectionstatus.AGReportingObjectResponseList
    }
// Returns whether the element value for AGReportingObjectResponseList is nil in the container CollectionStatus.
  func (s *CollectionStatus) AGReportingObjectResponseList_IsNil() bool {
    return s.collectionstatus.AGReportingObjectResponseList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) CollectionYear() *SchoolYearType {
    if s.collectionstatus.CollectionYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionstatus.CollectionYear = ((*SchoolYearType)(v))
      }
      }
      return s.collectionstatus.CollectionYear
    }
// Returns whether the element value for CollectionYear is nil in the container CollectionStatus.
  func (s *CollectionStatus) CollectionYear_IsNil() bool {
    return s.collectionstatus.CollectionYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) LocalCodeList() *LocalCodeListType {
    if s.collectionstatus.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.collectionstatus.LocalCodeList = v
      }
      }
      return s.collectionstatus.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container CollectionStatus.
  func (s *CollectionStatus) LocalCodeList_IsNil() bool {
    return s.collectionstatus.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) RefId() *RefIdType {
    if s.collectionstatus.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionstatus.RefId = ((*RefIdType)(v))
      }
      }
      return s.collectionstatus.RefId
    }
// Returns whether the element value for RefId is nil in the container CollectionStatus.
  func (s *CollectionStatus) RefId_IsNil() bool {
    return s.collectionstatus.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) ReportingAuthority() *String {
    if s.collectionstatus.ReportingAuthority == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionstatus.ReportingAuthority = ((*String)(v))
      }
      }
      return s.collectionstatus.ReportingAuthority
    }
// Returns whether the element value for ReportingAuthority is nil in the container CollectionStatus.
  func (s *CollectionStatus) ReportingAuthority_IsNil() bool {
    return s.collectionstatus.ReportingAuthority == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) ReportingAuthorityCommonwealthId() *String {
    if s.collectionstatus.ReportingAuthorityCommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionstatus.ReportingAuthorityCommonwealthId = ((*String)(v))
      }
      }
      return s.collectionstatus.ReportingAuthorityCommonwealthId
    }
// Returns whether the element value for ReportingAuthorityCommonwealthId is nil in the container CollectionStatus.
  func (s *CollectionStatus) ReportingAuthorityCommonwealthId_IsNil() bool {
    return s.collectionstatus.ReportingAuthorityCommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) ReportingAuthoritySystem() *String {
    if s.collectionstatus.ReportingAuthoritySystem == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionstatus.ReportingAuthoritySystem = ((*String)(v))
      }
      }
      return s.collectionstatus.ReportingAuthoritySystem
    }
// Returns whether the element value for ReportingAuthoritySystem is nil in the container CollectionStatus.
  func (s *CollectionStatus) ReportingAuthoritySystem_IsNil() bool {
    return s.collectionstatus.ReportingAuthoritySystem == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) RoundCode() *String {
    if s.collectionstatus.RoundCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionstatus.RoundCode = ((*String)(v))
      }
      }
      return s.collectionstatus.RoundCode
    }
// Returns whether the element value for RoundCode is nil in the container CollectionStatus.
  func (s *CollectionStatus) RoundCode_IsNil() bool {
    return s.collectionstatus.RoundCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.collectionstatus.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.collectionstatus.SIF_ExtendedElements = v
      }
      }
      return s.collectionstatus.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container CollectionStatus.
  func (s *CollectionStatus) SIF_ExtendedElements_IsNil() bool {
    return s.collectionstatus.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) SIF_Metadata() *SIF_MetadataType {
    if s.collectionstatus.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.collectionstatus.SIF_Metadata = v
      }
      }
      return s.collectionstatus.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container CollectionStatus.
  func (s *CollectionStatus) SIF_Metadata_IsNil() bool {
    return s.collectionstatus.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) SubmissionTimestamp() *String {
    if s.collectionstatus.SubmissionTimestamp == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionstatus.SubmissionTimestamp = ((*String)(v))
      }
      }
      return s.collectionstatus.SubmissionTimestamp
    }
// Returns whether the element value for SubmissionTimestamp is nil in the container CollectionStatus.
  func (s *CollectionStatus) SubmissionTimestamp_IsNil() bool {
    return s.collectionstatus.SubmissionTimestamp == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CollectionStatus) SubmittedBy() *String {
    if s.collectionstatus.SubmittedBy == nil {
    if v, ok:= StringPointer(""); ok {
      s.collectionstatus.SubmittedBy = ((*String)(v))
      }
      }
      return s.collectionstatus.SubmittedBy
    }
// Returns whether the element value for SubmittedBy is nil in the container CollectionStatus.
  func (s *CollectionStatus) SubmittedBy_IsNil() bool {
    return s.collectionstatus.SubmittedBy == nil
    }

// Set the value of a property to nil
func (n *ComponentType) Unset(key string) *ComponentType {
        switch key {
  case "AssociatedObjects":
   n.componenttype.AssociatedObjects = nil
  case "Description":
   n.componenttype.Description = nil
  case "Name":
   n.componenttype.Name = nil
  case "Reference":
   n.componenttype.Reference = nil
  case "Strategies":
   n.componenttype.Strategies = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ComponentType")
        }
        return n
}

// Set a sequence of properties
func (n *ComponentType) SetProperties(props ...Prop) *ComponentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ComponentType) SetProperty(key string, value interface{}) *ComponentType {
        if n == nil {
                n, _ = ComponentTypePointer(ComponentType{})
        }
        switch key {
    case "AssociatedObjects":
    if v, ok:= AssociatedObjectsTypePointer(value); ok {
      n.componenttype.AssociatedObjects = v
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.componenttype.Description = ((*String)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.componenttype.Name = ((*String)(v))
      }
    case "Reference":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.componenttype.Reference = ((*String)(v))
      }
    case "Strategies":
    if v, ok:= StrategiesTypePointer(value); ok {
      n.componenttype.Strategies = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ComponentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ComponentType) AssociatedObjects() *AssociatedObjectsType {
    if s.componenttype.AssociatedObjects == nil {
     if v, ok:= AssociatedObjectsTypePointer(AssociatedObjectsType{}); ok {
      s.componenttype.AssociatedObjects = v
      }
      }
      return s.componenttype.AssociatedObjects
    }
// Returns whether the element value for AssociatedObjects is nil in the container ComponentType.
  func (s *ComponentType) AssociatedObjects_IsNil() bool {
    return s.componenttype.AssociatedObjects == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ComponentType) Description() *String {
    if s.componenttype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.componenttype.Description = ((*String)(v))
      }
      }
      return s.componenttype.Description
    }
// Returns whether the element value for Description is nil in the container ComponentType.
  func (s *ComponentType) Description_IsNil() bool {
    return s.componenttype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ComponentType) Name() *String {
    if s.componenttype.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.componenttype.Name = ((*String)(v))
      }
      }
      return s.componenttype.Name
    }
// Returns whether the element value for Name is nil in the container ComponentType.
  func (s *ComponentType) Name_IsNil() bool {
    return s.componenttype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ComponentType) Reference() *String {
    if s.componenttype.Reference == nil {
    if v, ok:= StringPointer(""); ok {
      s.componenttype.Reference = ((*String)(v))
      }
      }
      return s.componenttype.Reference
    }
// Returns whether the element value for Reference is nil in the container ComponentType.
  func (s *ComponentType) Reference_IsNil() bool {
    return s.componenttype.Reference == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ComponentType) Strategies() *StrategiesType {
    if s.componenttype.Strategies == nil {
     if v, ok:= StrategiesTypePointer(StrategiesType{}); ok {
      s.componenttype.Strategies = v
      }
      }
      return s.componenttype.Strategies
    }
// Returns whether the element value for Strategies is nil in the container ComponentType.
  func (s *ComponentType) Strategies_IsNil() bool {
    return s.componenttype.Strategies == nil
    }

// Set the value of a property to nil
func (n *ConsentToSharingOfDataContainerType) Unset(key string) *ConsentToSharingOfDataContainerType {
        switch key {
  case "DataDomainObligationList":
   n.consenttosharingofdatacontainertype.DataDomainObligationList = nil
  case "NeverShareWithList":
   n.consenttosharingofdatacontainertype.NeverShareWithList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ConsentToSharingOfDataContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *ConsentToSharingOfDataContainerType) SetProperties(props ...Prop) *ConsentToSharingOfDataContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ConsentToSharingOfDataContainerType) SetProperty(key string, value interface{}) *ConsentToSharingOfDataContainerType {
        if n == nil {
                n, _ = ConsentToSharingOfDataContainerTypePointer(ConsentToSharingOfDataContainerType{})
        }
        switch key {
    case "DataDomainObligationList":
    if v, ok:= DataDomainObligationListTypePointer(value); ok {
      n.consenttosharingofdatacontainertype.DataDomainObligationList = v
      }
    case "NeverShareWithList":
    if v, ok:= NeverShareWithListTypePointer(value); ok {
      n.consenttosharingofdatacontainertype.NeverShareWithList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ConsentToSharingOfDataContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ConsentToSharingOfDataContainerType) DataDomainObligationList() *DataDomainObligationListType {
    if s.consenttosharingofdatacontainertype.DataDomainObligationList == nil {
     if v, ok:= DataDomainObligationListTypePointer(DataDomainObligationListType{}); ok {
      s.consenttosharingofdatacontainertype.DataDomainObligationList = v
      }
      }
      return s.consenttosharingofdatacontainertype.DataDomainObligationList
    }
// Returns whether the element value for DataDomainObligationList is nil in the container ConsentToSharingOfDataContainerType.
  func (s *ConsentToSharingOfDataContainerType) DataDomainObligationList_IsNil() bool {
    return s.consenttosharingofdatacontainertype.DataDomainObligationList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ConsentToSharingOfDataContainerType) NeverShareWithList() *NeverShareWithListType {
    if s.consenttosharingofdatacontainertype.NeverShareWithList == nil {
     if v, ok:= NeverShareWithListTypePointer(NeverShareWithListType{}); ok {
      s.consenttosharingofdatacontainertype.NeverShareWithList = v
      }
      }
      return s.consenttosharingofdatacontainertype.NeverShareWithList
    }
// Returns whether the element value for NeverShareWithList is nil in the container ConsentToSharingOfDataContainerType.
  func (s *ConsentToSharingOfDataContainerType) NeverShareWithList_IsNil() bool {
    return s.consenttosharingofdatacontainertype.NeverShareWithList == nil
    }

// Set the value of a property to nil
func (n *ContactFlagsType) Unset(key string) *ContactFlagsType {
        switch key {
  case "AccessToRecords":
   n.contactflagstype.AccessToRecords = nil
  case "AttendanceContact":
   n.contactflagstype.AttendanceContact = nil
  case "DisciplinaryContact":
   n.contactflagstype.DisciplinaryContact = nil
  case "EmergencyContact":
   n.contactflagstype.EmergencyContact = nil
  case "FamilyMail":
   n.contactflagstype.FamilyMail = nil
  case "FeesAccess":
   n.contactflagstype.FeesAccess = nil
  case "FeesBilling":
   n.contactflagstype.FeesBilling = nil
  case "HasCustody":
   n.contactflagstype.HasCustody = nil
  case "InterventionOrder":
   n.contactflagstype.InterventionOrder = nil
  case "LivesWith":
   n.contactflagstype.LivesWith = nil
  case "ParentLegalGuardian":
   n.contactflagstype.ParentLegalGuardian = nil
  case "PickupRights":
   n.contactflagstype.PickupRights = nil
  case "PrimaryCareProvider":
   n.contactflagstype.PrimaryCareProvider = nil
  case "ReceivesAssessmentReport":
   n.contactflagstype.ReceivesAssessmentReport = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ContactFlagsType")
        }
        return n
}

// Set a sequence of properties
func (n *ContactFlagsType) SetProperties(props ...Prop) *ContactFlagsType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ContactFlagsType) SetProperty(key string, value interface{}) *ContactFlagsType {
        if n == nil {
                n, _ = ContactFlagsTypePointer(ContactFlagsType{})
        }
        switch key {
    case "AccessToRecords":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.AccessToRecords = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "AttendanceContact":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.AttendanceContact = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "DisciplinaryContact":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.DisciplinaryContact = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "EmergencyContact":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.EmergencyContact = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "FamilyMail":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.FamilyMail = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "FeesAccess":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.FeesAccess = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "FeesBilling":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.FeesBilling = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "HasCustody":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.HasCustody = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "InterventionOrder":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.InterventionOrder = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "LivesWith":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.LivesWith = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "ParentLegalGuardian":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.ParentLegalGuardian = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "PickupRights":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.PickupRights = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "PrimaryCareProvider":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.PrimaryCareProvider = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "ReceivesAssessmentReport":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.contactflagstype.ReceivesAssessmentReport = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ContactFlagsType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) AccessToRecords() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.AccessToRecords == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.AccessToRecords = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.AccessToRecords
    }
// Returns whether the element value for AccessToRecords is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) AccessToRecords_IsNil() bool {
    return s.contactflagstype.AccessToRecords == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) AttendanceContact() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.AttendanceContact == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.AttendanceContact = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.AttendanceContact
    }
// Returns whether the element value for AttendanceContact is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) AttendanceContact_IsNil() bool {
    return s.contactflagstype.AttendanceContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) DisciplinaryContact() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.DisciplinaryContact == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.DisciplinaryContact = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.DisciplinaryContact
    }
// Returns whether the element value for DisciplinaryContact is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) DisciplinaryContact_IsNil() bool {
    return s.contactflagstype.DisciplinaryContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) EmergencyContact() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.EmergencyContact == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.EmergencyContact = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.EmergencyContact
    }
// Returns whether the element value for EmergencyContact is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) EmergencyContact_IsNil() bool {
    return s.contactflagstype.EmergencyContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) FamilyMail() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.FamilyMail == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.FamilyMail = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.FamilyMail
    }
// Returns whether the element value for FamilyMail is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) FamilyMail_IsNil() bool {
    return s.contactflagstype.FamilyMail == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) FeesAccess() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.FeesAccess == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.FeesAccess = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.FeesAccess
    }
// Returns whether the element value for FeesAccess is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) FeesAccess_IsNil() bool {
    return s.contactflagstype.FeesAccess == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) FeesBilling() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.FeesBilling == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.FeesBilling = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.FeesBilling
    }
// Returns whether the element value for FeesBilling is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) FeesBilling_IsNil() bool {
    return s.contactflagstype.FeesBilling == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) HasCustody() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.HasCustody == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.HasCustody = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.HasCustody
    }
// Returns whether the element value for HasCustody is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) HasCustody_IsNil() bool {
    return s.contactflagstype.HasCustody == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) InterventionOrder() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.InterventionOrder == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.InterventionOrder = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.InterventionOrder
    }
// Returns whether the element value for InterventionOrder is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) InterventionOrder_IsNil() bool {
    return s.contactflagstype.InterventionOrder == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) LivesWith() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.LivesWith == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.LivesWith = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.LivesWith
    }
// Returns whether the element value for LivesWith is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) LivesWith_IsNil() bool {
    return s.contactflagstype.LivesWith == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) ParentLegalGuardian() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.ParentLegalGuardian == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.ParentLegalGuardian = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.ParentLegalGuardian
    }
// Returns whether the element value for ParentLegalGuardian is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) ParentLegalGuardian_IsNil() bool {
    return s.contactflagstype.ParentLegalGuardian == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) PickupRights() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.PickupRights == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.PickupRights = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.PickupRights
    }
// Returns whether the element value for PickupRights is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) PickupRights_IsNil() bool {
    return s.contactflagstype.PickupRights == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) PrimaryCareProvider() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.PrimaryCareProvider == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.PrimaryCareProvider = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.PrimaryCareProvider
    }
// Returns whether the element value for PrimaryCareProvider is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) PrimaryCareProvider_IsNil() bool {
    return s.contactflagstype.PrimaryCareProvider == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactFlagsType) ReceivesAssessmentReport() *AUCodeSetsYesOrNoCategoryType {
    if s.contactflagstype.ReceivesAssessmentReport == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactflagstype.ReceivesAssessmentReport = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.contactflagstype.ReceivesAssessmentReport
    }
// Returns whether the element value for ReceivesAssessmentReport is nil in the container ContactFlagsType.
  func (s *ContactFlagsType) ReceivesAssessmentReport_IsNil() bool {
    return s.contactflagstype.ReceivesAssessmentReport == nil
    }

// Set the value of a property to nil
func (n *ContactInfoType) Unset(key string) *ContactInfoType {
        switch key {
  case "Address":
   n.contactinfotype.Address = nil
  case "EmailList":
   n.contactinfotype.EmailList = nil
  case "Name":
   n.contactinfotype.Name = nil
  case "PhoneNumberList":
   n.contactinfotype.PhoneNumberList = nil
  case "PositionTitle":
   n.contactinfotype.PositionTitle = nil
  case "Qualifications":
   n.contactinfotype.Qualifications = nil
  case "RegistrationDetails":
   n.contactinfotype.RegistrationDetails = nil
  case "Role":
   n.contactinfotype.Role = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ContactInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *ContactInfoType) SetProperties(props ...Prop) *ContactInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ContactInfoType) SetProperty(key string, value interface{}) *ContactInfoType {
        if n == nil {
                n, _ = ContactInfoTypePointer(ContactInfoType{})
        }
        switch key {
    case "Address":
    if v, ok:= AddressTypePointer(value); ok {
      n.contactinfotype.Address = v
      }
    case "EmailList":
    if v, ok:= EmailListTypePointer(value); ok {
      n.contactinfotype.EmailList = v
      }
    case "Name":
    if v, ok:= NameTypePointer(value); ok {
      n.contactinfotype.Name = v
      }
    case "PhoneNumberList":
    if v, ok:= PhoneNumberListTypePointer(value); ok {
      n.contactinfotype.PhoneNumberList = v
      }
    case "PositionTitle":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.contactinfotype.PositionTitle = ((*String)(v))
      }
    case "Qualifications":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.contactinfotype.Qualifications = ((*String)(v))
      }
    case "RegistrationDetails":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.contactinfotype.RegistrationDetails = ((*String)(v))
      }
    case "Role":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.contactinfotype.Role = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ContactInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactInfoType) Address() *AddressType {
    if s.contactinfotype.Address == nil {
     if v, ok:= AddressTypePointer(AddressType{}); ok {
      s.contactinfotype.Address = v
      }
      }
      return s.contactinfotype.Address
    }
// Returns whether the element value for Address is nil in the container ContactInfoType.
  func (s *ContactInfoType) Address_IsNil() bool {
    return s.contactinfotype.Address == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactInfoType) EmailList() *EmailListType {
    if s.contactinfotype.EmailList == nil {
     if v, ok:= EmailListTypePointer(EmailListType{}); ok {
      s.contactinfotype.EmailList = v
      }
      }
      return s.contactinfotype.EmailList
    }
// Returns whether the element value for EmailList is nil in the container ContactInfoType.
  func (s *ContactInfoType) EmailList_IsNil() bool {
    return s.contactinfotype.EmailList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactInfoType) Name() *NameType {
    if s.contactinfotype.Name == nil {
     if v, ok:= NameTypePointer(NameType{}); ok {
      s.contactinfotype.Name = v
      }
      }
      return s.contactinfotype.Name
    }
// Returns whether the element value for Name is nil in the container ContactInfoType.
  func (s *ContactInfoType) Name_IsNil() bool {
    return s.contactinfotype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactInfoType) PhoneNumberList() *PhoneNumberListType {
    if s.contactinfotype.PhoneNumberList == nil {
     if v, ok:= PhoneNumberListTypePointer(PhoneNumberListType{}); ok {
      s.contactinfotype.PhoneNumberList = v
      }
      }
      return s.contactinfotype.PhoneNumberList
    }
// Returns whether the element value for PhoneNumberList is nil in the container ContactInfoType.
  func (s *ContactInfoType) PhoneNumberList_IsNil() bool {
    return s.contactinfotype.PhoneNumberList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactInfoType) PositionTitle() *String {
    if s.contactinfotype.PositionTitle == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactinfotype.PositionTitle = ((*String)(v))
      }
      }
      return s.contactinfotype.PositionTitle
    }
// Returns whether the element value for PositionTitle is nil in the container ContactInfoType.
  func (s *ContactInfoType) PositionTitle_IsNil() bool {
    return s.contactinfotype.PositionTitle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactInfoType) Qualifications() *String {
    if s.contactinfotype.Qualifications == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactinfotype.Qualifications = ((*String)(v))
      }
      }
      return s.contactinfotype.Qualifications
    }
// Returns whether the element value for Qualifications is nil in the container ContactInfoType.
  func (s *ContactInfoType) Qualifications_IsNil() bool {
    return s.contactinfotype.Qualifications == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactInfoType) RegistrationDetails() *String {
    if s.contactinfotype.RegistrationDetails == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactinfotype.RegistrationDetails = ((*String)(v))
      }
      }
      return s.contactinfotype.RegistrationDetails
    }
// Returns whether the element value for RegistrationDetails is nil in the container ContactInfoType.
  func (s *ContactInfoType) RegistrationDetails_IsNil() bool {
    return s.contactinfotype.RegistrationDetails == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactInfoType) Role() *String {
    if s.contactinfotype.Role == nil {
    if v, ok:= StringPointer(""); ok {
      s.contactinfotype.Role = ((*String)(v))
      }
      }
      return s.contactinfotype.Role
    }
// Returns whether the element value for Role is nil in the container ContactInfoType.
  func (s *ContactInfoType) Role_IsNil() bool {
    return s.contactinfotype.Role == nil
    }

// Set the value of a property to nil
func (n *ContactType) Unset(key string) *ContactType {
        switch key {
  case "Address":
   n.contacttype.Address = nil
  case "Email":
   n.contacttype.Email = nil
  case "Name":
   n.contacttype.Name = nil
  case "PhoneNumber":
   n.contacttype.PhoneNumber = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ContactType")
        }
        return n
}

// Set a sequence of properties
func (n *ContactType) SetProperties(props ...Prop) *ContactType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ContactType) SetProperty(key string, value interface{}) *ContactType {
        if n == nil {
                n, _ = ContactTypePointer(ContactType{})
        }
        switch key {
    case "Address":
    if v, ok:= AddressTypePointer(value); ok {
      n.contacttype.Address = v
      }
    case "Email":
    if v, ok:= EmailTypePointer(value); ok {
      n.contacttype.Email = v
      }
    case "Name":
    if v, ok:= NameTypePointer(value); ok {
      n.contacttype.Name = v
      }
    case "PhoneNumber":
    if v, ok:= PhoneNumberTypePointer(value); ok {
      n.contacttype.PhoneNumber = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ContactType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactType) Address() *AddressType {
    if s.contacttype.Address == nil {
     if v, ok:= AddressTypePointer(AddressType{}); ok {
      s.contacttype.Address = v
      }
      }
      return s.contacttype.Address
    }
// Returns whether the element value for Address is nil in the container ContactType.
  func (s *ContactType) Address_IsNil() bool {
    return s.contacttype.Address == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactType) Email() *EmailType {
    if s.contacttype.Email == nil {
     if v, ok:= EmailTypePointer(EmailType{}); ok {
      s.contacttype.Email = v
      }
      }
      return s.contacttype.Email
    }
// Returns whether the element value for Email is nil in the container ContactType.
  func (s *ContactType) Email_IsNil() bool {
    return s.contacttype.Email == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactType) Name() *NameType {
    if s.contacttype.Name == nil {
     if v, ok:= NameTypePointer(NameType{}); ok {
      s.contacttype.Name = v
      }
      }
      return s.contacttype.Name
    }
// Returns whether the element value for Name is nil in the container ContactType.
  func (s *ContactType) Name_IsNil() bool {
    return s.contacttype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ContactType) PhoneNumber() *PhoneNumberType {
    if s.contacttype.PhoneNumber == nil {
     if v, ok:= PhoneNumberTypePointer(PhoneNumberType{}); ok {
      s.contacttype.PhoneNumber = v
      }
      }
      return s.contacttype.PhoneNumber
    }
// Returns whether the element value for PhoneNumber is nil in the container ContactType.
  func (s *ContactType) PhoneNumber_IsNil() bool {
    return s.contacttype.PhoneNumber == nil
    }

// Set the value of a property to nil
func (n *CopyRightContainerType) Unset(key string) *CopyRightContainerType {
        switch key {
  case "Date":
   n.copyrightcontainertype.Date = nil
  case "Holder":
   n.copyrightcontainertype.Holder = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CopyRightContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *CopyRightContainerType) SetProperties(props ...Prop) *CopyRightContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CopyRightContainerType) SetProperty(key string, value interface{}) *CopyRightContainerType {
        if n == nil {
                n, _ = CopyRightContainerTypePointer(CopyRightContainerType{})
        }
        switch key {
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.copyrightcontainertype.Date = ((*String)(v))
      }
    case "Holder":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.copyrightcontainertype.Holder = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CopyRightContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CopyRightContainerType) Date() *String {
    if s.copyrightcontainertype.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.copyrightcontainertype.Date = ((*String)(v))
      }
      }
      return s.copyrightcontainertype.Date
    }
// Returns whether the element value for Date is nil in the container CopyRightContainerType.
  func (s *CopyRightContainerType) Date_IsNil() bool {
    return s.copyrightcontainertype.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CopyRightContainerType) Holder() *String {
    if s.copyrightcontainertype.Holder == nil {
    if v, ok:= StringPointer(""); ok {
      s.copyrightcontainertype.Holder = ((*String)(v))
      }
      }
      return s.copyrightcontainertype.Holder
    }
// Returns whether the element value for Holder is nil in the container CopyRightContainerType.
  func (s *CopyRightContainerType) Holder_IsNil() bool {
    return s.copyrightcontainertype.Holder == nil
    }

// Set the value of a property to nil
func (n *CreatedType) Unset(key string) *CreatedType {
        switch key {
  case "Creators":
   n.createdtype.Creators = nil
  case "DateTime":
   n.createdtype.DateTime = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CreatedType")
        }
        return n
}

// Set a sequence of properties
func (n *CreatedType) SetProperties(props ...Prop) *CreatedType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CreatedType) SetProperty(key string, value interface{}) *CreatedType {
        if n == nil {
                n, _ = CreatedTypePointer(CreatedType{})
        }
        switch key {
    case "Creators":
    if v, ok:= CreatorListTypePointer(value); ok {
      n.createdtype.Creators = v
      }
    case "DateTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.createdtype.DateTime = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CreatedType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CreatedType) Creators() *CreatorListType {
    if s.createdtype.Creators == nil {
     if v, ok:= CreatorListTypePointer(CreatorListType{}); ok {
      s.createdtype.Creators = v
      }
      }
      return s.createdtype.Creators
    }
// Returns whether the element value for Creators is nil in the container CreatedType.
  func (s *CreatedType) Creators_IsNil() bool {
    return s.createdtype.Creators == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CreatedType) DateTime() *String {
    if s.createdtype.DateTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.createdtype.DateTime = ((*String)(v))
      }
      }
      return s.createdtype.DateTime
    }
// Returns whether the element value for DateTime is nil in the container CreatedType.
  func (s *CreatedType) DateTime_IsNil() bool {
    return s.createdtype.DateTime == nil
    }

// Set the value of a property to nil
func (n *CreationUserType) Unset(key string) *CreationUserType {
        switch key {
  case "Type":
   n.creationusertype.Type = nil
  case "UserId":
   n.creationusertype.UserId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CreationUserType")
        }
        return n
}

// Set a sequence of properties
func (n *CreationUserType) SetProperties(props ...Prop) *CreationUserType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *CreationUserType) SetProperty(key string, value interface{}) *CreationUserType {
        if n == nil {
                n, _ = CreationUserTypePointer(CreationUserType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.creationusertype.Type = ((*String)(v))
      }
    case "UserId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.creationusertype.UserId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "CreationUserType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CreationUserType) Type() *String {
    if s.creationusertype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.creationusertype.Type = ((*String)(v))
      }
      }
      return s.creationusertype.Type
    }
// Returns whether the element value for Type is nil in the container CreationUserType.
  func (s *CreationUserType) Type_IsNil() bool {
    return s.creationusertype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *CreationUserType) UserId() *String {
    if s.creationusertype.UserId == nil {
    if v, ok:= StringPointer(""); ok {
      s.creationusertype.UserId = ((*String)(v))
      }
      }
      return s.creationusertype.UserId
    }
// Returns whether the element value for UserId is nil in the container CreationUserType.
  func (s *CreationUserType) UserId_IsNil() bool {
    return s.creationusertype.UserId == nil
    }

// Set the value of a property to nil
func (n *DataDomainObligationType) Unset(key string) *DataDomainObligationType {
        switch key {
  case "DataDomain":
   n.datadomainobligationtype.DataDomain = nil
  case "DoNotShareWithList":
   n.datadomainobligationtype.DoNotShareWithList = nil
  case "DomainComments":
   n.datadomainobligationtype.DomainComments = nil
  case "ShareWithList":
   n.datadomainobligationtype.ShareWithList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DataDomainObligationType")
        }
        return n
}

// Set a sequence of properties
func (n *DataDomainObligationType) SetProperties(props ...Prop) *DataDomainObligationType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DataDomainObligationType) SetProperty(key string, value interface{}) *DataDomainObligationType {
        if n == nil {
                n, _ = DataDomainObligationTypePointer(DataDomainObligationType{})
        }
        switch key {
    case "DataDomain":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.datadomainobligationtype.DataDomain = ((*String)(v))
      }
    case "DoNotShareWithList":
    if v, ok:= DoNotShareWithListTypePointer(value); ok {
      n.datadomainobligationtype.DoNotShareWithList = v
      }
    case "DomainComments":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.datadomainobligationtype.DomainComments = ((*String)(v))
      }
    case "ShareWithList":
    if v, ok:= ShareWithListTypePointer(value); ok {
      n.datadomainobligationtype.ShareWithList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DataDomainObligationType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DataDomainObligationType) DataDomain() *String {
    if s.datadomainobligationtype.DataDomain == nil {
    if v, ok:= StringPointer(""); ok {
      s.datadomainobligationtype.DataDomain = ((*String)(v))
      }
      }
      return s.datadomainobligationtype.DataDomain
    }
// Returns whether the element value for DataDomain is nil in the container DataDomainObligationType.
  func (s *DataDomainObligationType) DataDomain_IsNil() bool {
    return s.datadomainobligationtype.DataDomain == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DataDomainObligationType) DoNotShareWithList() *DoNotShareWithListType {
    if s.datadomainobligationtype.DoNotShareWithList == nil {
     if v, ok:= DoNotShareWithListTypePointer(DoNotShareWithListType{}); ok {
      s.datadomainobligationtype.DoNotShareWithList = v
      }
      }
      return s.datadomainobligationtype.DoNotShareWithList
    }
// Returns whether the element value for DoNotShareWithList is nil in the container DataDomainObligationType.
  func (s *DataDomainObligationType) DoNotShareWithList_IsNil() bool {
    return s.datadomainobligationtype.DoNotShareWithList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DataDomainObligationType) DomainComments() *String {
    if s.datadomainobligationtype.DomainComments == nil {
    if v, ok:= StringPointer(""); ok {
      s.datadomainobligationtype.DomainComments = ((*String)(v))
      }
      }
      return s.datadomainobligationtype.DomainComments
    }
// Returns whether the element value for DomainComments is nil in the container DataDomainObligationType.
  func (s *DataDomainObligationType) DomainComments_IsNil() bool {
    return s.datadomainobligationtype.DomainComments == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DataDomainObligationType) ShareWithList() *ShareWithListType {
    if s.datadomainobligationtype.ShareWithList == nil {
     if v, ok:= ShareWithListTypePointer(ShareWithListType{}); ok {
      s.datadomainobligationtype.ShareWithList = v
      }
      }
      return s.datadomainobligationtype.ShareWithList
    }
// Returns whether the element value for ShareWithList is nil in the container DataDomainObligationType.
  func (s *DataDomainObligationType) ShareWithList_IsNil() bool {
    return s.datadomainobligationtype.ShareWithList == nil
    }

// Set the value of a property to nil
func (n *DebitOrCreditAmountType) Unset(key string) *DebitOrCreditAmountType {
        switch key {
  case "Type":
   n.debitorcreditamounttype.Type = nil
  case "Currency":
   n.debitorcreditamounttype.Currency = nil
  case "Value":
   n.debitorcreditamounttype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DebitOrCreditAmountType")
        }
        return n
}

// Set a sequence of properties
func (n *DebitOrCreditAmountType) SetProperties(props ...Prop) *DebitOrCreditAmountType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DebitOrCreditAmountType) SetProperty(key string, value interface{}) *DebitOrCreditAmountType {
        if n == nil {
                n, _ = DebitOrCreditAmountTypePointer(DebitOrCreditAmountType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debitorcreditamounttype.Type = ((*String)(v))
      }
    case "Currency":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(ISO4217CurrencyNamesAndCodeElementsType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "ISO4217CurrencyNamesAndCodeElementsType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.debitorcreditamounttype.Currency = ((*ISO4217CurrencyNamesAndCodeElementsType)(v))
      }
    case "Value":
    
    if v, ok:= FloatPointer(value); ok {
      n.debitorcreditamounttype.Value = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DebitOrCreditAmountType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DebitOrCreditAmountType) Type() *String {
    if s.debitorcreditamounttype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.debitorcreditamounttype.Type = ((*String)(v))
      }
      }
      return s.debitorcreditamounttype.Type
    }
// Returns whether the element value for Type is nil in the container DebitOrCreditAmountType.
  func (s *DebitOrCreditAmountType) Type_IsNil() bool {
    return s.debitorcreditamounttype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DebitOrCreditAmountType) Currency() *ISO4217CurrencyNamesAndCodeElementsType {
    if s.debitorcreditamounttype.Currency == nil {
    if v, ok:= StringPointer(""); ok {
      s.debitorcreditamounttype.Currency = ((*ISO4217CurrencyNamesAndCodeElementsType)(v))
      }
      }
      return s.debitorcreditamounttype.Currency
    }
// Returns whether the element value for Currency is nil in the container DebitOrCreditAmountType.
  func (s *DebitOrCreditAmountType) Currency_IsNil() bool {
    return s.debitorcreditamounttype.Currency == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DebitOrCreditAmountType) Value() *Float {
    if s.debitorcreditamounttype.Value == nil {
    if v, ok:= FloatPointer(0); ok {
      s.debitorcreditamounttype.Value = ((*Float)(v))
      }
      }
      return s.debitorcreditamounttype.Value
    }
// Returns whether the element value for Value is nil in the container DebitOrCreditAmountType.
  func (s *DebitOrCreditAmountType) Value_IsNil() bool {
    return s.debitorcreditamounttype.Value == nil
    }

// Set the value of a property to nil
func (n *Debtor) Unset(key string) *Debtor {
        switch key {
  case "AccountName":
   n.debtor.AccountName = nil
  case "AccountNumber":
   n.debtor.AccountNumber = nil
  case "AddressList":
   n.debtor.AddressList = nil
  case "BSB":
   n.debtor.BSB = nil
  case "BilledEntity":
   n.debtor.BilledEntity = nil
  case "BillingName":
   n.debtor.BillingName = nil
  case "BillingNote":
   n.debtor.BillingNote = nil
  case "Discount":
   n.debtor.Discount = nil
  case "LocalCodeList":
   n.debtor.LocalCodeList = nil
  case "LocalId":
   n.debtor.LocalId = nil
  case "RefId":
   n.debtor.RefId = nil
  case "SIF_ExtendedElements":
   n.debtor.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.debtor.SIF_Metadata = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Debtor")
        }
        return n
}

// Set a sequence of properties
func (n *Debtor) SetProperties(props ...Prop) *Debtor {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *Debtor) SetProperty(key string, value interface{}) *Debtor {
        if n == nil {
                n, _ = DebtorPointer(Debtor{})
        }
        switch key {
    case "AccountName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor.AccountName = ((*String)(v))
      }
    case "AccountNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor.AccountNumber = ((*String)(v))
      }
    case "AddressList":
    if v, ok:= AddressListTypePointer(value); ok {
      n.debtor.AddressList = v
      }
    case "BSB":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor.BSB = ((*String)(v))
      }
    case "BilledEntity":
    if v, ok:= Debtor_BilledEntityPointer(value); ok {
      n.debtor.BilledEntity = v
      }
    case "BillingName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor.BillingName = ((*String)(v))
      }
    case "BillingNote":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor.BillingNote = ((*String)(v))
      }
    case "Discount":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor.Discount = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.debtor.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor.LocalId = ((*LocalIdType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.debtor.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.debtor.SIF_Metadata = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Debtor")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) AccountName() *String {
    if s.debtor.AccountName == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor.AccountName = ((*String)(v))
      }
      }
      return s.debtor.AccountName
    }
// Returns whether the element value for AccountName is nil in the container Debtor.
  func (s *Debtor) AccountName_IsNil() bool {
    return s.debtor.AccountName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) AccountNumber() *String {
    if s.debtor.AccountNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor.AccountNumber = ((*String)(v))
      }
      }
      return s.debtor.AccountNumber
    }
// Returns whether the element value for AccountNumber is nil in the container Debtor.
  func (s *Debtor) AccountNumber_IsNil() bool {
    return s.debtor.AccountNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) AddressList() *AddressListType {
    if s.debtor.AddressList == nil {
     if v, ok:= AddressListTypePointer(AddressListType{}); ok {
      s.debtor.AddressList = v
      }
      }
      return s.debtor.AddressList
    }
// Returns whether the element value for AddressList is nil in the container Debtor.
  func (s *Debtor) AddressList_IsNil() bool {
    return s.debtor.AddressList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) BSB() *String {
    if s.debtor.BSB == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor.BSB = ((*String)(v))
      }
      }
      return s.debtor.BSB
    }
// Returns whether the element value for BSB is nil in the container Debtor.
  func (s *Debtor) BSB_IsNil() bool {
    return s.debtor.BSB == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) BilledEntity() *Debtor_BilledEntity {
    if s.debtor.BilledEntity == nil {
     if v, ok:= Debtor_BilledEntityPointer(Debtor_BilledEntity{}); ok {
      s.debtor.BilledEntity = v
      }
      }
      return s.debtor.BilledEntity
    }
// Returns whether the element value for BilledEntity is nil in the container Debtor.
  func (s *Debtor) BilledEntity_IsNil() bool {
    return s.debtor.BilledEntity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) BillingName() *String {
    if s.debtor.BillingName == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor.BillingName = ((*String)(v))
      }
      }
      return s.debtor.BillingName
    }
// Returns whether the element value for BillingName is nil in the container Debtor.
  func (s *Debtor) BillingName_IsNil() bool {
    return s.debtor.BillingName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) BillingNote() *String {
    if s.debtor.BillingNote == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor.BillingNote = ((*String)(v))
      }
      }
      return s.debtor.BillingNote
    }
// Returns whether the element value for BillingNote is nil in the container Debtor.
  func (s *Debtor) BillingNote_IsNil() bool {
    return s.debtor.BillingNote == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) Discount() *String {
    if s.debtor.Discount == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor.Discount = ((*String)(v))
      }
      }
      return s.debtor.Discount
    }
// Returns whether the element value for Discount is nil in the container Debtor.
  func (s *Debtor) Discount_IsNil() bool {
    return s.debtor.Discount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) LocalCodeList() *LocalCodeListType {
    if s.debtor.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.debtor.LocalCodeList = v
      }
      }
      return s.debtor.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container Debtor.
  func (s *Debtor) LocalCodeList_IsNil() bool {
    return s.debtor.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) LocalId() *LocalIdType {
    if s.debtor.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.debtor.LocalId
    }
// Returns whether the element value for LocalId is nil in the container Debtor.
  func (s *Debtor) LocalId_IsNil() bool {
    return s.debtor.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) RefId() *RefIdType {
    if s.debtor.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor.RefId = ((*RefIdType)(v))
      }
      }
      return s.debtor.RefId
    }
// Returns whether the element value for RefId is nil in the container Debtor.
  func (s *Debtor) RefId_IsNil() bool {
    return s.debtor.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.debtor.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.debtor.SIF_ExtendedElements = v
      }
      }
      return s.debtor.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container Debtor.
  func (s *Debtor) SIF_ExtendedElements_IsNil() bool {
    return s.debtor.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor) SIF_Metadata() *SIF_MetadataType {
    if s.debtor.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.debtor.SIF_Metadata = v
      }
      }
      return s.debtor.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container Debtor.
  func (s *Debtor) SIF_Metadata_IsNil() bool {
    return s.debtor.SIF_Metadata == nil
    }

// Set the value of a property to nil
func (n *Debtor_BilledEntity) Unset(key string) *Debtor_BilledEntity {
        switch key {
  case "SIF_RefObject":
   n.debtor_billedentity.SIF_RefObject = nil
  case "Value":
   n.debtor_billedentity.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Debtor_BilledEntity")
        }
        return n
}

// Set a sequence of properties
func (n *Debtor_BilledEntity) SetProperties(props ...Prop) *Debtor_BilledEntity {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *Debtor_BilledEntity) SetProperty(key string, value interface{}) *Debtor_BilledEntity {
        if n == nil {
                n, _ = Debtor_BilledEntityPointer(Debtor_BilledEntity{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor_billedentity.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.debtor_billedentity.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Debtor_BilledEntity")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor_BilledEntity) SIF_RefObject() *String {
    if s.debtor_billedentity.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor_billedentity.SIF_RefObject = ((*String)(v))
      }
      }
      return s.debtor_billedentity.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container Debtor_BilledEntity.
  func (s *Debtor_BilledEntity) SIF_RefObject_IsNil() bool {
    return s.debtor_billedentity.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Debtor_BilledEntity) Value() *String {
    if s.debtor_billedentity.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.debtor_billedentity.Value = ((*String)(v))
      }
      }
      return s.debtor_billedentity.Value
    }
// Returns whether the element value for Value is nil in the container Debtor_BilledEntity.
  func (s *Debtor_BilledEntity) Value_IsNil() bool {
    return s.debtor_billedentity.Value == nil
    }

// Set the value of a property to nil
func (n *DemographicsType) Unset(key string) *DemographicsType {
        switch key {
  case "AustralianCitizenshipStatus":
   n.demographicstype.AustralianCitizenshipStatus = nil
  case "BirthDate":
   n.demographicstype.BirthDate = nil
  case "BirthDateVerification":
   n.demographicstype.BirthDateVerification = nil
  case "CountriesOfCitizenship":
   n.demographicstype.CountriesOfCitizenship = nil
  case "CountriesOfResidency":
   n.demographicstype.CountriesOfResidency = nil
  case "CountryArrivalDate":
   n.demographicstype.CountryArrivalDate = nil
  case "CountryOfBirth":
   n.demographicstype.CountryOfBirth = nil
  case "CulturalBackground":
   n.demographicstype.CulturalBackground = nil
  case "DateOfDeath":
   n.demographicstype.DateOfDeath = nil
  case "Deceased":
   n.demographicstype.Deceased = nil
  case "DwellingArrangement":
   n.demographicstype.DwellingArrangement = nil
  case "EnglishProficiency":
   n.demographicstype.EnglishProficiency = nil
  case "Gender":
   n.demographicstype.Gender = nil
  case "ImmunisationCertificateStatus":
   n.demographicstype.ImmunisationCertificateStatus = nil
  case "IndigenousStatus":
   n.demographicstype.IndigenousStatus = nil
  case "InterpreterRequired":
   n.demographicstype.InterpreterRequired = nil
  case "LBOTE":
   n.demographicstype.LBOTE = nil
  case "LanguageList":
   n.demographicstype.LanguageList = nil
  case "MaritalStatus":
   n.demographicstype.MaritalStatus = nil
  case "MedicareCardHolder":
   n.demographicstype.MedicareCardHolder = nil
  case "MedicareNumber":
   n.demographicstype.MedicareNumber = nil
  case "MedicarePositionNumber":
   n.demographicstype.MedicarePositionNumber = nil
  case "Passport":
   n.demographicstype.Passport = nil
  case "PermanentResident":
   n.demographicstype.PermanentResident = nil
  case "PlaceOfBirth":
   n.demographicstype.PlaceOfBirth = nil
  case "PrivateHealthInsurance":
   n.demographicstype.PrivateHealthInsurance = nil
  case "Religion":
   n.demographicstype.Religion = nil
  case "ReligiousEventList":
   n.demographicstype.ReligiousEventList = nil
  case "ReligiousRegion":
   n.demographicstype.ReligiousRegion = nil
  case "Sex":
   n.demographicstype.Sex = nil
  case "StateOfBirth":
   n.demographicstype.StateOfBirth = nil
  case "VisaConditions":
   n.demographicstype.VisaConditions = nil
  case "VisaExpiryDate":
   n.demographicstype.VisaExpiryDate = nil
  case "VisaGrantDate":
   n.demographicstype.VisaGrantDate = nil
  case "VisaNumber":
   n.demographicstype.VisaNumber = nil
  case "VisaStatisticalCode":
   n.demographicstype.VisaStatisticalCode = nil
  case "VisaStudyEntitlement":
   n.demographicstype.VisaStudyEntitlement = nil
  case "VisaSubClass":
   n.demographicstype.VisaSubClass = nil
  case "VisaSubClassList":
   n.demographicstype.VisaSubClassList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DemographicsType")
        }
        return n
}

// Set a sequence of properties
func (n *DemographicsType) SetProperties(props ...Prop) *DemographicsType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DemographicsType) SetProperty(key string, value interface{}) *DemographicsType {
        if n == nil {
                n, _ = DemographicsTypePointer(DemographicsType{})
        }
        switch key {
    case "AustralianCitizenshipStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAustralianCitizenshipStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAustralianCitizenshipStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.AustralianCitizenshipStatus = ((*AUCodeSetsAustralianCitizenshipStatusType)(v))
      }
    case "BirthDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.BirthDate = ((*BirthDateType)(v))
      }
    case "BirthDateVerification":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsBirthdateVerificationType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsBirthdateVerificationType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.BirthDateVerification = ((*AUCodeSetsBirthdateVerificationType)(v))
      }
    case "CountriesOfCitizenship":
    if v, ok:= CountryListTypePointer(value); ok {
      n.demographicstype.CountriesOfCitizenship = v
      }
    case "CountriesOfResidency":
    if v, ok:= CountryList2TypePointer(value); ok {
      n.demographicstype.CountriesOfResidency = v
      }
    case "CountryArrivalDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.CountryArrivalDate = ((*String)(v))
      }
    case "CountryOfBirth":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.CountryOfBirth = ((*CountryType)(v))
      }
    case "CulturalBackground":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.CulturalBackground = ((*AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType)(v))
      }
    case "DateOfDeath":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.DateOfDeath = ((*String)(v))
      }
    case "Deceased":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.Deceased = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "DwellingArrangement":
    if v, ok:= DwellingArrangementTypePointer(value); ok {
      n.demographicstype.DwellingArrangement = v
      }
    case "EnglishProficiency":
    if v, ok:= EnglishProficiencyTypePointer(value); ok {
      n.demographicstype.EnglishProficiency = v
      }
    case "Gender":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSexCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSexCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.Gender = ((*AUCodeSetsSexCodeType)(v))
      }
    case "ImmunisationCertificateStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsImmunisationCertificateStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsImmunisationCertificateStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.ImmunisationCertificateStatus = ((*AUCodeSetsImmunisationCertificateStatusType)(v))
      }
    case "IndigenousStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsIndigenousStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsIndigenousStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.IndigenousStatus = ((*AUCodeSetsIndigenousStatusType)(v))
      }
    case "InterpreterRequired":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.InterpreterRequired = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "LBOTE":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.LBOTE = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "LanguageList":
    if v, ok:= LanguageListTypePointer(value); ok {
      n.demographicstype.LanguageList = v
      }
    case "MaritalStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsMaritalStatusAIHWType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsMaritalStatusAIHWType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.MaritalStatus = ((*AUCodeSetsMaritalStatusAIHWType)(v))
      }
    case "MedicareCardHolder":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.MedicareCardHolder = ((*String)(v))
      }
    case "MedicareNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.MedicareNumber = ((*String)(v))
      }
    case "MedicarePositionNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.MedicarePositionNumber = ((*String)(v))
      }
    case "Passport":
    if v, ok:= PassportTypePointer(value); ok {
      n.demographicstype.Passport = v
      }
    case "PermanentResident":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsPermanentResidentStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsPermanentResidentStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.PermanentResident = ((*AUCodeSetsPermanentResidentStatusType)(v))
      }
    case "PlaceOfBirth":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.PlaceOfBirth = ((*String)(v))
      }
    case "PrivateHealthInsurance":
    if v, ok:= PrivateHealthInsuranceTypePointer(value); ok {
      n.demographicstype.PrivateHealthInsurance = v
      }
    case "Religion":
    if v, ok:= ReligionTypePointer(value); ok {
      n.demographicstype.Religion = v
      }
    case "ReligiousEventList":
    if v, ok:= ReligiousEventListTypePointer(value); ok {
      n.demographicstype.ReligiousEventList = v
      }
    case "ReligiousRegion":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.ReligiousRegion = ((*String)(v))
      }
    case "Sex":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSexCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSexCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.Sex = ((*AUCodeSetsSexCodeType)(v))
      }
    case "StateOfBirth":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.StateOfBirth = ((*StateProvinceType)(v))
      }
    case "VisaConditions":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.VisaConditions = ((*String)(v))
      }
    case "VisaExpiryDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.VisaExpiryDate = ((*String)(v))
      }
    case "VisaGrantDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.VisaGrantDate = ((*String)(v))
      }
    case "VisaNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.VisaNumber = ((*String)(v))
      }
    case "VisaStatisticalCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.VisaStatisticalCode = ((*String)(v))
      }
    case "VisaStudyEntitlement":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsVisaStudyEntitlementType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsVisaStudyEntitlementType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.demographicstype.VisaStudyEntitlement = ((*AUCodeSetsVisaStudyEntitlementType)(v))
      }
    case "VisaSubClass":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.demographicstype.VisaSubClass = ((*VisaSubClassCodeType)(v))
      }
    case "VisaSubClassList":
    if v, ok:= VisaSubClassListTypePointer(value); ok {
      n.demographicstype.VisaSubClassList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DemographicsType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) AustralianCitizenshipStatus() *AUCodeSetsAustralianCitizenshipStatusType {
    if s.demographicstype.AustralianCitizenshipStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.AustralianCitizenshipStatus = ((*AUCodeSetsAustralianCitizenshipStatusType)(v))
      }
      }
      return s.demographicstype.AustralianCitizenshipStatus
    }
// Returns whether the element value for AustralianCitizenshipStatus is nil in the container DemographicsType.
  func (s *DemographicsType) AustralianCitizenshipStatus_IsNil() bool {
    return s.demographicstype.AustralianCitizenshipStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) BirthDate() *BirthDateType {
    if s.demographicstype.BirthDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.BirthDate = ((*BirthDateType)(v))
      }
      }
      return s.demographicstype.BirthDate
    }
// Returns whether the element value for BirthDate is nil in the container DemographicsType.
  func (s *DemographicsType) BirthDate_IsNil() bool {
    return s.demographicstype.BirthDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) BirthDateVerification() *AUCodeSetsBirthdateVerificationType {
    if s.demographicstype.BirthDateVerification == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.BirthDateVerification = ((*AUCodeSetsBirthdateVerificationType)(v))
      }
      }
      return s.demographicstype.BirthDateVerification
    }
// Returns whether the element value for BirthDateVerification is nil in the container DemographicsType.
  func (s *DemographicsType) BirthDateVerification_IsNil() bool {
    return s.demographicstype.BirthDateVerification == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) CountriesOfCitizenship() *CountryListType {
    if s.demographicstype.CountriesOfCitizenship == nil {
     if v, ok:= CountryListTypePointer(CountryListType{}); ok {
      s.demographicstype.CountriesOfCitizenship = v
      }
      }
      return s.demographicstype.CountriesOfCitizenship
    }
// Returns whether the element value for CountriesOfCitizenship is nil in the container DemographicsType.
  func (s *DemographicsType) CountriesOfCitizenship_IsNil() bool {
    return s.demographicstype.CountriesOfCitizenship == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) CountriesOfResidency() *CountryList2Type {
    if s.demographicstype.CountriesOfResidency == nil {
     if v, ok:= CountryList2TypePointer(CountryList2Type{}); ok {
      s.demographicstype.CountriesOfResidency = v
      }
      }
      return s.demographicstype.CountriesOfResidency
    }
// Returns whether the element value for CountriesOfResidency is nil in the container DemographicsType.
  func (s *DemographicsType) CountriesOfResidency_IsNil() bool {
    return s.demographicstype.CountriesOfResidency == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) CountryArrivalDate() *String {
    if s.demographicstype.CountryArrivalDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.CountryArrivalDate = ((*String)(v))
      }
      }
      return s.demographicstype.CountryArrivalDate
    }
// Returns whether the element value for CountryArrivalDate is nil in the container DemographicsType.
  func (s *DemographicsType) CountryArrivalDate_IsNil() bool {
    return s.demographicstype.CountryArrivalDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) CountryOfBirth() *CountryType {
    if s.demographicstype.CountryOfBirth == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.CountryOfBirth = ((*CountryType)(v))
      }
      }
      return s.demographicstype.CountryOfBirth
    }
// Returns whether the element value for CountryOfBirth is nil in the container DemographicsType.
  func (s *DemographicsType) CountryOfBirth_IsNil() bool {
    return s.demographicstype.CountryOfBirth == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) CulturalBackground() *AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType {
    if s.demographicstype.CulturalBackground == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.CulturalBackground = ((*AUCodeSetsAustralianStandardClassificationOfCulturalAndEthnicGroupsASCCEGType)(v))
      }
      }
      return s.demographicstype.CulturalBackground
    }
// Returns whether the element value for CulturalBackground is nil in the container DemographicsType.
  func (s *DemographicsType) CulturalBackground_IsNil() bool {
    return s.demographicstype.CulturalBackground == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) DateOfDeath() *String {
    if s.demographicstype.DateOfDeath == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.DateOfDeath = ((*String)(v))
      }
      }
      return s.demographicstype.DateOfDeath
    }
// Returns whether the element value for DateOfDeath is nil in the container DemographicsType.
  func (s *DemographicsType) DateOfDeath_IsNil() bool {
    return s.demographicstype.DateOfDeath == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) Deceased() *AUCodeSetsYesOrNoCategoryType {
    if s.demographicstype.Deceased == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.Deceased = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.demographicstype.Deceased
    }
// Returns whether the element value for Deceased is nil in the container DemographicsType.
  func (s *DemographicsType) Deceased_IsNil() bool {
    return s.demographicstype.Deceased == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) DwellingArrangement() *DwellingArrangementType {
    if s.demographicstype.DwellingArrangement == nil {
     if v, ok:= DwellingArrangementTypePointer(DwellingArrangementType{}); ok {
      s.demographicstype.DwellingArrangement = v
      }
      }
      return s.demographicstype.DwellingArrangement
    }
// Returns whether the element value for DwellingArrangement is nil in the container DemographicsType.
  func (s *DemographicsType) DwellingArrangement_IsNil() bool {
    return s.demographicstype.DwellingArrangement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) EnglishProficiency() *EnglishProficiencyType {
    if s.demographicstype.EnglishProficiency == nil {
     if v, ok:= EnglishProficiencyTypePointer(EnglishProficiencyType{}); ok {
      s.demographicstype.EnglishProficiency = v
      }
      }
      return s.demographicstype.EnglishProficiency
    }
// Returns whether the element value for EnglishProficiency is nil in the container DemographicsType.
  func (s *DemographicsType) EnglishProficiency_IsNil() bool {
    return s.demographicstype.EnglishProficiency == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) Gender() *AUCodeSetsSexCodeType {
    if s.demographicstype.Gender == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.Gender = ((*AUCodeSetsSexCodeType)(v))
      }
      }
      return s.demographicstype.Gender
    }
// Returns whether the element value for Gender is nil in the container DemographicsType.
  func (s *DemographicsType) Gender_IsNil() bool {
    return s.demographicstype.Gender == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) ImmunisationCertificateStatus() *AUCodeSetsImmunisationCertificateStatusType {
    if s.demographicstype.ImmunisationCertificateStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.ImmunisationCertificateStatus = ((*AUCodeSetsImmunisationCertificateStatusType)(v))
      }
      }
      return s.demographicstype.ImmunisationCertificateStatus
    }
// Returns whether the element value for ImmunisationCertificateStatus is nil in the container DemographicsType.
  func (s *DemographicsType) ImmunisationCertificateStatus_IsNil() bool {
    return s.demographicstype.ImmunisationCertificateStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) IndigenousStatus() *AUCodeSetsIndigenousStatusType {
    if s.demographicstype.IndigenousStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.IndigenousStatus = ((*AUCodeSetsIndigenousStatusType)(v))
      }
      }
      return s.demographicstype.IndigenousStatus
    }
// Returns whether the element value for IndigenousStatus is nil in the container DemographicsType.
  func (s *DemographicsType) IndigenousStatus_IsNil() bool {
    return s.demographicstype.IndigenousStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) InterpreterRequired() *AUCodeSetsYesOrNoCategoryType {
    if s.demographicstype.InterpreterRequired == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.InterpreterRequired = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.demographicstype.InterpreterRequired
    }
// Returns whether the element value for InterpreterRequired is nil in the container DemographicsType.
  func (s *DemographicsType) InterpreterRequired_IsNil() bool {
    return s.demographicstype.InterpreterRequired == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) LBOTE() *AUCodeSetsYesOrNoCategoryType {
    if s.demographicstype.LBOTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.LBOTE = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.demographicstype.LBOTE
    }
// Returns whether the element value for LBOTE is nil in the container DemographicsType.
  func (s *DemographicsType) LBOTE_IsNil() bool {
    return s.demographicstype.LBOTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) LanguageList() *LanguageListType {
    if s.demographicstype.LanguageList == nil {
     if v, ok:= LanguageListTypePointer(LanguageListType{}); ok {
      s.demographicstype.LanguageList = v
      }
      }
      return s.demographicstype.LanguageList
    }
// Returns whether the element value for LanguageList is nil in the container DemographicsType.
  func (s *DemographicsType) LanguageList_IsNil() bool {
    return s.demographicstype.LanguageList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) MaritalStatus() *AUCodeSetsMaritalStatusAIHWType {
    if s.demographicstype.MaritalStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.MaritalStatus = ((*AUCodeSetsMaritalStatusAIHWType)(v))
      }
      }
      return s.demographicstype.MaritalStatus
    }
// Returns whether the element value for MaritalStatus is nil in the container DemographicsType.
  func (s *DemographicsType) MaritalStatus_IsNil() bool {
    return s.demographicstype.MaritalStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) MedicareCardHolder() *String {
    if s.demographicstype.MedicareCardHolder == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.MedicareCardHolder = ((*String)(v))
      }
      }
      return s.demographicstype.MedicareCardHolder
    }
// Returns whether the element value for MedicareCardHolder is nil in the container DemographicsType.
  func (s *DemographicsType) MedicareCardHolder_IsNil() bool {
    return s.demographicstype.MedicareCardHolder == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) MedicareNumber() *String {
    if s.demographicstype.MedicareNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.MedicareNumber = ((*String)(v))
      }
      }
      return s.demographicstype.MedicareNumber
    }
// Returns whether the element value for MedicareNumber is nil in the container DemographicsType.
  func (s *DemographicsType) MedicareNumber_IsNil() bool {
    return s.demographicstype.MedicareNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) MedicarePositionNumber() *String {
    if s.demographicstype.MedicarePositionNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.MedicarePositionNumber = ((*String)(v))
      }
      }
      return s.demographicstype.MedicarePositionNumber
    }
// Returns whether the element value for MedicarePositionNumber is nil in the container DemographicsType.
  func (s *DemographicsType) MedicarePositionNumber_IsNil() bool {
    return s.demographicstype.MedicarePositionNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) Passport() *PassportType {
    if s.demographicstype.Passport == nil {
     if v, ok:= PassportTypePointer(PassportType{}); ok {
      s.demographicstype.Passport = v
      }
      }
      return s.demographicstype.Passport
    }
// Returns whether the element value for Passport is nil in the container DemographicsType.
  func (s *DemographicsType) Passport_IsNil() bool {
    return s.demographicstype.Passport == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) PermanentResident() *AUCodeSetsPermanentResidentStatusType {
    if s.demographicstype.PermanentResident == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.PermanentResident = ((*AUCodeSetsPermanentResidentStatusType)(v))
      }
      }
      return s.demographicstype.PermanentResident
    }
// Returns whether the element value for PermanentResident is nil in the container DemographicsType.
  func (s *DemographicsType) PermanentResident_IsNil() bool {
    return s.demographicstype.PermanentResident == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) PlaceOfBirth() *String {
    if s.demographicstype.PlaceOfBirth == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.PlaceOfBirth = ((*String)(v))
      }
      }
      return s.demographicstype.PlaceOfBirth
    }
// Returns whether the element value for PlaceOfBirth is nil in the container DemographicsType.
  func (s *DemographicsType) PlaceOfBirth_IsNil() bool {
    return s.demographicstype.PlaceOfBirth == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) PrivateHealthInsurance() *PrivateHealthInsuranceType {
    if s.demographicstype.PrivateHealthInsurance == nil {
     if v, ok:= PrivateHealthInsuranceTypePointer(PrivateHealthInsuranceType{}); ok {
      s.demographicstype.PrivateHealthInsurance = v
      }
      }
      return s.demographicstype.PrivateHealthInsurance
    }
// Returns whether the element value for PrivateHealthInsurance is nil in the container DemographicsType.
  func (s *DemographicsType) PrivateHealthInsurance_IsNil() bool {
    return s.demographicstype.PrivateHealthInsurance == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) Religion() *ReligionType {
    if s.demographicstype.Religion == nil {
     if v, ok:= ReligionTypePointer(ReligionType{}); ok {
      s.demographicstype.Religion = v
      }
      }
      return s.demographicstype.Religion
    }
// Returns whether the element value for Religion is nil in the container DemographicsType.
  func (s *DemographicsType) Religion_IsNil() bool {
    return s.demographicstype.Religion == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) ReligiousEventList() *ReligiousEventListType {
    if s.demographicstype.ReligiousEventList == nil {
     if v, ok:= ReligiousEventListTypePointer(ReligiousEventListType{}); ok {
      s.demographicstype.ReligiousEventList = v
      }
      }
      return s.demographicstype.ReligiousEventList
    }
// Returns whether the element value for ReligiousEventList is nil in the container DemographicsType.
  func (s *DemographicsType) ReligiousEventList_IsNil() bool {
    return s.demographicstype.ReligiousEventList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) ReligiousRegion() *String {
    if s.demographicstype.ReligiousRegion == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.ReligiousRegion = ((*String)(v))
      }
      }
      return s.demographicstype.ReligiousRegion
    }
// Returns whether the element value for ReligiousRegion is nil in the container DemographicsType.
  func (s *DemographicsType) ReligiousRegion_IsNil() bool {
    return s.demographicstype.ReligiousRegion == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) Sex() *AUCodeSetsSexCodeType {
    if s.demographicstype.Sex == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.Sex = ((*AUCodeSetsSexCodeType)(v))
      }
      }
      return s.demographicstype.Sex
    }
// Returns whether the element value for Sex is nil in the container DemographicsType.
  func (s *DemographicsType) Sex_IsNil() bool {
    return s.demographicstype.Sex == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) StateOfBirth() *StateProvinceType {
    if s.demographicstype.StateOfBirth == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.StateOfBirth = ((*StateProvinceType)(v))
      }
      }
      return s.demographicstype.StateOfBirth
    }
// Returns whether the element value for StateOfBirth is nil in the container DemographicsType.
  func (s *DemographicsType) StateOfBirth_IsNil() bool {
    return s.demographicstype.StateOfBirth == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) VisaConditions() *String {
    if s.demographicstype.VisaConditions == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.VisaConditions = ((*String)(v))
      }
      }
      return s.demographicstype.VisaConditions
    }
// Returns whether the element value for VisaConditions is nil in the container DemographicsType.
  func (s *DemographicsType) VisaConditions_IsNil() bool {
    return s.demographicstype.VisaConditions == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) VisaExpiryDate() *String {
    if s.demographicstype.VisaExpiryDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.VisaExpiryDate = ((*String)(v))
      }
      }
      return s.demographicstype.VisaExpiryDate
    }
// Returns whether the element value for VisaExpiryDate is nil in the container DemographicsType.
  func (s *DemographicsType) VisaExpiryDate_IsNil() bool {
    return s.demographicstype.VisaExpiryDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) VisaGrantDate() *String {
    if s.demographicstype.VisaGrantDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.VisaGrantDate = ((*String)(v))
      }
      }
      return s.demographicstype.VisaGrantDate
    }
// Returns whether the element value for VisaGrantDate is nil in the container DemographicsType.
  func (s *DemographicsType) VisaGrantDate_IsNil() bool {
    return s.demographicstype.VisaGrantDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) VisaNumber() *String {
    if s.demographicstype.VisaNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.VisaNumber = ((*String)(v))
      }
      }
      return s.demographicstype.VisaNumber
    }
// Returns whether the element value for VisaNumber is nil in the container DemographicsType.
  func (s *DemographicsType) VisaNumber_IsNil() bool {
    return s.demographicstype.VisaNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) VisaStatisticalCode() *String {
    if s.demographicstype.VisaStatisticalCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.VisaStatisticalCode = ((*String)(v))
      }
      }
      return s.demographicstype.VisaStatisticalCode
    }
// Returns whether the element value for VisaStatisticalCode is nil in the container DemographicsType.
  func (s *DemographicsType) VisaStatisticalCode_IsNil() bool {
    return s.demographicstype.VisaStatisticalCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) VisaStudyEntitlement() *AUCodeSetsVisaStudyEntitlementType {
    if s.demographicstype.VisaStudyEntitlement == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.VisaStudyEntitlement = ((*AUCodeSetsVisaStudyEntitlementType)(v))
      }
      }
      return s.demographicstype.VisaStudyEntitlement
    }
// Returns whether the element value for VisaStudyEntitlement is nil in the container DemographicsType.
  func (s *DemographicsType) VisaStudyEntitlement_IsNil() bool {
    return s.demographicstype.VisaStudyEntitlement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) VisaSubClass() *VisaSubClassCodeType {
    if s.demographicstype.VisaSubClass == nil {
    if v, ok:= StringPointer(""); ok {
      s.demographicstype.VisaSubClass = ((*VisaSubClassCodeType)(v))
      }
      }
      return s.demographicstype.VisaSubClass
    }
// Returns whether the element value for VisaSubClass is nil in the container DemographicsType.
  func (s *DemographicsType) VisaSubClass_IsNil() bool {
    return s.demographicstype.VisaSubClass == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DemographicsType) VisaSubClassList() *VisaSubClassListType {
    if s.demographicstype.VisaSubClassList == nil {
     if v, ok:= VisaSubClassListTypePointer(VisaSubClassListType{}); ok {
      s.demographicstype.VisaSubClassList = v
      }
      }
      return s.demographicstype.VisaSubClassList
    }
// Returns whether the element value for VisaSubClassList is nil in the container DemographicsType.
  func (s *DemographicsType) VisaSubClassList_IsNil() bool {
    return s.demographicstype.VisaSubClassList == nil
    }

// Set the value of a property to nil
func (n *DepartureSchoolType) Unset(key string) *DepartureSchoolType {
        switch key {
  case "ACARAId":
   n.departureschooltype.ACARAId = nil
  case "City":
   n.departureschooltype.City = nil
  case "ExitDate":
   n.departureschooltype.ExitDate = nil
  case "Name":
   n.departureschooltype.Name = nil
  case "SchoolContactList":
   n.departureschooltype.SchoolContactList = nil
  case "Sector":
   n.departureschooltype.Sector = nil
  case "StartedAtSchoolDate":
   n.departureschooltype.StartedAtSchoolDate = nil
  case "State":
   n.departureschooltype.State = nil
  case "System":
   n.departureschooltype.System = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DepartureSchoolType")
        }
        return n
}

// Set a sequence of properties
func (n *DepartureSchoolType) SetProperties(props ...Prop) *DepartureSchoolType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DepartureSchoolType) SetProperty(key string, value interface{}) *DepartureSchoolType {
        if n == nil {
                n, _ = DepartureSchoolTypePointer(DepartureSchoolType{})
        }
        switch key {
    case "ACARAId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.departureschooltype.ACARAId = ((*String)(v))
      }
    case "City":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.departureschooltype.City = ((*String)(v))
      }
    case "ExitDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.departureschooltype.ExitDate = ((*String)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.departureschooltype.Name = ((*String)(v))
      }
    case "SchoolContactList":
    if v, ok:= SchoolContactListTypePointer(value); ok {
      n.departureschooltype.SchoolContactList = v
      }
    case "Sector":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolSectorCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolSectorCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.departureschooltype.Sector = ((*AUCodeSetsSchoolSectorCodeType)(v))
      }
    case "StartedAtSchoolDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.departureschooltype.StartedAtSchoolDate = ((*String)(v))
      }
    case "State":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.departureschooltype.State = ((*StateProvinceType)(v))
      }
    case "System":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolSystemType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolSystemType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.departureschooltype.System = ((*AUCodeSetsSchoolSystemType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DepartureSchoolType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DepartureSchoolType) ACARAId() *String {
    if s.departureschooltype.ACARAId == nil {
    if v, ok:= StringPointer(""); ok {
      s.departureschooltype.ACARAId = ((*String)(v))
      }
      }
      return s.departureschooltype.ACARAId
    }
// Returns whether the element value for ACARAId is nil in the container DepartureSchoolType.
  func (s *DepartureSchoolType) ACARAId_IsNil() bool {
    return s.departureschooltype.ACARAId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DepartureSchoolType) City() *String {
    if s.departureschooltype.City == nil {
    if v, ok:= StringPointer(""); ok {
      s.departureschooltype.City = ((*String)(v))
      }
      }
      return s.departureschooltype.City
    }
// Returns whether the element value for City is nil in the container DepartureSchoolType.
  func (s *DepartureSchoolType) City_IsNil() bool {
    return s.departureschooltype.City == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DepartureSchoolType) ExitDate() *String {
    if s.departureschooltype.ExitDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.departureschooltype.ExitDate = ((*String)(v))
      }
      }
      return s.departureschooltype.ExitDate
    }
// Returns whether the element value for ExitDate is nil in the container DepartureSchoolType.
  func (s *DepartureSchoolType) ExitDate_IsNil() bool {
    return s.departureschooltype.ExitDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DepartureSchoolType) Name() *String {
    if s.departureschooltype.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.departureschooltype.Name = ((*String)(v))
      }
      }
      return s.departureschooltype.Name
    }
// Returns whether the element value for Name is nil in the container DepartureSchoolType.
  func (s *DepartureSchoolType) Name_IsNil() bool {
    return s.departureschooltype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DepartureSchoolType) SchoolContactList() *SchoolContactListType {
    if s.departureschooltype.SchoolContactList == nil {
     if v, ok:= SchoolContactListTypePointer(SchoolContactListType{}); ok {
      s.departureschooltype.SchoolContactList = v
      }
      }
      return s.departureschooltype.SchoolContactList
    }
// Returns whether the element value for SchoolContactList is nil in the container DepartureSchoolType.
  func (s *DepartureSchoolType) SchoolContactList_IsNil() bool {
    return s.departureschooltype.SchoolContactList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DepartureSchoolType) Sector() *AUCodeSetsSchoolSectorCodeType {
    if s.departureschooltype.Sector == nil {
    if v, ok:= StringPointer(""); ok {
      s.departureschooltype.Sector = ((*AUCodeSetsSchoolSectorCodeType)(v))
      }
      }
      return s.departureschooltype.Sector
    }
// Returns whether the element value for Sector is nil in the container DepartureSchoolType.
  func (s *DepartureSchoolType) Sector_IsNil() bool {
    return s.departureschooltype.Sector == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DepartureSchoolType) StartedAtSchoolDate() *String {
    if s.departureschooltype.StartedAtSchoolDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.departureschooltype.StartedAtSchoolDate = ((*String)(v))
      }
      }
      return s.departureschooltype.StartedAtSchoolDate
    }
// Returns whether the element value for StartedAtSchoolDate is nil in the container DepartureSchoolType.
  func (s *DepartureSchoolType) StartedAtSchoolDate_IsNil() bool {
    return s.departureschooltype.StartedAtSchoolDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DepartureSchoolType) State() *StateProvinceType {
    if s.departureschooltype.State == nil {
    if v, ok:= StringPointer(""); ok {
      s.departureschooltype.State = ((*StateProvinceType)(v))
      }
      }
      return s.departureschooltype.State
    }
// Returns whether the element value for State is nil in the container DepartureSchoolType.
  func (s *DepartureSchoolType) State_IsNil() bool {
    return s.departureschooltype.State == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DepartureSchoolType) System() *AUCodeSetsSchoolSystemType {
    if s.departureschooltype.System == nil {
    if v, ok:= StringPointer(""); ok {
      s.departureschooltype.System = ((*AUCodeSetsSchoolSystemType)(v))
      }
      }
      return s.departureschooltype.System
    }
// Returns whether the element value for System is nil in the container DepartureSchoolType.
  func (s *DepartureSchoolType) System_IsNil() bool {
    return s.departureschooltype.System == nil
    }

// Set the value of a property to nil
func (n *DetentionContainerType) Unset(key string) *DetentionContainerType {
        switch key {
  case "DetentionCategory":
   n.detentioncontainertype.DetentionCategory = nil
  case "DetentionDate":
   n.detentioncontainertype.DetentionDate = nil
  case "DetentionLocation":
   n.detentioncontainertype.DetentionLocation = nil
  case "DetentionNotes":
   n.detentioncontainertype.DetentionNotes = nil
  case "Status":
   n.detentioncontainertype.Status = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DetentionContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *DetentionContainerType) SetProperties(props ...Prop) *DetentionContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DetentionContainerType) SetProperty(key string, value interface{}) *DetentionContainerType {
        if n == nil {
                n, _ = DetentionContainerTypePointer(DetentionContainerType{})
        }
        switch key {
    case "DetentionCategory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsDetentionCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsDetentionCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.detentioncontainertype.DetentionCategory = ((*AUCodeSetsDetentionCategoryType)(v))
      }
    case "DetentionDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.detentioncontainertype.DetentionDate = ((*String)(v))
      }
    case "DetentionLocation":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.detentioncontainertype.DetentionLocation = ((*String)(v))
      }
    case "DetentionNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.detentioncontainertype.DetentionNotes = ((*String)(v))
      }
    case "Status":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.detentioncontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DetentionContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DetentionContainerType) DetentionCategory() *AUCodeSetsDetentionCategoryType {
    if s.detentioncontainertype.DetentionCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.detentioncontainertype.DetentionCategory = ((*AUCodeSetsDetentionCategoryType)(v))
      }
      }
      return s.detentioncontainertype.DetentionCategory
    }
// Returns whether the element value for DetentionCategory is nil in the container DetentionContainerType.
  func (s *DetentionContainerType) DetentionCategory_IsNil() bool {
    return s.detentioncontainertype.DetentionCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DetentionContainerType) DetentionDate() *String {
    if s.detentioncontainertype.DetentionDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.detentioncontainertype.DetentionDate = ((*String)(v))
      }
      }
      return s.detentioncontainertype.DetentionDate
    }
// Returns whether the element value for DetentionDate is nil in the container DetentionContainerType.
  func (s *DetentionContainerType) DetentionDate_IsNil() bool {
    return s.detentioncontainertype.DetentionDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DetentionContainerType) DetentionLocation() *String {
    if s.detentioncontainertype.DetentionLocation == nil {
    if v, ok:= StringPointer(""); ok {
      s.detentioncontainertype.DetentionLocation = ((*String)(v))
      }
      }
      return s.detentioncontainertype.DetentionLocation
    }
// Returns whether the element value for DetentionLocation is nil in the container DetentionContainerType.
  func (s *DetentionContainerType) DetentionLocation_IsNil() bool {
    return s.detentioncontainertype.DetentionLocation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DetentionContainerType) DetentionNotes() *String {
    if s.detentioncontainertype.DetentionNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.detentioncontainertype.DetentionNotes = ((*String)(v))
      }
      }
      return s.detentioncontainertype.DetentionNotes
    }
// Returns whether the element value for DetentionNotes is nil in the container DetentionContainerType.
  func (s *DetentionContainerType) DetentionNotes_IsNil() bool {
    return s.detentioncontainertype.DetentionNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DetentionContainerType) Status() *AUCodeSetsWellbeingStatusType {
    if s.detentioncontainertype.Status == nil {
    if v, ok:= StringPointer(""); ok {
      s.detentioncontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
      }
      return s.detentioncontainertype.Status
    }
// Returns whether the element value for Status is nil in the container DetentionContainerType.
  func (s *DetentionContainerType) Status_IsNil() bool {
    return s.detentioncontainertype.Status == nil
    }

// Set the value of a property to nil
func (n *DoNotShareWithType) Unset(key string) *DoNotShareWithType {
        switch key {
  case "DoNotShareWithComments":
   n.donotsharewithtype.DoNotShareWithComments = nil
  case "DoNotShareWithLocalId":
   n.donotsharewithtype.DoNotShareWithLocalId = nil
  case "DoNotShareWithName":
   n.donotsharewithtype.DoNotShareWithName = nil
  case "DoNotShareWithObjectTypeName":
   n.donotsharewithtype.DoNotShareWithObjectTypeName = nil
  case "DoNotShareWithParty":
   n.donotsharewithtype.DoNotShareWithParty = nil
  case "DoNotShareWithPurpose":
   n.donotsharewithtype.DoNotShareWithPurpose = nil
  case "DoNotShareWithRefId":
   n.donotsharewithtype.DoNotShareWithRefId = nil
  case "DoNotShareWithRelationship":
   n.donotsharewithtype.DoNotShareWithRelationship = nil
  case "DoNotShareWithRole":
   n.donotsharewithtype.DoNotShareWithRole = nil
  case "DoNotShareWithURL":
   n.donotsharewithtype.DoNotShareWithURL = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DoNotShareWithType")
        }
        return n
}

// Set a sequence of properties
func (n *DoNotShareWithType) SetProperties(props ...Prop) *DoNotShareWithType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DoNotShareWithType) SetProperty(key string, value interface{}) *DoNotShareWithType {
        if n == nil {
                n, _ = DoNotShareWithTypePointer(DoNotShareWithType{})
        }
        switch key {
    case "DoNotShareWithComments":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithComments = ((*String)(v))
      }
    case "DoNotShareWithLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithLocalId = ((*LocalIdType)(v))
      }
    case "DoNotShareWithName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithName = ((*String)(v))
      }
    case "DoNotShareWithObjectTypeName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithObjectTypeName = ((*String)(v))
      }
    case "DoNotShareWithParty":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithParty = ((*String)(v))
      }
    case "DoNotShareWithPurpose":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithPurpose = ((*String)(v))
      }
    case "DoNotShareWithRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithRefId = ((*String)(v))
      }
    case "DoNotShareWithRelationship":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithRelationship = ((*String)(v))
      }
    case "DoNotShareWithRole":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithRole = ((*String)(v))
      }
    case "DoNotShareWithURL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.donotsharewithtype.DoNotShareWithURL = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DoNotShareWithType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithComments() *String {
    if s.donotsharewithtype.DoNotShareWithComments == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithComments = ((*String)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithComments
    }
// Returns whether the element value for DoNotShareWithComments is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithComments_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithComments == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithLocalId() *LocalIdType {
    if s.donotsharewithtype.DoNotShareWithLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithLocalId = ((*LocalIdType)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithLocalId
    }
// Returns whether the element value for DoNotShareWithLocalId is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithLocalId_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithName() *String {
    if s.donotsharewithtype.DoNotShareWithName == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithName = ((*String)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithName
    }
// Returns whether the element value for DoNotShareWithName is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithName_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithObjectTypeName() *String {
    if s.donotsharewithtype.DoNotShareWithObjectTypeName == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithObjectTypeName = ((*String)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithObjectTypeName
    }
// Returns whether the element value for DoNotShareWithObjectTypeName is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithObjectTypeName_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithObjectTypeName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithParty() *String {
    if s.donotsharewithtype.DoNotShareWithParty == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithParty = ((*String)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithParty
    }
// Returns whether the element value for DoNotShareWithParty is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithParty_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithParty == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithPurpose() *String {
    if s.donotsharewithtype.DoNotShareWithPurpose == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithPurpose = ((*String)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithPurpose
    }
// Returns whether the element value for DoNotShareWithPurpose is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithPurpose_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithPurpose == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithRefId() *String {
    if s.donotsharewithtype.DoNotShareWithRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithRefId = ((*String)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithRefId
    }
// Returns whether the element value for DoNotShareWithRefId is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithRefId_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithRelationship() *String {
    if s.donotsharewithtype.DoNotShareWithRelationship == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithRelationship = ((*String)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithRelationship
    }
// Returns whether the element value for DoNotShareWithRelationship is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithRelationship_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithRelationship == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithRole() *String {
    if s.donotsharewithtype.DoNotShareWithRole == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithRole = ((*String)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithRole
    }
// Returns whether the element value for DoNotShareWithRole is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithRole_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithRole == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DoNotShareWithType) DoNotShareWithURL() *String {
    if s.donotsharewithtype.DoNotShareWithURL == nil {
    if v, ok:= StringPointer(""); ok {
      s.donotsharewithtype.DoNotShareWithURL = ((*String)(v))
      }
      }
      return s.donotsharewithtype.DoNotShareWithURL
    }
// Returns whether the element value for DoNotShareWithURL is nil in the container DoNotShareWithType.
  func (s *DoNotShareWithType) DoNotShareWithURL_IsNil() bool {
    return s.donotsharewithtype.DoNotShareWithURL == nil
    }

// Set the value of a property to nil
func (n *DomainBandsContainerType) Unset(key string) *DomainBandsContainerType {
        switch key {
  case "Band10Lower":
   n.domainbandscontainertype.Band10Lower = nil
  case "Band10Upper":
   n.domainbandscontainertype.Band10Upper = nil
  case "Band1Lower":
   n.domainbandscontainertype.Band1Lower = nil
  case "Band1Upper":
   n.domainbandscontainertype.Band1Upper = nil
  case "Band2Lower":
   n.domainbandscontainertype.Band2Lower = nil
  case "Band2Upper":
   n.domainbandscontainertype.Band2Upper = nil
  case "Band3Lower":
   n.domainbandscontainertype.Band3Lower = nil
  case "Band3Upper":
   n.domainbandscontainertype.Band3Upper = nil
  case "Band4Lower":
   n.domainbandscontainertype.Band4Lower = nil
  case "Band4Upper":
   n.domainbandscontainertype.Band4Upper = nil
  case "Band5Lower":
   n.domainbandscontainertype.Band5Lower = nil
  case "Band5Upper":
   n.domainbandscontainertype.Band5Upper = nil
  case "Band6Lower":
   n.domainbandscontainertype.Band6Lower = nil
  case "Band6Upper":
   n.domainbandscontainertype.Band6Upper = nil
  case "Band7Lower":
   n.domainbandscontainertype.Band7Lower = nil
  case "Band7Upper":
   n.domainbandscontainertype.Band7Upper = nil
  case "Band8Lower":
   n.domainbandscontainertype.Band8Lower = nil
  case "Band8Upper":
   n.domainbandscontainertype.Band8Upper = nil
  case "Band9Lower":
   n.domainbandscontainertype.Band9Lower = nil
  case "Band9Upper":
   n.domainbandscontainertype.Band9Upper = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DomainBandsContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *DomainBandsContainerType) SetProperties(props ...Prop) *DomainBandsContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DomainBandsContainerType) SetProperty(key string, value interface{}) *DomainBandsContainerType {
        if n == nil {
                n, _ = DomainBandsContainerTypePointer(DomainBandsContainerType{})
        }
        switch key {
    case "Band10Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band10Lower = ((*Float)(v))
      }
    case "Band10Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band10Upper = ((*Float)(v))
      }
    case "Band1Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band1Lower = ((*Float)(v))
      }
    case "Band1Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band1Upper = ((*Float)(v))
      }
    case "Band2Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band2Lower = ((*Float)(v))
      }
    case "Band2Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band2Upper = ((*Float)(v))
      }
    case "Band3Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band3Lower = ((*Float)(v))
      }
    case "Band3Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band3Upper = ((*Float)(v))
      }
    case "Band4Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band4Lower = ((*Float)(v))
      }
    case "Band4Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band4Upper = ((*Float)(v))
      }
    case "Band5Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band5Lower = ((*Float)(v))
      }
    case "Band5Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band5Upper = ((*Float)(v))
      }
    case "Band6Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band6Lower = ((*Float)(v))
      }
    case "Band6Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band6Upper = ((*Float)(v))
      }
    case "Band7Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band7Lower = ((*Float)(v))
      }
    case "Band7Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band7Upper = ((*Float)(v))
      }
    case "Band8Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band8Lower = ((*Float)(v))
      }
    case "Band8Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band8Upper = ((*Float)(v))
      }
    case "Band9Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band9Lower = ((*Float)(v))
      }
    case "Band9Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainbandscontainertype.Band9Upper = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DomainBandsContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band10Lower() *Float {
    if s.domainbandscontainertype.Band10Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band10Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band10Lower
    }
// Returns whether the element value for Band10Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band10Lower_IsNil() bool {
    return s.domainbandscontainertype.Band10Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band10Upper() *Float {
    if s.domainbandscontainertype.Band10Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band10Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band10Upper
    }
// Returns whether the element value for Band10Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band10Upper_IsNil() bool {
    return s.domainbandscontainertype.Band10Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band1Lower() *Float {
    if s.domainbandscontainertype.Band1Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band1Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band1Lower
    }
// Returns whether the element value for Band1Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band1Lower_IsNil() bool {
    return s.domainbandscontainertype.Band1Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band1Upper() *Float {
    if s.domainbandscontainertype.Band1Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band1Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band1Upper
    }
// Returns whether the element value for Band1Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band1Upper_IsNil() bool {
    return s.domainbandscontainertype.Band1Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band2Lower() *Float {
    if s.domainbandscontainertype.Band2Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band2Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band2Lower
    }
// Returns whether the element value for Band2Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band2Lower_IsNil() bool {
    return s.domainbandscontainertype.Band2Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band2Upper() *Float {
    if s.domainbandscontainertype.Band2Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band2Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band2Upper
    }
// Returns whether the element value for Band2Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band2Upper_IsNil() bool {
    return s.domainbandscontainertype.Band2Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band3Lower() *Float {
    if s.domainbandscontainertype.Band3Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band3Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band3Lower
    }
// Returns whether the element value for Band3Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band3Lower_IsNil() bool {
    return s.domainbandscontainertype.Band3Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band3Upper() *Float {
    if s.domainbandscontainertype.Band3Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band3Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band3Upper
    }
// Returns whether the element value for Band3Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band3Upper_IsNil() bool {
    return s.domainbandscontainertype.Band3Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band4Lower() *Float {
    if s.domainbandscontainertype.Band4Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band4Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band4Lower
    }
// Returns whether the element value for Band4Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band4Lower_IsNil() bool {
    return s.domainbandscontainertype.Band4Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band4Upper() *Float {
    if s.domainbandscontainertype.Band4Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band4Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band4Upper
    }
// Returns whether the element value for Band4Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band4Upper_IsNil() bool {
    return s.domainbandscontainertype.Band4Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band5Lower() *Float {
    if s.domainbandscontainertype.Band5Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band5Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band5Lower
    }
// Returns whether the element value for Band5Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band5Lower_IsNil() bool {
    return s.domainbandscontainertype.Band5Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band5Upper() *Float {
    if s.domainbandscontainertype.Band5Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band5Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band5Upper
    }
// Returns whether the element value for Band5Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band5Upper_IsNil() bool {
    return s.domainbandscontainertype.Band5Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band6Lower() *Float {
    if s.domainbandscontainertype.Band6Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band6Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band6Lower
    }
// Returns whether the element value for Band6Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band6Lower_IsNil() bool {
    return s.domainbandscontainertype.Band6Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band6Upper() *Float {
    if s.domainbandscontainertype.Band6Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band6Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band6Upper
    }
// Returns whether the element value for Band6Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band6Upper_IsNil() bool {
    return s.domainbandscontainertype.Band6Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band7Lower() *Float {
    if s.domainbandscontainertype.Band7Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band7Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band7Lower
    }
// Returns whether the element value for Band7Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band7Lower_IsNil() bool {
    return s.domainbandscontainertype.Band7Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band7Upper() *Float {
    if s.domainbandscontainertype.Band7Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band7Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band7Upper
    }
// Returns whether the element value for Band7Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band7Upper_IsNil() bool {
    return s.domainbandscontainertype.Band7Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band8Lower() *Float {
    if s.domainbandscontainertype.Band8Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band8Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band8Lower
    }
// Returns whether the element value for Band8Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band8Lower_IsNil() bool {
    return s.domainbandscontainertype.Band8Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band8Upper() *Float {
    if s.domainbandscontainertype.Band8Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band8Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band8Upper
    }
// Returns whether the element value for Band8Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band8Upper_IsNil() bool {
    return s.domainbandscontainertype.Band8Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band9Lower() *Float {
    if s.domainbandscontainertype.Band9Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band9Lower = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band9Lower
    }
// Returns whether the element value for Band9Lower is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band9Lower_IsNil() bool {
    return s.domainbandscontainertype.Band9Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainBandsContainerType) Band9Upper() *Float {
    if s.domainbandscontainertype.Band9Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainbandscontainertype.Band9Upper = ((*Float)(v))
      }
      }
      return s.domainbandscontainertype.Band9Upper
    }
// Returns whether the element value for Band9Upper is nil in the container DomainBandsContainerType.
  func (s *DomainBandsContainerType) Band9Upper_IsNil() bool {
    return s.domainbandscontainertype.Band9Upper == nil
    }

// Set the value of a property to nil
func (n *DomainProficiencyContainerType) Unset(key string) *DomainProficiencyContainerType {
        switch key {
  case "Level1Lower":
   n.domainproficiencycontainertype.Level1Lower = nil
  case "Level1Upper":
   n.domainproficiencycontainertype.Level1Upper = nil
  case "Level2Lower":
   n.domainproficiencycontainertype.Level2Lower = nil
  case "Level2Upper":
   n.domainproficiencycontainertype.Level2Upper = nil
  case "Level3Lower":
   n.domainproficiencycontainertype.Level3Lower = nil
  case "Level3Upper":
   n.domainproficiencycontainertype.Level3Upper = nil
  case "Level4Lower":
   n.domainproficiencycontainertype.Level4Lower = nil
  case "Level4Upper":
   n.domainproficiencycontainertype.Level4Upper = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DomainProficiencyContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *DomainProficiencyContainerType) SetProperties(props ...Prop) *DomainProficiencyContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DomainProficiencyContainerType) SetProperty(key string, value interface{}) *DomainProficiencyContainerType {
        if n == nil {
                n, _ = DomainProficiencyContainerTypePointer(DomainProficiencyContainerType{})
        }
        switch key {
    case "Level1Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainproficiencycontainertype.Level1Lower = ((*Float)(v))
      }
    case "Level1Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainproficiencycontainertype.Level1Upper = ((*Float)(v))
      }
    case "Level2Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainproficiencycontainertype.Level2Lower = ((*Float)(v))
      }
    case "Level2Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainproficiencycontainertype.Level2Upper = ((*Float)(v))
      }
    case "Level3Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainproficiencycontainertype.Level3Lower = ((*Float)(v))
      }
    case "Level3Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainproficiencycontainertype.Level3Upper = ((*Float)(v))
      }
    case "Level4Lower":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainproficiencycontainertype.Level4Lower = ((*Float)(v))
      }
    case "Level4Upper":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainproficiencycontainertype.Level4Upper = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DomainProficiencyContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainProficiencyContainerType) Level1Lower() *Float {
    if s.domainproficiencycontainertype.Level1Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainproficiencycontainertype.Level1Lower = ((*Float)(v))
      }
      }
      return s.domainproficiencycontainertype.Level1Lower
    }
// Returns whether the element value for Level1Lower is nil in the container DomainProficiencyContainerType.
  func (s *DomainProficiencyContainerType) Level1Lower_IsNil() bool {
    return s.domainproficiencycontainertype.Level1Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainProficiencyContainerType) Level1Upper() *Float {
    if s.domainproficiencycontainertype.Level1Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainproficiencycontainertype.Level1Upper = ((*Float)(v))
      }
      }
      return s.domainproficiencycontainertype.Level1Upper
    }
// Returns whether the element value for Level1Upper is nil in the container DomainProficiencyContainerType.
  func (s *DomainProficiencyContainerType) Level1Upper_IsNil() bool {
    return s.domainproficiencycontainertype.Level1Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainProficiencyContainerType) Level2Lower() *Float {
    if s.domainproficiencycontainertype.Level2Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainproficiencycontainertype.Level2Lower = ((*Float)(v))
      }
      }
      return s.domainproficiencycontainertype.Level2Lower
    }
// Returns whether the element value for Level2Lower is nil in the container DomainProficiencyContainerType.
  func (s *DomainProficiencyContainerType) Level2Lower_IsNil() bool {
    return s.domainproficiencycontainertype.Level2Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainProficiencyContainerType) Level2Upper() *Float {
    if s.domainproficiencycontainertype.Level2Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainproficiencycontainertype.Level2Upper = ((*Float)(v))
      }
      }
      return s.domainproficiencycontainertype.Level2Upper
    }
// Returns whether the element value for Level2Upper is nil in the container DomainProficiencyContainerType.
  func (s *DomainProficiencyContainerType) Level2Upper_IsNil() bool {
    return s.domainproficiencycontainertype.Level2Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainProficiencyContainerType) Level3Lower() *Float {
    if s.domainproficiencycontainertype.Level3Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainproficiencycontainertype.Level3Lower = ((*Float)(v))
      }
      }
      return s.domainproficiencycontainertype.Level3Lower
    }
// Returns whether the element value for Level3Lower is nil in the container DomainProficiencyContainerType.
  func (s *DomainProficiencyContainerType) Level3Lower_IsNil() bool {
    return s.domainproficiencycontainertype.Level3Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainProficiencyContainerType) Level3Upper() *Float {
    if s.domainproficiencycontainertype.Level3Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainproficiencycontainertype.Level3Upper = ((*Float)(v))
      }
      }
      return s.domainproficiencycontainertype.Level3Upper
    }
// Returns whether the element value for Level3Upper is nil in the container DomainProficiencyContainerType.
  func (s *DomainProficiencyContainerType) Level3Upper_IsNil() bool {
    return s.domainproficiencycontainertype.Level3Upper == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainProficiencyContainerType) Level4Lower() *Float {
    if s.domainproficiencycontainertype.Level4Lower == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainproficiencycontainertype.Level4Lower = ((*Float)(v))
      }
      }
      return s.domainproficiencycontainertype.Level4Lower
    }
// Returns whether the element value for Level4Lower is nil in the container DomainProficiencyContainerType.
  func (s *DomainProficiencyContainerType) Level4Lower_IsNil() bool {
    return s.domainproficiencycontainertype.Level4Lower == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainProficiencyContainerType) Level4Upper() *Float {
    if s.domainproficiencycontainertype.Level4Upper == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainproficiencycontainertype.Level4Upper = ((*Float)(v))
      }
      }
      return s.domainproficiencycontainertype.Level4Upper
    }
// Returns whether the element value for Level4Upper is nil in the container DomainProficiencyContainerType.
  func (s *DomainProficiencyContainerType) Level4Upper_IsNil() bool {
    return s.domainproficiencycontainertype.Level4Upper == nil
    }

// Set the value of a property to nil
func (n *DomainScoreSDTNType) Unset(key string) *DomainScoreSDTNType {
        switch key {
  case "PlausibleScaledValueList":
   n.domainscoresdtntype.PlausibleScaledValueList = nil
  case "RawScore":
   n.domainscoresdtntype.RawScore = nil
  case "ScaledScoreLogitStandardError":
   n.domainscoresdtntype.ScaledScoreLogitStandardError = nil
  case "ScaledScoreLogitValue":
   n.domainscoresdtntype.ScaledScoreLogitValue = nil
  case "ScaledScoreStandardError":
   n.domainscoresdtntype.ScaledScoreStandardError = nil
  case "ScaledScoreValue":
   n.domainscoresdtntype.ScaledScoreValue = nil
  case "StudentDomainBand":
   n.domainscoresdtntype.StudentDomainBand = nil
  case "StudentProficiency":
   n.domainscoresdtntype.StudentProficiency = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DomainScoreSDTNType")
        }
        return n
}

// Set a sequence of properties
func (n *DomainScoreSDTNType) SetProperties(props ...Prop) *DomainScoreSDTNType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DomainScoreSDTNType) SetProperty(key string, value interface{}) *DomainScoreSDTNType {
        if n == nil {
                n, _ = DomainScoreSDTNTypePointer(DomainScoreSDTNType{})
        }
        switch key {
    case "PlausibleScaledValueList":
    if v, ok:= PlausibleScaledValueListTypePointer(value); ok {
      n.domainscoresdtntype.PlausibleScaledValueList = v
      }
    case "RawScore":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoresdtntype.RawScore = ((*Float)(v))
      }
    case "ScaledScoreLogitStandardError":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoresdtntype.ScaledScoreLogitStandardError = ((*Float)(v))
      }
    case "ScaledScoreLogitValue":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoresdtntype.ScaledScoreLogitValue = ((*Float)(v))
      }
    case "ScaledScoreStandardError":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoresdtntype.ScaledScoreStandardError = ((*Float)(v))
      }
    case "ScaledScoreValue":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoresdtntype.ScaledScoreValue = ((*Float)(v))
      }
    case "StudentDomainBand":
    
    if v, ok:= IntPointer(value); ok {
      n.domainscoresdtntype.StudentDomainBand = ((*Int)(v))
      }
    case "StudentProficiency":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.domainscoresdtntype.StudentProficiency = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DomainScoreSDTNType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreSDTNType) PlausibleScaledValueList() *PlausibleScaledValueListType {
    if s.domainscoresdtntype.PlausibleScaledValueList == nil {
     if v, ok:= PlausibleScaledValueListTypePointer(PlausibleScaledValueListType{}); ok {
      s.domainscoresdtntype.PlausibleScaledValueList = v
      }
      }
      return s.domainscoresdtntype.PlausibleScaledValueList
    }
// Returns whether the element value for PlausibleScaledValueList is nil in the container DomainScoreSDTNType.
  func (s *DomainScoreSDTNType) PlausibleScaledValueList_IsNil() bool {
    return s.domainscoresdtntype.PlausibleScaledValueList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreSDTNType) RawScore() *Float {
    if s.domainscoresdtntype.RawScore == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoresdtntype.RawScore = ((*Float)(v))
      }
      }
      return s.domainscoresdtntype.RawScore
    }
// Returns whether the element value for RawScore is nil in the container DomainScoreSDTNType.
  func (s *DomainScoreSDTNType) RawScore_IsNil() bool {
    return s.domainscoresdtntype.RawScore == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreSDTNType) ScaledScoreLogitStandardError() *Float {
    if s.domainscoresdtntype.ScaledScoreLogitStandardError == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoresdtntype.ScaledScoreLogitStandardError = ((*Float)(v))
      }
      }
      return s.domainscoresdtntype.ScaledScoreLogitStandardError
    }
// Returns whether the element value for ScaledScoreLogitStandardError is nil in the container DomainScoreSDTNType.
  func (s *DomainScoreSDTNType) ScaledScoreLogitStandardError_IsNil() bool {
    return s.domainscoresdtntype.ScaledScoreLogitStandardError == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreSDTNType) ScaledScoreLogitValue() *Float {
    if s.domainscoresdtntype.ScaledScoreLogitValue == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoresdtntype.ScaledScoreLogitValue = ((*Float)(v))
      }
      }
      return s.domainscoresdtntype.ScaledScoreLogitValue
    }
// Returns whether the element value for ScaledScoreLogitValue is nil in the container DomainScoreSDTNType.
  func (s *DomainScoreSDTNType) ScaledScoreLogitValue_IsNil() bool {
    return s.domainscoresdtntype.ScaledScoreLogitValue == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreSDTNType) ScaledScoreStandardError() *Float {
    if s.domainscoresdtntype.ScaledScoreStandardError == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoresdtntype.ScaledScoreStandardError = ((*Float)(v))
      }
      }
      return s.domainscoresdtntype.ScaledScoreStandardError
    }
// Returns whether the element value for ScaledScoreStandardError is nil in the container DomainScoreSDTNType.
  func (s *DomainScoreSDTNType) ScaledScoreStandardError_IsNil() bool {
    return s.domainscoresdtntype.ScaledScoreStandardError == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreSDTNType) ScaledScoreValue() *Float {
    if s.domainscoresdtntype.ScaledScoreValue == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoresdtntype.ScaledScoreValue = ((*Float)(v))
      }
      }
      return s.domainscoresdtntype.ScaledScoreValue
    }
// Returns whether the element value for ScaledScoreValue is nil in the container DomainScoreSDTNType.
  func (s *DomainScoreSDTNType) ScaledScoreValue_IsNil() bool {
    return s.domainscoresdtntype.ScaledScoreValue == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreSDTNType) StudentDomainBand() *Int {
    if s.domainscoresdtntype.StudentDomainBand == nil {
    if v, ok:= IntPointer(0); ok {
      s.domainscoresdtntype.StudentDomainBand = ((*Int)(v))
      }
      }
      return s.domainscoresdtntype.StudentDomainBand
    }
// Returns whether the element value for StudentDomainBand is nil in the container DomainScoreSDTNType.
  func (s *DomainScoreSDTNType) StudentDomainBand_IsNil() bool {
    return s.domainscoresdtntype.StudentDomainBand == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreSDTNType) StudentProficiency() *String {
    if s.domainscoresdtntype.StudentProficiency == nil {
    if v, ok:= StringPointer(""); ok {
      s.domainscoresdtntype.StudentProficiency = ((*String)(v))
      }
      }
      return s.domainscoresdtntype.StudentProficiency
    }
// Returns whether the element value for StudentProficiency is nil in the container DomainScoreSDTNType.
  func (s *DomainScoreSDTNType) StudentProficiency_IsNil() bool {
    return s.domainscoresdtntype.StudentProficiency == nil
    }

// Set the value of a property to nil
func (n *DomainScoreType) Unset(key string) *DomainScoreType {
        switch key {
  case "PlausibleScaledValueList":
   n.domainscoretype.PlausibleScaledValueList = nil
  case "RawScore":
   n.domainscoretype.RawScore = nil
  case "ScaledScoreLogitStandardError":
   n.domainscoretype.ScaledScoreLogitStandardError = nil
  case "ScaledScoreLogitValue":
   n.domainscoretype.ScaledScoreLogitValue = nil
  case "ScaledScoreStandardError":
   n.domainscoretype.ScaledScoreStandardError = nil
  case "ScaledScoreValue":
   n.domainscoretype.ScaledScoreValue = nil
  case "StudentDomainBand":
   n.domainscoretype.StudentDomainBand = nil
  case "StudentProficiency":
   n.domainscoretype.StudentProficiency = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DomainScoreType")
        }
        return n
}

// Set a sequence of properties
func (n *DomainScoreType) SetProperties(props ...Prop) *DomainScoreType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DomainScoreType) SetProperty(key string, value interface{}) *DomainScoreType {
        if n == nil {
                n, _ = DomainScoreTypePointer(DomainScoreType{})
        }
        switch key {
    case "PlausibleScaledValueList":
    if v, ok:= PlausibleScaledValueListTypePointer(value); ok {
      n.domainscoretype.PlausibleScaledValueList = v
      }
    case "RawScore":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoretype.RawScore = ((*Float)(v))
      }
    case "ScaledScoreLogitStandardError":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoretype.ScaledScoreLogitStandardError = ((*Float)(v))
      }
    case "ScaledScoreLogitValue":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoretype.ScaledScoreLogitValue = ((*Float)(v))
      }
    case "ScaledScoreStandardError":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoretype.ScaledScoreStandardError = ((*Float)(v))
      }
    case "ScaledScoreValue":
    
    if v, ok:= FloatPointer(value); ok {
      n.domainscoretype.ScaledScoreValue = ((*Float)(v))
      }
    case "StudentDomainBand":
    
    if v, ok:= IntPointer(value); ok {
      n.domainscoretype.StudentDomainBand = ((*Int)(v))
      }
    case "StudentProficiency":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.domainscoretype.StudentProficiency = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DomainScoreType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreType) PlausibleScaledValueList() *PlausibleScaledValueListType {
    if s.domainscoretype.PlausibleScaledValueList == nil {
     if v, ok:= PlausibleScaledValueListTypePointer(PlausibleScaledValueListType{}); ok {
      s.domainscoretype.PlausibleScaledValueList = v
      }
      }
      return s.domainscoretype.PlausibleScaledValueList
    }
// Returns whether the element value for PlausibleScaledValueList is nil in the container DomainScoreType.
  func (s *DomainScoreType) PlausibleScaledValueList_IsNil() bool {
    return s.domainscoretype.PlausibleScaledValueList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreType) RawScore() *Float {
    if s.domainscoretype.RawScore == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoretype.RawScore = ((*Float)(v))
      }
      }
      return s.domainscoretype.RawScore
    }
// Returns whether the element value for RawScore is nil in the container DomainScoreType.
  func (s *DomainScoreType) RawScore_IsNil() bool {
    return s.domainscoretype.RawScore == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreType) ScaledScoreLogitStandardError() *Float {
    if s.domainscoretype.ScaledScoreLogitStandardError == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoretype.ScaledScoreLogitStandardError = ((*Float)(v))
      }
      }
      return s.domainscoretype.ScaledScoreLogitStandardError
    }
// Returns whether the element value for ScaledScoreLogitStandardError is nil in the container DomainScoreType.
  func (s *DomainScoreType) ScaledScoreLogitStandardError_IsNil() bool {
    return s.domainscoretype.ScaledScoreLogitStandardError == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreType) ScaledScoreLogitValue() *Float {
    if s.domainscoretype.ScaledScoreLogitValue == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoretype.ScaledScoreLogitValue = ((*Float)(v))
      }
      }
      return s.domainscoretype.ScaledScoreLogitValue
    }
// Returns whether the element value for ScaledScoreLogitValue is nil in the container DomainScoreType.
  func (s *DomainScoreType) ScaledScoreLogitValue_IsNil() bool {
    return s.domainscoretype.ScaledScoreLogitValue == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreType) ScaledScoreStandardError() *Float {
    if s.domainscoretype.ScaledScoreStandardError == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoretype.ScaledScoreStandardError = ((*Float)(v))
      }
      }
      return s.domainscoretype.ScaledScoreStandardError
    }
// Returns whether the element value for ScaledScoreStandardError is nil in the container DomainScoreType.
  func (s *DomainScoreType) ScaledScoreStandardError_IsNil() bool {
    return s.domainscoretype.ScaledScoreStandardError == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreType) ScaledScoreValue() *Float {
    if s.domainscoretype.ScaledScoreValue == nil {
    if v, ok:= FloatPointer(0); ok {
      s.domainscoretype.ScaledScoreValue = ((*Float)(v))
      }
      }
      return s.domainscoretype.ScaledScoreValue
    }
// Returns whether the element value for ScaledScoreValue is nil in the container DomainScoreType.
  func (s *DomainScoreType) ScaledScoreValue_IsNil() bool {
    return s.domainscoretype.ScaledScoreValue == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreType) StudentDomainBand() *Int {
    if s.domainscoretype.StudentDomainBand == nil {
    if v, ok:= IntPointer(0); ok {
      s.domainscoretype.StudentDomainBand = ((*Int)(v))
      }
      }
      return s.domainscoretype.StudentDomainBand
    }
// Returns whether the element value for StudentDomainBand is nil in the container DomainScoreType.
  func (s *DomainScoreType) StudentDomainBand_IsNil() bool {
    return s.domainscoretype.StudentDomainBand == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DomainScoreType) StudentProficiency() *String {
    if s.domainscoretype.StudentProficiency == nil {
    if v, ok:= StringPointer(""); ok {
      s.domainscoretype.StudentProficiency = ((*String)(v))
      }
      }
      return s.domainscoretype.StudentProficiency
    }
// Returns whether the element value for StudentProficiency is nil in the container DomainScoreType.
  func (s *DomainScoreType) StudentProficiency_IsNil() bool {
    return s.domainscoretype.StudentProficiency == nil
    }

// Set the value of a property to nil
func (n *DurationType) Unset(key string) *DurationType {
        switch key {
  case "Units":
   n.durationtype.Units = nil
  case "Value":
   n.durationtype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DurationType")
        }
        return n
}

// Set a sequence of properties
func (n *DurationType) SetProperties(props ...Prop) *DurationType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DurationType) SetProperty(key string, value interface{}) *DurationType {
        if n == nil {
                n, _ = DurationTypePointer(DurationType{})
        }
        switch key {
    case "Units":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.durationtype.Units = ((*String)(v))
      }
    case "Value":
    
    if v, ok:= IntPointer(value); ok {
      n.durationtype.Value = ((*Int)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DurationType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DurationType) Units() *String {
    if s.durationtype.Units == nil {
    if v, ok:= StringPointer(""); ok {
      s.durationtype.Units = ((*String)(v))
      }
      }
      return s.durationtype.Units
    }
// Returns whether the element value for Units is nil in the container DurationType.
  func (s *DurationType) Units_IsNil() bool {
    return s.durationtype.Units == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DurationType) Value() *Int {
    if s.durationtype.Value == nil {
    if v, ok:= IntPointer(0); ok {
      s.durationtype.Value = ((*Int)(v))
      }
      }
      return s.durationtype.Value
    }
// Returns whether the element value for Value is nil in the container DurationType.
  func (s *DurationType) Value_IsNil() bool {
    return s.durationtype.Value == nil
    }

// Set the value of a property to nil
func (n *DwellingArrangementType) Unset(key string) *DwellingArrangementType {
        switch key {
  case "Code":
   n.dwellingarrangementtype.Code = nil
  case "OtherCodeList":
   n.dwellingarrangementtype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DwellingArrangementType")
        }
        return n
}

// Set a sequence of properties
func (n *DwellingArrangementType) SetProperties(props ...Prop) *DwellingArrangementType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *DwellingArrangementType) SetProperty(key string, value interface{}) *DwellingArrangementType {
        if n == nil {
                n, _ = DwellingArrangementTypePointer(DwellingArrangementType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsDwellingArrangementType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsDwellingArrangementType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.dwellingarrangementtype.Code = ((*AUCodeSetsDwellingArrangementType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.dwellingarrangementtype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "DwellingArrangementType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DwellingArrangementType) Code() *AUCodeSetsDwellingArrangementType {
    if s.dwellingarrangementtype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.dwellingarrangementtype.Code = ((*AUCodeSetsDwellingArrangementType)(v))
      }
      }
      return s.dwellingarrangementtype.Code
    }
// Returns whether the element value for Code is nil in the container DwellingArrangementType.
  func (s *DwellingArrangementType) Code_IsNil() bool {
    return s.dwellingarrangementtype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *DwellingArrangementType) OtherCodeList() *OtherCodeListType {
    if s.dwellingarrangementtype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.dwellingarrangementtype.OtherCodeList = v
      }
      }
      return s.dwellingarrangementtype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container DwellingArrangementType.
  func (s *DwellingArrangementType) OtherCodeList_IsNil() bool {
    return s.dwellingarrangementtype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *EducationalAssessmentType) Unset(key string) *EducationalAssessmentType {
        switch key {
  case "Content":
   n.educationalassessmenttype.Content = nil
  case "Name":
   n.educationalassessmenttype.Name = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EducationalAssessmentType")
        }
        return n
}

// Set a sequence of properties
func (n *EducationalAssessmentType) SetProperties(props ...Prop) *EducationalAssessmentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *EducationalAssessmentType) SetProperty(key string, value interface{}) *EducationalAssessmentType {
        if n == nil {
                n, _ = EducationalAssessmentTypePointer(EducationalAssessmentType{})
        }
        switch key {
    case "Content":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.educationalassessmenttype.Content = ((*String)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.educationalassessmenttype.Name = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EducationalAssessmentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EducationalAssessmentType) Content() *String {
    if s.educationalassessmenttype.Content == nil {
    if v, ok:= StringPointer(""); ok {
      s.educationalassessmenttype.Content = ((*String)(v))
      }
      }
      return s.educationalassessmenttype.Content
    }
// Returns whether the element value for Content is nil in the container EducationalAssessmentType.
  func (s *EducationalAssessmentType) Content_IsNil() bool {
    return s.educationalassessmenttype.Content == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EducationalAssessmentType) Name() *String {
    if s.educationalassessmenttype.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.educationalassessmenttype.Name = ((*String)(v))
      }
      }
      return s.educationalassessmenttype.Name
    }
// Returns whether the element value for Name is nil in the container EducationalAssessmentType.
  func (s *EducationalAssessmentType) Name_IsNil() bool {
    return s.educationalassessmenttype.Name == nil
    }

// Set the value of a property to nil
func (n *ElectronicIdType) Unset(key string) *ElectronicIdType {
        switch key {
  case "Type":
   n.electronicidtype.Type = nil
  case "Value":
   n.electronicidtype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ElectronicIdType")
        }
        return n
}

// Set a sequence of properties
func (n *ElectronicIdType) SetProperties(props ...Prop) *ElectronicIdType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ElectronicIdType) SetProperty(key string, value interface{}) *ElectronicIdType {
        if n == nil {
                n, _ = ElectronicIdTypePointer(ElectronicIdType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsElectronicIdTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsElectronicIdTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.electronicidtype.Type = ((*AUCodeSetsElectronicIdTypeType)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.electronicidtype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ElectronicIdType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ElectronicIdType) Type() *AUCodeSetsElectronicIdTypeType {
    if s.electronicidtype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.electronicidtype.Type = ((*AUCodeSetsElectronicIdTypeType)(v))
      }
      }
      return s.electronicidtype.Type
    }
// Returns whether the element value for Type is nil in the container ElectronicIdType.
  func (s *ElectronicIdType) Type_IsNil() bool {
    return s.electronicidtype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ElectronicIdType) Value() *String {
    if s.electronicidtype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.electronicidtype.Value = ((*String)(v))
      }
      }
      return s.electronicidtype.Value
    }
// Returns whether the element value for Value is nil in the container ElectronicIdType.
  func (s *ElectronicIdType) Value_IsNil() bool {
    return s.electronicidtype.Value == nil
    }

// Set the value of a property to nil
func (n *EmailType) Unset(key string) *EmailType {
        switch key {
  case "Type":
   n.emailtype.Type = nil
  case "Value":
   n.emailtype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EmailType")
        }
        return n
}

// Set a sequence of properties
func (n *EmailType) SetProperties(props ...Prop) *EmailType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *EmailType) SetProperty(key string, value interface{}) *EmailType {
        if n == nil {
                n, _ = EmailTypePointer(EmailType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEmailTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEmailTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.emailtype.Type = ((*AUCodeSetsEmailTypeType)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.emailtype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EmailType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EmailType) Type() *AUCodeSetsEmailTypeType {
    if s.emailtype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.emailtype.Type = ((*AUCodeSetsEmailTypeType)(v))
      }
      }
      return s.emailtype.Type
    }
// Returns whether the element value for Type is nil in the container EmailType.
  func (s *EmailType) Type_IsNil() bool {
    return s.emailtype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EmailType) Value() *String {
    if s.emailtype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.emailtype.Value = ((*String)(v))
      }
      }
      return s.emailtype.Value
    }
// Returns whether the element value for Value is nil in the container EmailType.
  func (s *EmailType) Value_IsNil() bool {
    return s.emailtype.Value == nil
    }

// Set the value of a property to nil
func (n *EnglishProficiencyType) Unset(key string) *EnglishProficiencyType {
        switch key {
  case "Code":
   n.englishproficiencytype.Code = nil
  case "OtherCodeList":
   n.englishproficiencytype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EnglishProficiencyType")
        }
        return n
}

// Set a sequence of properties
func (n *EnglishProficiencyType) SetProperties(props ...Prop) *EnglishProficiencyType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *EnglishProficiencyType) SetProperty(key string, value interface{}) *EnglishProficiencyType {
        if n == nil {
                n, _ = EnglishProficiencyTypePointer(EnglishProficiencyType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEnglishProficiencyType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEnglishProficiencyType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.englishproficiencytype.Code = ((*AUCodeSetsEnglishProficiencyType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.englishproficiencytype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EnglishProficiencyType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EnglishProficiencyType) Code() *AUCodeSetsEnglishProficiencyType {
    if s.englishproficiencytype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.englishproficiencytype.Code = ((*AUCodeSetsEnglishProficiencyType)(v))
      }
      }
      return s.englishproficiencytype.Code
    }
// Returns whether the element value for Code is nil in the container EnglishProficiencyType.
  func (s *EnglishProficiencyType) Code_IsNil() bool {
    return s.englishproficiencytype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EnglishProficiencyType) OtherCodeList() *OtherCodeListType {
    if s.englishproficiencytype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.englishproficiencytype.OtherCodeList = v
      }
      }
      return s.englishproficiencytype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container EnglishProficiencyType.
  func (s *EnglishProficiencyType) OtherCodeList_IsNil() bool {
    return s.englishproficiencytype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *EntityContactInfoType) Unset(key string) *EntityContactInfoType {
        switch key {
  case "Address":
   n.entitycontactinfotype.Address = nil
  case "Email":
   n.entitycontactinfotype.Email = nil
  case "Name":
   n.entitycontactinfotype.Name = nil
  case "PhoneNumber":
   n.entitycontactinfotype.PhoneNumber = nil
  case "PositionTitle":
   n.entitycontactinfotype.PositionTitle = nil
  case "Qualifications":
   n.entitycontactinfotype.Qualifications = nil
  case "RegistrationDetails":
   n.entitycontactinfotype.RegistrationDetails = nil
  case "Role":
   n.entitycontactinfotype.Role = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EntityContactInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *EntityContactInfoType) SetProperties(props ...Prop) *EntityContactInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *EntityContactInfoType) SetProperty(key string, value interface{}) *EntityContactInfoType {
        if n == nil {
                n, _ = EntityContactInfoTypePointer(EntityContactInfoType{})
        }
        switch key {
    case "Address":
    if v, ok:= AddressTypePointer(value); ok {
      n.entitycontactinfotype.Address = v
      }
    case "Email":
    if v, ok:= EmailTypePointer(value); ok {
      n.entitycontactinfotype.Email = v
      }
    case "Name":
    if v, ok:= NameTypePointer(value); ok {
      n.entitycontactinfotype.Name = v
      }
    case "PhoneNumber":
    if v, ok:= PhoneNumberTypePointer(value); ok {
      n.entitycontactinfotype.PhoneNumber = v
      }
    case "PositionTitle":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.entitycontactinfotype.PositionTitle = ((*String)(v))
      }
    case "Qualifications":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.entitycontactinfotype.Qualifications = ((*String)(v))
      }
    case "RegistrationDetails":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.entitycontactinfotype.RegistrationDetails = ((*String)(v))
      }
    case "Role":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.entitycontactinfotype.Role = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EntityContactInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EntityContactInfoType) Address() *AddressType {
    if s.entitycontactinfotype.Address == nil {
     if v, ok:= AddressTypePointer(AddressType{}); ok {
      s.entitycontactinfotype.Address = v
      }
      }
      return s.entitycontactinfotype.Address
    }
// Returns whether the element value for Address is nil in the container EntityContactInfoType.
  func (s *EntityContactInfoType) Address_IsNil() bool {
    return s.entitycontactinfotype.Address == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EntityContactInfoType) Email() *EmailType {
    if s.entitycontactinfotype.Email == nil {
     if v, ok:= EmailTypePointer(EmailType{}); ok {
      s.entitycontactinfotype.Email = v
      }
      }
      return s.entitycontactinfotype.Email
    }
// Returns whether the element value for Email is nil in the container EntityContactInfoType.
  func (s *EntityContactInfoType) Email_IsNil() bool {
    return s.entitycontactinfotype.Email == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EntityContactInfoType) Name() *NameType {
    if s.entitycontactinfotype.Name == nil {
     if v, ok:= NameTypePointer(NameType{}); ok {
      s.entitycontactinfotype.Name = v
      }
      }
      return s.entitycontactinfotype.Name
    }
// Returns whether the element value for Name is nil in the container EntityContactInfoType.
  func (s *EntityContactInfoType) Name_IsNil() bool {
    return s.entitycontactinfotype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EntityContactInfoType) PhoneNumber() *PhoneNumberType {
    if s.entitycontactinfotype.PhoneNumber == nil {
     if v, ok:= PhoneNumberTypePointer(PhoneNumberType{}); ok {
      s.entitycontactinfotype.PhoneNumber = v
      }
      }
      return s.entitycontactinfotype.PhoneNumber
    }
// Returns whether the element value for PhoneNumber is nil in the container EntityContactInfoType.
  func (s *EntityContactInfoType) PhoneNumber_IsNil() bool {
    return s.entitycontactinfotype.PhoneNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EntityContactInfoType) PositionTitle() *String {
    if s.entitycontactinfotype.PositionTitle == nil {
    if v, ok:= StringPointer(""); ok {
      s.entitycontactinfotype.PositionTitle = ((*String)(v))
      }
      }
      return s.entitycontactinfotype.PositionTitle
    }
// Returns whether the element value for PositionTitle is nil in the container EntityContactInfoType.
  func (s *EntityContactInfoType) PositionTitle_IsNil() bool {
    return s.entitycontactinfotype.PositionTitle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EntityContactInfoType) Qualifications() *String {
    if s.entitycontactinfotype.Qualifications == nil {
    if v, ok:= StringPointer(""); ok {
      s.entitycontactinfotype.Qualifications = ((*String)(v))
      }
      }
      return s.entitycontactinfotype.Qualifications
    }
// Returns whether the element value for Qualifications is nil in the container EntityContactInfoType.
  func (s *EntityContactInfoType) Qualifications_IsNil() bool {
    return s.entitycontactinfotype.Qualifications == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EntityContactInfoType) RegistrationDetails() *String {
    if s.entitycontactinfotype.RegistrationDetails == nil {
    if v, ok:= StringPointer(""); ok {
      s.entitycontactinfotype.RegistrationDetails = ((*String)(v))
      }
      }
      return s.entitycontactinfotype.RegistrationDetails
    }
// Returns whether the element value for RegistrationDetails is nil in the container EntityContactInfoType.
  func (s *EntityContactInfoType) RegistrationDetails_IsNil() bool {
    return s.entitycontactinfotype.RegistrationDetails == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EntityContactInfoType) Role() *String {
    if s.entitycontactinfotype.Role == nil {
    if v, ok:= StringPointer(""); ok {
      s.entitycontactinfotype.Role = ((*String)(v))
      }
      }
      return s.entitycontactinfotype.Role
    }
// Returns whether the element value for Role is nil in the container EntityContactInfoType.
  func (s *EntityContactInfoType) Role_IsNil() bool {
    return s.entitycontactinfotype.Role == nil
    }

// Set the value of a property to nil
func (n *EquipmentInfo) Unset(key string) *EquipmentInfo {
        switch key {
  case "AssetNumber":
   n.equipmentinfo.AssetNumber = nil
  case "Description":
   n.equipmentinfo.Description = nil
  case "EquipmentType":
   n.equipmentinfo.EquipmentType = nil
  case "InvoiceRefId":
   n.equipmentinfo.InvoiceRefId = nil
  case "LocalCodeList":
   n.equipmentinfo.LocalCodeList = nil
  case "LocalId":
   n.equipmentinfo.LocalId = nil
  case "Name":
   n.equipmentinfo.Name = nil
  case "PurchaseOrderRefId":
   n.equipmentinfo.PurchaseOrderRefId = nil
  case "RefId":
   n.equipmentinfo.RefId = nil
  case "SIF_ExtendedElements":
   n.equipmentinfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.equipmentinfo.SIF_Metadata = nil
  case "SIF_RefId":
   n.equipmentinfo.SIF_RefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EquipmentInfo")
        }
        return n
}

// Set a sequence of properties
func (n *EquipmentInfo) SetProperties(props ...Prop) *EquipmentInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *EquipmentInfo) SetProperty(key string, value interface{}) *EquipmentInfo {
        if n == nil {
                n, _ = EquipmentInfoPointer(EquipmentInfo{})
        }
        switch key {
    case "AssetNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo.AssetNumber = ((*LocalIdType)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo.Description = ((*String)(v))
      }
    case "EquipmentType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo.EquipmentType = ((*String)(v))
      }
    case "InvoiceRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo.InvoiceRefId = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.equipmentinfo.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo.LocalId = ((*LocalIdType)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo.Name = ((*String)(v))
      }
    case "PurchaseOrderRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo.PurchaseOrderRefId = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.equipmentinfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.equipmentinfo.SIF_Metadata = v
      }
    case "SIF_RefId":
    if v, ok:= EquipmentInfo_SIF_RefIdPointer(value); ok {
      n.equipmentinfo.SIF_RefId = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EquipmentInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) AssetNumber() *LocalIdType {
    if s.equipmentinfo.AssetNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo.AssetNumber = ((*LocalIdType)(v))
      }
      }
      return s.equipmentinfo.AssetNumber
    }
// Returns whether the element value for AssetNumber is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) AssetNumber_IsNil() bool {
    return s.equipmentinfo.AssetNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) Description() *String {
    if s.equipmentinfo.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo.Description = ((*String)(v))
      }
      }
      return s.equipmentinfo.Description
    }
// Returns whether the element value for Description is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) Description_IsNil() bool {
    return s.equipmentinfo.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) EquipmentType() *String {
    if s.equipmentinfo.EquipmentType == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo.EquipmentType = ((*String)(v))
      }
      }
      return s.equipmentinfo.EquipmentType
    }
// Returns whether the element value for EquipmentType is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) EquipmentType_IsNil() bool {
    return s.equipmentinfo.EquipmentType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) InvoiceRefId() *String {
    if s.equipmentinfo.InvoiceRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo.InvoiceRefId = ((*String)(v))
      }
      }
      return s.equipmentinfo.InvoiceRefId
    }
// Returns whether the element value for InvoiceRefId is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) InvoiceRefId_IsNil() bool {
    return s.equipmentinfo.InvoiceRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) LocalCodeList() *LocalCodeListType {
    if s.equipmentinfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.equipmentinfo.LocalCodeList = v
      }
      }
      return s.equipmentinfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) LocalCodeList_IsNil() bool {
    return s.equipmentinfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) LocalId() *LocalIdType {
    if s.equipmentinfo.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.equipmentinfo.LocalId
    }
// Returns whether the element value for LocalId is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) LocalId_IsNil() bool {
    return s.equipmentinfo.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) Name() *String {
    if s.equipmentinfo.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo.Name = ((*String)(v))
      }
      }
      return s.equipmentinfo.Name
    }
// Returns whether the element value for Name is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) Name_IsNil() bool {
    return s.equipmentinfo.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) PurchaseOrderRefId() *String {
    if s.equipmentinfo.PurchaseOrderRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo.PurchaseOrderRefId = ((*String)(v))
      }
      }
      return s.equipmentinfo.PurchaseOrderRefId
    }
// Returns whether the element value for PurchaseOrderRefId is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) PurchaseOrderRefId_IsNil() bool {
    return s.equipmentinfo.PurchaseOrderRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) RefId() *RefIdType {
    if s.equipmentinfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.equipmentinfo.RefId
    }
// Returns whether the element value for RefId is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) RefId_IsNil() bool {
    return s.equipmentinfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.equipmentinfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.equipmentinfo.SIF_ExtendedElements = v
      }
      }
      return s.equipmentinfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) SIF_ExtendedElements_IsNil() bool {
    return s.equipmentinfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) SIF_Metadata() *SIF_MetadataType {
    if s.equipmentinfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.equipmentinfo.SIF_Metadata = v
      }
      }
      return s.equipmentinfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) SIF_Metadata_IsNil() bool {
    return s.equipmentinfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo) SIF_RefId() *EquipmentInfo_SIF_RefId {
    if s.equipmentinfo.SIF_RefId == nil {
     if v, ok:= EquipmentInfo_SIF_RefIdPointer(EquipmentInfo_SIF_RefId{}); ok {
      s.equipmentinfo.SIF_RefId = v
      }
      }
      return s.equipmentinfo.SIF_RefId
    }
// Returns whether the element value for SIF_RefId is nil in the container EquipmentInfo.
  func (s *EquipmentInfo) SIF_RefId_IsNil() bool {
    return s.equipmentinfo.SIF_RefId == nil
    }

// Set the value of a property to nil
func (n *EquipmentInfo_SIF_RefId) Unset(key string) *EquipmentInfo_SIF_RefId {
        switch key {
  case "SIF_RefObject":
   n.equipmentinfo_sif_refid.SIF_RefObject = nil
  case "Value":
   n.equipmentinfo_sif_refid.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EquipmentInfo_SIF_RefId")
        }
        return n
}

// Set a sequence of properties
func (n *EquipmentInfo_SIF_RefId) SetProperties(props ...Prop) *EquipmentInfo_SIF_RefId {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *EquipmentInfo_SIF_RefId) SetProperty(key string, value interface{}) *EquipmentInfo_SIF_RefId {
        if n == nil {
                n, _ = EquipmentInfo_SIF_RefIdPointer(EquipmentInfo_SIF_RefId{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo_sif_refid.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.equipmentinfo_sif_refid.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EquipmentInfo_SIF_RefId")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo_SIF_RefId) SIF_RefObject() *String {
    if s.equipmentinfo_sif_refid.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo_sif_refid.SIF_RefObject = ((*String)(v))
      }
      }
      return s.equipmentinfo_sif_refid.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container EquipmentInfo_SIF_RefId.
  func (s *EquipmentInfo_SIF_RefId) SIF_RefObject_IsNil() bool {
    return s.equipmentinfo_sif_refid.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EquipmentInfo_SIF_RefId) Value() *String {
    if s.equipmentinfo_sif_refid.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.equipmentinfo_sif_refid.Value = ((*String)(v))
      }
      }
      return s.equipmentinfo_sif_refid.Value
    }
// Returns whether the element value for Value is nil in the container EquipmentInfo_SIF_RefId.
  func (s *EquipmentInfo_SIF_RefId) Value_IsNil() bool {
    return s.equipmentinfo_sif_refid.Value == nil
    }

// Set the value of a property to nil
func (n *EvaluationType) Unset(key string) *EvaluationType {
        switch key {
  case "Date":
   n.evaluationtype.Date = nil
  case "Description":
   n.evaluationtype.Description = nil
  case "Name":
   n.evaluationtype.Name = nil
  case "RefId":
   n.evaluationtype.RefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EvaluationType")
        }
        return n
}

// Set a sequence of properties
func (n *EvaluationType) SetProperties(props ...Prop) *EvaluationType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *EvaluationType) SetProperty(key string, value interface{}) *EvaluationType {
        if n == nil {
                n, _ = EvaluationTypePointer(EvaluationType{})
        }
        switch key {
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.evaluationtype.Date = ((*String)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.evaluationtype.Description = ((*String)(v))
      }
    case "Name":
    if v, ok:= NameTypePointer(value); ok {
      n.evaluationtype.Name = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.evaluationtype.RefId = ((*RefIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "EvaluationType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EvaluationType) Date() *String {
    if s.evaluationtype.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.evaluationtype.Date = ((*String)(v))
      }
      }
      return s.evaluationtype.Date
    }
// Returns whether the element value for Date is nil in the container EvaluationType.
  func (s *EvaluationType) Date_IsNil() bool {
    return s.evaluationtype.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EvaluationType) Description() *String {
    if s.evaluationtype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.evaluationtype.Description = ((*String)(v))
      }
      }
      return s.evaluationtype.Description
    }
// Returns whether the element value for Description is nil in the container EvaluationType.
  func (s *EvaluationType) Description_IsNil() bool {
    return s.evaluationtype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EvaluationType) Name() *NameType {
    if s.evaluationtype.Name == nil {
     if v, ok:= NameTypePointer(NameType{}); ok {
      s.evaluationtype.Name = v
      }
      }
      return s.evaluationtype.Name
    }
// Returns whether the element value for Name is nil in the container EvaluationType.
  func (s *EvaluationType) Name_IsNil() bool {
    return s.evaluationtype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *EvaluationType) RefId() *RefIdType {
    if s.evaluationtype.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.evaluationtype.RefId = ((*RefIdType)(v))
      }
      }
      return s.evaluationtype.RefId
    }
// Returns whether the element value for RefId is nil in the container EvaluationType.
  func (s *EvaluationType) RefId_IsNil() bool {
    return s.evaluationtype.RefId == nil
    }

// Set the value of a property to nil
func (n *ExclusionRuleType) Unset(key string) *ExclusionRuleType {
        switch key {
  case "Type":
   n.exclusionruletype.Type = nil
  case "Value":
   n.exclusionruletype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ExclusionRuleType")
        }
        return n
}

// Set a sequence of properties
func (n *ExclusionRuleType) SetProperties(props ...Prop) *ExclusionRuleType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ExclusionRuleType) SetProperty(key string, value interface{}) *ExclusionRuleType {
        if n == nil {
                n, _ = ExclusionRuleTypePointer(ExclusionRuleType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.exclusionruletype.Type = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.exclusionruletype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ExclusionRuleType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ExclusionRuleType) Type() *String {
    if s.exclusionruletype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.exclusionruletype.Type = ((*String)(v))
      }
      }
      return s.exclusionruletype.Type
    }
// Returns whether the element value for Type is nil in the container ExclusionRuleType.
  func (s *ExclusionRuleType) Type_IsNil() bool {
    return s.exclusionruletype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ExclusionRuleType) Value() *String {
    if s.exclusionruletype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.exclusionruletype.Value = ((*String)(v))
      }
      }
      return s.exclusionruletype.Value
    }
// Returns whether the element value for Value is nil in the container ExclusionRuleType.
  func (s *ExclusionRuleType) Value_IsNil() bool {
    return s.exclusionruletype.Value == nil
    }

// Set the value of a property to nil
func (n *ExpenseAccountType) Unset(key string) *ExpenseAccountType {
        switch key {
  case "AccountCode":
   n.expenseaccounttype.AccountCode = nil
  case "AccountingPeriod":
   n.expenseaccounttype.AccountingPeriod = nil
  case "Amount":
   n.expenseaccounttype.Amount = nil
  case "FinancialAccountRefId":
   n.expenseaccounttype.FinancialAccountRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ExpenseAccountType")
        }
        return n
}

// Set a sequence of properties
func (n *ExpenseAccountType) SetProperties(props ...Prop) *ExpenseAccountType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ExpenseAccountType) SetProperty(key string, value interface{}) *ExpenseAccountType {
        if n == nil {
                n, _ = ExpenseAccountTypePointer(ExpenseAccountType{})
        }
        switch key {
    case "AccountCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.expenseaccounttype.AccountCode = ((*String)(v))
      }
    case "AccountingPeriod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.expenseaccounttype.AccountingPeriod = ((*LocalIdType)(v))
      }
    case "Amount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.expenseaccounttype.Amount = v
      }
    case "FinancialAccountRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.expenseaccounttype.FinancialAccountRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ExpenseAccountType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ExpenseAccountType) AccountCode() *String {
    if s.expenseaccounttype.AccountCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.expenseaccounttype.AccountCode = ((*String)(v))
      }
      }
      return s.expenseaccounttype.AccountCode
    }
// Returns whether the element value for AccountCode is nil in the container ExpenseAccountType.
  func (s *ExpenseAccountType) AccountCode_IsNil() bool {
    return s.expenseaccounttype.AccountCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ExpenseAccountType) AccountingPeriod() *LocalIdType {
    if s.expenseaccounttype.AccountingPeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.expenseaccounttype.AccountingPeriod = ((*LocalIdType)(v))
      }
      }
      return s.expenseaccounttype.AccountingPeriod
    }
// Returns whether the element value for AccountingPeriod is nil in the container ExpenseAccountType.
  func (s *ExpenseAccountType) AccountingPeriod_IsNil() bool {
    return s.expenseaccounttype.AccountingPeriod == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ExpenseAccountType) Amount() *MonetaryAmountType {
    if s.expenseaccounttype.Amount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.expenseaccounttype.Amount = v
      }
      }
      return s.expenseaccounttype.Amount
    }
// Returns whether the element value for Amount is nil in the container ExpenseAccountType.
  func (s *ExpenseAccountType) Amount_IsNil() bool {
    return s.expenseaccounttype.Amount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ExpenseAccountType) FinancialAccountRefId() *String {
    if s.expenseaccounttype.FinancialAccountRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.expenseaccounttype.FinancialAccountRefId = ((*String)(v))
      }
      }
      return s.expenseaccounttype.FinancialAccountRefId
    }
// Returns whether the element value for FinancialAccountRefId is nil in the container ExpenseAccountType.
  func (s *ExpenseAccountType) FinancialAccountRefId_IsNil() bool {
    return s.expenseaccounttype.FinancialAccountRefId == nil
    }

// Set the value of a property to nil
func (n *FQContextualQuestionType) Unset(key string) *FQContextualQuestionType {
        switch key {
  case "FQAnswer":
   n.fqcontextualquestiontype.FQAnswer = nil
  case "FQContext":
   n.fqcontextualquestiontype.FQContext = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FQContextualQuestionType")
        }
        return n
}

// Set a sequence of properties
func (n *FQContextualQuestionType) SetProperties(props ...Prop) *FQContextualQuestionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *FQContextualQuestionType) SetProperty(key string, value interface{}) *FQContextualQuestionType {
        if n == nil {
                n, _ = FQContextualQuestionTypePointer(FQContextualQuestionType{})
        }
        switch key {
    case "FQAnswer":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fqcontextualquestiontype.FQAnswer = ((*String)(v))
      }
    case "FQContext":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fqcontextualquestiontype.FQContext = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FQContextualQuestionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQContextualQuestionType) FQAnswer() *String {
    if s.fqcontextualquestiontype.FQAnswer == nil {
    if v, ok:= StringPointer(""); ok {
      s.fqcontextualquestiontype.FQAnswer = ((*String)(v))
      }
      }
      return s.fqcontextualquestiontype.FQAnswer
    }
// Returns whether the element value for FQAnswer is nil in the container FQContextualQuestionType.
  func (s *FQContextualQuestionType) FQAnswer_IsNil() bool {
    return s.fqcontextualquestiontype.FQAnswer == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQContextualQuestionType) FQContext() *String {
    if s.fqcontextualquestiontype.FQContext == nil {
    if v, ok:= StringPointer(""); ok {
      s.fqcontextualquestiontype.FQContext = ((*String)(v))
      }
      }
      return s.fqcontextualquestiontype.FQContext
    }
// Returns whether the element value for FQContext is nil in the container FQContextualQuestionType.
  func (s *FQContextualQuestionType) FQContext_IsNil() bool {
    return s.fqcontextualquestiontype.FQContext == nil
    }

// Set the value of a property to nil
func (n *FQItemType) Unset(key string) *FQItemType {
        switch key {
  case "BoardingAmount":
   n.fqitemtype.BoardingAmount = nil
  case "DioceseAmount":
   n.fqitemtype.DioceseAmount = nil
  case "FQComments":
   n.fqitemtype.FQComments = nil
  case "FQItemCode":
   n.fqitemtype.FQItemCode = nil
  case "SystemAmount":
   n.fqitemtype.SystemAmount = nil
  case "TuitionAmount":
   n.fqitemtype.TuitionAmount = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FQItemType")
        }
        return n
}

// Set a sequence of properties
func (n *FQItemType) SetProperties(props ...Prop) *FQItemType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *FQItemType) SetProperty(key string, value interface{}) *FQItemType {
        if n == nil {
                n, _ = FQItemTypePointer(FQItemType{})
        }
        switch key {
    case "BoardingAmount":
    
    if v, ok:= FloatPointer(value); ok {
      n.fqitemtype.BoardingAmount = ((*Float)(v))
      }
    case "DioceseAmount":
    
    if v, ok:= FloatPointer(value); ok {
      n.fqitemtype.DioceseAmount = ((*Float)(v))
      }
    case "FQComments":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fqitemtype.FQComments = ((*String)(v))
      }
    case "FQItemCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fqitemtype.FQItemCode = ((*String)(v))
      }
    case "SystemAmount":
    
    if v, ok:= FloatPointer(value); ok {
      n.fqitemtype.SystemAmount = ((*Float)(v))
      }
    case "TuitionAmount":
    
    if v, ok:= FloatPointer(value); ok {
      n.fqitemtype.TuitionAmount = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FQItemType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQItemType) BoardingAmount() *Float {
    if s.fqitemtype.BoardingAmount == nil {
    if v, ok:= FloatPointer(0); ok {
      s.fqitemtype.BoardingAmount = ((*Float)(v))
      }
      }
      return s.fqitemtype.BoardingAmount
    }
// Returns whether the element value for BoardingAmount is nil in the container FQItemType.
  func (s *FQItemType) BoardingAmount_IsNil() bool {
    return s.fqitemtype.BoardingAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQItemType) DioceseAmount() *Float {
    if s.fqitemtype.DioceseAmount == nil {
    if v, ok:= FloatPointer(0); ok {
      s.fqitemtype.DioceseAmount = ((*Float)(v))
      }
      }
      return s.fqitemtype.DioceseAmount
    }
// Returns whether the element value for DioceseAmount is nil in the container FQItemType.
  func (s *FQItemType) DioceseAmount_IsNil() bool {
    return s.fqitemtype.DioceseAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQItemType) FQComments() *String {
    if s.fqitemtype.FQComments == nil {
    if v, ok:= StringPointer(""); ok {
      s.fqitemtype.FQComments = ((*String)(v))
      }
      }
      return s.fqitemtype.FQComments
    }
// Returns whether the element value for FQComments is nil in the container FQItemType.
  func (s *FQItemType) FQComments_IsNil() bool {
    return s.fqitemtype.FQComments == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQItemType) FQItemCode() *String {
    if s.fqitemtype.FQItemCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.fqitemtype.FQItemCode = ((*String)(v))
      }
      }
      return s.fqitemtype.FQItemCode
    }
// Returns whether the element value for FQItemCode is nil in the container FQItemType.
  func (s *FQItemType) FQItemCode_IsNil() bool {
    return s.fqitemtype.FQItemCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQItemType) SystemAmount() *Float {
    if s.fqitemtype.SystemAmount == nil {
    if v, ok:= FloatPointer(0); ok {
      s.fqitemtype.SystemAmount = ((*Float)(v))
      }
      }
      return s.fqitemtype.SystemAmount
    }
// Returns whether the element value for SystemAmount is nil in the container FQItemType.
  func (s *FQItemType) SystemAmount_IsNil() bool {
    return s.fqitemtype.SystemAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQItemType) TuitionAmount() *Float {
    if s.fqitemtype.TuitionAmount == nil {
    if v, ok:= FloatPointer(0); ok {
      s.fqitemtype.TuitionAmount = ((*Float)(v))
      }
      }
      return s.fqitemtype.TuitionAmount
    }
// Returns whether the element value for TuitionAmount is nil in the container FQItemType.
  func (s *FQItemType) TuitionAmount_IsNil() bool {
    return s.fqitemtype.TuitionAmount == nil
    }

// Set the value of a property to nil
func (n *FQReportingType) Unset(key string) *FQReportingType {
        switch key {
  case "AGRuleList":
   n.fqreportingtype.AGRuleList = nil
  case "CommonwealthId":
   n.fqreportingtype.CommonwealthId = nil
  case "EntityContact":
   n.fqreportingtype.EntityContact = nil
  case "EntityName":
   n.fqreportingtype.EntityName = nil
  case "FQContextualQuestionList":
   n.fqreportingtype.FQContextualQuestionList = nil
  case "FQItemList":
   n.fqreportingtype.FQItemList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FQReportingType")
        }
        return n
}

// Set a sequence of properties
func (n *FQReportingType) SetProperties(props ...Prop) *FQReportingType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *FQReportingType) SetProperty(key string, value interface{}) *FQReportingType {
        if n == nil {
                n, _ = FQReportingTypePointer(FQReportingType{})
        }
        switch key {
    case "AGRuleList":
    if v, ok:= AGRuleListTypePointer(value); ok {
      n.fqreportingtype.AGRuleList = v
      }
    case "CommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fqreportingtype.CommonwealthId = ((*String)(v))
      }
    case "EntityContact":
    if v, ok:= EntityContactInfoTypePointer(value); ok {
      n.fqreportingtype.EntityContact = v
      }
    case "EntityName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fqreportingtype.EntityName = ((*String)(v))
      }
    case "FQContextualQuestionList":
    if v, ok:= FQContextualQuestionListTypePointer(value); ok {
      n.fqreportingtype.FQContextualQuestionList = v
      }
    case "FQItemList":
    if v, ok:= FQItemListTypePointer(value); ok {
      n.fqreportingtype.FQItemList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FQReportingType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQReportingType) AGRuleList() *AGRuleListType {
    if s.fqreportingtype.AGRuleList == nil {
     if v, ok:= AGRuleListTypePointer(AGRuleListType{}); ok {
      s.fqreportingtype.AGRuleList = v
      }
      }
      return s.fqreportingtype.AGRuleList
    }
// Returns whether the element value for AGRuleList is nil in the container FQReportingType.
  func (s *FQReportingType) AGRuleList_IsNil() bool {
    return s.fqreportingtype.AGRuleList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQReportingType) CommonwealthId() *String {
    if s.fqreportingtype.CommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.fqreportingtype.CommonwealthId = ((*String)(v))
      }
      }
      return s.fqreportingtype.CommonwealthId
    }
// Returns whether the element value for CommonwealthId is nil in the container FQReportingType.
  func (s *FQReportingType) CommonwealthId_IsNil() bool {
    return s.fqreportingtype.CommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQReportingType) EntityContact() *EntityContactInfoType {
    if s.fqreportingtype.EntityContact == nil {
     if v, ok:= EntityContactInfoTypePointer(EntityContactInfoType{}); ok {
      s.fqreportingtype.EntityContact = v
      }
      }
      return s.fqreportingtype.EntityContact
    }
// Returns whether the element value for EntityContact is nil in the container FQReportingType.
  func (s *FQReportingType) EntityContact_IsNil() bool {
    return s.fqreportingtype.EntityContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQReportingType) EntityName() *String {
    if s.fqreportingtype.EntityName == nil {
    if v, ok:= StringPointer(""); ok {
      s.fqreportingtype.EntityName = ((*String)(v))
      }
      }
      return s.fqreportingtype.EntityName
    }
// Returns whether the element value for EntityName is nil in the container FQReportingType.
  func (s *FQReportingType) EntityName_IsNil() bool {
    return s.fqreportingtype.EntityName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQReportingType) FQContextualQuestionList() *FQContextualQuestionListType {
    if s.fqreportingtype.FQContextualQuestionList == nil {
     if v, ok:= FQContextualQuestionListTypePointer(FQContextualQuestionListType{}); ok {
      s.fqreportingtype.FQContextualQuestionList = v
      }
      }
      return s.fqreportingtype.FQContextualQuestionList
    }
// Returns whether the element value for FQContextualQuestionList is nil in the container FQReportingType.
  func (s *FQReportingType) FQContextualQuestionList_IsNil() bool {
    return s.fqreportingtype.FQContextualQuestionList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FQReportingType) FQItemList() *FQItemListType {
    if s.fqreportingtype.FQItemList == nil {
     if v, ok:= FQItemListTypePointer(FQItemListType{}); ok {
      s.fqreportingtype.FQItemList = v
      }
      }
      return s.fqreportingtype.FQItemList
    }
// Returns whether the element value for FQItemList is nil in the container FQReportingType.
  func (s *FQReportingType) FQItemList_IsNil() bool {
    return s.fqreportingtype.FQItemList == nil
    }

// Set the value of a property to nil
func (n *FinancialAccount) Unset(key string) *FinancialAccount {
        switch key {
  case "AccountCode":
   n.financialaccount.AccountCode = nil
  case "AccountNumber":
   n.financialaccount.AccountNumber = nil
  case "ChargedLocationInfoRefId":
   n.financialaccount.ChargedLocationInfoRefId = nil
  case "ClassType":
   n.financialaccount.ClassType = nil
  case "CreationDate":
   n.financialaccount.CreationDate = nil
  case "CreationTime":
   n.financialaccount.CreationTime = nil
  case "Description":
   n.financialaccount.Description = nil
  case "LocalCodeList":
   n.financialaccount.LocalCodeList = nil
  case "LocalId":
   n.financialaccount.LocalId = nil
  case "Name":
   n.financialaccount.Name = nil
  case "ParentAccountRefId":
   n.financialaccount.ParentAccountRefId = nil
  case "RefId":
   n.financialaccount.RefId = nil
  case "SIF_ExtendedElements":
   n.financialaccount.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.financialaccount.SIF_Metadata = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FinancialAccount")
        }
        return n
}

// Set a sequence of properties
func (n *FinancialAccount) SetProperties(props ...Prop) *FinancialAccount {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *FinancialAccount) SetProperty(key string, value interface{}) *FinancialAccount {
        if n == nil {
                n, _ = FinancialAccountPointer(FinancialAccount{})
        }
        switch key {
    case "AccountCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.AccountCode = ((*String)(v))
      }
    case "AccountNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.AccountNumber = ((*String)(v))
      }
    case "ChargedLocationInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.ChargedLocationInfoRefId = ((*String)(v))
      }
    case "ClassType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.ClassType = ((*String)(v))
      }
    case "CreationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.CreationDate = ((*String)(v))
      }
    case "CreationTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.CreationTime = ((*String)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.Description = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.financialaccount.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.LocalId = ((*LocalIdType)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.Name = ((*String)(v))
      }
    case "ParentAccountRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.ParentAccountRefId = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialaccount.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.financialaccount.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.financialaccount.SIF_Metadata = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FinancialAccount")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) AccountCode() *String {
    if s.financialaccount.AccountCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.AccountCode = ((*String)(v))
      }
      }
      return s.financialaccount.AccountCode
    }
// Returns whether the element value for AccountCode is nil in the container FinancialAccount.
  func (s *FinancialAccount) AccountCode_IsNil() bool {
    return s.financialaccount.AccountCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) AccountNumber() *String {
    if s.financialaccount.AccountNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.AccountNumber = ((*String)(v))
      }
      }
      return s.financialaccount.AccountNumber
    }
// Returns whether the element value for AccountNumber is nil in the container FinancialAccount.
  func (s *FinancialAccount) AccountNumber_IsNil() bool {
    return s.financialaccount.AccountNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) ChargedLocationInfoRefId() *String {
    if s.financialaccount.ChargedLocationInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.ChargedLocationInfoRefId = ((*String)(v))
      }
      }
      return s.financialaccount.ChargedLocationInfoRefId
    }
// Returns whether the element value for ChargedLocationInfoRefId is nil in the container FinancialAccount.
  func (s *FinancialAccount) ChargedLocationInfoRefId_IsNil() bool {
    return s.financialaccount.ChargedLocationInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) ClassType() *String {
    if s.financialaccount.ClassType == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.ClassType = ((*String)(v))
      }
      }
      return s.financialaccount.ClassType
    }
// Returns whether the element value for ClassType is nil in the container FinancialAccount.
  func (s *FinancialAccount) ClassType_IsNil() bool {
    return s.financialaccount.ClassType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) CreationDate() *String {
    if s.financialaccount.CreationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.CreationDate = ((*String)(v))
      }
      }
      return s.financialaccount.CreationDate
    }
// Returns whether the element value for CreationDate is nil in the container FinancialAccount.
  func (s *FinancialAccount) CreationDate_IsNil() bool {
    return s.financialaccount.CreationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) CreationTime() *String {
    if s.financialaccount.CreationTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.CreationTime = ((*String)(v))
      }
      }
      return s.financialaccount.CreationTime
    }
// Returns whether the element value for CreationTime is nil in the container FinancialAccount.
  func (s *FinancialAccount) CreationTime_IsNil() bool {
    return s.financialaccount.CreationTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) Description() *String {
    if s.financialaccount.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.Description = ((*String)(v))
      }
      }
      return s.financialaccount.Description
    }
// Returns whether the element value for Description is nil in the container FinancialAccount.
  func (s *FinancialAccount) Description_IsNil() bool {
    return s.financialaccount.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) LocalCodeList() *LocalCodeListType {
    if s.financialaccount.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.financialaccount.LocalCodeList = v
      }
      }
      return s.financialaccount.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container FinancialAccount.
  func (s *FinancialAccount) LocalCodeList_IsNil() bool {
    return s.financialaccount.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) LocalId() *LocalIdType {
    if s.financialaccount.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.financialaccount.LocalId
    }
// Returns whether the element value for LocalId is nil in the container FinancialAccount.
  func (s *FinancialAccount) LocalId_IsNil() bool {
    return s.financialaccount.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) Name() *String {
    if s.financialaccount.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.Name = ((*String)(v))
      }
      }
      return s.financialaccount.Name
    }
// Returns whether the element value for Name is nil in the container FinancialAccount.
  func (s *FinancialAccount) Name_IsNil() bool {
    return s.financialaccount.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) ParentAccountRefId() *String {
    if s.financialaccount.ParentAccountRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.ParentAccountRefId = ((*String)(v))
      }
      }
      return s.financialaccount.ParentAccountRefId
    }
// Returns whether the element value for ParentAccountRefId is nil in the container FinancialAccount.
  func (s *FinancialAccount) ParentAccountRefId_IsNil() bool {
    return s.financialaccount.ParentAccountRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) RefId() *RefIdType {
    if s.financialaccount.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialaccount.RefId = ((*RefIdType)(v))
      }
      }
      return s.financialaccount.RefId
    }
// Returns whether the element value for RefId is nil in the container FinancialAccount.
  func (s *FinancialAccount) RefId_IsNil() bool {
    return s.financialaccount.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.financialaccount.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.financialaccount.SIF_ExtendedElements = v
      }
      }
      return s.financialaccount.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container FinancialAccount.
  func (s *FinancialAccount) SIF_ExtendedElements_IsNil() bool {
    return s.financialaccount.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialAccount) SIF_Metadata() *SIF_MetadataType {
    if s.financialaccount.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.financialaccount.SIF_Metadata = v
      }
      }
      return s.financialaccount.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container FinancialAccount.
  func (s *FinancialAccount) SIF_Metadata_IsNil() bool {
    return s.financialaccount.SIF_Metadata == nil
    }

// Set the value of a property to nil
func (n *FinancialQuestionnaireCollection) Unset(key string) *FinancialQuestionnaireCollection {
        switch key {
  case "FQReportingList":
   n.financialquestionnairecollection.FQReportingList = nil
  case "FQYear":
   n.financialquestionnairecollection.FQYear = nil
  case "LocalCodeList":
   n.financialquestionnairecollection.LocalCodeList = nil
  case "RefId":
   n.financialquestionnairecollection.RefId = nil
  case "RoundCode":
   n.financialquestionnairecollection.RoundCode = nil
  case "SIF_ExtendedElements":
   n.financialquestionnairecollection.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.financialquestionnairecollection.SIF_Metadata = nil
  case "SoftwareVendorInfo":
   n.financialquestionnairecollection.SoftwareVendorInfo = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FinancialQuestionnaireCollection")
        }
        return n
}

// Set a sequence of properties
func (n *FinancialQuestionnaireCollection) SetProperties(props ...Prop) *FinancialQuestionnaireCollection {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *FinancialQuestionnaireCollection) SetProperty(key string, value interface{}) *FinancialQuestionnaireCollection {
        if n == nil {
                n, _ = FinancialQuestionnaireCollectionPointer(FinancialQuestionnaireCollection{})
        }
        switch key {
    case "FQReportingList":
    if v, ok:= FQReportingListTypePointer(value); ok {
      n.financialquestionnairecollection.FQReportingList = v
      }
    case "FQYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialquestionnairecollection.FQYear = ((*SchoolYearType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.financialquestionnairecollection.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialquestionnairecollection.RefId = ((*RefIdType)(v))
      }
    case "RoundCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.financialquestionnairecollection.RoundCode = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.financialquestionnairecollection.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.financialquestionnairecollection.SIF_Metadata = v
      }
    case "SoftwareVendorInfo":
    if v, ok:= SoftwareVendorInfoContainerTypePointer(value); ok {
      n.financialquestionnairecollection.SoftwareVendorInfo = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FinancialQuestionnaireCollection")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialQuestionnaireCollection) FQReportingList() *FQReportingListType {
    if s.financialquestionnairecollection.FQReportingList == nil {
     if v, ok:= FQReportingListTypePointer(FQReportingListType{}); ok {
      s.financialquestionnairecollection.FQReportingList = v
      }
      }
      return s.financialquestionnairecollection.FQReportingList
    }
// Returns whether the element value for FQReportingList is nil in the container FinancialQuestionnaireCollection.
  func (s *FinancialQuestionnaireCollection) FQReportingList_IsNil() bool {
    return s.financialquestionnairecollection.FQReportingList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialQuestionnaireCollection) FQYear() *SchoolYearType {
    if s.financialquestionnairecollection.FQYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialquestionnairecollection.FQYear = ((*SchoolYearType)(v))
      }
      }
      return s.financialquestionnairecollection.FQYear
    }
// Returns whether the element value for FQYear is nil in the container FinancialQuestionnaireCollection.
  func (s *FinancialQuestionnaireCollection) FQYear_IsNil() bool {
    return s.financialquestionnairecollection.FQYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialQuestionnaireCollection) LocalCodeList() *LocalCodeListType {
    if s.financialquestionnairecollection.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.financialquestionnairecollection.LocalCodeList = v
      }
      }
      return s.financialquestionnairecollection.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container FinancialQuestionnaireCollection.
  func (s *FinancialQuestionnaireCollection) LocalCodeList_IsNil() bool {
    return s.financialquestionnairecollection.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialQuestionnaireCollection) RefId() *RefIdType {
    if s.financialquestionnairecollection.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialquestionnairecollection.RefId = ((*RefIdType)(v))
      }
      }
      return s.financialquestionnairecollection.RefId
    }
// Returns whether the element value for RefId is nil in the container FinancialQuestionnaireCollection.
  func (s *FinancialQuestionnaireCollection) RefId_IsNil() bool {
    return s.financialquestionnairecollection.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialQuestionnaireCollection) RoundCode() *String {
    if s.financialquestionnairecollection.RoundCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.financialquestionnairecollection.RoundCode = ((*String)(v))
      }
      }
      return s.financialquestionnairecollection.RoundCode
    }
// Returns whether the element value for RoundCode is nil in the container FinancialQuestionnaireCollection.
  func (s *FinancialQuestionnaireCollection) RoundCode_IsNil() bool {
    return s.financialquestionnairecollection.RoundCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialQuestionnaireCollection) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.financialquestionnairecollection.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.financialquestionnairecollection.SIF_ExtendedElements = v
      }
      }
      return s.financialquestionnairecollection.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container FinancialQuestionnaireCollection.
  func (s *FinancialQuestionnaireCollection) SIF_ExtendedElements_IsNil() bool {
    return s.financialquestionnairecollection.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialQuestionnaireCollection) SIF_Metadata() *SIF_MetadataType {
    if s.financialquestionnairecollection.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.financialquestionnairecollection.SIF_Metadata = v
      }
      }
      return s.financialquestionnairecollection.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container FinancialQuestionnaireCollection.
  func (s *FinancialQuestionnaireCollection) SIF_Metadata_IsNil() bool {
    return s.financialquestionnairecollection.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FinancialQuestionnaireCollection) SoftwareVendorInfo() *SoftwareVendorInfoContainerType {
    if s.financialquestionnairecollection.SoftwareVendorInfo == nil {
     if v, ok:= SoftwareVendorInfoContainerTypePointer(SoftwareVendorInfoContainerType{}); ok {
      s.financialquestionnairecollection.SoftwareVendorInfo = v
      }
      }
      return s.financialquestionnairecollection.SoftwareVendorInfo
    }
// Returns whether the element value for SoftwareVendorInfo is nil in the container FinancialQuestionnaireCollection.
  func (s *FinancialQuestionnaireCollection) SoftwareVendorInfo_IsNil() bool {
    return s.financialquestionnairecollection.SoftwareVendorInfo == nil
    }

// Set the value of a property to nil
func (n *FineInfoType) Unset(key string) *FineInfoType {
        switch key {
  case "Amount":
   n.fineinfotype.Amount = nil
  case "Assessed":
   n.fineinfotype.Assessed = nil
  case "Description":
   n.fineinfotype.Description = nil
  case "Reference":
   n.fineinfotype.Reference = nil
  case "Type":
   n.fineinfotype.Type = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FineInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *FineInfoType) SetProperties(props ...Prop) *FineInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *FineInfoType) SetProperty(key string, value interface{}) *FineInfoType {
        if n == nil {
                n, _ = FineInfoTypePointer(FineInfoType{})
        }
        switch key {
    case "Amount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.fineinfotype.Amount = v
      }
    case "Assessed":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fineinfotype.Assessed = ((*String)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fineinfotype.Description = ((*String)(v))
      }
    case "Reference":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fineinfotype.Reference = ((*String)(v))
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.fineinfotype.Type = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FineInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FineInfoType) Amount() *MonetaryAmountType {
    if s.fineinfotype.Amount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.fineinfotype.Amount = v
      }
      }
      return s.fineinfotype.Amount
    }
// Returns whether the element value for Amount is nil in the container FineInfoType.
  func (s *FineInfoType) Amount_IsNil() bool {
    return s.fineinfotype.Amount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FineInfoType) Assessed() *String {
    if s.fineinfotype.Assessed == nil {
    if v, ok:= StringPointer(""); ok {
      s.fineinfotype.Assessed = ((*String)(v))
      }
      }
      return s.fineinfotype.Assessed
    }
// Returns whether the element value for Assessed is nil in the container FineInfoType.
  func (s *FineInfoType) Assessed_IsNil() bool {
    return s.fineinfotype.Assessed == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FineInfoType) Description() *String {
    if s.fineinfotype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.fineinfotype.Description = ((*String)(v))
      }
      }
      return s.fineinfotype.Description
    }
// Returns whether the element value for Description is nil in the container FineInfoType.
  func (s *FineInfoType) Description_IsNil() bool {
    return s.fineinfotype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FineInfoType) Reference() *String {
    if s.fineinfotype.Reference == nil {
    if v, ok:= StringPointer(""); ok {
      s.fineinfotype.Reference = ((*String)(v))
      }
      }
      return s.fineinfotype.Reference
    }
// Returns whether the element value for Reference is nil in the container FineInfoType.
  func (s *FineInfoType) Reference_IsNil() bool {
    return s.fineinfotype.Reference == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FineInfoType) Type() *String {
    if s.fineinfotype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.fineinfotype.Type = ((*String)(v))
      }
      }
      return s.fineinfotype.Type
    }
// Returns whether the element value for Type is nil in the container FineInfoType.
  func (s *FineInfoType) Type_IsNil() bool {
    return s.fineinfotype.Type == nil
    }

// Set the value of a property to nil
func (n *FollowUpActionType) Unset(key string) *FollowUpActionType {
        switch key {
  case "Date":
   n.followupactiontype.Date = nil
  case "FollowUpActionCategory":
   n.followupactiontype.FollowUpActionCategory = nil
  case "FollowUpDetails":
   n.followupactiontype.FollowUpDetails = nil
  case "WellbeingResponseRefId":
   n.followupactiontype.WellbeingResponseRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FollowUpActionType")
        }
        return n
}

// Set a sequence of properties
func (n *FollowUpActionType) SetProperties(props ...Prop) *FollowUpActionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *FollowUpActionType) SetProperty(key string, value interface{}) *FollowUpActionType {
        if n == nil {
                n, _ = FollowUpActionTypePointer(FollowUpActionType{})
        }
        switch key {
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.followupactiontype.Date = ((*String)(v))
      }
    case "FollowUpActionCategory":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.followupactiontype.FollowUpActionCategory = ((*String)(v))
      }
    case "FollowUpDetails":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.followupactiontype.FollowUpDetails = ((*String)(v))
      }
    case "WellbeingResponseRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.followupactiontype.WellbeingResponseRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "FollowUpActionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FollowUpActionType) Date() *String {
    if s.followupactiontype.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.followupactiontype.Date = ((*String)(v))
      }
      }
      return s.followupactiontype.Date
    }
// Returns whether the element value for Date is nil in the container FollowUpActionType.
  func (s *FollowUpActionType) Date_IsNil() bool {
    return s.followupactiontype.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FollowUpActionType) FollowUpActionCategory() *String {
    if s.followupactiontype.FollowUpActionCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.followupactiontype.FollowUpActionCategory = ((*String)(v))
      }
      }
      return s.followupactiontype.FollowUpActionCategory
    }
// Returns whether the element value for FollowUpActionCategory is nil in the container FollowUpActionType.
  func (s *FollowUpActionType) FollowUpActionCategory_IsNil() bool {
    return s.followupactiontype.FollowUpActionCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FollowUpActionType) FollowUpDetails() *String {
    if s.followupactiontype.FollowUpDetails == nil {
    if v, ok:= StringPointer(""); ok {
      s.followupactiontype.FollowUpDetails = ((*String)(v))
      }
      }
      return s.followupactiontype.FollowUpDetails
    }
// Returns whether the element value for FollowUpDetails is nil in the container FollowUpActionType.
  func (s *FollowUpActionType) FollowUpDetails_IsNil() bool {
    return s.followupactiontype.FollowUpDetails == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *FollowUpActionType) WellbeingResponseRefId() *String {
    if s.followupactiontype.WellbeingResponseRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.followupactiontype.WellbeingResponseRefId = ((*String)(v))
      }
      }
      return s.followupactiontype.WellbeingResponseRefId
    }
// Returns whether the element value for WellbeingResponseRefId is nil in the container FollowUpActionType.
  func (s *FollowUpActionType) WellbeingResponseRefId_IsNil() bool {
    return s.followupactiontype.WellbeingResponseRefId == nil
    }

// Set the value of a property to nil
func (n *GenericRubricType) Unset(key string) *GenericRubricType {
        switch key {
  case "Descriptor":
   n.genericrubrictype.Descriptor = nil
  case "RubricType":
   n.genericrubrictype.RubricType = nil
  case "ScoreList":
   n.genericrubrictype.ScoreList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GenericRubricType")
        }
        return n
}

// Set a sequence of properties
func (n *GenericRubricType) SetProperties(props ...Prop) *GenericRubricType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *GenericRubricType) SetProperty(key string, value interface{}) *GenericRubricType {
        if n == nil {
                n, _ = GenericRubricTypePointer(GenericRubricType{})
        }
        switch key {
    case "Descriptor":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.genericrubrictype.Descriptor = ((*String)(v))
      }
    case "RubricType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.genericrubrictype.RubricType = ((*String)(v))
      }
    case "ScoreList":
    if v, ok:= ScoreListTypePointer(value); ok {
      n.genericrubrictype.ScoreList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GenericRubricType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GenericRubricType) Descriptor() *String {
    if s.genericrubrictype.Descriptor == nil {
    if v, ok:= StringPointer(""); ok {
      s.genericrubrictype.Descriptor = ((*String)(v))
      }
      }
      return s.genericrubrictype.Descriptor
    }
// Returns whether the element value for Descriptor is nil in the container GenericRubricType.
  func (s *GenericRubricType) Descriptor_IsNil() bool {
    return s.genericrubrictype.Descriptor == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GenericRubricType) RubricType() *String {
    if s.genericrubrictype.RubricType == nil {
    if v, ok:= StringPointer(""); ok {
      s.genericrubrictype.RubricType = ((*String)(v))
      }
      }
      return s.genericrubrictype.RubricType
    }
// Returns whether the element value for RubricType is nil in the container GenericRubricType.
  func (s *GenericRubricType) RubricType_IsNil() bool {
    return s.genericrubrictype.RubricType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GenericRubricType) ScoreList() *ScoreListType {
    if s.genericrubrictype.ScoreList == nil {
     if v, ok:= ScoreListTypePointer(ScoreListType{}); ok {
      s.genericrubrictype.ScoreList = v
      }
      }
      return s.genericrubrictype.ScoreList
    }
// Returns whether the element value for ScoreList is nil in the container GenericRubricType.
  func (s *GenericRubricType) ScoreList_IsNil() bool {
    return s.genericrubrictype.ScoreList == nil
    }

// Set the value of a property to nil
func (n *GradeType) Unset(key string) *GradeType {
        switch key {
  case "Letter":
   n.gradetype.Letter = nil
  case "MarkInfoRefId":
   n.gradetype.MarkInfoRefId = nil
  case "Narrative":
   n.gradetype.Narrative = nil
  case "Numeric":
   n.gradetype.Numeric = nil
  case "Percentage":
   n.gradetype.Percentage = nil
  case "ProgressLevel":
   n.gradetype.ProgressLevel = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GradeType")
        }
        return n
}

// Set a sequence of properties
func (n *GradeType) SetProperties(props ...Prop) *GradeType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *GradeType) SetProperty(key string, value interface{}) *GradeType {
        if n == nil {
                n, _ = GradeTypePointer(GradeType{})
        }
        switch key {
    case "Letter":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradetype.Letter = ((*String)(v))
      }
    case "MarkInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradetype.MarkInfoRefId = ((*String)(v))
      }
    case "Narrative":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradetype.Narrative = ((*String)(v))
      }
    case "Numeric":
    
    if v, ok:= FloatPointer(value); ok {
      n.gradetype.Numeric = ((*Float)(v))
      }
    case "Percentage":
    
    if v, ok:= FloatPointer(value); ok {
      n.gradetype.Percentage = ((*Float)(v))
      }
    case "ProgressLevel":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsGradeProgressLevelType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsGradeProgressLevelType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.gradetype.ProgressLevel = ((*AUCodeSetsGradeProgressLevelType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GradeType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradeType) Letter() *String {
    if s.gradetype.Letter == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradetype.Letter = ((*String)(v))
      }
      }
      return s.gradetype.Letter
    }
// Returns whether the element value for Letter is nil in the container GradeType.
  func (s *GradeType) Letter_IsNil() bool {
    return s.gradetype.Letter == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradeType) MarkInfoRefId() *String {
    if s.gradetype.MarkInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradetype.MarkInfoRefId = ((*String)(v))
      }
      }
      return s.gradetype.MarkInfoRefId
    }
// Returns whether the element value for MarkInfoRefId is nil in the container GradeType.
  func (s *GradeType) MarkInfoRefId_IsNil() bool {
    return s.gradetype.MarkInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradeType) Narrative() *String {
    if s.gradetype.Narrative == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradetype.Narrative = ((*String)(v))
      }
      }
      return s.gradetype.Narrative
    }
// Returns whether the element value for Narrative is nil in the container GradeType.
  func (s *GradeType) Narrative_IsNil() bool {
    return s.gradetype.Narrative == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradeType) Numeric() *Float {
    if s.gradetype.Numeric == nil {
    if v, ok:= FloatPointer(0); ok {
      s.gradetype.Numeric = ((*Float)(v))
      }
      }
      return s.gradetype.Numeric
    }
// Returns whether the element value for Numeric is nil in the container GradeType.
  func (s *GradeType) Numeric_IsNil() bool {
    return s.gradetype.Numeric == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradeType) Percentage() *Float {
    if s.gradetype.Percentage == nil {
    if v, ok:= FloatPointer(0); ok {
      s.gradetype.Percentage = ((*Float)(v))
      }
      }
      return s.gradetype.Percentage
    }
// Returns whether the element value for Percentage is nil in the container GradeType.
  func (s *GradeType) Percentage_IsNil() bool {
    return s.gradetype.Percentage == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradeType) ProgressLevel() *AUCodeSetsGradeProgressLevelType {
    if s.gradetype.ProgressLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradetype.ProgressLevel = ((*AUCodeSetsGradeProgressLevelType)(v))
      }
      }
      return s.gradetype.ProgressLevel
    }
// Returns whether the element value for ProgressLevel is nil in the container GradeType.
  func (s *GradeType) ProgressLevel_IsNil() bool {
    return s.gradetype.ProgressLevel == nil
    }

// Set the value of a property to nil
func (n *GradingAssignment) Unset(key string) *GradingAssignment {
        switch key {
  case "AssessmentType":
   n.gradingassignment.AssessmentType = nil
  case "AssignmentPurpose":
   n.gradingassignment.AssignmentPurpose = nil
  case "CreateDate":
   n.gradingassignment.CreateDate = nil
  case "Description":
   n.gradingassignment.Description = nil
  case "DetailedDescriptionBinary":
   n.gradingassignment.DetailedDescriptionBinary = nil
  case "DetailedDescriptionURL":
   n.gradingassignment.DetailedDescriptionURL = nil
  case "DueDate":
   n.gradingassignment.DueDate = nil
  case "GradingCategory":
   n.gradingassignment.GradingCategory = nil
  case "LearningStandardList":
   n.gradingassignment.LearningStandardList = nil
  case "LevelAssessed":
   n.gradingassignment.LevelAssessed = nil
  case "LocalCodeList":
   n.gradingassignment.LocalCodeList = nil
  case "MaxAttemptsAllowed":
   n.gradingassignment.MaxAttemptsAllowed = nil
  case "PointsPossible":
   n.gradingassignment.PointsPossible = nil
  case "PrerequisiteList":
   n.gradingassignment.PrerequisiteList = nil
  case "RefId":
   n.gradingassignment.RefId = nil
  case "RubricScoringGuide":
   n.gradingassignment.RubricScoringGuide = nil
  case "SIF_ExtendedElements":
   n.gradingassignment.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.gradingassignment.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.gradingassignment.SchoolInfoRefId = nil
  case "StudentPersonalRefIdList":
   n.gradingassignment.StudentPersonalRefIdList = nil
  case "SubAssignmentList":
   n.gradingassignment.SubAssignmentList = nil
  case "TeachingGroupRefId":
   n.gradingassignment.TeachingGroupRefId = nil
  case "Weight":
   n.gradingassignment.Weight = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GradingAssignment")
        }
        return n
}

// Set a sequence of properties
func (n *GradingAssignment) SetProperties(props ...Prop) *GradingAssignment {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *GradingAssignment) SetProperty(key string, value interface{}) *GradingAssignment {
        if n == nil {
                n, _ = GradingAssignmentPointer(GradingAssignment{})
        }
        switch key {
    case "AssessmentType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.AssessmentType = ((*String)(v))
      }
    case "AssignmentPurpose":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.AssignmentPurpose = ((*String)(v))
      }
    case "CreateDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.CreateDate = ((*String)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.Description = ((*String)(v))
      }
    case "DetailedDescriptionBinary":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.DetailedDescriptionBinary = ((*String)(v))
      }
    case "DetailedDescriptionURL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.DetailedDescriptionURL = ((*String)(v))
      }
    case "DueDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.DueDate = ((*String)(v))
      }
    case "GradingCategory":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.GradingCategory = ((*String)(v))
      }
    case "LearningStandardList":
    if v, ok:= LearningStandardListTypePointer(value); ok {
      n.gradingassignment.LearningStandardList = v
      }
    case "LevelAssessed":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.LevelAssessed = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.gradingassignment.LocalCodeList = v
      }
    case "MaxAttemptsAllowed":
    
    if v, ok:= IntPointer(value); ok {
      n.gradingassignment.MaxAttemptsAllowed = ((*Int)(v))
      }
    case "PointsPossible":
    
    if v, ok:= IntPointer(value); ok {
      n.gradingassignment.PointsPossible = ((*Int)(v))
      }
    case "PrerequisiteList":
    if v, ok:= PrerequisitesTypePointer(value); ok {
      n.gradingassignment.PrerequisiteList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.RefId = ((*RefIdType)(v))
      }
    case "RubricScoringGuide":
    if v, ok:= GenericRubricTypePointer(value); ok {
      n.gradingassignment.RubricScoringGuide = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.gradingassignment.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.gradingassignment.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.SchoolInfoRefId = ((*String)(v))
      }
    case "StudentPersonalRefIdList":
    if v, ok:= StudentsTypePointer(value); ok {
      n.gradingassignment.StudentPersonalRefIdList = v
      }
    case "SubAssignmentList":
    if v, ok:= AssignmentListTypePointer(value); ok {
      n.gradingassignment.SubAssignmentList = v
      }
    case "TeachingGroupRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignment.TeachingGroupRefId = ((*String)(v))
      }
    case "Weight":
    
    if v, ok:= FloatPointer(value); ok {
      n.gradingassignment.Weight = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GradingAssignment")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) AssessmentType() *String {
    if s.gradingassignment.AssessmentType == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.AssessmentType = ((*String)(v))
      }
      }
      return s.gradingassignment.AssessmentType
    }
// Returns whether the element value for AssessmentType is nil in the container GradingAssignment.
  func (s *GradingAssignment) AssessmentType_IsNil() bool {
    return s.gradingassignment.AssessmentType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) AssignmentPurpose() *String {
    if s.gradingassignment.AssignmentPurpose == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.AssignmentPurpose = ((*String)(v))
      }
      }
      return s.gradingassignment.AssignmentPurpose
    }
// Returns whether the element value for AssignmentPurpose is nil in the container GradingAssignment.
  func (s *GradingAssignment) AssignmentPurpose_IsNil() bool {
    return s.gradingassignment.AssignmentPurpose == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) CreateDate() *String {
    if s.gradingassignment.CreateDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.CreateDate = ((*String)(v))
      }
      }
      return s.gradingassignment.CreateDate
    }
// Returns whether the element value for CreateDate is nil in the container GradingAssignment.
  func (s *GradingAssignment) CreateDate_IsNil() bool {
    return s.gradingassignment.CreateDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) Description() *String {
    if s.gradingassignment.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.Description = ((*String)(v))
      }
      }
      return s.gradingassignment.Description
    }
// Returns whether the element value for Description is nil in the container GradingAssignment.
  func (s *GradingAssignment) Description_IsNil() bool {
    return s.gradingassignment.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) DetailedDescriptionBinary() *String {
    if s.gradingassignment.DetailedDescriptionBinary == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.DetailedDescriptionBinary = ((*String)(v))
      }
      }
      return s.gradingassignment.DetailedDescriptionBinary
    }
// Returns whether the element value for DetailedDescriptionBinary is nil in the container GradingAssignment.
  func (s *GradingAssignment) DetailedDescriptionBinary_IsNil() bool {
    return s.gradingassignment.DetailedDescriptionBinary == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) DetailedDescriptionURL() *String {
    if s.gradingassignment.DetailedDescriptionURL == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.DetailedDescriptionURL = ((*String)(v))
      }
      }
      return s.gradingassignment.DetailedDescriptionURL
    }
// Returns whether the element value for DetailedDescriptionURL is nil in the container GradingAssignment.
  func (s *GradingAssignment) DetailedDescriptionURL_IsNil() bool {
    return s.gradingassignment.DetailedDescriptionURL == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) DueDate() *String {
    if s.gradingassignment.DueDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.DueDate = ((*String)(v))
      }
      }
      return s.gradingassignment.DueDate
    }
// Returns whether the element value for DueDate is nil in the container GradingAssignment.
  func (s *GradingAssignment) DueDate_IsNil() bool {
    return s.gradingassignment.DueDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) GradingCategory() *String {
    if s.gradingassignment.GradingCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.GradingCategory = ((*String)(v))
      }
      }
      return s.gradingassignment.GradingCategory
    }
// Returns whether the element value for GradingCategory is nil in the container GradingAssignment.
  func (s *GradingAssignment) GradingCategory_IsNil() bool {
    return s.gradingassignment.GradingCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) LearningStandardList() *LearningStandardListType {
    if s.gradingassignment.LearningStandardList == nil {
     if v, ok:= LearningStandardListTypePointer(LearningStandardListType{}); ok {
      s.gradingassignment.LearningStandardList = v
      }
      }
      return s.gradingassignment.LearningStandardList
    }
// Returns whether the element value for LearningStandardList is nil in the container GradingAssignment.
  func (s *GradingAssignment) LearningStandardList_IsNil() bool {
    return s.gradingassignment.LearningStandardList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) LevelAssessed() *String {
    if s.gradingassignment.LevelAssessed == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.LevelAssessed = ((*String)(v))
      }
      }
      return s.gradingassignment.LevelAssessed
    }
// Returns whether the element value for LevelAssessed is nil in the container GradingAssignment.
  func (s *GradingAssignment) LevelAssessed_IsNil() bool {
    return s.gradingassignment.LevelAssessed == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) LocalCodeList() *LocalCodeListType {
    if s.gradingassignment.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.gradingassignment.LocalCodeList = v
      }
      }
      return s.gradingassignment.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container GradingAssignment.
  func (s *GradingAssignment) LocalCodeList_IsNil() bool {
    return s.gradingassignment.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) MaxAttemptsAllowed() *Int {
    if s.gradingassignment.MaxAttemptsAllowed == nil {
    if v, ok:= IntPointer(0); ok {
      s.gradingassignment.MaxAttemptsAllowed = ((*Int)(v))
      }
      }
      return s.gradingassignment.MaxAttemptsAllowed
    }
// Returns whether the element value for MaxAttemptsAllowed is nil in the container GradingAssignment.
  func (s *GradingAssignment) MaxAttemptsAllowed_IsNil() bool {
    return s.gradingassignment.MaxAttemptsAllowed == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) PointsPossible() *Int {
    if s.gradingassignment.PointsPossible == nil {
    if v, ok:= IntPointer(0); ok {
      s.gradingassignment.PointsPossible = ((*Int)(v))
      }
      }
      return s.gradingassignment.PointsPossible
    }
// Returns whether the element value for PointsPossible is nil in the container GradingAssignment.
  func (s *GradingAssignment) PointsPossible_IsNil() bool {
    return s.gradingassignment.PointsPossible == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) PrerequisiteList() *PrerequisitesType {
    if s.gradingassignment.PrerequisiteList == nil {
     if v, ok:= PrerequisitesTypePointer(PrerequisitesType{}); ok {
      s.gradingassignment.PrerequisiteList = v
      }
      }
      return s.gradingassignment.PrerequisiteList
    }
// Returns whether the element value for PrerequisiteList is nil in the container GradingAssignment.
  func (s *GradingAssignment) PrerequisiteList_IsNil() bool {
    return s.gradingassignment.PrerequisiteList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) RefId() *RefIdType {
    if s.gradingassignment.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.RefId = ((*RefIdType)(v))
      }
      }
      return s.gradingassignment.RefId
    }
// Returns whether the element value for RefId is nil in the container GradingAssignment.
  func (s *GradingAssignment) RefId_IsNil() bool {
    return s.gradingassignment.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) RubricScoringGuide() *GenericRubricType {
    if s.gradingassignment.RubricScoringGuide == nil {
     if v, ok:= GenericRubricTypePointer(GenericRubricType{}); ok {
      s.gradingassignment.RubricScoringGuide = v
      }
      }
      return s.gradingassignment.RubricScoringGuide
    }
// Returns whether the element value for RubricScoringGuide is nil in the container GradingAssignment.
  func (s *GradingAssignment) RubricScoringGuide_IsNil() bool {
    return s.gradingassignment.RubricScoringGuide == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.gradingassignment.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.gradingassignment.SIF_ExtendedElements = v
      }
      }
      return s.gradingassignment.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container GradingAssignment.
  func (s *GradingAssignment) SIF_ExtendedElements_IsNil() bool {
    return s.gradingassignment.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) SIF_Metadata() *SIF_MetadataType {
    if s.gradingassignment.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.gradingassignment.SIF_Metadata = v
      }
      }
      return s.gradingassignment.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container GradingAssignment.
  func (s *GradingAssignment) SIF_Metadata_IsNil() bool {
    return s.gradingassignment.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) SchoolInfoRefId() *String {
    if s.gradingassignment.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.gradingassignment.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container GradingAssignment.
  func (s *GradingAssignment) SchoolInfoRefId_IsNil() bool {
    return s.gradingassignment.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) StudentPersonalRefIdList() *StudentsType {
    if s.gradingassignment.StudentPersonalRefIdList == nil {
     if v, ok:= StudentsTypePointer(StudentsType{}); ok {
      s.gradingassignment.StudentPersonalRefIdList = v
      }
      }
      return s.gradingassignment.StudentPersonalRefIdList
    }
// Returns whether the element value for StudentPersonalRefIdList is nil in the container GradingAssignment.
  func (s *GradingAssignment) StudentPersonalRefIdList_IsNil() bool {
    return s.gradingassignment.StudentPersonalRefIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) SubAssignmentList() *AssignmentListType {
    if s.gradingassignment.SubAssignmentList == nil {
     if v, ok:= AssignmentListTypePointer(AssignmentListType{}); ok {
      s.gradingassignment.SubAssignmentList = v
      }
      }
      return s.gradingassignment.SubAssignmentList
    }
// Returns whether the element value for SubAssignmentList is nil in the container GradingAssignment.
  func (s *GradingAssignment) SubAssignmentList_IsNil() bool {
    return s.gradingassignment.SubAssignmentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) TeachingGroupRefId() *String {
    if s.gradingassignment.TeachingGroupRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignment.TeachingGroupRefId = ((*String)(v))
      }
      }
      return s.gradingassignment.TeachingGroupRefId
    }
// Returns whether the element value for TeachingGroupRefId is nil in the container GradingAssignment.
  func (s *GradingAssignment) TeachingGroupRefId_IsNil() bool {
    return s.gradingassignment.TeachingGroupRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignment) Weight() *Float {
    if s.gradingassignment.Weight == nil {
    if v, ok:= FloatPointer(0); ok {
      s.gradingassignment.Weight = ((*Float)(v))
      }
      }
      return s.gradingassignment.Weight
    }
// Returns whether the element value for Weight is nil in the container GradingAssignment.
  func (s *GradingAssignment) Weight_IsNil() bool {
    return s.gradingassignment.Weight == nil
    }

// Set the value of a property to nil
func (n *GradingAssignmentScore) Unset(key string) *GradingAssignmentScore {
        switch key {
  case "AssignmentScoreIteration":
   n.gradingassignmentscore.AssignmentScoreIteration = nil
  case "DateGraded":
   n.gradingassignmentscore.DateGraded = nil
  case "ExpectedScore":
   n.gradingassignmentscore.ExpectedScore = nil
  case "GradingAssignmentRefId":
   n.gradingassignmentscore.GradingAssignmentRefId = nil
  case "LocalCodeList":
   n.gradingassignmentscore.LocalCodeList = nil
  case "MarkInfoRefId":
   n.gradingassignmentscore.MarkInfoRefId = nil
  case "RefId":
   n.gradingassignmentscore.RefId = nil
  case "SIF_ExtendedElements":
   n.gradingassignmentscore.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.gradingassignmentscore.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.gradingassignmentscore.SchoolInfoRefId = nil
  case "ScoreDescription":
   n.gradingassignmentscore.ScoreDescription = nil
  case "ScoreLetter":
   n.gradingassignmentscore.ScoreLetter = nil
  case "ScorePercent":
   n.gradingassignmentscore.ScorePercent = nil
  case "ScorePoints":
   n.gradingassignmentscore.ScorePoints = nil
  case "StaffPersonalRefId":
   n.gradingassignmentscore.StaffPersonalRefId = nil
  case "StudentPersonalLocalId":
   n.gradingassignmentscore.StudentPersonalLocalId = nil
  case "StudentPersonalRefId":
   n.gradingassignmentscore.StudentPersonalRefId = nil
  case "SubscoreList":
   n.gradingassignmentscore.SubscoreList = nil
  case "TeacherJudgement":
   n.gradingassignmentscore.TeacherJudgement = nil
  case "TeachingGroupRefId":
   n.gradingassignmentscore.TeachingGroupRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GradingAssignmentScore")
        }
        return n
}

// Set a sequence of properties
func (n *GradingAssignmentScore) SetProperties(props ...Prop) *GradingAssignmentScore {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *GradingAssignmentScore) SetProperty(key string, value interface{}) *GradingAssignmentScore {
        if n == nil {
                n, _ = GradingAssignmentScorePointer(GradingAssignmentScore{})
        }
        switch key {
    case "AssignmentScoreIteration":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.AssignmentScoreIteration = ((*String)(v))
      }
    case "DateGraded":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.DateGraded = ((*String)(v))
      }
    case "ExpectedScore":
    
    if v, ok:= BoolPointer(value); ok {
      n.gradingassignmentscore.ExpectedScore = ((*Bool)(v))
      }
    case "GradingAssignmentRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.GradingAssignmentRefId = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.gradingassignmentscore.LocalCodeList = v
      }
    case "MarkInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.MarkInfoRefId = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.gradingassignmentscore.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.gradingassignmentscore.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.SchoolInfoRefId = ((*String)(v))
      }
    case "ScoreDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.ScoreDescription = ((*String)(v))
      }
    case "ScoreLetter":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.ScoreLetter = ((*String)(v))
      }
    case "ScorePercent":
    
    if v, ok:= FloatPointer(value); ok {
      n.gradingassignmentscore.ScorePercent = ((*Float)(v))
      }
    case "ScorePoints":
    
    if v, ok:= IntPointer(value); ok {
      n.gradingassignmentscore.ScorePoints = ((*Int)(v))
      }
    case "StaffPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.StaffPersonalRefId = ((*String)(v))
      }
    case "StudentPersonalLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.StudentPersonalLocalId = ((*LocalIdType)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.StudentPersonalRefId = ((*String)(v))
      }
    case "SubscoreList":
    if v, ok:= NAPSubscoreListTypePointer(value); ok {
      n.gradingassignmentscore.SubscoreList = v
      }
    case "TeacherJudgement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.TeacherJudgement = ((*String)(v))
      }
    case "TeachingGroupRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.gradingassignmentscore.TeachingGroupRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GradingAssignmentScore")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) AssignmentScoreIteration() *String {
    if s.gradingassignmentscore.AssignmentScoreIteration == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.AssignmentScoreIteration = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.AssignmentScoreIteration
    }
// Returns whether the element value for AssignmentScoreIteration is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) AssignmentScoreIteration_IsNil() bool {
    return s.gradingassignmentscore.AssignmentScoreIteration == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) DateGraded() *String {
    if s.gradingassignmentscore.DateGraded == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.DateGraded = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.DateGraded
    }
// Returns whether the element value for DateGraded is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) DateGraded_IsNil() bool {
    return s.gradingassignmentscore.DateGraded == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) ExpectedScore() *Bool {
    if s.gradingassignmentscore.ExpectedScore == nil {
    if v, ok:= BoolPointer(false); ok {
      s.gradingassignmentscore.ExpectedScore = ((*Bool)(v))
      }
      }
      return s.gradingassignmentscore.ExpectedScore
    }
// Returns whether the element value for ExpectedScore is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) ExpectedScore_IsNil() bool {
    return s.gradingassignmentscore.ExpectedScore == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) GradingAssignmentRefId() *String {
    if s.gradingassignmentscore.GradingAssignmentRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.GradingAssignmentRefId = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.GradingAssignmentRefId
    }
// Returns whether the element value for GradingAssignmentRefId is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) GradingAssignmentRefId_IsNil() bool {
    return s.gradingassignmentscore.GradingAssignmentRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) LocalCodeList() *LocalCodeListType {
    if s.gradingassignmentscore.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.gradingassignmentscore.LocalCodeList = v
      }
      }
      return s.gradingassignmentscore.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) LocalCodeList_IsNil() bool {
    return s.gradingassignmentscore.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) MarkInfoRefId() *String {
    if s.gradingassignmentscore.MarkInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.MarkInfoRefId = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.MarkInfoRefId
    }
// Returns whether the element value for MarkInfoRefId is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) MarkInfoRefId_IsNil() bool {
    return s.gradingassignmentscore.MarkInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) RefId() *RefIdType {
    if s.gradingassignmentscore.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.RefId = ((*RefIdType)(v))
      }
      }
      return s.gradingassignmentscore.RefId
    }
// Returns whether the element value for RefId is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) RefId_IsNil() bool {
    return s.gradingassignmentscore.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.gradingassignmentscore.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.gradingassignmentscore.SIF_ExtendedElements = v
      }
      }
      return s.gradingassignmentscore.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) SIF_ExtendedElements_IsNil() bool {
    return s.gradingassignmentscore.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) SIF_Metadata() *SIF_MetadataType {
    if s.gradingassignmentscore.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.gradingassignmentscore.SIF_Metadata = v
      }
      }
      return s.gradingassignmentscore.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) SIF_Metadata_IsNil() bool {
    return s.gradingassignmentscore.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) SchoolInfoRefId() *String {
    if s.gradingassignmentscore.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) SchoolInfoRefId_IsNil() bool {
    return s.gradingassignmentscore.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) ScoreDescription() *String {
    if s.gradingassignmentscore.ScoreDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.ScoreDescription = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.ScoreDescription
    }
// Returns whether the element value for ScoreDescription is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) ScoreDescription_IsNil() bool {
    return s.gradingassignmentscore.ScoreDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) ScoreLetter() *String {
    if s.gradingassignmentscore.ScoreLetter == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.ScoreLetter = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.ScoreLetter
    }
// Returns whether the element value for ScoreLetter is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) ScoreLetter_IsNil() bool {
    return s.gradingassignmentscore.ScoreLetter == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) ScorePercent() *Float {
    if s.gradingassignmentscore.ScorePercent == nil {
    if v, ok:= FloatPointer(0); ok {
      s.gradingassignmentscore.ScorePercent = ((*Float)(v))
      }
      }
      return s.gradingassignmentscore.ScorePercent
    }
// Returns whether the element value for ScorePercent is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) ScorePercent_IsNil() bool {
    return s.gradingassignmentscore.ScorePercent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) ScorePoints() *Int {
    if s.gradingassignmentscore.ScorePoints == nil {
    if v, ok:= IntPointer(0); ok {
      s.gradingassignmentscore.ScorePoints = ((*Int)(v))
      }
      }
      return s.gradingassignmentscore.ScorePoints
    }
// Returns whether the element value for ScorePoints is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) ScorePoints_IsNil() bool {
    return s.gradingassignmentscore.ScorePoints == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) StaffPersonalRefId() *String {
    if s.gradingassignmentscore.StaffPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.StaffPersonalRefId = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.StaffPersonalRefId
    }
// Returns whether the element value for StaffPersonalRefId is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) StaffPersonalRefId_IsNil() bool {
    return s.gradingassignmentscore.StaffPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) StudentPersonalLocalId() *LocalIdType {
    if s.gradingassignmentscore.StudentPersonalLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.StudentPersonalLocalId = ((*LocalIdType)(v))
      }
      }
      return s.gradingassignmentscore.StudentPersonalLocalId
    }
// Returns whether the element value for StudentPersonalLocalId is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) StudentPersonalLocalId_IsNil() bool {
    return s.gradingassignmentscore.StudentPersonalLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) StudentPersonalRefId() *String {
    if s.gradingassignmentscore.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) StudentPersonalRefId_IsNil() bool {
    return s.gradingassignmentscore.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) SubscoreList() *NAPSubscoreListType {
    if s.gradingassignmentscore.SubscoreList == nil {
     if v, ok:= NAPSubscoreListTypePointer(NAPSubscoreListType{}); ok {
      s.gradingassignmentscore.SubscoreList = v
      }
      }
      return s.gradingassignmentscore.SubscoreList
    }
// Returns whether the element value for SubscoreList is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) SubscoreList_IsNil() bool {
    return s.gradingassignmentscore.SubscoreList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) TeacherJudgement() *String {
    if s.gradingassignmentscore.TeacherJudgement == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.TeacherJudgement = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.TeacherJudgement
    }
// Returns whether the element value for TeacherJudgement is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) TeacherJudgement_IsNil() bool {
    return s.gradingassignmentscore.TeacherJudgement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GradingAssignmentScore) TeachingGroupRefId() *String {
    if s.gradingassignmentscore.TeachingGroupRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.gradingassignmentscore.TeachingGroupRefId = ((*String)(v))
      }
      }
      return s.gradingassignmentscore.TeachingGroupRefId
    }
// Returns whether the element value for TeachingGroupRefId is nil in the container GradingAssignmentScore.
  func (s *GradingAssignmentScore) TeachingGroupRefId_IsNil() bool {
    return s.gradingassignmentscore.TeachingGroupRefId == nil
    }

// Set the value of a property to nil
func (n *GridLocationType) Unset(key string) *GridLocationType {
        switch key {
  case "Latitude":
   n.gridlocationtype.Latitude = nil
  case "Longitude":
   n.gridlocationtype.Longitude = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GridLocationType")
        }
        return n
}

// Set a sequence of properties
func (n *GridLocationType) SetProperties(props ...Prop) *GridLocationType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *GridLocationType) SetProperty(key string, value interface{}) *GridLocationType {
        if n == nil {
                n, _ = GridLocationTypePointer(GridLocationType{})
        }
        switch key {
    case "Latitude":
    
    if v, ok:= FloatPointer(value); ok {
      n.gridlocationtype.Latitude = ((*Float)(v))
      }
    case "Longitude":
    
    if v, ok:= FloatPointer(value); ok {
      n.gridlocationtype.Longitude = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "GridLocationType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GridLocationType) Latitude() *Float {
    if s.gridlocationtype.Latitude == nil {
    if v, ok:= FloatPointer(0); ok {
      s.gridlocationtype.Latitude = ((*Float)(v))
      }
      }
      return s.gridlocationtype.Latitude
    }
// Returns whether the element value for Latitude is nil in the container GridLocationType.
  func (s *GridLocationType) Latitude_IsNil() bool {
    return s.gridlocationtype.Latitude == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *GridLocationType) Longitude() *Float {
    if s.gridlocationtype.Longitude == nil {
    if v, ok:= FloatPointer(0); ok {
      s.gridlocationtype.Longitude = ((*Float)(v))
      }
      }
      return s.gridlocationtype.Longitude
    }
// Returns whether the element value for Longitude is nil in the container GridLocationType.
  func (s *GridLocationType) Longitude_IsNil() bool {
    return s.gridlocationtype.Longitude == nil
    }

// Set the value of a property to nil
func (n *HoldInfoType) Unset(key string) *HoldInfoType {
        switch key {
  case "DateNeeded":
   n.holdinfotype.DateNeeded = nil
  case "DatePlaced":
   n.holdinfotype.DatePlaced = nil
  case "Expires":
   n.holdinfotype.Expires = nil
  case "MadeAvailable":
   n.holdinfotype.MadeAvailable = nil
  case "ReservationExpiry":
   n.holdinfotype.ReservationExpiry = nil
  case "Type":
   n.holdinfotype.Type = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "HoldInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *HoldInfoType) SetProperties(props ...Prop) *HoldInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *HoldInfoType) SetProperty(key string, value interface{}) *HoldInfoType {
        if n == nil {
                n, _ = HoldInfoTypePointer(HoldInfoType{})
        }
        switch key {
    case "DateNeeded":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.holdinfotype.DateNeeded = ((*String)(v))
      }
    case "DatePlaced":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.holdinfotype.DatePlaced = ((*String)(v))
      }
    case "Expires":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.holdinfotype.Expires = ((*String)(v))
      }
    case "MadeAvailable":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.holdinfotype.MadeAvailable = ((*String)(v))
      }
    case "ReservationExpiry":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.holdinfotype.ReservationExpiry = ((*String)(v))
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.holdinfotype.Type = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "HoldInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HoldInfoType) DateNeeded() *String {
    if s.holdinfotype.DateNeeded == nil {
    if v, ok:= StringPointer(""); ok {
      s.holdinfotype.DateNeeded = ((*String)(v))
      }
      }
      return s.holdinfotype.DateNeeded
    }
// Returns whether the element value for DateNeeded is nil in the container HoldInfoType.
  func (s *HoldInfoType) DateNeeded_IsNil() bool {
    return s.holdinfotype.DateNeeded == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HoldInfoType) DatePlaced() *String {
    if s.holdinfotype.DatePlaced == nil {
    if v, ok:= StringPointer(""); ok {
      s.holdinfotype.DatePlaced = ((*String)(v))
      }
      }
      return s.holdinfotype.DatePlaced
    }
// Returns whether the element value for DatePlaced is nil in the container HoldInfoType.
  func (s *HoldInfoType) DatePlaced_IsNil() bool {
    return s.holdinfotype.DatePlaced == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HoldInfoType) Expires() *String {
    if s.holdinfotype.Expires == nil {
    if v, ok:= StringPointer(""); ok {
      s.holdinfotype.Expires = ((*String)(v))
      }
      }
      return s.holdinfotype.Expires
    }
// Returns whether the element value for Expires is nil in the container HoldInfoType.
  func (s *HoldInfoType) Expires_IsNil() bool {
    return s.holdinfotype.Expires == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HoldInfoType) MadeAvailable() *String {
    if s.holdinfotype.MadeAvailable == nil {
    if v, ok:= StringPointer(""); ok {
      s.holdinfotype.MadeAvailable = ((*String)(v))
      }
      }
      return s.holdinfotype.MadeAvailable
    }
// Returns whether the element value for MadeAvailable is nil in the container HoldInfoType.
  func (s *HoldInfoType) MadeAvailable_IsNil() bool {
    return s.holdinfotype.MadeAvailable == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HoldInfoType) ReservationExpiry() *String {
    if s.holdinfotype.ReservationExpiry == nil {
    if v, ok:= StringPointer(""); ok {
      s.holdinfotype.ReservationExpiry = ((*String)(v))
      }
      }
      return s.holdinfotype.ReservationExpiry
    }
// Returns whether the element value for ReservationExpiry is nil in the container HoldInfoType.
  func (s *HoldInfoType) ReservationExpiry_IsNil() bool {
    return s.holdinfotype.ReservationExpiry == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HoldInfoType) Type() *String {
    if s.holdinfotype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.holdinfotype.Type = ((*String)(v))
      }
      }
      return s.holdinfotype.Type
    }
// Returns whether the element value for Type is nil in the container HoldInfoType.
  func (s *HoldInfoType) Type_IsNil() bool {
    return s.holdinfotype.Type == nil
    }

// Set the value of a property to nil
func (n *HomeroomType) Unset(key string) *HomeroomType {
        switch key {
  case "SIF_RefObject":
   n.homeroomtype.SIF_RefObject = nil
  case "Value":
   n.homeroomtype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "HomeroomType")
        }
        return n
}

// Set a sequence of properties
func (n *HomeroomType) SetProperties(props ...Prop) *HomeroomType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *HomeroomType) SetProperty(key string, value interface{}) *HomeroomType {
        if n == nil {
                n, _ = HomeroomTypePointer(HomeroomType{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.homeroomtype.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.homeroomtype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "HomeroomType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HomeroomType) SIF_RefObject() *String {
    if s.homeroomtype.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.homeroomtype.SIF_RefObject = ((*String)(v))
      }
      }
      return s.homeroomtype.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container HomeroomType.
  func (s *HomeroomType) SIF_RefObject_IsNil() bool {
    return s.homeroomtype.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HomeroomType) Value() *String {
    if s.homeroomtype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.homeroomtype.Value = ((*String)(v))
      }
      }
      return s.homeroomtype.Value
    }
// Returns whether the element value for Value is nil in the container HomeroomType.
  func (s *HomeroomType) Value_IsNil() bool {
    return s.homeroomtype.Value == nil
    }

// Set the value of a property to nil
func (n *HouseholdContactInfoType) Unset(key string) *HouseholdContactInfoType {
        switch key {
  case "AddressList":
   n.householdcontactinfotype.AddressList = nil
  case "EmailList":
   n.householdcontactinfotype.EmailList = nil
  case "HouseholdContactId":
   n.householdcontactinfotype.HouseholdContactId = nil
  case "HouseholdSalutation":
   n.householdcontactinfotype.HouseholdSalutation = nil
  case "PhoneNumberList":
   n.householdcontactinfotype.PhoneNumberList = nil
  case "PreferenceNumber":
   n.householdcontactinfotype.PreferenceNumber = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "HouseholdContactInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *HouseholdContactInfoType) SetProperties(props ...Prop) *HouseholdContactInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *HouseholdContactInfoType) SetProperty(key string, value interface{}) *HouseholdContactInfoType {
        if n == nil {
                n, _ = HouseholdContactInfoTypePointer(HouseholdContactInfoType{})
        }
        switch key {
    case "AddressList":
    if v, ok:= AddressListTypePointer(value); ok {
      n.householdcontactinfotype.AddressList = v
      }
    case "EmailList":
    if v, ok:= EmailListTypePointer(value); ok {
      n.householdcontactinfotype.EmailList = v
      }
    case "HouseholdContactId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.householdcontactinfotype.HouseholdContactId = ((*LocalIdType)(v))
      }
    case "HouseholdSalutation":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.householdcontactinfotype.HouseholdSalutation = ((*String)(v))
      }
    case "PhoneNumberList":
    if v, ok:= PhoneNumberListTypePointer(value); ok {
      n.householdcontactinfotype.PhoneNumberList = v
      }
    case "PreferenceNumber":
    
    if v, ok:= IntPointer(value); ok {
      n.householdcontactinfotype.PreferenceNumber = ((*Int)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "HouseholdContactInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HouseholdContactInfoType) AddressList() *AddressListType {
    if s.householdcontactinfotype.AddressList == nil {
     if v, ok:= AddressListTypePointer(AddressListType{}); ok {
      s.householdcontactinfotype.AddressList = v
      }
      }
      return s.householdcontactinfotype.AddressList
    }
// Returns whether the element value for AddressList is nil in the container HouseholdContactInfoType.
  func (s *HouseholdContactInfoType) AddressList_IsNil() bool {
    return s.householdcontactinfotype.AddressList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HouseholdContactInfoType) EmailList() *EmailListType {
    if s.householdcontactinfotype.EmailList == nil {
     if v, ok:= EmailListTypePointer(EmailListType{}); ok {
      s.householdcontactinfotype.EmailList = v
      }
      }
      return s.householdcontactinfotype.EmailList
    }
// Returns whether the element value for EmailList is nil in the container HouseholdContactInfoType.
  func (s *HouseholdContactInfoType) EmailList_IsNil() bool {
    return s.householdcontactinfotype.EmailList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HouseholdContactInfoType) HouseholdContactId() *LocalIdType {
    if s.householdcontactinfotype.HouseholdContactId == nil {
    if v, ok:= StringPointer(""); ok {
      s.householdcontactinfotype.HouseholdContactId = ((*LocalIdType)(v))
      }
      }
      return s.householdcontactinfotype.HouseholdContactId
    }
// Returns whether the element value for HouseholdContactId is nil in the container HouseholdContactInfoType.
  func (s *HouseholdContactInfoType) HouseholdContactId_IsNil() bool {
    return s.householdcontactinfotype.HouseholdContactId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HouseholdContactInfoType) HouseholdSalutation() *String {
    if s.householdcontactinfotype.HouseholdSalutation == nil {
    if v, ok:= StringPointer(""); ok {
      s.householdcontactinfotype.HouseholdSalutation = ((*String)(v))
      }
      }
      return s.householdcontactinfotype.HouseholdSalutation
    }
// Returns whether the element value for HouseholdSalutation is nil in the container HouseholdContactInfoType.
  func (s *HouseholdContactInfoType) HouseholdSalutation_IsNil() bool {
    return s.householdcontactinfotype.HouseholdSalutation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HouseholdContactInfoType) PhoneNumberList() *PhoneNumberListType {
    if s.householdcontactinfotype.PhoneNumberList == nil {
     if v, ok:= PhoneNumberListTypePointer(PhoneNumberListType{}); ok {
      s.householdcontactinfotype.PhoneNumberList = v
      }
      }
      return s.householdcontactinfotype.PhoneNumberList
    }
// Returns whether the element value for PhoneNumberList is nil in the container HouseholdContactInfoType.
  func (s *HouseholdContactInfoType) PhoneNumberList_IsNil() bool {
    return s.householdcontactinfotype.PhoneNumberList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *HouseholdContactInfoType) PreferenceNumber() *Int {
    if s.householdcontactinfotype.PreferenceNumber == nil {
    if v, ok:= IntPointer(0); ok {
      s.householdcontactinfotype.PreferenceNumber = ((*Int)(v))
      }
      }
      return s.householdcontactinfotype.PreferenceNumber
    }
// Returns whether the element value for PreferenceNumber is nil in the container HouseholdContactInfoType.
  func (s *HouseholdContactInfoType) PreferenceNumber_IsNil() bool {
    return s.householdcontactinfotype.PreferenceNumber == nil
    }

// Set the value of a property to nil
func (n *Identity) Unset(key string) *Identity {
        switch key {
  case "AuthenticationSource":
   n.identity.AuthenticationSource = nil
  case "AuthenticationSourceGlobalUID":
   n.identity.AuthenticationSourceGlobalUID = nil
  case "IdentityAssertions":
   n.identity.IdentityAssertions = nil
  case "LocalCodeList":
   n.identity.LocalCodeList = nil
  case "PasswordList":
   n.identity.PasswordList = nil
  case "RefId":
   n.identity.RefId = nil
  case "SIF_ExtendedElements":
   n.identity.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.identity.SIF_Metadata = nil
  case "SIF_RefId":
   n.identity.SIF_RefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Identity")
        }
        return n
}

// Set a sequence of properties
func (n *Identity) SetProperties(props ...Prop) *Identity {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *Identity) SetProperty(key string, value interface{}) *Identity {
        if n == nil {
                n, _ = IdentityPointer(Identity{})
        }
        switch key {
    case "AuthenticationSource":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.identity.AuthenticationSource = ((*String)(v))
      }
    case "AuthenticationSourceGlobalUID":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.identity.AuthenticationSourceGlobalUID = ((*String)(v))
      }
    case "IdentityAssertions":
    if v, ok:= IdentityAssertionsTypePointer(value); ok {
      n.identity.IdentityAssertions = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.identity.LocalCodeList = v
      }
    case "PasswordList":
    if v, ok:= PasswordListTypePointer(value); ok {
      n.identity.PasswordList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.identity.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.identity.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.identity.SIF_Metadata = v
      }
    case "SIF_RefId":
    if v, ok:= Identity_SIF_RefIdPointer(value); ok {
      n.identity.SIF_RefId = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Identity")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity) AuthenticationSource() *String {
    if s.identity.AuthenticationSource == nil {
    if v, ok:= StringPointer(""); ok {
      s.identity.AuthenticationSource = ((*String)(v))
      }
      }
      return s.identity.AuthenticationSource
    }
// Returns whether the element value for AuthenticationSource is nil in the container Identity.
  func (s *Identity) AuthenticationSource_IsNil() bool {
    return s.identity.AuthenticationSource == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity) AuthenticationSourceGlobalUID() *String {
    if s.identity.AuthenticationSourceGlobalUID == nil {
    if v, ok:= StringPointer(""); ok {
      s.identity.AuthenticationSourceGlobalUID = ((*String)(v))
      }
      }
      return s.identity.AuthenticationSourceGlobalUID
    }
// Returns whether the element value for AuthenticationSourceGlobalUID is nil in the container Identity.
  func (s *Identity) AuthenticationSourceGlobalUID_IsNil() bool {
    return s.identity.AuthenticationSourceGlobalUID == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity) IdentityAssertions() *IdentityAssertionsType {
    if s.identity.IdentityAssertions == nil {
     if v, ok:= IdentityAssertionsTypePointer(IdentityAssertionsType{}); ok {
      s.identity.IdentityAssertions = v
      }
      }
      return s.identity.IdentityAssertions
    }
// Returns whether the element value for IdentityAssertions is nil in the container Identity.
  func (s *Identity) IdentityAssertions_IsNil() bool {
    return s.identity.IdentityAssertions == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity) LocalCodeList() *LocalCodeListType {
    if s.identity.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.identity.LocalCodeList = v
      }
      }
      return s.identity.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container Identity.
  func (s *Identity) LocalCodeList_IsNil() bool {
    return s.identity.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity) PasswordList() *PasswordListType {
    if s.identity.PasswordList == nil {
     if v, ok:= PasswordListTypePointer(PasswordListType{}); ok {
      s.identity.PasswordList = v
      }
      }
      return s.identity.PasswordList
    }
// Returns whether the element value for PasswordList is nil in the container Identity.
  func (s *Identity) PasswordList_IsNil() bool {
    return s.identity.PasswordList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity) RefId() *RefIdType {
    if s.identity.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.identity.RefId = ((*RefIdType)(v))
      }
      }
      return s.identity.RefId
    }
// Returns whether the element value for RefId is nil in the container Identity.
  func (s *Identity) RefId_IsNil() bool {
    return s.identity.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.identity.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.identity.SIF_ExtendedElements = v
      }
      }
      return s.identity.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container Identity.
  func (s *Identity) SIF_ExtendedElements_IsNil() bool {
    return s.identity.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity) SIF_Metadata() *SIF_MetadataType {
    if s.identity.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.identity.SIF_Metadata = v
      }
      }
      return s.identity.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container Identity.
  func (s *Identity) SIF_Metadata_IsNil() bool {
    return s.identity.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity) SIF_RefId() *Identity_SIF_RefId {
    if s.identity.SIF_RefId == nil {
     if v, ok:= Identity_SIF_RefIdPointer(Identity_SIF_RefId{}); ok {
      s.identity.SIF_RefId = v
      }
      }
      return s.identity.SIF_RefId
    }
// Returns whether the element value for SIF_RefId is nil in the container Identity.
  func (s *Identity) SIF_RefId_IsNil() bool {
    return s.identity.SIF_RefId == nil
    }

// Set the value of a property to nil
func (n *IdentityAssertionType) Unset(key string) *IdentityAssertionType {
        switch key {
  case "SchemaName":
   n.identityassertiontype.SchemaName = nil
  case "Value":
   n.identityassertiontype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "IdentityAssertionType")
        }
        return n
}

// Set a sequence of properties
func (n *IdentityAssertionType) SetProperties(props ...Prop) *IdentityAssertionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *IdentityAssertionType) SetProperty(key string, value interface{}) *IdentityAssertionType {
        if n == nil {
                n, _ = IdentityAssertionTypePointer(IdentityAssertionType{})
        }
        switch key {
    case "SchemaName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.identityassertiontype.SchemaName = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.identityassertiontype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "IdentityAssertionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *IdentityAssertionType) SchemaName() *String {
    if s.identityassertiontype.SchemaName == nil {
    if v, ok:= StringPointer(""); ok {
      s.identityassertiontype.SchemaName = ((*String)(v))
      }
      }
      return s.identityassertiontype.SchemaName
    }
// Returns whether the element value for SchemaName is nil in the container IdentityAssertionType.
  func (s *IdentityAssertionType) SchemaName_IsNil() bool {
    return s.identityassertiontype.SchemaName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *IdentityAssertionType) Value() *String {
    if s.identityassertiontype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.identityassertiontype.Value = ((*String)(v))
      }
      }
      return s.identityassertiontype.Value
    }
// Returns whether the element value for Value is nil in the container IdentityAssertionType.
  func (s *IdentityAssertionType) Value_IsNil() bool {
    return s.identityassertiontype.Value == nil
    }

// Set the value of a property to nil
func (n *Identity_SIF_RefId) Unset(key string) *Identity_SIF_RefId {
        switch key {
  case "SIF_RefObject":
   n.identity_sif_refid.SIF_RefObject = nil
  case "Value":
   n.identity_sif_refid.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Identity_SIF_RefId")
        }
        return n
}

// Set a sequence of properties
func (n *Identity_SIF_RefId) SetProperties(props ...Prop) *Identity_SIF_RefId {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *Identity_SIF_RefId) SetProperty(key string, value interface{}) *Identity_SIF_RefId {
        if n == nil {
                n, _ = Identity_SIF_RefIdPointer(Identity_SIF_RefId{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.identity_sif_refid.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.identity_sif_refid.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Identity_SIF_RefId")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity_SIF_RefId) SIF_RefObject() *String {
    if s.identity_sif_refid.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.identity_sif_refid.SIF_RefObject = ((*String)(v))
      }
      }
      return s.identity_sif_refid.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container Identity_SIF_RefId.
  func (s *Identity_SIF_RefId) SIF_RefObject_IsNil() bool {
    return s.identity_sif_refid.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Identity_SIF_RefId) Value() *String {
    if s.identity_sif_refid.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.identity_sif_refid.Value = ((*String)(v))
      }
      }
      return s.identity_sif_refid.Value
    }
// Returns whether the element value for Value is nil in the container Identity_SIF_RefId.
  func (s *Identity_SIF_RefId) Value_IsNil() bool {
    return s.identity_sif_refid.Value == nil
    }

// Set the value of a property to nil
func (n *Invoice) Unset(key string) *Invoice {
        switch key {
  case "AccountCodeList":
   n.invoice.AccountCodeList = nil
  case "AccountingPeriod":
   n.invoice.AccountingPeriod = nil
  case "ApprovedBy":
   n.invoice.ApprovedBy = nil
  case "BilledAmount":
   n.invoice.BilledAmount = nil
  case "BillingDate":
   n.invoice.BillingDate = nil
  case "ChargedLocationInfoRefId":
   n.invoice.ChargedLocationInfoRefId = nil
  case "CreatedBy":
   n.invoice.CreatedBy = nil
  case "DueDate":
   n.invoice.DueDate = nil
  case "FinancialAccountRefIdList":
   n.invoice.FinancialAccountRefIdList = nil
  case "FormNumber":
   n.invoice.FormNumber = nil
  case "InvoicedEntity":
   n.invoice.InvoicedEntity = nil
  case "ItemDetail":
   n.invoice.ItemDetail = nil
  case "Ledger":
   n.invoice.Ledger = nil
  case "LocalCodeList":
   n.invoice.LocalCodeList = nil
  case "LocalId":
   n.invoice.LocalId = nil
  case "NetAmount":
   n.invoice.NetAmount = nil
  case "PurchasingItems":
   n.invoice.PurchasingItems = nil
  case "RefId":
   n.invoice.RefId = nil
  case "RelatedPurchaseOrderRefId":
   n.invoice.RelatedPurchaseOrderRefId = nil
  case "SIF_ExtendedElements":
   n.invoice.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.invoice.SIF_Metadata = nil
  case "TaxAmount":
   n.invoice.TaxAmount = nil
  case "TaxRate":
   n.invoice.TaxRate = nil
  case "TaxType":
   n.invoice.TaxType = nil
  case "TransactionDescription":
   n.invoice.TransactionDescription = nil
  case "Voluntary":
   n.invoice.Voluntary = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Invoice")
        }
        return n
}

// Set a sequence of properties
func (n *Invoice) SetProperties(props ...Prop) *Invoice {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *Invoice) SetProperty(key string, value interface{}) *Invoice {
        if n == nil {
                n, _ = InvoicePointer(Invoice{})
        }
        switch key {
    case "AccountCodeList":
    if v, ok:= AccountCodeListTypePointer(value); ok {
      n.invoice.AccountCodeList = v
      }
    case "AccountingPeriod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.AccountingPeriod = ((*LocalIdType)(v))
      }
    case "ApprovedBy":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.ApprovedBy = ((*String)(v))
      }
    case "BilledAmount":
    if v, ok:= DebitOrCreditAmountTypePointer(value); ok {
      n.invoice.BilledAmount = v
      }
    case "BillingDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.BillingDate = ((*String)(v))
      }
    case "ChargedLocationInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.ChargedLocationInfoRefId = ((*String)(v))
      }
    case "CreatedBy":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.CreatedBy = ((*String)(v))
      }
    case "DueDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.DueDate = ((*String)(v))
      }
    case "FinancialAccountRefIdList":
    if v, ok:= FinancialAccountRefIdListTypePointer(value); ok {
      n.invoice.FinancialAccountRefIdList = v
      }
    case "FormNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.FormNumber = ((*LocalIdType)(v))
      }
    case "InvoicedEntity":
    if v, ok:= Invoice_InvoicedEntityPointer(value); ok {
      n.invoice.InvoicedEntity = v
      }
    case "ItemDetail":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.ItemDetail = ((*String)(v))
      }
    case "Ledger":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.Ledger = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.invoice.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.LocalId = ((*LocalIdType)(v))
      }
    case "NetAmount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.invoice.NetAmount = v
      }
    case "PurchasingItems":
    if v, ok:= PurchasingItemsTypePointer(value); ok {
      n.invoice.PurchasingItems = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.RefId = ((*RefIdType)(v))
      }
    case "RelatedPurchaseOrderRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.RelatedPurchaseOrderRefId = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.invoice.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.invoice.SIF_Metadata = v
      }
    case "TaxAmount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.invoice.TaxAmount = v
      }
    case "TaxRate":
    
    if v, ok:= FloatPointer(value); ok {
      n.invoice.TaxRate = ((*Float)(v))
      }
    case "TaxType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.TaxType = ((*String)(v))
      }
    case "TransactionDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice.TransactionDescription = ((*String)(v))
      }
    case "Voluntary":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.invoice.Voluntary = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Invoice")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) AccountCodeList() *AccountCodeListType {
    if s.invoice.AccountCodeList == nil {
     if v, ok:= AccountCodeListTypePointer(AccountCodeListType{}); ok {
      s.invoice.AccountCodeList = v
      }
      }
      return s.invoice.AccountCodeList
    }
// Returns whether the element value for AccountCodeList is nil in the container Invoice.
  func (s *Invoice) AccountCodeList_IsNil() bool {
    return s.invoice.AccountCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) AccountingPeriod() *LocalIdType {
    if s.invoice.AccountingPeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.AccountingPeriod = ((*LocalIdType)(v))
      }
      }
      return s.invoice.AccountingPeriod
    }
// Returns whether the element value for AccountingPeriod is nil in the container Invoice.
  func (s *Invoice) AccountingPeriod_IsNil() bool {
    return s.invoice.AccountingPeriod == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) ApprovedBy() *String {
    if s.invoice.ApprovedBy == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.ApprovedBy = ((*String)(v))
      }
      }
      return s.invoice.ApprovedBy
    }
// Returns whether the element value for ApprovedBy is nil in the container Invoice.
  func (s *Invoice) ApprovedBy_IsNil() bool {
    return s.invoice.ApprovedBy == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) BilledAmount() *DebitOrCreditAmountType {
    if s.invoice.BilledAmount == nil {
     if v, ok:= DebitOrCreditAmountTypePointer(DebitOrCreditAmountType{}); ok {
      s.invoice.BilledAmount = v
      }
      }
      return s.invoice.BilledAmount
    }
// Returns whether the element value for BilledAmount is nil in the container Invoice.
  func (s *Invoice) BilledAmount_IsNil() bool {
    return s.invoice.BilledAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) BillingDate() *String {
    if s.invoice.BillingDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.BillingDate = ((*String)(v))
      }
      }
      return s.invoice.BillingDate
    }
// Returns whether the element value for BillingDate is nil in the container Invoice.
  func (s *Invoice) BillingDate_IsNil() bool {
    return s.invoice.BillingDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) ChargedLocationInfoRefId() *String {
    if s.invoice.ChargedLocationInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.ChargedLocationInfoRefId = ((*String)(v))
      }
      }
      return s.invoice.ChargedLocationInfoRefId
    }
// Returns whether the element value for ChargedLocationInfoRefId is nil in the container Invoice.
  func (s *Invoice) ChargedLocationInfoRefId_IsNil() bool {
    return s.invoice.ChargedLocationInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) CreatedBy() *String {
    if s.invoice.CreatedBy == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.CreatedBy = ((*String)(v))
      }
      }
      return s.invoice.CreatedBy
    }
// Returns whether the element value for CreatedBy is nil in the container Invoice.
  func (s *Invoice) CreatedBy_IsNil() bool {
    return s.invoice.CreatedBy == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) DueDate() *String {
    if s.invoice.DueDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.DueDate = ((*String)(v))
      }
      }
      return s.invoice.DueDate
    }
// Returns whether the element value for DueDate is nil in the container Invoice.
  func (s *Invoice) DueDate_IsNil() bool {
    return s.invoice.DueDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) FinancialAccountRefIdList() *FinancialAccountRefIdListType {
    if s.invoice.FinancialAccountRefIdList == nil {
     if v, ok:= FinancialAccountRefIdListTypePointer(FinancialAccountRefIdListType{}); ok {
      s.invoice.FinancialAccountRefIdList = v
      }
      }
      return s.invoice.FinancialAccountRefIdList
    }
// Returns whether the element value for FinancialAccountRefIdList is nil in the container Invoice.
  func (s *Invoice) FinancialAccountRefIdList_IsNil() bool {
    return s.invoice.FinancialAccountRefIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) FormNumber() *LocalIdType {
    if s.invoice.FormNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.FormNumber = ((*LocalIdType)(v))
      }
      }
      return s.invoice.FormNumber
    }
// Returns whether the element value for FormNumber is nil in the container Invoice.
  func (s *Invoice) FormNumber_IsNil() bool {
    return s.invoice.FormNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) InvoicedEntity() *Invoice_InvoicedEntity {
    if s.invoice.InvoicedEntity == nil {
     if v, ok:= Invoice_InvoicedEntityPointer(Invoice_InvoicedEntity{}); ok {
      s.invoice.InvoicedEntity = v
      }
      }
      return s.invoice.InvoicedEntity
    }
// Returns whether the element value for InvoicedEntity is nil in the container Invoice.
  func (s *Invoice) InvoicedEntity_IsNil() bool {
    return s.invoice.InvoicedEntity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) ItemDetail() *String {
    if s.invoice.ItemDetail == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.ItemDetail = ((*String)(v))
      }
      }
      return s.invoice.ItemDetail
    }
// Returns whether the element value for ItemDetail is nil in the container Invoice.
  func (s *Invoice) ItemDetail_IsNil() bool {
    return s.invoice.ItemDetail == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) Ledger() *String {
    if s.invoice.Ledger == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.Ledger = ((*String)(v))
      }
      }
      return s.invoice.Ledger
    }
// Returns whether the element value for Ledger is nil in the container Invoice.
  func (s *Invoice) Ledger_IsNil() bool {
    return s.invoice.Ledger == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) LocalCodeList() *LocalCodeListType {
    if s.invoice.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.invoice.LocalCodeList = v
      }
      }
      return s.invoice.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container Invoice.
  func (s *Invoice) LocalCodeList_IsNil() bool {
    return s.invoice.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) LocalId() *LocalIdType {
    if s.invoice.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.invoice.LocalId
    }
// Returns whether the element value for LocalId is nil in the container Invoice.
  func (s *Invoice) LocalId_IsNil() bool {
    return s.invoice.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) NetAmount() *MonetaryAmountType {
    if s.invoice.NetAmount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.invoice.NetAmount = v
      }
      }
      return s.invoice.NetAmount
    }
// Returns whether the element value for NetAmount is nil in the container Invoice.
  func (s *Invoice) NetAmount_IsNil() bool {
    return s.invoice.NetAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) PurchasingItems() *PurchasingItemsType {
    if s.invoice.PurchasingItems == nil {
     if v, ok:= PurchasingItemsTypePointer(PurchasingItemsType{}); ok {
      s.invoice.PurchasingItems = v
      }
      }
      return s.invoice.PurchasingItems
    }
// Returns whether the element value for PurchasingItems is nil in the container Invoice.
  func (s *Invoice) PurchasingItems_IsNil() bool {
    return s.invoice.PurchasingItems == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) RefId() *RefIdType {
    if s.invoice.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.RefId = ((*RefIdType)(v))
      }
      }
      return s.invoice.RefId
    }
// Returns whether the element value for RefId is nil in the container Invoice.
  func (s *Invoice) RefId_IsNil() bool {
    return s.invoice.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) RelatedPurchaseOrderRefId() *String {
    if s.invoice.RelatedPurchaseOrderRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.RelatedPurchaseOrderRefId = ((*String)(v))
      }
      }
      return s.invoice.RelatedPurchaseOrderRefId
    }
// Returns whether the element value for RelatedPurchaseOrderRefId is nil in the container Invoice.
  func (s *Invoice) RelatedPurchaseOrderRefId_IsNil() bool {
    return s.invoice.RelatedPurchaseOrderRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.invoice.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.invoice.SIF_ExtendedElements = v
      }
      }
      return s.invoice.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container Invoice.
  func (s *Invoice) SIF_ExtendedElements_IsNil() bool {
    return s.invoice.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) SIF_Metadata() *SIF_MetadataType {
    if s.invoice.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.invoice.SIF_Metadata = v
      }
      }
      return s.invoice.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container Invoice.
  func (s *Invoice) SIF_Metadata_IsNil() bool {
    return s.invoice.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) TaxAmount() *MonetaryAmountType {
    if s.invoice.TaxAmount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.invoice.TaxAmount = v
      }
      }
      return s.invoice.TaxAmount
    }
// Returns whether the element value for TaxAmount is nil in the container Invoice.
  func (s *Invoice) TaxAmount_IsNil() bool {
    return s.invoice.TaxAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) TaxRate() *Float {
    if s.invoice.TaxRate == nil {
    if v, ok:= FloatPointer(0); ok {
      s.invoice.TaxRate = ((*Float)(v))
      }
      }
      return s.invoice.TaxRate
    }
// Returns whether the element value for TaxRate is nil in the container Invoice.
  func (s *Invoice) TaxRate_IsNil() bool {
    return s.invoice.TaxRate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) TaxType() *String {
    if s.invoice.TaxType == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.TaxType = ((*String)(v))
      }
      }
      return s.invoice.TaxType
    }
// Returns whether the element value for TaxType is nil in the container Invoice.
  func (s *Invoice) TaxType_IsNil() bool {
    return s.invoice.TaxType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) TransactionDescription() *String {
    if s.invoice.TransactionDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.TransactionDescription = ((*String)(v))
      }
      }
      return s.invoice.TransactionDescription
    }
// Returns whether the element value for TransactionDescription is nil in the container Invoice.
  func (s *Invoice) TransactionDescription_IsNil() bool {
    return s.invoice.TransactionDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice) Voluntary() *AUCodeSetsYesOrNoCategoryType {
    if s.invoice.Voluntary == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice.Voluntary = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.invoice.Voluntary
    }
// Returns whether the element value for Voluntary is nil in the container Invoice.
  func (s *Invoice) Voluntary_IsNil() bool {
    return s.invoice.Voluntary == nil
    }

// Set the value of a property to nil
func (n *Invoice_InvoicedEntity) Unset(key string) *Invoice_InvoicedEntity {
        switch key {
  case "SIF_RefObject":
   n.invoice_invoicedentity.SIF_RefObject = nil
  case "Value":
   n.invoice_invoicedentity.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Invoice_InvoicedEntity")
        }
        return n
}

// Set a sequence of properties
func (n *Invoice_InvoicedEntity) SetProperties(props ...Prop) *Invoice_InvoicedEntity {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *Invoice_InvoicedEntity) SetProperty(key string, value interface{}) *Invoice_InvoicedEntity {
        if n == nil {
                n, _ = Invoice_InvoicedEntityPointer(Invoice_InvoicedEntity{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice_invoicedentity.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.invoice_invoicedentity.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Invoice_InvoicedEntity")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice_InvoicedEntity) SIF_RefObject() *String {
    if s.invoice_invoicedentity.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice_invoicedentity.SIF_RefObject = ((*String)(v))
      }
      }
      return s.invoice_invoicedentity.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container Invoice_InvoicedEntity.
  func (s *Invoice_InvoicedEntity) SIF_RefObject_IsNil() bool {
    return s.invoice_invoicedentity.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Invoice_InvoicedEntity) Value() *String {
    if s.invoice_invoicedentity.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.invoice_invoicedentity.Value = ((*String)(v))
      }
      }
      return s.invoice_invoicedentity.Value
    }
// Returns whether the element value for Value is nil in the container Invoice_InvoicedEntity.
  func (s *Invoice_InvoicedEntity) Value_IsNil() bool {
    return s.invoice_invoicedentity.Value == nil
    }

// Set the value of a property to nil
func (n *Journal) Unset(key string) *Journal {
        switch key {
  case "Amount":
   n.journal.Amount = nil
  case "ApprovedBy":
   n.journal.ApprovedBy = nil
  case "ApprovedDate":
   n.journal.ApprovedDate = nil
  case "CreatedBy":
   n.journal.CreatedBy = nil
  case "CreatedDate":
   n.journal.CreatedDate = nil
  case "CreditAccountCode":
   n.journal.CreditAccountCode = nil
  case "CreditFinancialAccountRefId":
   n.journal.CreditFinancialAccountRefId = nil
  case "DebitAccountCode":
   n.journal.DebitAccountCode = nil
  case "DebitFinancialAccountRefId":
   n.journal.DebitFinancialAccountRefId = nil
  case "GSTCodeOriginal":
   n.journal.GSTCodeOriginal = nil
  case "GSTCodeReplacement":
   n.journal.GSTCodeReplacement = nil
  case "JournalAdjustmentList":
   n.journal.JournalAdjustmentList = nil
  case "LocalCodeList":
   n.journal.LocalCodeList = nil
  case "LocalId":
   n.journal.LocalId = nil
  case "Note":
   n.journal.Note = nil
  case "OriginatingTransactionRefId":
   n.journal.OriginatingTransactionRefId = nil
  case "RefId":
   n.journal.RefId = nil
  case "SIF_ExtendedElements":
   n.journal.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.journal.SIF_Metadata = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Journal")
        }
        return n
}

// Set a sequence of properties
func (n *Journal) SetProperties(props ...Prop) *Journal {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *Journal) SetProperty(key string, value interface{}) *Journal {
        if n == nil {
                n, _ = JournalPointer(Journal{})
        }
        switch key {
    case "Amount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.journal.Amount = v
      }
    case "ApprovedBy":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.ApprovedBy = ((*String)(v))
      }
    case "ApprovedDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.ApprovedDate = ((*String)(v))
      }
    case "CreatedBy":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.CreatedBy = ((*String)(v))
      }
    case "CreatedDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.CreatedDate = ((*String)(v))
      }
    case "CreditAccountCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.CreditAccountCode = ((*String)(v))
      }
    case "CreditFinancialAccountRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.CreditFinancialAccountRefId = ((*String)(v))
      }
    case "DebitAccountCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.DebitAccountCode = ((*String)(v))
      }
    case "DebitFinancialAccountRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.DebitFinancialAccountRefId = ((*String)(v))
      }
    case "GSTCodeOriginal":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.GSTCodeOriginal = ((*String)(v))
      }
    case "GSTCodeReplacement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.GSTCodeReplacement = ((*String)(v))
      }
    case "JournalAdjustmentList":
    if v, ok:= JournalAdjustmentListTypePointer(value); ok {
      n.journal.JournalAdjustmentList = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.journal.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.LocalId = ((*LocalIdType)(v))
      }
    case "Note":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.Note = ((*String)(v))
      }
    case "OriginatingTransactionRefId":
    if v, ok:= Journal_OriginatingTransactionRefIdPointer(value); ok {
      n.journal.OriginatingTransactionRefId = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.journal.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.journal.SIF_Metadata = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Journal")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) Amount() *MonetaryAmountType {
    if s.journal.Amount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.journal.Amount = v
      }
      }
      return s.journal.Amount
    }
// Returns whether the element value for Amount is nil in the container Journal.
  func (s *Journal) Amount_IsNil() bool {
    return s.journal.Amount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) ApprovedBy() *String {
    if s.journal.ApprovedBy == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.ApprovedBy = ((*String)(v))
      }
      }
      return s.journal.ApprovedBy
    }
// Returns whether the element value for ApprovedBy is nil in the container Journal.
  func (s *Journal) ApprovedBy_IsNil() bool {
    return s.journal.ApprovedBy == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) ApprovedDate() *String {
    if s.journal.ApprovedDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.ApprovedDate = ((*String)(v))
      }
      }
      return s.journal.ApprovedDate
    }
// Returns whether the element value for ApprovedDate is nil in the container Journal.
  func (s *Journal) ApprovedDate_IsNil() bool {
    return s.journal.ApprovedDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) CreatedBy() *String {
    if s.journal.CreatedBy == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.CreatedBy = ((*String)(v))
      }
      }
      return s.journal.CreatedBy
    }
// Returns whether the element value for CreatedBy is nil in the container Journal.
  func (s *Journal) CreatedBy_IsNil() bool {
    return s.journal.CreatedBy == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) CreatedDate() *String {
    if s.journal.CreatedDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.CreatedDate = ((*String)(v))
      }
      }
      return s.journal.CreatedDate
    }
// Returns whether the element value for CreatedDate is nil in the container Journal.
  func (s *Journal) CreatedDate_IsNil() bool {
    return s.journal.CreatedDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) CreditAccountCode() *String {
    if s.journal.CreditAccountCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.CreditAccountCode = ((*String)(v))
      }
      }
      return s.journal.CreditAccountCode
    }
// Returns whether the element value for CreditAccountCode is nil in the container Journal.
  func (s *Journal) CreditAccountCode_IsNil() bool {
    return s.journal.CreditAccountCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) CreditFinancialAccountRefId() *String {
    if s.journal.CreditFinancialAccountRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.CreditFinancialAccountRefId = ((*String)(v))
      }
      }
      return s.journal.CreditFinancialAccountRefId
    }
// Returns whether the element value for CreditFinancialAccountRefId is nil in the container Journal.
  func (s *Journal) CreditFinancialAccountRefId_IsNil() bool {
    return s.journal.CreditFinancialAccountRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) DebitAccountCode() *String {
    if s.journal.DebitAccountCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.DebitAccountCode = ((*String)(v))
      }
      }
      return s.journal.DebitAccountCode
    }
// Returns whether the element value for DebitAccountCode is nil in the container Journal.
  func (s *Journal) DebitAccountCode_IsNil() bool {
    return s.journal.DebitAccountCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) DebitFinancialAccountRefId() *String {
    if s.journal.DebitFinancialAccountRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.DebitFinancialAccountRefId = ((*String)(v))
      }
      }
      return s.journal.DebitFinancialAccountRefId
    }
// Returns whether the element value for DebitFinancialAccountRefId is nil in the container Journal.
  func (s *Journal) DebitFinancialAccountRefId_IsNil() bool {
    return s.journal.DebitFinancialAccountRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) GSTCodeOriginal() *String {
    if s.journal.GSTCodeOriginal == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.GSTCodeOriginal = ((*String)(v))
      }
      }
      return s.journal.GSTCodeOriginal
    }
// Returns whether the element value for GSTCodeOriginal is nil in the container Journal.
  func (s *Journal) GSTCodeOriginal_IsNil() bool {
    return s.journal.GSTCodeOriginal == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) GSTCodeReplacement() *String {
    if s.journal.GSTCodeReplacement == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.GSTCodeReplacement = ((*String)(v))
      }
      }
      return s.journal.GSTCodeReplacement
    }
// Returns whether the element value for GSTCodeReplacement is nil in the container Journal.
  func (s *Journal) GSTCodeReplacement_IsNil() bool {
    return s.journal.GSTCodeReplacement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) JournalAdjustmentList() *JournalAdjustmentListType {
    if s.journal.JournalAdjustmentList == nil {
     if v, ok:= JournalAdjustmentListTypePointer(JournalAdjustmentListType{}); ok {
      s.journal.JournalAdjustmentList = v
      }
      }
      return s.journal.JournalAdjustmentList
    }
// Returns whether the element value for JournalAdjustmentList is nil in the container Journal.
  func (s *Journal) JournalAdjustmentList_IsNil() bool {
    return s.journal.JournalAdjustmentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) LocalCodeList() *LocalCodeListType {
    if s.journal.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.journal.LocalCodeList = v
      }
      }
      return s.journal.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container Journal.
  func (s *Journal) LocalCodeList_IsNil() bool {
    return s.journal.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) LocalId() *LocalIdType {
    if s.journal.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.journal.LocalId
    }
// Returns whether the element value for LocalId is nil in the container Journal.
  func (s *Journal) LocalId_IsNil() bool {
    return s.journal.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) Note() *String {
    if s.journal.Note == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.Note = ((*String)(v))
      }
      }
      return s.journal.Note
    }
// Returns whether the element value for Note is nil in the container Journal.
  func (s *Journal) Note_IsNil() bool {
    return s.journal.Note == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) OriginatingTransactionRefId() *Journal_OriginatingTransactionRefId {
    if s.journal.OriginatingTransactionRefId == nil {
     if v, ok:= Journal_OriginatingTransactionRefIdPointer(Journal_OriginatingTransactionRefId{}); ok {
      s.journal.OriginatingTransactionRefId = v
      }
      }
      return s.journal.OriginatingTransactionRefId
    }
// Returns whether the element value for OriginatingTransactionRefId is nil in the container Journal.
  func (s *Journal) OriginatingTransactionRefId_IsNil() bool {
    return s.journal.OriginatingTransactionRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) RefId() *RefIdType {
    if s.journal.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal.RefId = ((*RefIdType)(v))
      }
      }
      return s.journal.RefId
    }
// Returns whether the element value for RefId is nil in the container Journal.
  func (s *Journal) RefId_IsNil() bool {
    return s.journal.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.journal.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.journal.SIF_ExtendedElements = v
      }
      }
      return s.journal.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container Journal.
  func (s *Journal) SIF_ExtendedElements_IsNil() bool {
    return s.journal.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal) SIF_Metadata() *SIF_MetadataType {
    if s.journal.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.journal.SIF_Metadata = v
      }
      }
      return s.journal.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container Journal.
  func (s *Journal) SIF_Metadata_IsNil() bool {
    return s.journal.SIF_Metadata == nil
    }

// Set the value of a property to nil
func (n *JournalAdjustmentType) Unset(key string) *JournalAdjustmentType {
        switch key {
  case "CreditAccountCode":
   n.journaladjustmenttype.CreditAccountCode = nil
  case "CreditFinancialAccountRefId":
   n.journaladjustmenttype.CreditFinancialAccountRefId = nil
  case "DebitAccountCode":
   n.journaladjustmenttype.DebitAccountCode = nil
  case "DebitFinancialAccountRefId":
   n.journaladjustmenttype.DebitFinancialAccountRefId = nil
  case "GSTCodeOriginal":
   n.journaladjustmenttype.GSTCodeOriginal = nil
  case "GSTCodeReplacement":
   n.journaladjustmenttype.GSTCodeReplacement = nil
  case "LineAdjustmentAmount":
   n.journaladjustmenttype.LineAdjustmentAmount = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "JournalAdjustmentType")
        }
        return n
}

// Set a sequence of properties
func (n *JournalAdjustmentType) SetProperties(props ...Prop) *JournalAdjustmentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *JournalAdjustmentType) SetProperty(key string, value interface{}) *JournalAdjustmentType {
        if n == nil {
                n, _ = JournalAdjustmentTypePointer(JournalAdjustmentType{})
        }
        switch key {
    case "CreditAccountCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journaladjustmenttype.CreditAccountCode = ((*String)(v))
      }
    case "CreditFinancialAccountRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journaladjustmenttype.CreditFinancialAccountRefId = ((*String)(v))
      }
    case "DebitAccountCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journaladjustmenttype.DebitAccountCode = ((*String)(v))
      }
    case "DebitFinancialAccountRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journaladjustmenttype.DebitFinancialAccountRefId = ((*String)(v))
      }
    case "GSTCodeOriginal":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journaladjustmenttype.GSTCodeOriginal = ((*String)(v))
      }
    case "GSTCodeReplacement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journaladjustmenttype.GSTCodeReplacement = ((*String)(v))
      }
    case "LineAdjustmentAmount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.journaladjustmenttype.LineAdjustmentAmount = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "JournalAdjustmentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *JournalAdjustmentType) CreditAccountCode() *String {
    if s.journaladjustmenttype.CreditAccountCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.journaladjustmenttype.CreditAccountCode = ((*String)(v))
      }
      }
      return s.journaladjustmenttype.CreditAccountCode
    }
// Returns whether the element value for CreditAccountCode is nil in the container JournalAdjustmentType.
  func (s *JournalAdjustmentType) CreditAccountCode_IsNil() bool {
    return s.journaladjustmenttype.CreditAccountCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *JournalAdjustmentType) CreditFinancialAccountRefId() *String {
    if s.journaladjustmenttype.CreditFinancialAccountRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.journaladjustmenttype.CreditFinancialAccountRefId = ((*String)(v))
      }
      }
      return s.journaladjustmenttype.CreditFinancialAccountRefId
    }
// Returns whether the element value for CreditFinancialAccountRefId is nil in the container JournalAdjustmentType.
  func (s *JournalAdjustmentType) CreditFinancialAccountRefId_IsNil() bool {
    return s.journaladjustmenttype.CreditFinancialAccountRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *JournalAdjustmentType) DebitAccountCode() *String {
    if s.journaladjustmenttype.DebitAccountCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.journaladjustmenttype.DebitAccountCode = ((*String)(v))
      }
      }
      return s.journaladjustmenttype.DebitAccountCode
    }
// Returns whether the element value for DebitAccountCode is nil in the container JournalAdjustmentType.
  func (s *JournalAdjustmentType) DebitAccountCode_IsNil() bool {
    return s.journaladjustmenttype.DebitAccountCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *JournalAdjustmentType) DebitFinancialAccountRefId() *String {
    if s.journaladjustmenttype.DebitFinancialAccountRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.journaladjustmenttype.DebitFinancialAccountRefId = ((*String)(v))
      }
      }
      return s.journaladjustmenttype.DebitFinancialAccountRefId
    }
// Returns whether the element value for DebitFinancialAccountRefId is nil in the container JournalAdjustmentType.
  func (s *JournalAdjustmentType) DebitFinancialAccountRefId_IsNil() bool {
    return s.journaladjustmenttype.DebitFinancialAccountRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *JournalAdjustmentType) GSTCodeOriginal() *String {
    if s.journaladjustmenttype.GSTCodeOriginal == nil {
    if v, ok:= StringPointer(""); ok {
      s.journaladjustmenttype.GSTCodeOriginal = ((*String)(v))
      }
      }
      return s.journaladjustmenttype.GSTCodeOriginal
    }
// Returns whether the element value for GSTCodeOriginal is nil in the container JournalAdjustmentType.
  func (s *JournalAdjustmentType) GSTCodeOriginal_IsNil() bool {
    return s.journaladjustmenttype.GSTCodeOriginal == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *JournalAdjustmentType) GSTCodeReplacement() *String {
    if s.journaladjustmenttype.GSTCodeReplacement == nil {
    if v, ok:= StringPointer(""); ok {
      s.journaladjustmenttype.GSTCodeReplacement = ((*String)(v))
      }
      }
      return s.journaladjustmenttype.GSTCodeReplacement
    }
// Returns whether the element value for GSTCodeReplacement is nil in the container JournalAdjustmentType.
  func (s *JournalAdjustmentType) GSTCodeReplacement_IsNil() bool {
    return s.journaladjustmenttype.GSTCodeReplacement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *JournalAdjustmentType) LineAdjustmentAmount() *MonetaryAmountType {
    if s.journaladjustmenttype.LineAdjustmentAmount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.journaladjustmenttype.LineAdjustmentAmount = v
      }
      }
      return s.journaladjustmenttype.LineAdjustmentAmount
    }
// Returns whether the element value for LineAdjustmentAmount is nil in the container JournalAdjustmentType.
  func (s *JournalAdjustmentType) LineAdjustmentAmount_IsNil() bool {
    return s.journaladjustmenttype.LineAdjustmentAmount == nil
    }

// Set the value of a property to nil
func (n *Journal_OriginatingTransactionRefId) Unset(key string) *Journal_OriginatingTransactionRefId {
        switch key {
  case "SIF_RefObject":
   n.journal_originatingtransactionrefid.SIF_RefObject = nil
  case "Value":
   n.journal_originatingtransactionrefid.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Journal_OriginatingTransactionRefId")
        }
        return n
}

// Set a sequence of properties
func (n *Journal_OriginatingTransactionRefId) SetProperties(props ...Prop) *Journal_OriginatingTransactionRefId {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *Journal_OriginatingTransactionRefId) SetProperty(key string, value interface{}) *Journal_OriginatingTransactionRefId {
        if n == nil {
                n, _ = Journal_OriginatingTransactionRefIdPointer(Journal_OriginatingTransactionRefId{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal_originatingtransactionrefid.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.journal_originatingtransactionrefid.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "Journal_OriginatingTransactionRefId")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal_OriginatingTransactionRefId) SIF_RefObject() *String {
    if s.journal_originatingtransactionrefid.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal_originatingtransactionrefid.SIF_RefObject = ((*String)(v))
      }
      }
      return s.journal_originatingtransactionrefid.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container Journal_OriginatingTransactionRefId.
  func (s *Journal_OriginatingTransactionRefId) SIF_RefObject_IsNil() bool {
    return s.journal_originatingtransactionrefid.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *Journal_OriginatingTransactionRefId) Value() *String {
    if s.journal_originatingtransactionrefid.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.journal_originatingtransactionrefid.Value = ((*String)(v))
      }
      }
      return s.journal_originatingtransactionrefid.Value
    }
// Returns whether the element value for Value is nil in the container Journal_OriginatingTransactionRefId.
  func (s *Journal_OriginatingTransactionRefId) Value_IsNil() bool {
    return s.journal_originatingtransactionrefid.Value == nil
    }

// Set the value of a property to nil
func (n *LEAContactType) Unset(key string) *LEAContactType {
        switch key {
  case "ContactInfo":
   n.leacontacttype.ContactInfo = nil
  case "PublishInDirectory":
   n.leacontacttype.PublishInDirectory = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LEAContactType")
        }
        return n
}

// Set a sequence of properties
func (n *LEAContactType) SetProperties(props ...Prop) *LEAContactType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LEAContactType) SetProperty(key string, value interface{}) *LEAContactType {
        if n == nil {
                n, _ = LEAContactTypePointer(LEAContactType{})
        }
        switch key {
    case "ContactInfo":
    if v, ok:= ContactInfoTypePointer(value); ok {
      n.leacontacttype.ContactInfo = v
      }
    case "PublishInDirectory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.leacontacttype.PublishInDirectory = ((*PublishInDirectoryType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LEAContactType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAContactType) ContactInfo() *ContactInfoType {
    if s.leacontacttype.ContactInfo == nil {
     if v, ok:= ContactInfoTypePointer(ContactInfoType{}); ok {
      s.leacontacttype.ContactInfo = v
      }
      }
      return s.leacontacttype.ContactInfo
    }
// Returns whether the element value for ContactInfo is nil in the container LEAContactType.
  func (s *LEAContactType) ContactInfo_IsNil() bool {
    return s.leacontacttype.ContactInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAContactType) PublishInDirectory() *PublishInDirectoryType {
    if s.leacontacttype.PublishInDirectory == nil {
    if v, ok:= StringPointer(""); ok {
      s.leacontacttype.PublishInDirectory = ((*PublishInDirectoryType)(v))
      }
      }
      return s.leacontacttype.PublishInDirectory
    }
// Returns whether the element value for PublishInDirectory is nil in the container LEAContactType.
  func (s *LEAContactType) PublishInDirectory_IsNil() bool {
    return s.leacontacttype.PublishInDirectory == nil
    }

// Set the value of a property to nil
func (n *LEAInfo) Unset(key string) *LEAInfo {
        switch key {
  case "AddressList":
   n.leainfo.AddressList = nil
  case "CommonwealthId":
   n.leainfo.CommonwealthId = nil
  case "EducationAgencyType":
   n.leainfo.EducationAgencyType = nil
  case "JurisdictionLowerHouse":
   n.leainfo.JurisdictionLowerHouse = nil
  case "LEAContactList":
   n.leainfo.LEAContactList = nil
  case "LEAName":
   n.leainfo.LEAName = nil
  case "LEAURL":
   n.leainfo.LEAURL = nil
  case "LocalCodeList":
   n.leainfo.LocalCodeList = nil
  case "LocalId":
   n.leainfo.LocalId = nil
  case "OperationalStatus":
   n.leainfo.OperationalStatus = nil
  case "PhoneNumberList":
   n.leainfo.PhoneNumberList = nil
  case "RefId":
   n.leainfo.RefId = nil
  case "SIF_ExtendedElements":
   n.leainfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.leainfo.SIF_Metadata = nil
  case "SLA":
   n.leainfo.SLA = nil
  case "StateProvinceId":
   n.leainfo.StateProvinceId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LEAInfo")
        }
        return n
}

// Set a sequence of properties
func (n *LEAInfo) SetProperties(props ...Prop) *LEAInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LEAInfo) SetProperty(key string, value interface{}) *LEAInfo {
        if n == nil {
                n, _ = LEAInfoPointer(LEAInfo{})
        }
        switch key {
    case "AddressList":
    if v, ok:= AddressListTypePointer(value); ok {
      n.leainfo.AddressList = v
      }
    case "CommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.leainfo.CommonwealthId = ((*String)(v))
      }
    case "EducationAgencyType":
    if v, ok:= AgencyTypePointer(value); ok {
      n.leainfo.EducationAgencyType = v
      }
    case "JurisdictionLowerHouse":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.leainfo.JurisdictionLowerHouse = ((*String)(v))
      }
    case "LEAContactList":
    if v, ok:= LEAContactListTypePointer(value); ok {
      n.leainfo.LEAContactList = v
      }
    case "LEAName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.leainfo.LEAName = ((*String)(v))
      }
    case "LEAURL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.leainfo.LEAURL = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.leainfo.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.leainfo.LocalId = ((*LocalIdType)(v))
      }
    case "OperationalStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsOperationalStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsOperationalStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.leainfo.OperationalStatus = ((*OperationalStatusType)(v))
      }
    case "PhoneNumberList":
    if v, ok:= PhoneNumberListTypePointer(value); ok {
      n.leainfo.PhoneNumberList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.leainfo.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.leainfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.leainfo.SIF_Metadata = v
      }
    case "SLA":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.leainfo.SLA = ((*String)(v))
      }
    case "StateProvinceId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.leainfo.StateProvinceId = ((*StateProvinceIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LEAInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) AddressList() *AddressListType {
    if s.leainfo.AddressList == nil {
     if v, ok:= AddressListTypePointer(AddressListType{}); ok {
      s.leainfo.AddressList = v
      }
      }
      return s.leainfo.AddressList
    }
// Returns whether the element value for AddressList is nil in the container LEAInfo.
  func (s *LEAInfo) AddressList_IsNil() bool {
    return s.leainfo.AddressList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) CommonwealthId() *String {
    if s.leainfo.CommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.leainfo.CommonwealthId = ((*String)(v))
      }
      }
      return s.leainfo.CommonwealthId
    }
// Returns whether the element value for CommonwealthId is nil in the container LEAInfo.
  func (s *LEAInfo) CommonwealthId_IsNil() bool {
    return s.leainfo.CommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) EducationAgencyType() *AgencyType {
    if s.leainfo.EducationAgencyType == nil {
     if v, ok:= AgencyTypePointer(AgencyType{}); ok {
      s.leainfo.EducationAgencyType = v
      }
      }
      return s.leainfo.EducationAgencyType
    }
// Returns whether the element value for EducationAgencyType is nil in the container LEAInfo.
  func (s *LEAInfo) EducationAgencyType_IsNil() bool {
    return s.leainfo.EducationAgencyType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) JurisdictionLowerHouse() *String {
    if s.leainfo.JurisdictionLowerHouse == nil {
    if v, ok:= StringPointer(""); ok {
      s.leainfo.JurisdictionLowerHouse = ((*String)(v))
      }
      }
      return s.leainfo.JurisdictionLowerHouse
    }
// Returns whether the element value for JurisdictionLowerHouse is nil in the container LEAInfo.
  func (s *LEAInfo) JurisdictionLowerHouse_IsNil() bool {
    return s.leainfo.JurisdictionLowerHouse == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) LEAContactList() *LEAContactListType {
    if s.leainfo.LEAContactList == nil {
     if v, ok:= LEAContactListTypePointer(LEAContactListType{}); ok {
      s.leainfo.LEAContactList = v
      }
      }
      return s.leainfo.LEAContactList
    }
// Returns whether the element value for LEAContactList is nil in the container LEAInfo.
  func (s *LEAInfo) LEAContactList_IsNil() bool {
    return s.leainfo.LEAContactList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) LEAName() *String {
    if s.leainfo.LEAName == nil {
    if v, ok:= StringPointer(""); ok {
      s.leainfo.LEAName = ((*String)(v))
      }
      }
      return s.leainfo.LEAName
    }
// Returns whether the element value for LEAName is nil in the container LEAInfo.
  func (s *LEAInfo) LEAName_IsNil() bool {
    return s.leainfo.LEAName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) LEAURL() *String {
    if s.leainfo.LEAURL == nil {
    if v, ok:= StringPointer(""); ok {
      s.leainfo.LEAURL = ((*String)(v))
      }
      }
      return s.leainfo.LEAURL
    }
// Returns whether the element value for LEAURL is nil in the container LEAInfo.
  func (s *LEAInfo) LEAURL_IsNil() bool {
    return s.leainfo.LEAURL == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) LocalCodeList() *LocalCodeListType {
    if s.leainfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.leainfo.LocalCodeList = v
      }
      }
      return s.leainfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container LEAInfo.
  func (s *LEAInfo) LocalCodeList_IsNil() bool {
    return s.leainfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) LocalId() *LocalIdType {
    if s.leainfo.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.leainfo.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.leainfo.LocalId
    }
// Returns whether the element value for LocalId is nil in the container LEAInfo.
  func (s *LEAInfo) LocalId_IsNil() bool {
    return s.leainfo.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) OperationalStatus() *OperationalStatusType {
    if s.leainfo.OperationalStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.leainfo.OperationalStatus = ((*OperationalStatusType)(v))
      }
      }
      return s.leainfo.OperationalStatus
    }
// Returns whether the element value for OperationalStatus is nil in the container LEAInfo.
  func (s *LEAInfo) OperationalStatus_IsNil() bool {
    return s.leainfo.OperationalStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) PhoneNumberList() *PhoneNumberListType {
    if s.leainfo.PhoneNumberList == nil {
     if v, ok:= PhoneNumberListTypePointer(PhoneNumberListType{}); ok {
      s.leainfo.PhoneNumberList = v
      }
      }
      return s.leainfo.PhoneNumberList
    }
// Returns whether the element value for PhoneNumberList is nil in the container LEAInfo.
  func (s *LEAInfo) PhoneNumberList_IsNil() bool {
    return s.leainfo.PhoneNumberList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) RefId() *RefIdType {
    if s.leainfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.leainfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.leainfo.RefId
    }
// Returns whether the element value for RefId is nil in the container LEAInfo.
  func (s *LEAInfo) RefId_IsNil() bool {
    return s.leainfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.leainfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.leainfo.SIF_ExtendedElements = v
      }
      }
      return s.leainfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container LEAInfo.
  func (s *LEAInfo) SIF_ExtendedElements_IsNil() bool {
    return s.leainfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) SIF_Metadata() *SIF_MetadataType {
    if s.leainfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.leainfo.SIF_Metadata = v
      }
      }
      return s.leainfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container LEAInfo.
  func (s *LEAInfo) SIF_Metadata_IsNil() bool {
    return s.leainfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) SLA() *String {
    if s.leainfo.SLA == nil {
    if v, ok:= StringPointer(""); ok {
      s.leainfo.SLA = ((*String)(v))
      }
      }
      return s.leainfo.SLA
    }
// Returns whether the element value for SLA is nil in the container LEAInfo.
  func (s *LEAInfo) SLA_IsNil() bool {
    return s.leainfo.SLA == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LEAInfo) StateProvinceId() *StateProvinceIdType {
    if s.leainfo.StateProvinceId == nil {
    if v, ok:= StringPointer(""); ok {
      s.leainfo.StateProvinceId = ((*StateProvinceIdType)(v))
      }
      }
      return s.leainfo.StateProvinceId
    }
// Returns whether the element value for StateProvinceId is nil in the container LEAInfo.
  func (s *LEAInfo) StateProvinceId_IsNil() bool {
    return s.leainfo.StateProvinceId == nil
    }

// Set the value of a property to nil
func (n *LanguageBaseType) Unset(key string) *LanguageBaseType {
        switch key {
  case "Code":
   n.languagebasetype.Code = nil
  case "Dialect":
   n.languagebasetype.Dialect = nil
  case "LanguageType":
   n.languagebasetype.LanguageType = nil
  case "OtherCodeList":
   n.languagebasetype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LanguageBaseType")
        }
        return n
}

// Set a sequence of properties
func (n *LanguageBaseType) SetProperties(props ...Prop) *LanguageBaseType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LanguageBaseType) SetProperty(key string, value interface{}) *LanguageBaseType {
        if n == nil {
                n, _ = LanguageBaseTypePointer(LanguageBaseType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.languagebasetype.Code = ((*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType)(v))
      }
    case "Dialect":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.languagebasetype.Dialect = ((*String)(v))
      }
    case "LanguageType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsLanguageTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsLanguageTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.languagebasetype.LanguageType = ((*AUCodeSetsLanguageTypeType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.languagebasetype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LanguageBaseType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LanguageBaseType) Code() *AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType {
    if s.languagebasetype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.languagebasetype.Code = ((*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType)(v))
      }
      }
      return s.languagebasetype.Code
    }
// Returns whether the element value for Code is nil in the container LanguageBaseType.
  func (s *LanguageBaseType) Code_IsNil() bool {
    return s.languagebasetype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LanguageBaseType) Dialect() *String {
    if s.languagebasetype.Dialect == nil {
    if v, ok:= StringPointer(""); ok {
      s.languagebasetype.Dialect = ((*String)(v))
      }
      }
      return s.languagebasetype.Dialect
    }
// Returns whether the element value for Dialect is nil in the container LanguageBaseType.
  func (s *LanguageBaseType) Dialect_IsNil() bool {
    return s.languagebasetype.Dialect == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LanguageBaseType) LanguageType() *AUCodeSetsLanguageTypeType {
    if s.languagebasetype.LanguageType == nil {
    if v, ok:= StringPointer(""); ok {
      s.languagebasetype.LanguageType = ((*AUCodeSetsLanguageTypeType)(v))
      }
      }
      return s.languagebasetype.LanguageType
    }
// Returns whether the element value for LanguageType is nil in the container LanguageBaseType.
  func (s *LanguageBaseType) LanguageType_IsNil() bool {
    return s.languagebasetype.LanguageType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LanguageBaseType) OtherCodeList() *OtherCodeListType {
    if s.languagebasetype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.languagebasetype.OtherCodeList = v
      }
      }
      return s.languagebasetype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container LanguageBaseType.
  func (s *LanguageBaseType) OtherCodeList_IsNil() bool {
    return s.languagebasetype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *LanguageOfInstructionType) Unset(key string) *LanguageOfInstructionType {
        switch key {
  case "Code":
   n.languageofinstructiontype.Code = nil
  case "OtherCodeList":
   n.languageofinstructiontype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LanguageOfInstructionType")
        }
        return n
}

// Set a sequence of properties
func (n *LanguageOfInstructionType) SetProperties(props ...Prop) *LanguageOfInstructionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LanguageOfInstructionType) SetProperty(key string, value interface{}) *LanguageOfInstructionType {
        if n == nil {
                n, _ = LanguageOfInstructionTypePointer(LanguageOfInstructionType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.languageofinstructiontype.Code = ((*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.languageofinstructiontype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LanguageOfInstructionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LanguageOfInstructionType) Code() *AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType {
    if s.languageofinstructiontype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.languageofinstructiontype.Code = ((*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType)(v))
      }
      }
      return s.languageofinstructiontype.Code
    }
// Returns whether the element value for Code is nil in the container LanguageOfInstructionType.
  func (s *LanguageOfInstructionType) Code_IsNil() bool {
    return s.languageofinstructiontype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LanguageOfInstructionType) OtherCodeList() *OtherCodeListType {
    if s.languageofinstructiontype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.languageofinstructiontype.OtherCodeList = v
      }
      }
      return s.languageofinstructiontype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container LanguageOfInstructionType.
  func (s *LanguageOfInstructionType) OtherCodeList_IsNil() bool {
    return s.languageofinstructiontype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *LearningResource) Unset(key string) *LearningResource {
        switch key {
  case "AgreementDate":
   n.learningresource.AgreementDate = nil
  case "Approvals":
   n.learningresource.Approvals = nil
  case "Author":
   n.learningresource.Author = nil
  case "Components":
   n.learningresource.Components = nil
  case "Contacts":
   n.learningresource.Contacts = nil
  case "Description":
   n.learningresource.Description = nil
  case "Evaluations":
   n.learningresource.Evaluations = nil
  case "LearningResourcePackageRefId":
   n.learningresource.LearningResourcePackageRefId = nil
  case "LearningStandards":
   n.learningresource.LearningStandards = nil
  case "LocalCodeList":
   n.learningresource.LocalCodeList = nil
  case "Location":
   n.learningresource.Location = nil
  case "MediaTypes":
   n.learningresource.MediaTypes = nil
  case "Name":
   n.learningresource.Name = nil
  case "RefId":
   n.learningresource.RefId = nil
  case "SIF_ExtendedElements":
   n.learningresource.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.learningresource.SIF_Metadata = nil
  case "Status":
   n.learningresource.Status = nil
  case "SubjectAreas":
   n.learningresource.SubjectAreas = nil
  case "UseAgreement":
   n.learningresource.UseAgreement = nil
  case "YearLevels":
   n.learningresource.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningResource")
        }
        return n
}

// Set a sequence of properties
func (n *LearningResource) SetProperties(props ...Prop) *LearningResource {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LearningResource) SetProperty(key string, value interface{}) *LearningResource {
        if n == nil {
                n, _ = LearningResourcePointer(LearningResource{})
        }
        switch key {
    case "AgreementDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresource.AgreementDate = ((*String)(v))
      }
    case "Approvals":
    if v, ok:= ApprovalsTypePointer(value); ok {
      n.learningresource.Approvals = v
      }
    case "Author":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresource.Author = ((*String)(v))
      }
    case "Components":
    if v, ok:= ComponentsTypePointer(value); ok {
      n.learningresource.Components = v
      }
    case "Contacts":
    if v, ok:= ContactsTypePointer(value); ok {
      n.learningresource.Contacts = v
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresource.Description = ((*String)(v))
      }
    case "Evaluations":
    if v, ok:= EvaluationsTypePointer(value); ok {
      n.learningresource.Evaluations = v
      }
    case "LearningResourcePackageRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresource.LearningResourcePackageRefId = ((*String)(v))
      }
    case "LearningStandards":
    if v, ok:= LearningStandardsTypePointer(value); ok {
      n.learningresource.LearningStandards = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.learningresource.LocalCodeList = v
      }
    case "Location":
    if v, ok:= LearningResourceLocationTypePointer(value); ok {
      n.learningresource.Location = v
      }
    case "MediaTypes":
    if v, ok:= MediaTypesTypePointer(value); ok {
      n.learningresource.MediaTypes = v
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresource.Name = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresource.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.learningresource.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.learningresource.SIF_Metadata = v
      }
    case "Status":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresource.Status = ((*String)(v))
      }
    case "SubjectAreas":
    if v, ok:= ACStrandAreaListTypePointer(value); ok {
      n.learningresource.SubjectAreas = v
      }
    case "UseAgreement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresource.UseAgreement = ((*String)(v))
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.learningresource.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningResource")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) AgreementDate() *String {
    if s.learningresource.AgreementDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresource.AgreementDate = ((*String)(v))
      }
      }
      return s.learningresource.AgreementDate
    }
// Returns whether the element value for AgreementDate is nil in the container LearningResource.
  func (s *LearningResource) AgreementDate_IsNil() bool {
    return s.learningresource.AgreementDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) Approvals() *ApprovalsType {
    if s.learningresource.Approvals == nil {
     if v, ok:= ApprovalsTypePointer(ApprovalsType{}); ok {
      s.learningresource.Approvals = v
      }
      }
      return s.learningresource.Approvals
    }
// Returns whether the element value for Approvals is nil in the container LearningResource.
  func (s *LearningResource) Approvals_IsNil() bool {
    return s.learningresource.Approvals == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) Author() *String {
    if s.learningresource.Author == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresource.Author = ((*String)(v))
      }
      }
      return s.learningresource.Author
    }
// Returns whether the element value for Author is nil in the container LearningResource.
  func (s *LearningResource) Author_IsNil() bool {
    return s.learningresource.Author == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) Components() *ComponentsType {
    if s.learningresource.Components == nil {
     if v, ok:= ComponentsTypePointer(ComponentsType{}); ok {
      s.learningresource.Components = v
      }
      }
      return s.learningresource.Components
    }
// Returns whether the element value for Components is nil in the container LearningResource.
  func (s *LearningResource) Components_IsNil() bool {
    return s.learningresource.Components == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) Contacts() *ContactsType {
    if s.learningresource.Contacts == nil {
     if v, ok:= ContactsTypePointer(ContactsType{}); ok {
      s.learningresource.Contacts = v
      }
      }
      return s.learningresource.Contacts
    }
// Returns whether the element value for Contacts is nil in the container LearningResource.
  func (s *LearningResource) Contacts_IsNil() bool {
    return s.learningresource.Contacts == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) Description() *String {
    if s.learningresource.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresource.Description = ((*String)(v))
      }
      }
      return s.learningresource.Description
    }
// Returns whether the element value for Description is nil in the container LearningResource.
  func (s *LearningResource) Description_IsNil() bool {
    return s.learningresource.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) Evaluations() *EvaluationsType {
    if s.learningresource.Evaluations == nil {
     if v, ok:= EvaluationsTypePointer(EvaluationsType{}); ok {
      s.learningresource.Evaluations = v
      }
      }
      return s.learningresource.Evaluations
    }
// Returns whether the element value for Evaluations is nil in the container LearningResource.
  func (s *LearningResource) Evaluations_IsNil() bool {
    return s.learningresource.Evaluations == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) LearningResourcePackageRefId() *String {
    if s.learningresource.LearningResourcePackageRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresource.LearningResourcePackageRefId = ((*String)(v))
      }
      }
      return s.learningresource.LearningResourcePackageRefId
    }
// Returns whether the element value for LearningResourcePackageRefId is nil in the container LearningResource.
  func (s *LearningResource) LearningResourcePackageRefId_IsNil() bool {
    return s.learningresource.LearningResourcePackageRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) LearningStandards() *LearningStandardsType {
    if s.learningresource.LearningStandards == nil {
     if v, ok:= LearningStandardsTypePointer(LearningStandardsType{}); ok {
      s.learningresource.LearningStandards = v
      }
      }
      return s.learningresource.LearningStandards
    }
// Returns whether the element value for LearningStandards is nil in the container LearningResource.
  func (s *LearningResource) LearningStandards_IsNil() bool {
    return s.learningresource.LearningStandards == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) LocalCodeList() *LocalCodeListType {
    if s.learningresource.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.learningresource.LocalCodeList = v
      }
      }
      return s.learningresource.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container LearningResource.
  func (s *LearningResource) LocalCodeList_IsNil() bool {
    return s.learningresource.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) Location() *LearningResourceLocationType {
    if s.learningresource.Location == nil {
     if v, ok:= LearningResourceLocationTypePointer(LearningResourceLocationType{}); ok {
      s.learningresource.Location = v
      }
      }
      return s.learningresource.Location
    }
// Returns whether the element value for Location is nil in the container LearningResource.
  func (s *LearningResource) Location_IsNil() bool {
    return s.learningresource.Location == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) MediaTypes() *MediaTypesType {
    if s.learningresource.MediaTypes == nil {
     if v, ok:= MediaTypesTypePointer(MediaTypesType{}); ok {
      s.learningresource.MediaTypes = v
      }
      }
      return s.learningresource.MediaTypes
    }
// Returns whether the element value for MediaTypes is nil in the container LearningResource.
  func (s *LearningResource) MediaTypes_IsNil() bool {
    return s.learningresource.MediaTypes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) Name() *String {
    if s.learningresource.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresource.Name = ((*String)(v))
      }
      }
      return s.learningresource.Name
    }
// Returns whether the element value for Name is nil in the container LearningResource.
  func (s *LearningResource) Name_IsNil() bool {
    return s.learningresource.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) RefId() *RefIdType {
    if s.learningresource.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresource.RefId = ((*RefIdType)(v))
      }
      }
      return s.learningresource.RefId
    }
// Returns whether the element value for RefId is nil in the container LearningResource.
  func (s *LearningResource) RefId_IsNil() bool {
    return s.learningresource.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.learningresource.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.learningresource.SIF_ExtendedElements = v
      }
      }
      return s.learningresource.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container LearningResource.
  func (s *LearningResource) SIF_ExtendedElements_IsNil() bool {
    return s.learningresource.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) SIF_Metadata() *SIF_MetadataType {
    if s.learningresource.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.learningresource.SIF_Metadata = v
      }
      }
      return s.learningresource.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container LearningResource.
  func (s *LearningResource) SIF_Metadata_IsNil() bool {
    return s.learningresource.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) Status() *String {
    if s.learningresource.Status == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresource.Status = ((*String)(v))
      }
      }
      return s.learningresource.Status
    }
// Returns whether the element value for Status is nil in the container LearningResource.
  func (s *LearningResource) Status_IsNil() bool {
    return s.learningresource.Status == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) SubjectAreas() *ACStrandAreaListType {
    if s.learningresource.SubjectAreas == nil {
     if v, ok:= ACStrandAreaListTypePointer(ACStrandAreaListType{}); ok {
      s.learningresource.SubjectAreas = v
      }
      }
      return s.learningresource.SubjectAreas
    }
// Returns whether the element value for SubjectAreas is nil in the container LearningResource.
  func (s *LearningResource) SubjectAreas_IsNil() bool {
    return s.learningresource.SubjectAreas == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) UseAgreement() *String {
    if s.learningresource.UseAgreement == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresource.UseAgreement = ((*String)(v))
      }
      }
      return s.learningresource.UseAgreement
    }
// Returns whether the element value for UseAgreement is nil in the container LearningResource.
  func (s *LearningResource) UseAgreement_IsNil() bool {
    return s.learningresource.UseAgreement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResource) YearLevels() *YearLevelsType {
    if s.learningresource.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.learningresource.YearLevels = v
      }
      }
      return s.learningresource.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container LearningResource.
  func (s *LearningResource) YearLevels_IsNil() bool {
    return s.learningresource.YearLevels == nil
    }

// Set the value of a property to nil
func (n *LearningResourceLocationType) Unset(key string) *LearningResourceLocationType {
        switch key {
  case "ReferenceType":
   n.learningresourcelocationtype.ReferenceType = nil
  case "Value":
   n.learningresourcelocationtype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningResourceLocationType")
        }
        return n
}

// Set a sequence of properties
func (n *LearningResourceLocationType) SetProperties(props ...Prop) *LearningResourceLocationType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LearningResourceLocationType) SetProperty(key string, value interface{}) *LearningResourceLocationType {
        if n == nil {
                n, _ = LearningResourceLocationTypePointer(LearningResourceLocationType{})
        }
        switch key {
    case "ReferenceType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresourcelocationtype.ReferenceType = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningresourcelocationtype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningResourceLocationType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResourceLocationType) ReferenceType() *String {
    if s.learningresourcelocationtype.ReferenceType == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresourcelocationtype.ReferenceType = ((*String)(v))
      }
      }
      return s.learningresourcelocationtype.ReferenceType
    }
// Returns whether the element value for ReferenceType is nil in the container LearningResourceLocationType.
  func (s *LearningResourceLocationType) ReferenceType_IsNil() bool {
    return s.learningresourcelocationtype.ReferenceType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningResourceLocationType) Value() *String {
    if s.learningresourcelocationtype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningresourcelocationtype.Value = ((*String)(v))
      }
      }
      return s.learningresourcelocationtype.Value
    }
// Returns whether the element value for Value is nil in the container LearningResourceLocationType.
  func (s *LearningResourceLocationType) Value_IsNil() bool {
    return s.learningresourcelocationtype.Value == nil
    }

// Set the value of a property to nil
func (n *LearningStandardDocument) Unset(key string) *LearningStandardDocument {
        switch key {
  case "Authors":
   n.learningstandarddocument.Authors = nil
  case "Copyright":
   n.learningstandarddocument.Copyright = nil
  case "Description":
   n.learningstandarddocument.Description = nil
  case "DocumentDate":
   n.learningstandarddocument.DocumentDate = nil
  case "DocumentStatus":
   n.learningstandarddocument.DocumentStatus = nil
  case "EndOfLifeDate":
   n.learningstandarddocument.EndOfLifeDate = nil
  case "LearningStandardItemRefId":
   n.learningstandarddocument.LearningStandardItemRefId = nil
  case "LocalAdoptionDate":
   n.learningstandarddocument.LocalAdoptionDate = nil
  case "LocalArchiveDate":
   n.learningstandarddocument.LocalArchiveDate = nil
  case "LocalCodeList":
   n.learningstandarddocument.LocalCodeList = nil
  case "OrganizationContactPoint":
   n.learningstandarddocument.OrganizationContactPoint = nil
  case "Organizations":
   n.learningstandarddocument.Organizations = nil
  case "RefId":
   n.learningstandarddocument.RefId = nil
  case "RelatedLearningStandards":
   n.learningstandarddocument.RelatedLearningStandards = nil
  case "RepositoryDate":
   n.learningstandarddocument.RepositoryDate = nil
  case "RichDescription":
   n.learningstandarddocument.RichDescription = nil
  case "SIF_ExtendedElements":
   n.learningstandarddocument.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.learningstandarddocument.SIF_Metadata = nil
  case "Source":
   n.learningstandarddocument.Source = nil
  case "SubjectAreas":
   n.learningstandarddocument.SubjectAreas = nil
  case "Title":
   n.learningstandarddocument.Title = nil
  case "YearLevels":
   n.learningstandarddocument.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningStandardDocument")
        }
        return n
}

// Set a sequence of properties
func (n *LearningStandardDocument) SetProperties(props ...Prop) *LearningStandardDocument {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LearningStandardDocument) SetProperty(key string, value interface{}) *LearningStandardDocument {
        if n == nil {
                n, _ = LearningStandardDocumentPointer(LearningStandardDocument{})
        }
        switch key {
    case "Authors":
    if v, ok:= AuthorsTypePointer(value); ok {
      n.learningstandarddocument.Authors = v
      }
    case "Copyright":
    if v, ok:= CopyRightContainerTypePointer(value); ok {
      n.learningstandarddocument.Copyright = v
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.Description = ((*String)(v))
      }
    case "DocumentDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.DocumentDate = ((*String)(v))
      }
    case "DocumentStatus":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.DocumentStatus = ((*String)(v))
      }
    case "EndOfLifeDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.EndOfLifeDate = ((*String)(v))
      }
    case "LearningStandardItemRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.LearningStandardItemRefId = ((*String)(v))
      }
    case "LocalAdoptionDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.LocalAdoptionDate = ((*String)(v))
      }
    case "LocalArchiveDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.LocalArchiveDate = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.learningstandarddocument.LocalCodeList = v
      }
    case "OrganizationContactPoint":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.OrganizationContactPoint = ((*String)(v))
      }
    case "Organizations":
    if v, ok:= OrganizationsTypePointer(value); ok {
      n.learningstandarddocument.Organizations = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.RefId = ((*RefIdType)(v))
      }
    case "RelatedLearningStandards":
    if v, ok:= LearningStandardsDocumentTypePointer(value); ok {
      n.learningstandarddocument.RelatedLearningStandards = v
      }
    case "RepositoryDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.RepositoryDate = ((*String)(v))
      }
    case "RichDescription":
    if v, ok:= AbstractContentElementTypePointer(value); ok {
      n.learningstandarddocument.RichDescription = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.learningstandarddocument.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.learningstandarddocument.SIF_Metadata = v
      }
    case "Source":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.Source = ((*String)(v))
      }
    case "SubjectAreas":
    if v, ok:= ACStrandAreaListTypePointer(value); ok {
      n.learningstandarddocument.SubjectAreas = v
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarddocument.Title = ((*String)(v))
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.learningstandarddocument.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningStandardDocument")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) Authors() *AuthorsType {
    if s.learningstandarddocument.Authors == nil {
     if v, ok:= AuthorsTypePointer(AuthorsType{}); ok {
      s.learningstandarddocument.Authors = v
      }
      }
      return s.learningstandarddocument.Authors
    }
// Returns whether the element value for Authors is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) Authors_IsNil() bool {
    return s.learningstandarddocument.Authors == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) Copyright() *CopyRightContainerType {
    if s.learningstandarddocument.Copyright == nil {
     if v, ok:= CopyRightContainerTypePointer(CopyRightContainerType{}); ok {
      s.learningstandarddocument.Copyright = v
      }
      }
      return s.learningstandarddocument.Copyright
    }
// Returns whether the element value for Copyright is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) Copyright_IsNil() bool {
    return s.learningstandarddocument.Copyright == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) Description() *String {
    if s.learningstandarddocument.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.Description = ((*String)(v))
      }
      }
      return s.learningstandarddocument.Description
    }
// Returns whether the element value for Description is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) Description_IsNil() bool {
    return s.learningstandarddocument.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) DocumentDate() *String {
    if s.learningstandarddocument.DocumentDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.DocumentDate = ((*String)(v))
      }
      }
      return s.learningstandarddocument.DocumentDate
    }
// Returns whether the element value for DocumentDate is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) DocumentDate_IsNil() bool {
    return s.learningstandarddocument.DocumentDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) DocumentStatus() *String {
    if s.learningstandarddocument.DocumentStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.DocumentStatus = ((*String)(v))
      }
      }
      return s.learningstandarddocument.DocumentStatus
    }
// Returns whether the element value for DocumentStatus is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) DocumentStatus_IsNil() bool {
    return s.learningstandarddocument.DocumentStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) EndOfLifeDate() *String {
    if s.learningstandarddocument.EndOfLifeDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.EndOfLifeDate = ((*String)(v))
      }
      }
      return s.learningstandarddocument.EndOfLifeDate
    }
// Returns whether the element value for EndOfLifeDate is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) EndOfLifeDate_IsNil() bool {
    return s.learningstandarddocument.EndOfLifeDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) LearningStandardItemRefId() *String {
    if s.learningstandarddocument.LearningStandardItemRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.LearningStandardItemRefId = ((*String)(v))
      }
      }
      return s.learningstandarddocument.LearningStandardItemRefId
    }
// Returns whether the element value for LearningStandardItemRefId is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) LearningStandardItemRefId_IsNil() bool {
    return s.learningstandarddocument.LearningStandardItemRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) LocalAdoptionDate() *String {
    if s.learningstandarddocument.LocalAdoptionDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.LocalAdoptionDate = ((*String)(v))
      }
      }
      return s.learningstandarddocument.LocalAdoptionDate
    }
// Returns whether the element value for LocalAdoptionDate is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) LocalAdoptionDate_IsNil() bool {
    return s.learningstandarddocument.LocalAdoptionDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) LocalArchiveDate() *String {
    if s.learningstandarddocument.LocalArchiveDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.LocalArchiveDate = ((*String)(v))
      }
      }
      return s.learningstandarddocument.LocalArchiveDate
    }
// Returns whether the element value for LocalArchiveDate is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) LocalArchiveDate_IsNil() bool {
    return s.learningstandarddocument.LocalArchiveDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) LocalCodeList() *LocalCodeListType {
    if s.learningstandarddocument.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.learningstandarddocument.LocalCodeList = v
      }
      }
      return s.learningstandarddocument.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) LocalCodeList_IsNil() bool {
    return s.learningstandarddocument.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) OrganizationContactPoint() *String {
    if s.learningstandarddocument.OrganizationContactPoint == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.OrganizationContactPoint = ((*String)(v))
      }
      }
      return s.learningstandarddocument.OrganizationContactPoint
    }
// Returns whether the element value for OrganizationContactPoint is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) OrganizationContactPoint_IsNil() bool {
    return s.learningstandarddocument.OrganizationContactPoint == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) Organizations() *OrganizationsType {
    if s.learningstandarddocument.Organizations == nil {
     if v, ok:= OrganizationsTypePointer(OrganizationsType{}); ok {
      s.learningstandarddocument.Organizations = v
      }
      }
      return s.learningstandarddocument.Organizations
    }
// Returns whether the element value for Organizations is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) Organizations_IsNil() bool {
    return s.learningstandarddocument.Organizations == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) RefId() *RefIdType {
    if s.learningstandarddocument.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.RefId = ((*RefIdType)(v))
      }
      }
      return s.learningstandarddocument.RefId
    }
// Returns whether the element value for RefId is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) RefId_IsNil() bool {
    return s.learningstandarddocument.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) RelatedLearningStandards() *LearningStandardsDocumentType {
    if s.learningstandarddocument.RelatedLearningStandards == nil {
     if v, ok:= LearningStandardsDocumentTypePointer(LearningStandardsDocumentType{}); ok {
      s.learningstandarddocument.RelatedLearningStandards = v
      }
      }
      return s.learningstandarddocument.RelatedLearningStandards
    }
// Returns whether the element value for RelatedLearningStandards is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) RelatedLearningStandards_IsNil() bool {
    return s.learningstandarddocument.RelatedLearningStandards == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) RepositoryDate() *String {
    if s.learningstandarddocument.RepositoryDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.RepositoryDate = ((*String)(v))
      }
      }
      return s.learningstandarddocument.RepositoryDate
    }
// Returns whether the element value for RepositoryDate is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) RepositoryDate_IsNil() bool {
    return s.learningstandarddocument.RepositoryDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) RichDescription() *AbstractContentElementType {
    if s.learningstandarddocument.RichDescription == nil {
     if v, ok:= AbstractContentElementTypePointer(AbstractContentElementType{}); ok {
      s.learningstandarddocument.RichDescription = v
      }
      }
      return s.learningstandarddocument.RichDescription
    }
// Returns whether the element value for RichDescription is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) RichDescription_IsNil() bool {
    return s.learningstandarddocument.RichDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.learningstandarddocument.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.learningstandarddocument.SIF_ExtendedElements = v
      }
      }
      return s.learningstandarddocument.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) SIF_ExtendedElements_IsNil() bool {
    return s.learningstandarddocument.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) SIF_Metadata() *SIF_MetadataType {
    if s.learningstandarddocument.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.learningstandarddocument.SIF_Metadata = v
      }
      }
      return s.learningstandarddocument.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) SIF_Metadata_IsNil() bool {
    return s.learningstandarddocument.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) Source() *String {
    if s.learningstandarddocument.Source == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.Source = ((*String)(v))
      }
      }
      return s.learningstandarddocument.Source
    }
// Returns whether the element value for Source is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) Source_IsNil() bool {
    return s.learningstandarddocument.Source == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) SubjectAreas() *ACStrandAreaListType {
    if s.learningstandarddocument.SubjectAreas == nil {
     if v, ok:= ACStrandAreaListTypePointer(ACStrandAreaListType{}); ok {
      s.learningstandarddocument.SubjectAreas = v
      }
      }
      return s.learningstandarddocument.SubjectAreas
    }
// Returns whether the element value for SubjectAreas is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) SubjectAreas_IsNil() bool {
    return s.learningstandarddocument.SubjectAreas == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) Title() *String {
    if s.learningstandarddocument.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarddocument.Title = ((*String)(v))
      }
      }
      return s.learningstandarddocument.Title
    }
// Returns whether the element value for Title is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) Title_IsNil() bool {
    return s.learningstandarddocument.Title == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardDocument) YearLevels() *YearLevelsType {
    if s.learningstandarddocument.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.learningstandarddocument.YearLevels = v
      }
      }
      return s.learningstandarddocument.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container LearningStandardDocument.
  func (s *LearningStandardDocument) YearLevels_IsNil() bool {
    return s.learningstandarddocument.YearLevels == nil
    }

// Set the value of a property to nil
func (n *LearningStandardItem) Unset(key string) *LearningStandardItem {
        switch key {
  case "ACStrandSubjectArea":
   n.learningstandarditem.ACStrandSubjectArea = nil
  case "LearningStandardDocumentRefId":
   n.learningstandarditem.LearningStandardDocumentRefId = nil
  case "Level4":
   n.learningstandarditem.Level4 = nil
  case "Level5":
   n.learningstandarditem.Level5 = nil
  case "LocalCodeList":
   n.learningstandarditem.LocalCodeList = nil
  case "PredecessorItems":
   n.learningstandarditem.PredecessorItems = nil
  case "RefId":
   n.learningstandarditem.RefId = nil
  case "RelatedLearningStandardItems":
   n.learningstandarditem.RelatedLearningStandardItems = nil
  case "Resources":
   n.learningstandarditem.Resources = nil
  case "SIF_ExtendedElements":
   n.learningstandarditem.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.learningstandarditem.SIF_Metadata = nil
  case "StandardHierarchyLevel":
   n.learningstandarditem.StandardHierarchyLevel = nil
  case "StandardIdentifier":
   n.learningstandarditem.StandardIdentifier = nil
  case "StandardSettingBody":
   n.learningstandarditem.StandardSettingBody = nil
  case "StatementCodes":
   n.learningstandarditem.StatementCodes = nil
  case "Statements":
   n.learningstandarditem.Statements = nil
  case "YearLevels":
   n.learningstandarditem.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningStandardItem")
        }
        return n
}

// Set a sequence of properties
func (n *LearningStandardItem) SetProperties(props ...Prop) *LearningStandardItem {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LearningStandardItem) SetProperty(key string, value interface{}) *LearningStandardItem {
        if n == nil {
                n, _ = LearningStandardItemPointer(LearningStandardItem{})
        }
        switch key {
    case "ACStrandSubjectArea":
    if v, ok:= ACStrandSubjectAreaTypePointer(value); ok {
      n.learningstandarditem.ACStrandSubjectArea = v
      }
    case "LearningStandardDocumentRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarditem.LearningStandardDocumentRefId = ((*String)(v))
      }
    case "Level4":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarditem.Level4 = ((*String)(v))
      }
    case "Level5":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarditem.Level5 = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.learningstandarditem.LocalCodeList = v
      }
    case "PredecessorItems":
    if v, ok:= LearningStandardsTypePointer(value); ok {
      n.learningstandarditem.PredecessorItems = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandarditem.RefId = ((*RefIdType)(v))
      }
    case "RelatedLearningStandardItems":
    if v, ok:= RelatedLearningStandardItemRefIdListTypePointer(value); ok {
      n.learningstandarditem.RelatedLearningStandardItems = v
      }
    case "Resources":
    if v, ok:= LResourcesTypePointer(value); ok {
      n.learningstandarditem.Resources = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.learningstandarditem.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.learningstandarditem.SIF_Metadata = v
      }
    case "StandardHierarchyLevel":
    if v, ok:= StandardHierarchyLevelTypePointer(value); ok {
      n.learningstandarditem.StandardHierarchyLevel = v
      }
    case "StandardIdentifier":
    if v, ok:= StandardIdentifierTypePointer(value); ok {
      n.learningstandarditem.StandardIdentifier = v
      }
    case "StandardSettingBody":
    if v, ok:= StandardsSettingBodyTypePointer(value); ok {
      n.learningstandarditem.StandardSettingBody = v
      }
    case "StatementCodes":
    if v, ok:= StatementCodesTypePointer(value); ok {
      n.learningstandarditem.StatementCodes = v
      }
    case "Statements":
    if v, ok:= StatementsTypePointer(value); ok {
      n.learningstandarditem.Statements = v
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.learningstandarditem.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningStandardItem")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) ACStrandSubjectArea() *ACStrandSubjectAreaType {
    if s.learningstandarditem.ACStrandSubjectArea == nil {
     if v, ok:= ACStrandSubjectAreaTypePointer(ACStrandSubjectAreaType{}); ok {
      s.learningstandarditem.ACStrandSubjectArea = v
      }
      }
      return s.learningstandarditem.ACStrandSubjectArea
    }
// Returns whether the element value for ACStrandSubjectArea is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) ACStrandSubjectArea_IsNil() bool {
    return s.learningstandarditem.ACStrandSubjectArea == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) LearningStandardDocumentRefId() *String {
    if s.learningstandarditem.LearningStandardDocumentRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarditem.LearningStandardDocumentRefId = ((*String)(v))
      }
      }
      return s.learningstandarditem.LearningStandardDocumentRefId
    }
// Returns whether the element value for LearningStandardDocumentRefId is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) LearningStandardDocumentRefId_IsNil() bool {
    return s.learningstandarditem.LearningStandardDocumentRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) Level4() *String {
    if s.learningstandarditem.Level4 == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarditem.Level4 = ((*String)(v))
      }
      }
      return s.learningstandarditem.Level4
    }
// Returns whether the element value for Level4 is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) Level4_IsNil() bool {
    return s.learningstandarditem.Level4 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) Level5() *String {
    if s.learningstandarditem.Level5 == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarditem.Level5 = ((*String)(v))
      }
      }
      return s.learningstandarditem.Level5
    }
// Returns whether the element value for Level5 is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) Level5_IsNil() bool {
    return s.learningstandarditem.Level5 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) LocalCodeList() *LocalCodeListType {
    if s.learningstandarditem.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.learningstandarditem.LocalCodeList = v
      }
      }
      return s.learningstandarditem.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) LocalCodeList_IsNil() bool {
    return s.learningstandarditem.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) PredecessorItems() *LearningStandardsType {
    if s.learningstandarditem.PredecessorItems == nil {
     if v, ok:= LearningStandardsTypePointer(LearningStandardsType{}); ok {
      s.learningstandarditem.PredecessorItems = v
      }
      }
      return s.learningstandarditem.PredecessorItems
    }
// Returns whether the element value for PredecessorItems is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) PredecessorItems_IsNil() bool {
    return s.learningstandarditem.PredecessorItems == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) RefId() *RefIdType {
    if s.learningstandarditem.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandarditem.RefId = ((*RefIdType)(v))
      }
      }
      return s.learningstandarditem.RefId
    }
// Returns whether the element value for RefId is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) RefId_IsNil() bool {
    return s.learningstandarditem.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) RelatedLearningStandardItems() *RelatedLearningStandardItemRefIdListType {
    if s.learningstandarditem.RelatedLearningStandardItems == nil {
     if v, ok:= RelatedLearningStandardItemRefIdListTypePointer(RelatedLearningStandardItemRefIdListType{}); ok {
      s.learningstandarditem.RelatedLearningStandardItems = v
      }
      }
      return s.learningstandarditem.RelatedLearningStandardItems
    }
// Returns whether the element value for RelatedLearningStandardItems is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) RelatedLearningStandardItems_IsNil() bool {
    return s.learningstandarditem.RelatedLearningStandardItems == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) Resources() *LResourcesType {
    if s.learningstandarditem.Resources == nil {
     if v, ok:= LResourcesTypePointer(LResourcesType{}); ok {
      s.learningstandarditem.Resources = v
      }
      }
      return s.learningstandarditem.Resources
    }
// Returns whether the element value for Resources is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) Resources_IsNil() bool {
    return s.learningstandarditem.Resources == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.learningstandarditem.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.learningstandarditem.SIF_ExtendedElements = v
      }
      }
      return s.learningstandarditem.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) SIF_ExtendedElements_IsNil() bool {
    return s.learningstandarditem.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) SIF_Metadata() *SIF_MetadataType {
    if s.learningstandarditem.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.learningstandarditem.SIF_Metadata = v
      }
      }
      return s.learningstandarditem.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) SIF_Metadata_IsNil() bool {
    return s.learningstandarditem.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) StandardHierarchyLevel() *StandardHierarchyLevelType {
    if s.learningstandarditem.StandardHierarchyLevel == nil {
     if v, ok:= StandardHierarchyLevelTypePointer(StandardHierarchyLevelType{}); ok {
      s.learningstandarditem.StandardHierarchyLevel = v
      }
      }
      return s.learningstandarditem.StandardHierarchyLevel
    }
// Returns whether the element value for StandardHierarchyLevel is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) StandardHierarchyLevel_IsNil() bool {
    return s.learningstandarditem.StandardHierarchyLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) StandardIdentifier() *StandardIdentifierType {
    if s.learningstandarditem.StandardIdentifier == nil {
     if v, ok:= StandardIdentifierTypePointer(StandardIdentifierType{}); ok {
      s.learningstandarditem.StandardIdentifier = v
      }
      }
      return s.learningstandarditem.StandardIdentifier
    }
// Returns whether the element value for StandardIdentifier is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) StandardIdentifier_IsNil() bool {
    return s.learningstandarditem.StandardIdentifier == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) StandardSettingBody() *StandardsSettingBodyType {
    if s.learningstandarditem.StandardSettingBody == nil {
     if v, ok:= StandardsSettingBodyTypePointer(StandardsSettingBodyType{}); ok {
      s.learningstandarditem.StandardSettingBody = v
      }
      }
      return s.learningstandarditem.StandardSettingBody
    }
// Returns whether the element value for StandardSettingBody is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) StandardSettingBody_IsNil() bool {
    return s.learningstandarditem.StandardSettingBody == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) StatementCodes() *StatementCodesType {
    if s.learningstandarditem.StatementCodes == nil {
     if v, ok:= StatementCodesTypePointer(StatementCodesType{}); ok {
      s.learningstandarditem.StatementCodes = v
      }
      }
      return s.learningstandarditem.StatementCodes
    }
// Returns whether the element value for StatementCodes is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) StatementCodes_IsNil() bool {
    return s.learningstandarditem.StatementCodes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) Statements() *StatementsType {
    if s.learningstandarditem.Statements == nil {
     if v, ok:= StatementsTypePointer(StatementsType{}); ok {
      s.learningstandarditem.Statements = v
      }
      }
      return s.learningstandarditem.Statements
    }
// Returns whether the element value for Statements is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) Statements_IsNil() bool {
    return s.learningstandarditem.Statements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardItem) YearLevels() *YearLevelsType {
    if s.learningstandarditem.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.learningstandarditem.YearLevels = v
      }
      }
      return s.learningstandarditem.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container LearningStandardItem.
  func (s *LearningStandardItem) YearLevels_IsNil() bool {
    return s.learningstandarditem.YearLevels == nil
    }

// Set the value of a property to nil
func (n *LearningStandardType) Unset(key string) *LearningStandardType {
        switch key {
  case "LearningStandardItemRefId":
   n.learningstandardtype.LearningStandardItemRefId = nil
  case "LearningStandardLocalId":
   n.learningstandardtype.LearningStandardLocalId = nil
  case "LearningStandardURL":
   n.learningstandardtype.LearningStandardURL = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningStandardType")
        }
        return n
}

// Set a sequence of properties
func (n *LearningStandardType) SetProperties(props ...Prop) *LearningStandardType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LearningStandardType) SetProperty(key string, value interface{}) *LearningStandardType {
        if n == nil {
                n, _ = LearningStandardTypePointer(LearningStandardType{})
        }
        switch key {
    case "LearningStandardItemRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandardtype.LearningStandardItemRefId = ((*String)(v))
      }
    case "LearningStandardLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandardtype.LearningStandardLocalId = ((*LocalIdType)(v))
      }
    case "LearningStandardURL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.learningstandardtype.LearningStandardURL = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LearningStandardType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardType) LearningStandardItemRefId() *String {
    if s.learningstandardtype.LearningStandardItemRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandardtype.LearningStandardItemRefId = ((*String)(v))
      }
      }
      return s.learningstandardtype.LearningStandardItemRefId
    }
// Returns whether the element value for LearningStandardItemRefId is nil in the container LearningStandardType.
  func (s *LearningStandardType) LearningStandardItemRefId_IsNil() bool {
    return s.learningstandardtype.LearningStandardItemRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardType) LearningStandardLocalId() *LocalIdType {
    if s.learningstandardtype.LearningStandardLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandardtype.LearningStandardLocalId = ((*LocalIdType)(v))
      }
      }
      return s.learningstandardtype.LearningStandardLocalId
    }
// Returns whether the element value for LearningStandardLocalId is nil in the container LearningStandardType.
  func (s *LearningStandardType) LearningStandardLocalId_IsNil() bool {
    return s.learningstandardtype.LearningStandardLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LearningStandardType) LearningStandardURL() *String {
    if s.learningstandardtype.LearningStandardURL == nil {
    if v, ok:= StringPointer(""); ok {
      s.learningstandardtype.LearningStandardURL = ((*String)(v))
      }
      }
      return s.learningstandardtype.LearningStandardURL
    }
// Returns whether the element value for LearningStandardURL is nil in the container LearningStandardType.
  func (s *LearningStandardType) LearningStandardURL_IsNil() bool {
    return s.learningstandardtype.LearningStandardURL == nil
    }

// Set the value of a property to nil
func (n *LibraryItemInfoType) Unset(key string) *LibraryItemInfoType {
        switch key {
  case "Author":
   n.libraryiteminfotype.Author = nil
  case "CallNumber":
   n.libraryiteminfotype.CallNumber = nil
  case "Cost":
   n.libraryiteminfotype.Cost = nil
  case "ElectronicId":
   n.libraryiteminfotype.ElectronicId = nil
  case "ISBN":
   n.libraryiteminfotype.ISBN = nil
  case "ReplacementCost":
   n.libraryiteminfotype.ReplacementCost = nil
  case "Title":
   n.libraryiteminfotype.Title = nil
  case "Type":
   n.libraryiteminfotype.Type = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LibraryItemInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *LibraryItemInfoType) SetProperties(props ...Prop) *LibraryItemInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LibraryItemInfoType) SetProperty(key string, value interface{}) *LibraryItemInfoType {
        if n == nil {
                n, _ = LibraryItemInfoTypePointer(LibraryItemInfoType{})
        }
        switch key {
    case "Author":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.libraryiteminfotype.Author = ((*String)(v))
      }
    case "CallNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.libraryiteminfotype.CallNumber = ((*String)(v))
      }
    case "Cost":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.libraryiteminfotype.Cost = v
      }
    case "ElectronicId":
    if v, ok:= ElectronicIdTypePointer(value); ok {
      n.libraryiteminfotype.ElectronicId = v
      }
    case "ISBN":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.libraryiteminfotype.ISBN = ((*String)(v))
      }
    case "ReplacementCost":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.libraryiteminfotype.ReplacementCost = v
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.libraryiteminfotype.Title = ((*String)(v))
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.libraryiteminfotype.Type = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LibraryItemInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryItemInfoType) Author() *String {
    if s.libraryiteminfotype.Author == nil {
    if v, ok:= StringPointer(""); ok {
      s.libraryiteminfotype.Author = ((*String)(v))
      }
      }
      return s.libraryiteminfotype.Author
    }
// Returns whether the element value for Author is nil in the container LibraryItemInfoType.
  func (s *LibraryItemInfoType) Author_IsNil() bool {
    return s.libraryiteminfotype.Author == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryItemInfoType) CallNumber() *String {
    if s.libraryiteminfotype.CallNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.libraryiteminfotype.CallNumber = ((*String)(v))
      }
      }
      return s.libraryiteminfotype.CallNumber
    }
// Returns whether the element value for CallNumber is nil in the container LibraryItemInfoType.
  func (s *LibraryItemInfoType) CallNumber_IsNil() bool {
    return s.libraryiteminfotype.CallNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryItemInfoType) Cost() *MonetaryAmountType {
    if s.libraryiteminfotype.Cost == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.libraryiteminfotype.Cost = v
      }
      }
      return s.libraryiteminfotype.Cost
    }
// Returns whether the element value for Cost is nil in the container LibraryItemInfoType.
  func (s *LibraryItemInfoType) Cost_IsNil() bool {
    return s.libraryiteminfotype.Cost == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryItemInfoType) ElectronicId() *ElectronicIdType {
    if s.libraryiteminfotype.ElectronicId == nil {
     if v, ok:= ElectronicIdTypePointer(ElectronicIdType{}); ok {
      s.libraryiteminfotype.ElectronicId = v
      }
      }
      return s.libraryiteminfotype.ElectronicId
    }
// Returns whether the element value for ElectronicId is nil in the container LibraryItemInfoType.
  func (s *LibraryItemInfoType) ElectronicId_IsNil() bool {
    return s.libraryiteminfotype.ElectronicId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryItemInfoType) ISBN() *String {
    if s.libraryiteminfotype.ISBN == nil {
    if v, ok:= StringPointer(""); ok {
      s.libraryiteminfotype.ISBN = ((*String)(v))
      }
      }
      return s.libraryiteminfotype.ISBN
    }
// Returns whether the element value for ISBN is nil in the container LibraryItemInfoType.
  func (s *LibraryItemInfoType) ISBN_IsNil() bool {
    return s.libraryiteminfotype.ISBN == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryItemInfoType) ReplacementCost() *MonetaryAmountType {
    if s.libraryiteminfotype.ReplacementCost == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.libraryiteminfotype.ReplacementCost = v
      }
      }
      return s.libraryiteminfotype.ReplacementCost
    }
// Returns whether the element value for ReplacementCost is nil in the container LibraryItemInfoType.
  func (s *LibraryItemInfoType) ReplacementCost_IsNil() bool {
    return s.libraryiteminfotype.ReplacementCost == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryItemInfoType) Title() *String {
    if s.libraryiteminfotype.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.libraryiteminfotype.Title = ((*String)(v))
      }
      }
      return s.libraryiteminfotype.Title
    }
// Returns whether the element value for Title is nil in the container LibraryItemInfoType.
  func (s *LibraryItemInfoType) Title_IsNil() bool {
    return s.libraryiteminfotype.Title == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryItemInfoType) Type() *String {
    if s.libraryiteminfotype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.libraryiteminfotype.Type = ((*String)(v))
      }
      }
      return s.libraryiteminfotype.Type
    }
// Returns whether the element value for Type is nil in the container LibraryItemInfoType.
  func (s *LibraryItemInfoType) Type_IsNil() bool {
    return s.libraryiteminfotype.Type == nil
    }

// Set the value of a property to nil
func (n *LibraryMessageType) Unset(key string) *LibraryMessageType {
        switch key {
  case "Priority":
   n.librarymessagetype.Priority = nil
  case "PriorityCodeset":
   n.librarymessagetype.PriorityCodeset = nil
  case "Sent":
   n.librarymessagetype.Sent = nil
  case "Text":
   n.librarymessagetype.Text = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LibraryMessageType")
        }
        return n
}

// Set a sequence of properties
func (n *LibraryMessageType) SetProperties(props ...Prop) *LibraryMessageType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LibraryMessageType) SetProperty(key string, value interface{}) *LibraryMessageType {
        if n == nil {
                n, _ = LibraryMessageTypePointer(LibraryMessageType{})
        }
        switch key {
    case "Priority":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.librarymessagetype.Priority = ((*String)(v))
      }
    case "PriorityCodeset":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.librarymessagetype.PriorityCodeset = ((*String)(v))
      }
    case "Sent":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.librarymessagetype.Sent = ((*String)(v))
      }
    case "Text":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.librarymessagetype.Text = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LibraryMessageType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryMessageType) Priority() *String {
    if s.librarymessagetype.Priority == nil {
    if v, ok:= StringPointer(""); ok {
      s.librarymessagetype.Priority = ((*String)(v))
      }
      }
      return s.librarymessagetype.Priority
    }
// Returns whether the element value for Priority is nil in the container LibraryMessageType.
  func (s *LibraryMessageType) Priority_IsNil() bool {
    return s.librarymessagetype.Priority == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryMessageType) PriorityCodeset() *String {
    if s.librarymessagetype.PriorityCodeset == nil {
    if v, ok:= StringPointer(""); ok {
      s.librarymessagetype.PriorityCodeset = ((*String)(v))
      }
      }
      return s.librarymessagetype.PriorityCodeset
    }
// Returns whether the element value for PriorityCodeset is nil in the container LibraryMessageType.
  func (s *LibraryMessageType) PriorityCodeset_IsNil() bool {
    return s.librarymessagetype.PriorityCodeset == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryMessageType) Sent() *String {
    if s.librarymessagetype.Sent == nil {
    if v, ok:= StringPointer(""); ok {
      s.librarymessagetype.Sent = ((*String)(v))
      }
      }
      return s.librarymessagetype.Sent
    }
// Returns whether the element value for Sent is nil in the container LibraryMessageType.
  func (s *LibraryMessageType) Sent_IsNil() bool {
    return s.librarymessagetype.Sent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryMessageType) Text() *String {
    if s.librarymessagetype.Text == nil {
    if v, ok:= StringPointer(""); ok {
      s.librarymessagetype.Text = ((*String)(v))
      }
      }
      return s.librarymessagetype.Text
    }
// Returns whether the element value for Text is nil in the container LibraryMessageType.
  func (s *LibraryMessageType) Text_IsNil() bool {
    return s.librarymessagetype.Text == nil
    }

// Set the value of a property to nil
func (n *LibraryPatronStatus) Unset(key string) *LibraryPatronStatus {
        switch key {
  case "ElectronicIdList":
   n.librarypatronstatus.ElectronicIdList = nil
  case "FineAmount":
   n.librarypatronstatus.FineAmount = nil
  case "LibraryType":
   n.librarypatronstatus.LibraryType = nil
  case "LocalCodeList":
   n.librarypatronstatus.LocalCodeList = nil
  case "MessageList":
   n.librarypatronstatus.MessageList = nil
  case "NumberOfCheckouts":
   n.librarypatronstatus.NumberOfCheckouts = nil
  case "NumberOfFines":
   n.librarypatronstatus.NumberOfFines = nil
  case "NumberOfHoldItems":
   n.librarypatronstatus.NumberOfHoldItems = nil
  case "NumberOfOverdues":
   n.librarypatronstatus.NumberOfOverdues = nil
  case "NumberOfRefunds":
   n.librarypatronstatus.NumberOfRefunds = nil
  case "PatronLocalId":
   n.librarypatronstatus.PatronLocalId = nil
  case "PatronName":
   n.librarypatronstatus.PatronName = nil
  case "PatronRefId":
   n.librarypatronstatus.PatronRefId = nil
  case "PatronRefObject":
   n.librarypatronstatus.PatronRefObject = nil
  case "RefId":
   n.librarypatronstatus.RefId = nil
  case "RefundAmount":
   n.librarypatronstatus.RefundAmount = nil
  case "SIF_ExtendedElements":
   n.librarypatronstatus.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.librarypatronstatus.SIF_Metadata = nil
  case "TransactionList":
   n.librarypatronstatus.TransactionList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LibraryPatronStatus")
        }
        return n
}

// Set a sequence of properties
func (n *LibraryPatronStatus) SetProperties(props ...Prop) *LibraryPatronStatus {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LibraryPatronStatus) SetProperty(key string, value interface{}) *LibraryPatronStatus {
        if n == nil {
                n, _ = LibraryPatronStatusPointer(LibraryPatronStatus{})
        }
        switch key {
    case "ElectronicIdList":
    if v, ok:= ElectronicIdListTypePointer(value); ok {
      n.librarypatronstatus.ElectronicIdList = v
      }
    case "FineAmount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.librarypatronstatus.FineAmount = v
      }
    case "LibraryType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.librarypatronstatus.LibraryType = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.librarypatronstatus.LocalCodeList = v
      }
    case "MessageList":
    if v, ok:= LibraryMessageListTypePointer(value); ok {
      n.librarypatronstatus.MessageList = v
      }
    case "NumberOfCheckouts":
    
    if v, ok:= IntPointer(value); ok {
      n.librarypatronstatus.NumberOfCheckouts = ((*Int)(v))
      }
    case "NumberOfFines":
    
    if v, ok:= IntPointer(value); ok {
      n.librarypatronstatus.NumberOfFines = ((*Int)(v))
      }
    case "NumberOfHoldItems":
    
    if v, ok:= IntPointer(value); ok {
      n.librarypatronstatus.NumberOfHoldItems = ((*Int)(v))
      }
    case "NumberOfOverdues":
    
    if v, ok:= IntPointer(value); ok {
      n.librarypatronstatus.NumberOfOverdues = ((*Int)(v))
      }
    case "NumberOfRefunds":
    
    if v, ok:= IntPointer(value); ok {
      n.librarypatronstatus.NumberOfRefunds = ((*Int)(v))
      }
    case "PatronLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.librarypatronstatus.PatronLocalId = ((*LocalIdType)(v))
      }
    case "PatronName":
    if v, ok:= NameOfRecordTypePointer(value); ok {
      n.librarypatronstatus.PatronName = v
      }
    case "PatronRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.librarypatronstatus.PatronRefId = ((*String)(v))
      }
    case "PatronRefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.librarypatronstatus.PatronRefObject = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.librarypatronstatus.RefId = ((*RefIdType)(v))
      }
    case "RefundAmount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.librarypatronstatus.RefundAmount = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.librarypatronstatus.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.librarypatronstatus.SIF_Metadata = v
      }
    case "TransactionList":
    if v, ok:= LibraryTransactionListTypePointer(value); ok {
      n.librarypatronstatus.TransactionList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LibraryPatronStatus")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) ElectronicIdList() *ElectronicIdListType {
    if s.librarypatronstatus.ElectronicIdList == nil {
     if v, ok:= ElectronicIdListTypePointer(ElectronicIdListType{}); ok {
      s.librarypatronstatus.ElectronicIdList = v
      }
      }
      return s.librarypatronstatus.ElectronicIdList
    }
// Returns whether the element value for ElectronicIdList is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) ElectronicIdList_IsNil() bool {
    return s.librarypatronstatus.ElectronicIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) FineAmount() *MonetaryAmountType {
    if s.librarypatronstatus.FineAmount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.librarypatronstatus.FineAmount = v
      }
      }
      return s.librarypatronstatus.FineAmount
    }
// Returns whether the element value for FineAmount is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) FineAmount_IsNil() bool {
    return s.librarypatronstatus.FineAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) LibraryType() *String {
    if s.librarypatronstatus.LibraryType == nil {
    if v, ok:= StringPointer(""); ok {
      s.librarypatronstatus.LibraryType = ((*String)(v))
      }
      }
      return s.librarypatronstatus.LibraryType
    }
// Returns whether the element value for LibraryType is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) LibraryType_IsNil() bool {
    return s.librarypatronstatus.LibraryType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) LocalCodeList() *LocalCodeListType {
    if s.librarypatronstatus.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.librarypatronstatus.LocalCodeList = v
      }
      }
      return s.librarypatronstatus.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) LocalCodeList_IsNil() bool {
    return s.librarypatronstatus.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) MessageList() *LibraryMessageListType {
    if s.librarypatronstatus.MessageList == nil {
     if v, ok:= LibraryMessageListTypePointer(LibraryMessageListType{}); ok {
      s.librarypatronstatus.MessageList = v
      }
      }
      return s.librarypatronstatus.MessageList
    }
// Returns whether the element value for MessageList is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) MessageList_IsNil() bool {
    return s.librarypatronstatus.MessageList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) NumberOfCheckouts() *Int {
    if s.librarypatronstatus.NumberOfCheckouts == nil {
    if v, ok:= IntPointer(0); ok {
      s.librarypatronstatus.NumberOfCheckouts = ((*Int)(v))
      }
      }
      return s.librarypatronstatus.NumberOfCheckouts
    }
// Returns whether the element value for NumberOfCheckouts is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) NumberOfCheckouts_IsNil() bool {
    return s.librarypatronstatus.NumberOfCheckouts == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) NumberOfFines() *Int {
    if s.librarypatronstatus.NumberOfFines == nil {
    if v, ok:= IntPointer(0); ok {
      s.librarypatronstatus.NumberOfFines = ((*Int)(v))
      }
      }
      return s.librarypatronstatus.NumberOfFines
    }
// Returns whether the element value for NumberOfFines is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) NumberOfFines_IsNil() bool {
    return s.librarypatronstatus.NumberOfFines == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) NumberOfHoldItems() *Int {
    if s.librarypatronstatus.NumberOfHoldItems == nil {
    if v, ok:= IntPointer(0); ok {
      s.librarypatronstatus.NumberOfHoldItems = ((*Int)(v))
      }
      }
      return s.librarypatronstatus.NumberOfHoldItems
    }
// Returns whether the element value for NumberOfHoldItems is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) NumberOfHoldItems_IsNil() bool {
    return s.librarypatronstatus.NumberOfHoldItems == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) NumberOfOverdues() *Int {
    if s.librarypatronstatus.NumberOfOverdues == nil {
    if v, ok:= IntPointer(0); ok {
      s.librarypatronstatus.NumberOfOverdues = ((*Int)(v))
      }
      }
      return s.librarypatronstatus.NumberOfOverdues
    }
// Returns whether the element value for NumberOfOverdues is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) NumberOfOverdues_IsNil() bool {
    return s.librarypatronstatus.NumberOfOverdues == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) NumberOfRefunds() *Int {
    if s.librarypatronstatus.NumberOfRefunds == nil {
    if v, ok:= IntPointer(0); ok {
      s.librarypatronstatus.NumberOfRefunds = ((*Int)(v))
      }
      }
      return s.librarypatronstatus.NumberOfRefunds
    }
// Returns whether the element value for NumberOfRefunds is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) NumberOfRefunds_IsNil() bool {
    return s.librarypatronstatus.NumberOfRefunds == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) PatronLocalId() *LocalIdType {
    if s.librarypatronstatus.PatronLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.librarypatronstatus.PatronLocalId = ((*LocalIdType)(v))
      }
      }
      return s.librarypatronstatus.PatronLocalId
    }
// Returns whether the element value for PatronLocalId is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) PatronLocalId_IsNil() bool {
    return s.librarypatronstatus.PatronLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) PatronName() *NameOfRecordType {
    if s.librarypatronstatus.PatronName == nil {
     if v, ok:= NameOfRecordTypePointer(NameOfRecordType{}); ok {
      s.librarypatronstatus.PatronName = v
      }
      }
      return s.librarypatronstatus.PatronName
    }
// Returns whether the element value for PatronName is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) PatronName_IsNil() bool {
    return s.librarypatronstatus.PatronName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) PatronRefId() *String {
    if s.librarypatronstatus.PatronRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.librarypatronstatus.PatronRefId = ((*String)(v))
      }
      }
      return s.librarypatronstatus.PatronRefId
    }
// Returns whether the element value for PatronRefId is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) PatronRefId_IsNil() bool {
    return s.librarypatronstatus.PatronRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) PatronRefObject() *String {
    if s.librarypatronstatus.PatronRefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.librarypatronstatus.PatronRefObject = ((*String)(v))
      }
      }
      return s.librarypatronstatus.PatronRefObject
    }
// Returns whether the element value for PatronRefObject is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) PatronRefObject_IsNil() bool {
    return s.librarypatronstatus.PatronRefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) RefId() *RefIdType {
    if s.librarypatronstatus.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.librarypatronstatus.RefId = ((*RefIdType)(v))
      }
      }
      return s.librarypatronstatus.RefId
    }
// Returns whether the element value for RefId is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) RefId_IsNil() bool {
    return s.librarypatronstatus.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) RefundAmount() *MonetaryAmountType {
    if s.librarypatronstatus.RefundAmount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.librarypatronstatus.RefundAmount = v
      }
      }
      return s.librarypatronstatus.RefundAmount
    }
// Returns whether the element value for RefundAmount is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) RefundAmount_IsNil() bool {
    return s.librarypatronstatus.RefundAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.librarypatronstatus.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.librarypatronstatus.SIF_ExtendedElements = v
      }
      }
      return s.librarypatronstatus.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) SIF_ExtendedElements_IsNil() bool {
    return s.librarypatronstatus.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) SIF_Metadata() *SIF_MetadataType {
    if s.librarypatronstatus.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.librarypatronstatus.SIF_Metadata = v
      }
      }
      return s.librarypatronstatus.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) SIF_Metadata_IsNil() bool {
    return s.librarypatronstatus.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryPatronStatus) TransactionList() *LibraryTransactionListType {
    if s.librarypatronstatus.TransactionList == nil {
     if v, ok:= LibraryTransactionListTypePointer(LibraryTransactionListType{}); ok {
      s.librarypatronstatus.TransactionList = v
      }
      }
      return s.librarypatronstatus.TransactionList
    }
// Returns whether the element value for TransactionList is nil in the container LibraryPatronStatus.
  func (s *LibraryPatronStatus) TransactionList_IsNil() bool {
    return s.librarypatronstatus.TransactionList == nil
    }

// Set the value of a property to nil
func (n *LibraryTransactionType) Unset(key string) *LibraryTransactionType {
        switch key {
  case "CheckoutInfo":
   n.librarytransactiontype.CheckoutInfo = nil
  case "FineInfoList":
   n.librarytransactiontype.FineInfoList = nil
  case "HoldInfoList":
   n.librarytransactiontype.HoldInfoList = nil
  case "ItemInfo":
   n.librarytransactiontype.ItemInfo = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LibraryTransactionType")
        }
        return n
}

// Set a sequence of properties
func (n *LibraryTransactionType) SetProperties(props ...Prop) *LibraryTransactionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LibraryTransactionType) SetProperty(key string, value interface{}) *LibraryTransactionType {
        if n == nil {
                n, _ = LibraryTransactionTypePointer(LibraryTransactionType{})
        }
        switch key {
    case "CheckoutInfo":
    if v, ok:= CheckoutInfoTypePointer(value); ok {
      n.librarytransactiontype.CheckoutInfo = v
      }
    case "FineInfoList":
    if v, ok:= FineInfoListTypePointer(value); ok {
      n.librarytransactiontype.FineInfoList = v
      }
    case "HoldInfoList":
    if v, ok:= HoldInfoListTypePointer(value); ok {
      n.librarytransactiontype.HoldInfoList = v
      }
    case "ItemInfo":
    if v, ok:= LibraryItemInfoTypePointer(value); ok {
      n.librarytransactiontype.ItemInfo = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LibraryTransactionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryTransactionType) CheckoutInfo() *CheckoutInfoType {
    if s.librarytransactiontype.CheckoutInfo == nil {
     if v, ok:= CheckoutInfoTypePointer(CheckoutInfoType{}); ok {
      s.librarytransactiontype.CheckoutInfo = v
      }
      }
      return s.librarytransactiontype.CheckoutInfo
    }
// Returns whether the element value for CheckoutInfo is nil in the container LibraryTransactionType.
  func (s *LibraryTransactionType) CheckoutInfo_IsNil() bool {
    return s.librarytransactiontype.CheckoutInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryTransactionType) FineInfoList() *FineInfoListType {
    if s.librarytransactiontype.FineInfoList == nil {
     if v, ok:= FineInfoListTypePointer(FineInfoListType{}); ok {
      s.librarytransactiontype.FineInfoList = v
      }
      }
      return s.librarytransactiontype.FineInfoList
    }
// Returns whether the element value for FineInfoList is nil in the container LibraryTransactionType.
  func (s *LibraryTransactionType) FineInfoList_IsNil() bool {
    return s.librarytransactiontype.FineInfoList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryTransactionType) HoldInfoList() *HoldInfoListType {
    if s.librarytransactiontype.HoldInfoList == nil {
     if v, ok:= HoldInfoListTypePointer(HoldInfoListType{}); ok {
      s.librarytransactiontype.HoldInfoList = v
      }
      }
      return s.librarytransactiontype.HoldInfoList
    }
// Returns whether the element value for HoldInfoList is nil in the container LibraryTransactionType.
  func (s *LibraryTransactionType) HoldInfoList_IsNil() bool {
    return s.librarytransactiontype.HoldInfoList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LibraryTransactionType) ItemInfo() *LibraryItemInfoType {
    if s.librarytransactiontype.ItemInfo == nil {
     if v, ok:= LibraryItemInfoTypePointer(LibraryItemInfoType{}); ok {
      s.librarytransactiontype.ItemInfo = v
      }
      }
      return s.librarytransactiontype.ItemInfo
    }
// Returns whether the element value for ItemInfo is nil in the container LibraryTransactionType.
  func (s *LibraryTransactionType) ItemInfo_IsNil() bool {
    return s.librarytransactiontype.ItemInfo == nil
    }

// Set the value of a property to nil
func (n *LifeCycleCreatorType) Unset(key string) *LifeCycleCreatorType {
        switch key {
  case "ID":
   n.lifecyclecreatortype.ID = nil
  case "Name":
   n.lifecyclecreatortype.Name = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LifeCycleCreatorType")
        }
        return n
}

// Set a sequence of properties
func (n *LifeCycleCreatorType) SetProperties(props ...Prop) *LifeCycleCreatorType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LifeCycleCreatorType) SetProperty(key string, value interface{}) *LifeCycleCreatorType {
        if n == nil {
                n, _ = LifeCycleCreatorTypePointer(LifeCycleCreatorType{})
        }
        switch key {
    case "ID":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.lifecyclecreatortype.ID = ((*String)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.lifecyclecreatortype.Name = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LifeCycleCreatorType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LifeCycleCreatorType) ID() *String {
    if s.lifecyclecreatortype.ID == nil {
    if v, ok:= StringPointer(""); ok {
      s.lifecyclecreatortype.ID = ((*String)(v))
      }
      }
      return s.lifecyclecreatortype.ID
    }
// Returns whether the element value for ID is nil in the container LifeCycleCreatorType.
  func (s *LifeCycleCreatorType) ID_IsNil() bool {
    return s.lifecyclecreatortype.ID == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LifeCycleCreatorType) Name() *String {
    if s.lifecyclecreatortype.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.lifecyclecreatortype.Name = ((*String)(v))
      }
      }
      return s.lifecyclecreatortype.Name
    }
// Returns whether the element value for Name is nil in the container LifeCycleCreatorType.
  func (s *LifeCycleCreatorType) Name_IsNil() bool {
    return s.lifecyclecreatortype.Name == nil
    }

// Set the value of a property to nil
func (n *LifeCycleType) Unset(key string) *LifeCycleType {
        switch key {
  case "Created":
   n.lifecycletype.Created = nil
  case "ModificationHistory":
   n.lifecycletype.ModificationHistory = nil
  case "TimeElements":
   n.lifecycletype.TimeElements = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LifeCycleType")
        }
        return n
}

// Set a sequence of properties
func (n *LifeCycleType) SetProperties(props ...Prop) *LifeCycleType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LifeCycleType) SetProperty(key string, value interface{}) *LifeCycleType {
        if n == nil {
                n, _ = LifeCycleTypePointer(LifeCycleType{})
        }
        switch key {
    case "Created":
    if v, ok:= CreatedTypePointer(value); ok {
      n.lifecycletype.Created = v
      }
    case "ModificationHistory":
    if v, ok:= ModifiedListTypePointer(value); ok {
      n.lifecycletype.ModificationHistory = v
      }
    case "TimeElements":
    if v, ok:= TimeElementListTypePointer(value); ok {
      n.lifecycletype.TimeElements = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LifeCycleType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LifeCycleType) Created() *CreatedType {
    if s.lifecycletype.Created == nil {
     if v, ok:= CreatedTypePointer(CreatedType{}); ok {
      s.lifecycletype.Created = v
      }
      }
      return s.lifecycletype.Created
    }
// Returns whether the element value for Created is nil in the container LifeCycleType.
  func (s *LifeCycleType) Created_IsNil() bool {
    return s.lifecycletype.Created == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LifeCycleType) ModificationHistory() *ModifiedListType {
    if s.lifecycletype.ModificationHistory == nil {
     if v, ok:= ModifiedListTypePointer(ModifiedListType{}); ok {
      s.lifecycletype.ModificationHistory = v
      }
      }
      return s.lifecycletype.ModificationHistory
    }
// Returns whether the element value for ModificationHistory is nil in the container LifeCycleType.
  func (s *LifeCycleType) ModificationHistory_IsNil() bool {
    return s.lifecycletype.ModificationHistory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LifeCycleType) TimeElements() *TimeElementListType {
    if s.lifecycletype.TimeElements == nil {
     if v, ok:= TimeElementListTypePointer(TimeElementListType{}); ok {
      s.lifecycletype.TimeElements = v
      }
      }
      return s.lifecycletype.TimeElements
    }
// Returns whether the element value for TimeElements is nil in the container LifeCycleType.
  func (s *LifeCycleType) TimeElements_IsNil() bool {
    return s.lifecycletype.TimeElements == nil
    }

// Set the value of a property to nil
func (n *LocalCodeType) Unset(key string) *LocalCodeType {
        switch key {
  case "Description":
   n.localcodetype.Description = nil
  case "Element":
   n.localcodetype.Element = nil
  case "ListIndex":
   n.localcodetype.ListIndex = nil
  case "LocalisedCode":
   n.localcodetype.LocalisedCode = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LocalCodeType")
        }
        return n
}

// Set a sequence of properties
func (n *LocalCodeType) SetProperties(props ...Prop) *LocalCodeType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LocalCodeType) SetProperty(key string, value interface{}) *LocalCodeType {
        if n == nil {
                n, _ = LocalCodeTypePointer(LocalCodeType{})
        }
        switch key {
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.localcodetype.Description = ((*String)(v))
      }
    case "Element":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.localcodetype.Element = ((*String)(v))
      }
    case "ListIndex":
    
    if v, ok:= IntPointer(value); ok {
      n.localcodetype.ListIndex = ((*Int)(v))
      }
    case "LocalisedCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.localcodetype.LocalisedCode = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LocalCodeType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocalCodeType) Description() *String {
    if s.localcodetype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.localcodetype.Description = ((*String)(v))
      }
      }
      return s.localcodetype.Description
    }
// Returns whether the element value for Description is nil in the container LocalCodeType.
  func (s *LocalCodeType) Description_IsNil() bool {
    return s.localcodetype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocalCodeType) Element() *String {
    if s.localcodetype.Element == nil {
    if v, ok:= StringPointer(""); ok {
      s.localcodetype.Element = ((*String)(v))
      }
      }
      return s.localcodetype.Element
    }
// Returns whether the element value for Element is nil in the container LocalCodeType.
  func (s *LocalCodeType) Element_IsNil() bool {
    return s.localcodetype.Element == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocalCodeType) ListIndex() *Int {
    if s.localcodetype.ListIndex == nil {
    if v, ok:= IntPointer(0); ok {
      s.localcodetype.ListIndex = ((*Int)(v))
      }
      }
      return s.localcodetype.ListIndex
    }
// Returns whether the element value for ListIndex is nil in the container LocalCodeType.
  func (s *LocalCodeType) ListIndex_IsNil() bool {
    return s.localcodetype.ListIndex == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocalCodeType) LocalisedCode() *String {
    if s.localcodetype.LocalisedCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.localcodetype.LocalisedCode = ((*String)(v))
      }
      }
      return s.localcodetype.LocalisedCode
    }
// Returns whether the element value for LocalisedCode is nil in the container LocalCodeType.
  func (s *LocalCodeType) LocalisedCode_IsNil() bool {
    return s.localcodetype.LocalisedCode == nil
    }

// Set the value of a property to nil
func (n *LocationOfInstructionType) Unset(key string) *LocationOfInstructionType {
        switch key {
  case "Code":
   n.locationofinstructiontype.Code = nil
  case "OtherCodeList":
   n.locationofinstructiontype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LocationOfInstructionType")
        }
        return n
}

// Set a sequence of properties
func (n *LocationOfInstructionType) SetProperties(props ...Prop) *LocationOfInstructionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LocationOfInstructionType) SetProperty(key string, value interface{}) *LocationOfInstructionType {
        if n == nil {
                n, _ = LocationOfInstructionTypePointer(LocationOfInstructionType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsReceivingLocationOfInstructionType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsReceivingLocationOfInstructionType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.locationofinstructiontype.Code = ((*AUCodeSetsReceivingLocationOfInstructionType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.locationofinstructiontype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LocationOfInstructionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocationOfInstructionType) Code() *AUCodeSetsReceivingLocationOfInstructionType {
    if s.locationofinstructiontype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.locationofinstructiontype.Code = ((*AUCodeSetsReceivingLocationOfInstructionType)(v))
      }
      }
      return s.locationofinstructiontype.Code
    }
// Returns whether the element value for Code is nil in the container LocationOfInstructionType.
  func (s *LocationOfInstructionType) Code_IsNil() bool {
    return s.locationofinstructiontype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocationOfInstructionType) OtherCodeList() *OtherCodeListType {
    if s.locationofinstructiontype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.locationofinstructiontype.OtherCodeList = v
      }
      }
      return s.locationofinstructiontype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container LocationOfInstructionType.
  func (s *LocationOfInstructionType) OtherCodeList_IsNil() bool {
    return s.locationofinstructiontype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *LocationType) Unset(key string) *LocationType {
        switch key {
  case "LocationName":
   n.locationtype.LocationName = nil
  case "LocationRefId":
   n.locationtype.LocationRefId = nil
  case "Type":
   n.locationtype.Type = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LocationType")
        }
        return n
}

// Set a sequence of properties
func (n *LocationType) SetProperties(props ...Prop) *LocationType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LocationType) SetProperty(key string, value interface{}) *LocationType {
        if n == nil {
                n, _ = LocationTypePointer(LocationType{})
        }
        switch key {
    case "LocationName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.locationtype.LocationName = ((*String)(v))
      }
    case "LocationRefId":
    if v, ok:= LocationType_LocationRefIdPointer(value); ok {
      n.locationtype.LocationRefId = v
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.locationtype.Type = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LocationType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocationType) LocationName() *String {
    if s.locationtype.LocationName == nil {
    if v, ok:= StringPointer(""); ok {
      s.locationtype.LocationName = ((*String)(v))
      }
      }
      return s.locationtype.LocationName
    }
// Returns whether the element value for LocationName is nil in the container LocationType.
  func (s *LocationType) LocationName_IsNil() bool {
    return s.locationtype.LocationName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocationType) LocationRefId() *LocationType_LocationRefId {
    if s.locationtype.LocationRefId == nil {
     if v, ok:= LocationType_LocationRefIdPointer(LocationType_LocationRefId{}); ok {
      s.locationtype.LocationRefId = v
      }
      }
      return s.locationtype.LocationRefId
    }
// Returns whether the element value for LocationRefId is nil in the container LocationType.
  func (s *LocationType) LocationRefId_IsNil() bool {
    return s.locationtype.LocationRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocationType) Type() *String {
    if s.locationtype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.locationtype.Type = ((*String)(v))
      }
      }
      return s.locationtype.Type
    }
// Returns whether the element value for Type is nil in the container LocationType.
  func (s *LocationType) Type_IsNil() bool {
    return s.locationtype.Type == nil
    }

// Set the value of a property to nil
func (n *LocationType_LocationRefId) Unset(key string) *LocationType_LocationRefId {
        switch key {
  case "SIF_RefObject":
   n.locationtype_locationrefid.SIF_RefObject = nil
  case "Value":
   n.locationtype_locationrefid.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LocationType_LocationRefId")
        }
        return n
}

// Set a sequence of properties
func (n *LocationType_LocationRefId) SetProperties(props ...Prop) *LocationType_LocationRefId {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *LocationType_LocationRefId) SetProperty(key string, value interface{}) *LocationType_LocationRefId {
        if n == nil {
                n, _ = LocationType_LocationRefIdPointer(LocationType_LocationRefId{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.locationtype_locationrefid.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.locationtype_locationrefid.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "LocationType_LocationRefId")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocationType_LocationRefId) SIF_RefObject() *String {
    if s.locationtype_locationrefid.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.locationtype_locationrefid.SIF_RefObject = ((*String)(v))
      }
      }
      return s.locationtype_locationrefid.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container LocationType_LocationRefId.
  func (s *LocationType_LocationRefId) SIF_RefObject_IsNil() bool {
    return s.locationtype_locationrefid.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *LocationType_LocationRefId) Value() *String {
    if s.locationtype_locationrefid.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.locationtype_locationrefid.Value = ((*String)(v))
      }
      }
      return s.locationtype_locationrefid.Value
    }
// Returns whether the element value for Value is nil in the container LocationType_LocationRefId.
  func (s *LocationType_LocationRefId) Value_IsNil() bool {
    return s.locationtype_locationrefid.Value == nil
    }

// Set the value of a property to nil
func (n *MapReferenceType) Unset(key string) *MapReferenceType {
        switch key {
  case "MapNumber":
   n.mapreferencetype.MapNumber = nil
  case "Type":
   n.mapreferencetype.Type = nil
  case "XCoordinate":
   n.mapreferencetype.XCoordinate = nil
  case "YCoordinate":
   n.mapreferencetype.YCoordinate = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MapReferenceType")
        }
        return n
}

// Set a sequence of properties
func (n *MapReferenceType) SetProperties(props ...Prop) *MapReferenceType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *MapReferenceType) SetProperty(key string, value interface{}) *MapReferenceType {
        if n == nil {
                n, _ = MapReferenceTypePointer(MapReferenceType{})
        }
        switch key {
    case "MapNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.mapreferencetype.MapNumber = ((*String)(v))
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.mapreferencetype.Type = ((*String)(v))
      }
    case "XCoordinate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.mapreferencetype.XCoordinate = ((*String)(v))
      }
    case "YCoordinate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.mapreferencetype.YCoordinate = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MapReferenceType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MapReferenceType) MapNumber() *String {
    if s.mapreferencetype.MapNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.mapreferencetype.MapNumber = ((*String)(v))
      }
      }
      return s.mapreferencetype.MapNumber
    }
// Returns whether the element value for MapNumber is nil in the container MapReferenceType.
  func (s *MapReferenceType) MapNumber_IsNil() bool {
    return s.mapreferencetype.MapNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MapReferenceType) Type() *String {
    if s.mapreferencetype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.mapreferencetype.Type = ((*String)(v))
      }
      }
      return s.mapreferencetype.Type
    }
// Returns whether the element value for Type is nil in the container MapReferenceType.
  func (s *MapReferenceType) Type_IsNil() bool {
    return s.mapreferencetype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MapReferenceType) XCoordinate() *String {
    if s.mapreferencetype.XCoordinate == nil {
    if v, ok:= StringPointer(""); ok {
      s.mapreferencetype.XCoordinate = ((*String)(v))
      }
      }
      return s.mapreferencetype.XCoordinate
    }
// Returns whether the element value for XCoordinate is nil in the container MapReferenceType.
  func (s *MapReferenceType) XCoordinate_IsNil() bool {
    return s.mapreferencetype.XCoordinate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MapReferenceType) YCoordinate() *String {
    if s.mapreferencetype.YCoordinate == nil {
    if v, ok:= StringPointer(""); ok {
      s.mapreferencetype.YCoordinate = ((*String)(v))
      }
      }
      return s.mapreferencetype.YCoordinate
    }
// Returns whether the element value for YCoordinate is nil in the container MapReferenceType.
  func (s *MapReferenceType) YCoordinate_IsNil() bool {
    return s.mapreferencetype.YCoordinate == nil
    }

// Set the value of a property to nil
func (n *MarkValueInfo) Unset(key string) *MarkValueInfo {
        switch key {
  case "LocalCodeList":
   n.markvalueinfo.LocalCodeList = nil
  case "Name":
   n.markvalueinfo.Name = nil
  case "Narrative":
   n.markvalueinfo.Narrative = nil
  case "NarrativeMaximumSize":
   n.markvalueinfo.NarrativeMaximumSize = nil
  case "NumericHigh":
   n.markvalueinfo.NumericHigh = nil
  case "NumericLow":
   n.markvalueinfo.NumericLow = nil
  case "NumericPassingGrade":
   n.markvalueinfo.NumericPassingGrade = nil
  case "NumericPrecision":
   n.markvalueinfo.NumericPrecision = nil
  case "NumericScale":
   n.markvalueinfo.NumericScale = nil
  case "PercentageMaximum":
   n.markvalueinfo.PercentageMaximum = nil
  case "PercentageMinimum":
   n.markvalueinfo.PercentageMinimum = nil
  case "PercentagePassingGrade":
   n.markvalueinfo.PercentagePassingGrade = nil
  case "RefId":
   n.markvalueinfo.RefId = nil
  case "SIF_ExtendedElements":
   n.markvalueinfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.markvalueinfo.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.markvalueinfo.SchoolInfoRefId = nil
  case "ValidLetterMarkList":
   n.markvalueinfo.ValidLetterMarkList = nil
  case "YearLevels":
   n.markvalueinfo.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MarkValueInfo")
        }
        return n
}

// Set a sequence of properties
func (n *MarkValueInfo) SetProperties(props ...Prop) *MarkValueInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *MarkValueInfo) SetProperty(key string, value interface{}) *MarkValueInfo {
        if n == nil {
                n, _ = MarkValueInfoPointer(MarkValueInfo{})
        }
        switch key {
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.markvalueinfo.LocalCodeList = v
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.markvalueinfo.Name = ((*String)(v))
      }
    case "Narrative":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.markvalueinfo.Narrative = ((*String)(v))
      }
    case "NarrativeMaximumSize":
    
    if v, ok:= IntPointer(value); ok {
      n.markvalueinfo.NarrativeMaximumSize = ((*Int)(v))
      }
    case "NumericHigh":
    
    if v, ok:= FloatPointer(value); ok {
      n.markvalueinfo.NumericHigh = ((*Float)(v))
      }
    case "NumericLow":
    
    if v, ok:= FloatPointer(value); ok {
      n.markvalueinfo.NumericLow = ((*Float)(v))
      }
    case "NumericPassingGrade":
    
    if v, ok:= FloatPointer(value); ok {
      n.markvalueinfo.NumericPassingGrade = ((*Float)(v))
      }
    case "NumericPrecision":
    
    if v, ok:= IntPointer(value); ok {
      n.markvalueinfo.NumericPrecision = ((*Int)(v))
      }
    case "NumericScale":
    
    if v, ok:= IntPointer(value); ok {
      n.markvalueinfo.NumericScale = ((*Int)(v))
      }
    case "PercentageMaximum":
    
    if v, ok:= FloatPointer(value); ok {
      n.markvalueinfo.PercentageMaximum = ((*Float)(v))
      }
    case "PercentageMinimum":
    
    if v, ok:= FloatPointer(value); ok {
      n.markvalueinfo.PercentageMinimum = ((*Float)(v))
      }
    case "PercentagePassingGrade":
    
    if v, ok:= FloatPointer(value); ok {
      n.markvalueinfo.PercentagePassingGrade = ((*Float)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.markvalueinfo.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.markvalueinfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.markvalueinfo.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.markvalueinfo.SchoolInfoRefId = ((*String)(v))
      }
    case "ValidLetterMarkList":
    if v, ok:= ValidLetterMarkListTypePointer(value); ok {
      n.markvalueinfo.ValidLetterMarkList = v
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.markvalueinfo.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MarkValueInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) LocalCodeList() *LocalCodeListType {
    if s.markvalueinfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.markvalueinfo.LocalCodeList = v
      }
      }
      return s.markvalueinfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) LocalCodeList_IsNil() bool {
    return s.markvalueinfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) Name() *String {
    if s.markvalueinfo.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.markvalueinfo.Name = ((*String)(v))
      }
      }
      return s.markvalueinfo.Name
    }
// Returns whether the element value for Name is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) Name_IsNil() bool {
    return s.markvalueinfo.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) Narrative() *String {
    if s.markvalueinfo.Narrative == nil {
    if v, ok:= StringPointer(""); ok {
      s.markvalueinfo.Narrative = ((*String)(v))
      }
      }
      return s.markvalueinfo.Narrative
    }
// Returns whether the element value for Narrative is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) Narrative_IsNil() bool {
    return s.markvalueinfo.Narrative == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) NarrativeMaximumSize() *Int {
    if s.markvalueinfo.NarrativeMaximumSize == nil {
    if v, ok:= IntPointer(0); ok {
      s.markvalueinfo.NarrativeMaximumSize = ((*Int)(v))
      }
      }
      return s.markvalueinfo.NarrativeMaximumSize
    }
// Returns whether the element value for NarrativeMaximumSize is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) NarrativeMaximumSize_IsNil() bool {
    return s.markvalueinfo.NarrativeMaximumSize == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) NumericHigh() *Float {
    if s.markvalueinfo.NumericHigh == nil {
    if v, ok:= FloatPointer(0); ok {
      s.markvalueinfo.NumericHigh = ((*Float)(v))
      }
      }
      return s.markvalueinfo.NumericHigh
    }
// Returns whether the element value for NumericHigh is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) NumericHigh_IsNil() bool {
    return s.markvalueinfo.NumericHigh == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) NumericLow() *Float {
    if s.markvalueinfo.NumericLow == nil {
    if v, ok:= FloatPointer(0); ok {
      s.markvalueinfo.NumericLow = ((*Float)(v))
      }
      }
      return s.markvalueinfo.NumericLow
    }
// Returns whether the element value for NumericLow is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) NumericLow_IsNil() bool {
    return s.markvalueinfo.NumericLow == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) NumericPassingGrade() *Float {
    if s.markvalueinfo.NumericPassingGrade == nil {
    if v, ok:= FloatPointer(0); ok {
      s.markvalueinfo.NumericPassingGrade = ((*Float)(v))
      }
      }
      return s.markvalueinfo.NumericPassingGrade
    }
// Returns whether the element value for NumericPassingGrade is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) NumericPassingGrade_IsNil() bool {
    return s.markvalueinfo.NumericPassingGrade == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) NumericPrecision() *Int {
    if s.markvalueinfo.NumericPrecision == nil {
    if v, ok:= IntPointer(0); ok {
      s.markvalueinfo.NumericPrecision = ((*Int)(v))
      }
      }
      return s.markvalueinfo.NumericPrecision
    }
// Returns whether the element value for NumericPrecision is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) NumericPrecision_IsNil() bool {
    return s.markvalueinfo.NumericPrecision == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) NumericScale() *Int {
    if s.markvalueinfo.NumericScale == nil {
    if v, ok:= IntPointer(0); ok {
      s.markvalueinfo.NumericScale = ((*Int)(v))
      }
      }
      return s.markvalueinfo.NumericScale
    }
// Returns whether the element value for NumericScale is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) NumericScale_IsNil() bool {
    return s.markvalueinfo.NumericScale == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) PercentageMaximum() *Float {
    if s.markvalueinfo.PercentageMaximum == nil {
    if v, ok:= FloatPointer(0); ok {
      s.markvalueinfo.PercentageMaximum = ((*Float)(v))
      }
      }
      return s.markvalueinfo.PercentageMaximum
    }
// Returns whether the element value for PercentageMaximum is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) PercentageMaximum_IsNil() bool {
    return s.markvalueinfo.PercentageMaximum == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) PercentageMinimum() *Float {
    if s.markvalueinfo.PercentageMinimum == nil {
    if v, ok:= FloatPointer(0); ok {
      s.markvalueinfo.PercentageMinimum = ((*Float)(v))
      }
      }
      return s.markvalueinfo.PercentageMinimum
    }
// Returns whether the element value for PercentageMinimum is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) PercentageMinimum_IsNil() bool {
    return s.markvalueinfo.PercentageMinimum == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) PercentagePassingGrade() *Float {
    if s.markvalueinfo.PercentagePassingGrade == nil {
    if v, ok:= FloatPointer(0); ok {
      s.markvalueinfo.PercentagePassingGrade = ((*Float)(v))
      }
      }
      return s.markvalueinfo.PercentagePassingGrade
    }
// Returns whether the element value for PercentagePassingGrade is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) PercentagePassingGrade_IsNil() bool {
    return s.markvalueinfo.PercentagePassingGrade == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) RefId() *RefIdType {
    if s.markvalueinfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.markvalueinfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.markvalueinfo.RefId
    }
// Returns whether the element value for RefId is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) RefId_IsNil() bool {
    return s.markvalueinfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.markvalueinfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.markvalueinfo.SIF_ExtendedElements = v
      }
      }
      return s.markvalueinfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) SIF_ExtendedElements_IsNil() bool {
    return s.markvalueinfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) SIF_Metadata() *SIF_MetadataType {
    if s.markvalueinfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.markvalueinfo.SIF_Metadata = v
      }
      }
      return s.markvalueinfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) SIF_Metadata_IsNil() bool {
    return s.markvalueinfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) SchoolInfoRefId() *String {
    if s.markvalueinfo.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.markvalueinfo.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.markvalueinfo.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) SchoolInfoRefId_IsNil() bool {
    return s.markvalueinfo.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) ValidLetterMarkList() *ValidLetterMarkListType {
    if s.markvalueinfo.ValidLetterMarkList == nil {
     if v, ok:= ValidLetterMarkListTypePointer(ValidLetterMarkListType{}); ok {
      s.markvalueinfo.ValidLetterMarkList = v
      }
      }
      return s.markvalueinfo.ValidLetterMarkList
    }
// Returns whether the element value for ValidLetterMarkList is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) ValidLetterMarkList_IsNil() bool {
    return s.markvalueinfo.ValidLetterMarkList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkValueInfo) YearLevels() *YearLevelsType {
    if s.markvalueinfo.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.markvalueinfo.YearLevels = v
      }
      }
      return s.markvalueinfo.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container MarkValueInfo.
  func (s *MarkValueInfo) YearLevels_IsNil() bool {
    return s.markvalueinfo.YearLevels == nil
    }

// Set the value of a property to nil
func (n *MarkerType) Unset(key string) *MarkerType {
        switch key {
  case "Role":
   n.markertype.Role = nil
  case "StaffPersonalRefId":
   n.markertype.StaffPersonalRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MarkerType")
        }
        return n
}

// Set a sequence of properties
func (n *MarkerType) SetProperties(props ...Prop) *MarkerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *MarkerType) SetProperty(key string, value interface{}) *MarkerType {
        if n == nil {
                n, _ = MarkerTypePointer(MarkerType{})
        }
        switch key {
    case "Role":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.markertype.Role = ((*String)(v))
      }
    case "StaffPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.markertype.StaffPersonalRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MarkerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkerType) Role() *String {
    if s.markertype.Role == nil {
    if v, ok:= StringPointer(""); ok {
      s.markertype.Role = ((*String)(v))
      }
      }
      return s.markertype.Role
    }
// Returns whether the element value for Role is nil in the container MarkerType.
  func (s *MarkerType) Role_IsNil() bool {
    return s.markertype.Role == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MarkerType) StaffPersonalRefId() *String {
    if s.markertype.StaffPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.markertype.StaffPersonalRefId = ((*String)(v))
      }
      }
      return s.markertype.StaffPersonalRefId
    }
// Returns whether the element value for StaffPersonalRefId is nil in the container MarkerType.
  func (s *MarkerType) StaffPersonalRefId_IsNil() bool {
    return s.markertype.StaffPersonalRefId == nil
    }

// Set the value of a property to nil
func (n *MedicalAlertMessageType) Unset(key string) *MedicalAlertMessageType {
        switch key {
  case "Severity":
   n.medicalalertmessagetype.Severity = nil
  case "Value":
   n.medicalalertmessagetype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MedicalAlertMessageType")
        }
        return n
}

// Set a sequence of properties
func (n *MedicalAlertMessageType) SetProperties(props ...Prop) *MedicalAlertMessageType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *MedicalAlertMessageType) SetProperty(key string, value interface{}) *MedicalAlertMessageType {
        if n == nil {
                n, _ = MedicalAlertMessageTypePointer(MedicalAlertMessageType{})
        }
        switch key {
    case "Severity":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.medicalalertmessagetype.Severity = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.medicalalertmessagetype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MedicalAlertMessageType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MedicalAlertMessageType) Severity() *String {
    if s.medicalalertmessagetype.Severity == nil {
    if v, ok:= StringPointer(""); ok {
      s.medicalalertmessagetype.Severity = ((*String)(v))
      }
      }
      return s.medicalalertmessagetype.Severity
    }
// Returns whether the element value for Severity is nil in the container MedicalAlertMessageType.
  func (s *MedicalAlertMessageType) Severity_IsNil() bool {
    return s.medicalalertmessagetype.Severity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MedicalAlertMessageType) Value() *String {
    if s.medicalalertmessagetype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.medicalalertmessagetype.Value = ((*String)(v))
      }
      }
      return s.medicalalertmessagetype.Value
    }
// Returns whether the element value for Value is nil in the container MedicalAlertMessageType.
  func (s *MedicalAlertMessageType) Value_IsNil() bool {
    return s.medicalalertmessagetype.Value == nil
    }

// Set the value of a property to nil
func (n *MedicationType) Unset(key string) *MedicationType {
        switch key {
  case "AdministrationInformation":
   n.medicationtype.AdministrationInformation = nil
  case "Dosage":
   n.medicationtype.Dosage = nil
  case "Frequency":
   n.medicationtype.Frequency = nil
  case "MedicationName":
   n.medicationtype.MedicationName = nil
  case "Method":
   n.medicationtype.Method = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MedicationType")
        }
        return n
}

// Set a sequence of properties
func (n *MedicationType) SetProperties(props ...Prop) *MedicationType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *MedicationType) SetProperty(key string, value interface{}) *MedicationType {
        if n == nil {
                n, _ = MedicationTypePointer(MedicationType{})
        }
        switch key {
    case "AdministrationInformation":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.medicationtype.AdministrationInformation = ((*String)(v))
      }
    case "Dosage":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.medicationtype.Dosage = ((*String)(v))
      }
    case "Frequency":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.medicationtype.Frequency = ((*String)(v))
      }
    case "MedicationName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.medicationtype.MedicationName = ((*String)(v))
      }
    case "Method":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.medicationtype.Method = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MedicationType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MedicationType) AdministrationInformation() *String {
    if s.medicationtype.AdministrationInformation == nil {
    if v, ok:= StringPointer(""); ok {
      s.medicationtype.AdministrationInformation = ((*String)(v))
      }
      }
      return s.medicationtype.AdministrationInformation
    }
// Returns whether the element value for AdministrationInformation is nil in the container MedicationType.
  func (s *MedicationType) AdministrationInformation_IsNil() bool {
    return s.medicationtype.AdministrationInformation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MedicationType) Dosage() *String {
    if s.medicationtype.Dosage == nil {
    if v, ok:= StringPointer(""); ok {
      s.medicationtype.Dosage = ((*String)(v))
      }
      }
      return s.medicationtype.Dosage
    }
// Returns whether the element value for Dosage is nil in the container MedicationType.
  func (s *MedicationType) Dosage_IsNil() bool {
    return s.medicationtype.Dosage == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MedicationType) Frequency() *String {
    if s.medicationtype.Frequency == nil {
    if v, ok:= StringPointer(""); ok {
      s.medicationtype.Frequency = ((*String)(v))
      }
      }
      return s.medicationtype.Frequency
    }
// Returns whether the element value for Frequency is nil in the container MedicationType.
  func (s *MedicationType) Frequency_IsNil() bool {
    return s.medicationtype.Frequency == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MedicationType) MedicationName() *String {
    if s.medicationtype.MedicationName == nil {
    if v, ok:= StringPointer(""); ok {
      s.medicationtype.MedicationName = ((*String)(v))
      }
      }
      return s.medicationtype.MedicationName
    }
// Returns whether the element value for MedicationName is nil in the container MedicationType.
  func (s *MedicationType) MedicationName_IsNil() bool {
    return s.medicationtype.MedicationName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MedicationType) Method() *String {
    if s.medicationtype.Method == nil {
    if v, ok:= StringPointer(""); ok {
      s.medicationtype.Method = ((*String)(v))
      }
      }
      return s.medicationtype.Method
    }
// Returns whether the element value for Method is nil in the container MedicationType.
  func (s *MedicationType) Method_IsNil() bool {
    return s.medicationtype.Method == nil
    }

// Set the value of a property to nil
func (n *MediumOfInstructionType) Unset(key string) *MediumOfInstructionType {
        switch key {
  case "Code":
   n.mediumofinstructiontype.Code = nil
  case "OtherCodeList":
   n.mediumofinstructiontype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MediumOfInstructionType")
        }
        return n
}

// Set a sequence of properties
func (n *MediumOfInstructionType) SetProperties(props ...Prop) *MediumOfInstructionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *MediumOfInstructionType) SetProperty(key string, value interface{}) *MediumOfInstructionType {
        if n == nil {
                n, _ = MediumOfInstructionTypePointer(MediumOfInstructionType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsMediumOfInstructionType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsMediumOfInstructionType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.mediumofinstructiontype.Code = ((*AUCodeSetsMediumOfInstructionType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.mediumofinstructiontype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MediumOfInstructionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MediumOfInstructionType) Code() *AUCodeSetsMediumOfInstructionType {
    if s.mediumofinstructiontype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.mediumofinstructiontype.Code = ((*AUCodeSetsMediumOfInstructionType)(v))
      }
      }
      return s.mediumofinstructiontype.Code
    }
// Returns whether the element value for Code is nil in the container MediumOfInstructionType.
  func (s *MediumOfInstructionType) Code_IsNil() bool {
    return s.mediumofinstructiontype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MediumOfInstructionType) OtherCodeList() *OtherCodeListType {
    if s.mediumofinstructiontype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.mediumofinstructiontype.OtherCodeList = v
      }
      }
      return s.mediumofinstructiontype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container MediumOfInstructionType.
  func (s *MediumOfInstructionType) OtherCodeList_IsNil() bool {
    return s.mediumofinstructiontype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *ModifiedType) Unset(key string) *ModifiedType {
        switch key {
  case "By":
   n.modifiedtype.By = nil
  case "DateTime":
   n.modifiedtype.DateTime = nil
  case "Description":
   n.modifiedtype.Description = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ModifiedType")
        }
        return n
}

// Set a sequence of properties
func (n *ModifiedType) SetProperties(props ...Prop) *ModifiedType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ModifiedType) SetProperty(key string, value interface{}) *ModifiedType {
        if n == nil {
                n, _ = ModifiedTypePointer(ModifiedType{})
        }
        switch key {
    case "By":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.modifiedtype.By = ((*String)(v))
      }
    case "DateTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.modifiedtype.DateTime = ((*String)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.modifiedtype.Description = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ModifiedType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ModifiedType) By() *String {
    if s.modifiedtype.By == nil {
    if v, ok:= StringPointer(""); ok {
      s.modifiedtype.By = ((*String)(v))
      }
      }
      return s.modifiedtype.By
    }
// Returns whether the element value for By is nil in the container ModifiedType.
  func (s *ModifiedType) By_IsNil() bool {
    return s.modifiedtype.By == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ModifiedType) DateTime() *String {
    if s.modifiedtype.DateTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.modifiedtype.DateTime = ((*String)(v))
      }
      }
      return s.modifiedtype.DateTime
    }
// Returns whether the element value for DateTime is nil in the container ModifiedType.
  func (s *ModifiedType) DateTime_IsNil() bool {
    return s.modifiedtype.DateTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ModifiedType) Description() *String {
    if s.modifiedtype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.modifiedtype.Description = ((*String)(v))
      }
      }
      return s.modifiedtype.Description
    }
// Returns whether the element value for Description is nil in the container ModifiedType.
  func (s *ModifiedType) Description_IsNil() bool {
    return s.modifiedtype.Description == nil
    }

// Set the value of a property to nil
func (n *MonetaryAmountType) Unset(key string) *MonetaryAmountType {
        switch key {
  case "Currency":
   n.monetaryamounttype.Currency = nil
  case "Value":
   n.monetaryamounttype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MonetaryAmountType")
        }
        return n
}

// Set a sequence of properties
func (n *MonetaryAmountType) SetProperties(props ...Prop) *MonetaryAmountType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *MonetaryAmountType) SetProperty(key string, value interface{}) *MonetaryAmountType {
        if n == nil {
                n, _ = MonetaryAmountTypePointer(MonetaryAmountType{})
        }
        switch key {
    case "Currency":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(ISO4217CurrencyNamesAndCodeElementsType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "ISO4217CurrencyNamesAndCodeElementsType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.monetaryamounttype.Currency = ((*ISO4217CurrencyNamesAndCodeElementsType)(v))
      }
    case "Value":
    
    if v, ok:= FloatPointer(value); ok {
      n.monetaryamounttype.Value = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "MonetaryAmountType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MonetaryAmountType) Currency() *ISO4217CurrencyNamesAndCodeElementsType {
    if s.monetaryamounttype.Currency == nil {
    if v, ok:= StringPointer(""); ok {
      s.monetaryamounttype.Currency = ((*ISO4217CurrencyNamesAndCodeElementsType)(v))
      }
      }
      return s.monetaryamounttype.Currency
    }
// Returns whether the element value for Currency is nil in the container MonetaryAmountType.
  func (s *MonetaryAmountType) Currency_IsNil() bool {
    return s.monetaryamounttype.Currency == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *MonetaryAmountType) Value() *Float {
    if s.monetaryamounttype.Value == nil {
    if v, ok:= FloatPointer(0); ok {
      s.monetaryamounttype.Value = ((*Float)(v))
      }
      }
      return s.monetaryamounttype.Value
    }
// Returns whether the element value for Value is nil in the container MonetaryAmountType.
  func (s *MonetaryAmountType) Value_IsNil() bool {
    return s.monetaryamounttype.Value == nil
    }

// Set the value of a property to nil
func (n *NAPCodeFrame) Unset(key string) *NAPCodeFrame {
        switch key {
  case "LocalCodeList":
   n.napcodeframe.LocalCodeList = nil
  case "NAPTestRefId":
   n.napcodeframe.NAPTestRefId = nil
  case "RefId":
   n.napcodeframe.RefId = nil
  case "SIF_ExtendedElements":
   n.napcodeframe.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.napcodeframe.SIF_Metadata = nil
  case "TestContent":
   n.napcodeframe.TestContent = nil
  case "TestletList":
   n.napcodeframe.TestletList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPCodeFrame")
        }
        return n
}

// Set a sequence of properties
func (n *NAPCodeFrame) SetProperties(props ...Prop) *NAPCodeFrame {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPCodeFrame) SetProperty(key string, value interface{}) *NAPCodeFrame {
        if n == nil {
                n, _ = NAPCodeFramePointer(NAPCodeFrame{})
        }
        switch key {
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.napcodeframe.LocalCodeList = v
      }
    case "NAPTestRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napcodeframe.NAPTestRefId = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napcodeframe.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.napcodeframe.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.napcodeframe.SIF_Metadata = v
      }
    case "TestContent":
    if v, ok:= NAPTestContentTypePointer(value); ok {
      n.napcodeframe.TestContent = v
      }
    case "TestletList":
    if v, ok:= NAPCodeFrameTestletListTypePointer(value); ok {
      n.napcodeframe.TestletList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPCodeFrame")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPCodeFrame) LocalCodeList() *LocalCodeListType {
    if s.napcodeframe.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.napcodeframe.LocalCodeList = v
      }
      }
      return s.napcodeframe.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container NAPCodeFrame.
  func (s *NAPCodeFrame) LocalCodeList_IsNil() bool {
    return s.napcodeframe.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPCodeFrame) NAPTestRefId() *String {
    if s.napcodeframe.NAPTestRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napcodeframe.NAPTestRefId = ((*String)(v))
      }
      }
      return s.napcodeframe.NAPTestRefId
    }
// Returns whether the element value for NAPTestRefId is nil in the container NAPCodeFrame.
  func (s *NAPCodeFrame) NAPTestRefId_IsNil() bool {
    return s.napcodeframe.NAPTestRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPCodeFrame) RefId() *RefIdType {
    if s.napcodeframe.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napcodeframe.RefId = ((*RefIdType)(v))
      }
      }
      return s.napcodeframe.RefId
    }
// Returns whether the element value for RefId is nil in the container NAPCodeFrame.
  func (s *NAPCodeFrame) RefId_IsNil() bool {
    return s.napcodeframe.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPCodeFrame) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.napcodeframe.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.napcodeframe.SIF_ExtendedElements = v
      }
      }
      return s.napcodeframe.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container NAPCodeFrame.
  func (s *NAPCodeFrame) SIF_ExtendedElements_IsNil() bool {
    return s.napcodeframe.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPCodeFrame) SIF_Metadata() *SIF_MetadataType {
    if s.napcodeframe.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.napcodeframe.SIF_Metadata = v
      }
      }
      return s.napcodeframe.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container NAPCodeFrame.
  func (s *NAPCodeFrame) SIF_Metadata_IsNil() bool {
    return s.napcodeframe.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPCodeFrame) TestContent() *NAPTestContentType {
    if s.napcodeframe.TestContent == nil {
     if v, ok:= NAPTestContentTypePointer(NAPTestContentType{}); ok {
      s.napcodeframe.TestContent = v
      }
      }
      return s.napcodeframe.TestContent
    }
// Returns whether the element value for TestContent is nil in the container NAPCodeFrame.
  func (s *NAPCodeFrame) TestContent_IsNil() bool {
    return s.napcodeframe.TestContent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPCodeFrame) TestletList() *NAPCodeFrameTestletListType {
    if s.napcodeframe.TestletList == nil {
     if v, ok:= NAPCodeFrameTestletListTypePointer(NAPCodeFrameTestletListType{}); ok {
      s.napcodeframe.TestletList = v
      }
      }
      return s.napcodeframe.TestletList
    }
// Returns whether the element value for TestletList is nil in the container NAPCodeFrame.
  func (s *NAPCodeFrame) TestletList_IsNil() bool {
    return s.napcodeframe.TestletList == nil
    }

// Set the value of a property to nil
func (n *NAPEventStudentLink) Unset(key string) *NAPEventStudentLink {
        switch key {
  case "Adjustment":
   n.napeventstudentlink.Adjustment = nil
  case "DOBRange":
   n.napeventstudentlink.DOBRange = nil
  case "Date":
   n.napeventstudentlink.Date = nil
  case "Device":
   n.napeventstudentlink.Device = nil
  case "ExemptionReason":
   n.napeventstudentlink.ExemptionReason = nil
  case "LapsedTimeTest":
   n.napeventstudentlink.LapsedTimeTest = nil
  case "LocalCodeList":
   n.napeventstudentlink.LocalCodeList = nil
  case "NAPJurisdiction":
   n.napeventstudentlink.NAPJurisdiction = nil
  case "NAPTestLocalId":
   n.napeventstudentlink.NAPTestLocalId = nil
  case "NAPTestRefId":
   n.napeventstudentlink.NAPTestRefId = nil
  case "PSIOtherIdMatch":
   n.napeventstudentlink.PSIOtherIdMatch = nil
  case "ParticipationCode":
   n.napeventstudentlink.ParticipationCode = nil
  case "ParticipationText":
   n.napeventstudentlink.ParticipationText = nil
  case "PersonalDetailsChanged":
   n.napeventstudentlink.PersonalDetailsChanged = nil
  case "PlatformStudentIdentifier":
   n.napeventstudentlink.PlatformStudentIdentifier = nil
  case "PossibleDuplicate":
   n.napeventstudentlink.PossibleDuplicate = nil
  case "RefId":
   n.napeventstudentlink.RefId = nil
  case "ReportingSchoolName":
   n.napeventstudentlink.ReportingSchoolName = nil
  case "SIF_ExtendedElements":
   n.napeventstudentlink.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.napeventstudentlink.SIF_Metadata = nil
  case "SchoolACARAId":
   n.napeventstudentlink.SchoolACARAId = nil
  case "SchoolGeolocation":
   n.napeventstudentlink.SchoolGeolocation = nil
  case "SchoolInfoRefId":
   n.napeventstudentlink.SchoolInfoRefId = nil
  case "SchoolSector":
   n.napeventstudentlink.SchoolSector = nil
  case "StartTime":
   n.napeventstudentlink.StartTime = nil
  case "StudentPersonalRefId":
   n.napeventstudentlink.StudentPersonalRefId = nil
  case "System":
   n.napeventstudentlink.System = nil
  case "TestDisruptionList":
   n.napeventstudentlink.TestDisruptionList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPEventStudentLink")
        }
        return n
}

// Set a sequence of properties
func (n *NAPEventStudentLink) SetProperties(props ...Prop) *NAPEventStudentLink {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPEventStudentLink) SetProperty(key string, value interface{}) *NAPEventStudentLink {
        if n == nil {
                n, _ = NAPEventStudentLinkPointer(NAPEventStudentLink{})
        }
        switch key {
    case "Adjustment":
    if v, ok:= AdjustmentContainerTypePointer(value); ok {
      n.napeventstudentlink.Adjustment = v
      }
    case "DOBRange":
    
    if v, ok:= BoolPointer(value); ok {
      n.napeventstudentlink.DOBRange = ((*Bool)(v))
      }
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.Date = ((*String)(v))
      }
    case "Device":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.Device = ((*String)(v))
      }
    case "ExemptionReason":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.ExemptionReason = ((*String)(v))
      }
    case "LapsedTimeTest":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.LapsedTimeTest = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.napeventstudentlink.LocalCodeList = v
      }
    case "NAPJurisdiction":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPJurisdictionType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPJurisdictionType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.NAPJurisdiction = ((*AUCodeSetsNAPJurisdictionType)(v))
      }
    case "NAPTestLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.NAPTestLocalId = ((*LocalIdType)(v))
      }
    case "NAPTestRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.NAPTestRefId = ((*String)(v))
      }
    case "PSIOtherIdMatch":
    
    if v, ok:= BoolPointer(value); ok {
      n.napeventstudentlink.PSIOtherIdMatch = ((*Bool)(v))
      }
    case "ParticipationCode":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPParticipationCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPParticipationCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.ParticipationCode = ((*AUCodeSetsNAPParticipationCodeType)(v))
      }
    case "ParticipationText":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.ParticipationText = ((*String)(v))
      }
    case "PersonalDetailsChanged":
    
    if v, ok:= BoolPointer(value); ok {
      n.napeventstudentlink.PersonalDetailsChanged = ((*Bool)(v))
      }
    case "PlatformStudentIdentifier":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.PlatformStudentIdentifier = ((*LocalIdType)(v))
      }
    case "PossibleDuplicate":
    
    if v, ok:= BoolPointer(value); ok {
      n.napeventstudentlink.PossibleDuplicate = ((*Bool)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.RefId = ((*RefIdType)(v))
      }
    case "ReportingSchoolName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.ReportingSchoolName = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.napeventstudentlink.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.napeventstudentlink.SIF_Metadata = v
      }
    case "SchoolACARAId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.SchoolACARAId = ((*LocalIdType)(v))
      }
    case "SchoolGeolocation":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolLocationType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolLocationType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.SchoolGeolocation = ((*AUCodeSetsSchoolLocationType)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolSector":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolSectorCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolSectorCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.SchoolSector = ((*AUCodeSetsSchoolSectorCodeType)(v))
      }
    case "StartTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.StartTime = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.StudentPersonalRefId = ((*String)(v))
      }
    case "System":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolSystemType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolSystemType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.napeventstudentlink.System = ((*AUCodeSetsSchoolSystemType)(v))
      }
    case "TestDisruptionList":
    if v, ok:= TestDisruptionListTypePointer(value); ok {
      n.napeventstudentlink.TestDisruptionList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPEventStudentLink")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) Adjustment() *AdjustmentContainerType {
    if s.napeventstudentlink.Adjustment == nil {
     if v, ok:= AdjustmentContainerTypePointer(AdjustmentContainerType{}); ok {
      s.napeventstudentlink.Adjustment = v
      }
      }
      return s.napeventstudentlink.Adjustment
    }
// Returns whether the element value for Adjustment is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) Adjustment_IsNil() bool {
    return s.napeventstudentlink.Adjustment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) DOBRange() *Bool {
    if s.napeventstudentlink.DOBRange == nil {
    if v, ok:= BoolPointer(false); ok {
      s.napeventstudentlink.DOBRange = ((*Bool)(v))
      }
      }
      return s.napeventstudentlink.DOBRange
    }
// Returns whether the element value for DOBRange is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) DOBRange_IsNil() bool {
    return s.napeventstudentlink.DOBRange == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) Date() *String {
    if s.napeventstudentlink.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.Date = ((*String)(v))
      }
      }
      return s.napeventstudentlink.Date
    }
// Returns whether the element value for Date is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) Date_IsNil() bool {
    return s.napeventstudentlink.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) Device() *String {
    if s.napeventstudentlink.Device == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.Device = ((*String)(v))
      }
      }
      return s.napeventstudentlink.Device
    }
// Returns whether the element value for Device is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) Device_IsNil() bool {
    return s.napeventstudentlink.Device == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) ExemptionReason() *String {
    if s.napeventstudentlink.ExemptionReason == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.ExemptionReason = ((*String)(v))
      }
      }
      return s.napeventstudentlink.ExemptionReason
    }
// Returns whether the element value for ExemptionReason is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) ExemptionReason_IsNil() bool {
    return s.napeventstudentlink.ExemptionReason == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) LapsedTimeTest() *String {
    if s.napeventstudentlink.LapsedTimeTest == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.LapsedTimeTest = ((*String)(v))
      }
      }
      return s.napeventstudentlink.LapsedTimeTest
    }
// Returns whether the element value for LapsedTimeTest is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) LapsedTimeTest_IsNil() bool {
    return s.napeventstudentlink.LapsedTimeTest == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) LocalCodeList() *LocalCodeListType {
    if s.napeventstudentlink.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.napeventstudentlink.LocalCodeList = v
      }
      }
      return s.napeventstudentlink.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) LocalCodeList_IsNil() bool {
    return s.napeventstudentlink.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) NAPJurisdiction() *AUCodeSetsNAPJurisdictionType {
    if s.napeventstudentlink.NAPJurisdiction == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.NAPJurisdiction = ((*AUCodeSetsNAPJurisdictionType)(v))
      }
      }
      return s.napeventstudentlink.NAPJurisdiction
    }
// Returns whether the element value for NAPJurisdiction is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) NAPJurisdiction_IsNil() bool {
    return s.napeventstudentlink.NAPJurisdiction == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) NAPTestLocalId() *LocalIdType {
    if s.napeventstudentlink.NAPTestLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.NAPTestLocalId = ((*LocalIdType)(v))
      }
      }
      return s.napeventstudentlink.NAPTestLocalId
    }
// Returns whether the element value for NAPTestLocalId is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) NAPTestLocalId_IsNil() bool {
    return s.napeventstudentlink.NAPTestLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) NAPTestRefId() *String {
    if s.napeventstudentlink.NAPTestRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.NAPTestRefId = ((*String)(v))
      }
      }
      return s.napeventstudentlink.NAPTestRefId
    }
// Returns whether the element value for NAPTestRefId is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) NAPTestRefId_IsNil() bool {
    return s.napeventstudentlink.NAPTestRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) PSIOtherIdMatch() *Bool {
    if s.napeventstudentlink.PSIOtherIdMatch == nil {
    if v, ok:= BoolPointer(false); ok {
      s.napeventstudentlink.PSIOtherIdMatch = ((*Bool)(v))
      }
      }
      return s.napeventstudentlink.PSIOtherIdMatch
    }
// Returns whether the element value for PSIOtherIdMatch is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) PSIOtherIdMatch_IsNil() bool {
    return s.napeventstudentlink.PSIOtherIdMatch == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) ParticipationCode() *AUCodeSetsNAPParticipationCodeType {
    if s.napeventstudentlink.ParticipationCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.ParticipationCode = ((*AUCodeSetsNAPParticipationCodeType)(v))
      }
      }
      return s.napeventstudentlink.ParticipationCode
    }
// Returns whether the element value for ParticipationCode is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) ParticipationCode_IsNil() bool {
    return s.napeventstudentlink.ParticipationCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) ParticipationText() *String {
    if s.napeventstudentlink.ParticipationText == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.ParticipationText = ((*String)(v))
      }
      }
      return s.napeventstudentlink.ParticipationText
    }
// Returns whether the element value for ParticipationText is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) ParticipationText_IsNil() bool {
    return s.napeventstudentlink.ParticipationText == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) PersonalDetailsChanged() *Bool {
    if s.napeventstudentlink.PersonalDetailsChanged == nil {
    if v, ok:= BoolPointer(false); ok {
      s.napeventstudentlink.PersonalDetailsChanged = ((*Bool)(v))
      }
      }
      return s.napeventstudentlink.PersonalDetailsChanged
    }
// Returns whether the element value for PersonalDetailsChanged is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) PersonalDetailsChanged_IsNil() bool {
    return s.napeventstudentlink.PersonalDetailsChanged == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) PlatformStudentIdentifier() *LocalIdType {
    if s.napeventstudentlink.PlatformStudentIdentifier == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.PlatformStudentIdentifier = ((*LocalIdType)(v))
      }
      }
      return s.napeventstudentlink.PlatformStudentIdentifier
    }
// Returns whether the element value for PlatformStudentIdentifier is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) PlatformStudentIdentifier_IsNil() bool {
    return s.napeventstudentlink.PlatformStudentIdentifier == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) PossibleDuplicate() *Bool {
    if s.napeventstudentlink.PossibleDuplicate == nil {
    if v, ok:= BoolPointer(false); ok {
      s.napeventstudentlink.PossibleDuplicate = ((*Bool)(v))
      }
      }
      return s.napeventstudentlink.PossibleDuplicate
    }
// Returns whether the element value for PossibleDuplicate is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) PossibleDuplicate_IsNil() bool {
    return s.napeventstudentlink.PossibleDuplicate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) RefId() *RefIdType {
    if s.napeventstudentlink.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.RefId = ((*RefIdType)(v))
      }
      }
      return s.napeventstudentlink.RefId
    }
// Returns whether the element value for RefId is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) RefId_IsNil() bool {
    return s.napeventstudentlink.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) ReportingSchoolName() *String {
    if s.napeventstudentlink.ReportingSchoolName == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.ReportingSchoolName = ((*String)(v))
      }
      }
      return s.napeventstudentlink.ReportingSchoolName
    }
// Returns whether the element value for ReportingSchoolName is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) ReportingSchoolName_IsNil() bool {
    return s.napeventstudentlink.ReportingSchoolName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.napeventstudentlink.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.napeventstudentlink.SIF_ExtendedElements = v
      }
      }
      return s.napeventstudentlink.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) SIF_ExtendedElements_IsNil() bool {
    return s.napeventstudentlink.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) SIF_Metadata() *SIF_MetadataType {
    if s.napeventstudentlink.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.napeventstudentlink.SIF_Metadata = v
      }
      }
      return s.napeventstudentlink.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) SIF_Metadata_IsNil() bool {
    return s.napeventstudentlink.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) SchoolACARAId() *LocalIdType {
    if s.napeventstudentlink.SchoolACARAId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.SchoolACARAId = ((*LocalIdType)(v))
      }
      }
      return s.napeventstudentlink.SchoolACARAId
    }
// Returns whether the element value for SchoolACARAId is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) SchoolACARAId_IsNil() bool {
    return s.napeventstudentlink.SchoolACARAId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) SchoolGeolocation() *AUCodeSetsSchoolLocationType {
    if s.napeventstudentlink.SchoolGeolocation == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.SchoolGeolocation = ((*AUCodeSetsSchoolLocationType)(v))
      }
      }
      return s.napeventstudentlink.SchoolGeolocation
    }
// Returns whether the element value for SchoolGeolocation is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) SchoolGeolocation_IsNil() bool {
    return s.napeventstudentlink.SchoolGeolocation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) SchoolInfoRefId() *String {
    if s.napeventstudentlink.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.napeventstudentlink.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) SchoolInfoRefId_IsNil() bool {
    return s.napeventstudentlink.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) SchoolSector() *AUCodeSetsSchoolSectorCodeType {
    if s.napeventstudentlink.SchoolSector == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.SchoolSector = ((*AUCodeSetsSchoolSectorCodeType)(v))
      }
      }
      return s.napeventstudentlink.SchoolSector
    }
// Returns whether the element value for SchoolSector is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) SchoolSector_IsNil() bool {
    return s.napeventstudentlink.SchoolSector == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) StartTime() *String {
    if s.napeventstudentlink.StartTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.StartTime = ((*String)(v))
      }
      }
      return s.napeventstudentlink.StartTime
    }
// Returns whether the element value for StartTime is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) StartTime_IsNil() bool {
    return s.napeventstudentlink.StartTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) StudentPersonalRefId() *String {
    if s.napeventstudentlink.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.napeventstudentlink.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) StudentPersonalRefId_IsNil() bool {
    return s.napeventstudentlink.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) System() *AUCodeSetsSchoolSystemType {
    if s.napeventstudentlink.System == nil {
    if v, ok:= StringPointer(""); ok {
      s.napeventstudentlink.System = ((*AUCodeSetsSchoolSystemType)(v))
      }
      }
      return s.napeventstudentlink.System
    }
// Returns whether the element value for System is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) System_IsNil() bool {
    return s.napeventstudentlink.System == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPEventStudentLink) TestDisruptionList() *TestDisruptionListType {
    if s.napeventstudentlink.TestDisruptionList == nil {
     if v, ok:= TestDisruptionListTypePointer(TestDisruptionListType{}); ok {
      s.napeventstudentlink.TestDisruptionList = v
      }
      }
      return s.napeventstudentlink.TestDisruptionList
    }
// Returns whether the element value for TestDisruptionList is nil in the container NAPEventStudentLink.
  func (s *NAPEventStudentLink) TestDisruptionList_IsNil() bool {
    return s.napeventstudentlink.TestDisruptionList == nil
    }

// Set the value of a property to nil
func (n *NAPLANScoreType) Unset(key string) *NAPLANScoreType {
        switch key {
  case "Domain":
   n.naplanscoretype.Domain = nil
  case "DomainScore":
   n.naplanscoretype.DomainScore = nil
  case "ParticipationCode":
   n.naplanscoretype.ParticipationCode = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPLANScoreType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPLANScoreType) SetProperties(props ...Prop) *NAPLANScoreType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPLANScoreType) SetProperty(key string, value interface{}) *NAPLANScoreType {
        if n == nil {
                n, _ = NAPLANScoreTypePointer(NAPLANScoreType{})
        }
        switch key {
    case "Domain":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPTestDomainType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPTestDomainType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naplanscoretype.Domain = ((*AUCodeSetsNAPTestDomainType)(v))
      }
    case "DomainScore":
    if v, ok:= DomainScoreTypePointer(value); ok {
      n.naplanscoretype.DomainScore = v
      }
    case "ParticipationCode":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPParticipationCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPParticipationCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naplanscoretype.ParticipationCode = ((*AUCodeSetsNAPParticipationCodeType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPLANScoreType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPLANScoreType) Domain() *AUCodeSetsNAPTestDomainType {
    if s.naplanscoretype.Domain == nil {
    if v, ok:= StringPointer(""); ok {
      s.naplanscoretype.Domain = ((*AUCodeSetsNAPTestDomainType)(v))
      }
      }
      return s.naplanscoretype.Domain
    }
// Returns whether the element value for Domain is nil in the container NAPLANScoreType.
  func (s *NAPLANScoreType) Domain_IsNil() bool {
    return s.naplanscoretype.Domain == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPLANScoreType) DomainScore() *DomainScoreType {
    if s.naplanscoretype.DomainScore == nil {
     if v, ok:= DomainScoreTypePointer(DomainScoreType{}); ok {
      s.naplanscoretype.DomainScore = v
      }
      }
      return s.naplanscoretype.DomainScore
    }
// Returns whether the element value for DomainScore is nil in the container NAPLANScoreType.
  func (s *NAPLANScoreType) DomainScore_IsNil() bool {
    return s.naplanscoretype.DomainScore == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPLANScoreType) ParticipationCode() *AUCodeSetsNAPParticipationCodeType {
    if s.naplanscoretype.ParticipationCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.naplanscoretype.ParticipationCode = ((*AUCodeSetsNAPParticipationCodeType)(v))
      }
      }
      return s.naplanscoretype.ParticipationCode
    }
// Returns whether the element value for ParticipationCode is nil in the container NAPLANScoreType.
  func (s *NAPLANScoreType) ParticipationCode_IsNil() bool {
    return s.naplanscoretype.ParticipationCode == nil
    }

// Set the value of a property to nil
func (n *NAPLANScoreWithYearsType) Unset(key string) *NAPLANScoreWithYearsType {
        switch key {
  case "Domain":
   n.naplanscorewithyearstype.Domain = nil
  case "DomainScore":
   n.naplanscorewithyearstype.DomainScore = nil
  case "ParticipationCode":
   n.naplanscorewithyearstype.ParticipationCode = nil
  case "TestLevel":
   n.naplanscorewithyearstype.TestLevel = nil
  case "TestYear":
   n.naplanscorewithyearstype.TestYear = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPLANScoreWithYearsType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPLANScoreWithYearsType) SetProperties(props ...Prop) *NAPLANScoreWithYearsType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPLANScoreWithYearsType) SetProperty(key string, value interface{}) *NAPLANScoreWithYearsType {
        if n == nil {
                n, _ = NAPLANScoreWithYearsTypePointer(NAPLANScoreWithYearsType{})
        }
        switch key {
    case "Domain":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPTestDomainType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPTestDomainType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naplanscorewithyearstype.Domain = ((*AUCodeSetsNAPTestDomainType)(v))
      }
    case "DomainScore":
    if v, ok:= DomainScoreSDTNTypePointer(value); ok {
      n.naplanscorewithyearstype.DomainScore = v
      }
    case "ParticipationCode":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPParticipationCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPParticipationCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naplanscorewithyearstype.ParticipationCode = ((*AUCodeSetsNAPParticipationCodeType)(v))
      }
    case "TestLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.naplanscorewithyearstype.TestLevel = v
      }
    case "TestYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naplanscorewithyearstype.TestYear = ((*SchoolYearType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPLANScoreWithYearsType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPLANScoreWithYearsType) Domain() *AUCodeSetsNAPTestDomainType {
    if s.naplanscorewithyearstype.Domain == nil {
    if v, ok:= StringPointer(""); ok {
      s.naplanscorewithyearstype.Domain = ((*AUCodeSetsNAPTestDomainType)(v))
      }
      }
      return s.naplanscorewithyearstype.Domain
    }
// Returns whether the element value for Domain is nil in the container NAPLANScoreWithYearsType.
  func (s *NAPLANScoreWithYearsType) Domain_IsNil() bool {
    return s.naplanscorewithyearstype.Domain == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPLANScoreWithYearsType) DomainScore() *DomainScoreSDTNType {
    if s.naplanscorewithyearstype.DomainScore == nil {
     if v, ok:= DomainScoreSDTNTypePointer(DomainScoreSDTNType{}); ok {
      s.naplanscorewithyearstype.DomainScore = v
      }
      }
      return s.naplanscorewithyearstype.DomainScore
    }
// Returns whether the element value for DomainScore is nil in the container NAPLANScoreWithYearsType.
  func (s *NAPLANScoreWithYearsType) DomainScore_IsNil() bool {
    return s.naplanscorewithyearstype.DomainScore == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPLANScoreWithYearsType) ParticipationCode() *AUCodeSetsNAPParticipationCodeType {
    if s.naplanscorewithyearstype.ParticipationCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.naplanscorewithyearstype.ParticipationCode = ((*AUCodeSetsNAPParticipationCodeType)(v))
      }
      }
      return s.naplanscorewithyearstype.ParticipationCode
    }
// Returns whether the element value for ParticipationCode is nil in the container NAPLANScoreWithYearsType.
  func (s *NAPLANScoreWithYearsType) ParticipationCode_IsNil() bool {
    return s.naplanscorewithyearstype.ParticipationCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPLANScoreWithYearsType) TestLevel() *YearLevelType {
    if s.naplanscorewithyearstype.TestLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.naplanscorewithyearstype.TestLevel = v
      }
      }
      return s.naplanscorewithyearstype.TestLevel
    }
// Returns whether the element value for TestLevel is nil in the container NAPLANScoreWithYearsType.
  func (s *NAPLANScoreWithYearsType) TestLevel_IsNil() bool {
    return s.naplanscorewithyearstype.TestLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPLANScoreWithYearsType) TestYear() *SchoolYearType {
    if s.naplanscorewithyearstype.TestYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.naplanscorewithyearstype.TestYear = ((*SchoolYearType)(v))
      }
      }
      return s.naplanscorewithyearstype.TestYear
    }
// Returns whether the element value for TestYear is nil in the container NAPLANScoreWithYearsType.
  func (s *NAPLANScoreWithYearsType) TestYear_IsNil() bool {
    return s.naplanscorewithyearstype.TestYear == nil
    }

// Set the value of a property to nil
func (n *NAPStudentResponseSet) Unset(key string) *NAPStudentResponseSet {
        switch key {
  case "CalibrationSampleFlag":
   n.napstudentresponseset.CalibrationSampleFlag = nil
  case "DomainScore":
   n.napstudentresponseset.DomainScore = nil
  case "EquatingSampleFlag":
   n.napstudentresponseset.EquatingSampleFlag = nil
  case "LocalCodeList":
   n.napstudentresponseset.LocalCodeList = nil
  case "NAPTestLocalId":
   n.napstudentresponseset.NAPTestLocalId = nil
  case "NAPTestRefId":
   n.napstudentresponseset.NAPTestRefId = nil
  case "ParallelTest":
   n.napstudentresponseset.ParallelTest = nil
  case "PathTakenForDomain":
   n.napstudentresponseset.PathTakenForDomain = nil
  case "PlatformStudentIdentifier":
   n.napstudentresponseset.PlatformStudentIdentifier = nil
  case "RefId":
   n.napstudentresponseset.RefId = nil
  case "ReportExclusionFlag":
   n.napstudentresponseset.ReportExclusionFlag = nil
  case "SIF_ExtendedElements":
   n.napstudentresponseset.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.napstudentresponseset.SIF_Metadata = nil
  case "StudentPersonalRefId":
   n.napstudentresponseset.StudentPersonalRefId = nil
  case "TestletList":
   n.napstudentresponseset.TestletList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPStudentResponseSet")
        }
        return n
}

// Set a sequence of properties
func (n *NAPStudentResponseSet) SetProperties(props ...Prop) *NAPStudentResponseSet {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPStudentResponseSet) SetProperty(key string, value interface{}) *NAPStudentResponseSet {
        if n == nil {
                n, _ = NAPStudentResponseSetPointer(NAPStudentResponseSet{})
        }
        switch key {
    case "CalibrationSampleFlag":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napstudentresponseset.CalibrationSampleFlag = ((*String)(v))
      }
    case "DomainScore":
    if v, ok:= DomainScoreTypePointer(value); ok {
      n.napstudentresponseset.DomainScore = v
      }
    case "EquatingSampleFlag":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napstudentresponseset.EquatingSampleFlag = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.napstudentresponseset.LocalCodeList = v
      }
    case "NAPTestLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napstudentresponseset.NAPTestLocalId = ((*LocalIdType)(v))
      }
    case "NAPTestRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napstudentresponseset.NAPTestRefId = ((*String)(v))
      }
    case "ParallelTest":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napstudentresponseset.ParallelTest = ((*String)(v))
      }
    case "PathTakenForDomain":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napstudentresponseset.PathTakenForDomain = ((*String)(v))
      }
    case "PlatformStudentIdentifier":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napstudentresponseset.PlatformStudentIdentifier = ((*LocalIdType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napstudentresponseset.RefId = ((*RefIdType)(v))
      }
    case "ReportExclusionFlag":
    
    if v, ok:= BoolPointer(value); ok {
      n.napstudentresponseset.ReportExclusionFlag = ((*Bool)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.napstudentresponseset.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.napstudentresponseset.SIF_Metadata = v
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napstudentresponseset.StudentPersonalRefId = ((*String)(v))
      }
    case "TestletList":
    if v, ok:= NAPStudentResponseTestletListTypePointer(value); ok {
      n.napstudentresponseset.TestletList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPStudentResponseSet")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) CalibrationSampleFlag() *String {
    if s.napstudentresponseset.CalibrationSampleFlag == nil {
    if v, ok:= StringPointer(""); ok {
      s.napstudentresponseset.CalibrationSampleFlag = ((*String)(v))
      }
      }
      return s.napstudentresponseset.CalibrationSampleFlag
    }
// Returns whether the element value for CalibrationSampleFlag is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) CalibrationSampleFlag_IsNil() bool {
    return s.napstudentresponseset.CalibrationSampleFlag == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) DomainScore() *DomainScoreType {
    if s.napstudentresponseset.DomainScore == nil {
     if v, ok:= DomainScoreTypePointer(DomainScoreType{}); ok {
      s.napstudentresponseset.DomainScore = v
      }
      }
      return s.napstudentresponseset.DomainScore
    }
// Returns whether the element value for DomainScore is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) DomainScore_IsNil() bool {
    return s.napstudentresponseset.DomainScore == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) EquatingSampleFlag() *String {
    if s.napstudentresponseset.EquatingSampleFlag == nil {
    if v, ok:= StringPointer(""); ok {
      s.napstudentresponseset.EquatingSampleFlag = ((*String)(v))
      }
      }
      return s.napstudentresponseset.EquatingSampleFlag
    }
// Returns whether the element value for EquatingSampleFlag is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) EquatingSampleFlag_IsNil() bool {
    return s.napstudentresponseset.EquatingSampleFlag == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) LocalCodeList() *LocalCodeListType {
    if s.napstudentresponseset.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.napstudentresponseset.LocalCodeList = v
      }
      }
      return s.napstudentresponseset.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) LocalCodeList_IsNil() bool {
    return s.napstudentresponseset.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) NAPTestLocalId() *LocalIdType {
    if s.napstudentresponseset.NAPTestLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napstudentresponseset.NAPTestLocalId = ((*LocalIdType)(v))
      }
      }
      return s.napstudentresponseset.NAPTestLocalId
    }
// Returns whether the element value for NAPTestLocalId is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) NAPTestLocalId_IsNil() bool {
    return s.napstudentresponseset.NAPTestLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) NAPTestRefId() *String {
    if s.napstudentresponseset.NAPTestRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napstudentresponseset.NAPTestRefId = ((*String)(v))
      }
      }
      return s.napstudentresponseset.NAPTestRefId
    }
// Returns whether the element value for NAPTestRefId is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) NAPTestRefId_IsNil() bool {
    return s.napstudentresponseset.NAPTestRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) ParallelTest() *String {
    if s.napstudentresponseset.ParallelTest == nil {
    if v, ok:= StringPointer(""); ok {
      s.napstudentresponseset.ParallelTest = ((*String)(v))
      }
      }
      return s.napstudentresponseset.ParallelTest
    }
// Returns whether the element value for ParallelTest is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) ParallelTest_IsNil() bool {
    return s.napstudentresponseset.ParallelTest == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) PathTakenForDomain() *String {
    if s.napstudentresponseset.PathTakenForDomain == nil {
    if v, ok:= StringPointer(""); ok {
      s.napstudentresponseset.PathTakenForDomain = ((*String)(v))
      }
      }
      return s.napstudentresponseset.PathTakenForDomain
    }
// Returns whether the element value for PathTakenForDomain is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) PathTakenForDomain_IsNil() bool {
    return s.napstudentresponseset.PathTakenForDomain == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) PlatformStudentIdentifier() *LocalIdType {
    if s.napstudentresponseset.PlatformStudentIdentifier == nil {
    if v, ok:= StringPointer(""); ok {
      s.napstudentresponseset.PlatformStudentIdentifier = ((*LocalIdType)(v))
      }
      }
      return s.napstudentresponseset.PlatformStudentIdentifier
    }
// Returns whether the element value for PlatformStudentIdentifier is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) PlatformStudentIdentifier_IsNil() bool {
    return s.napstudentresponseset.PlatformStudentIdentifier == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) RefId() *RefIdType {
    if s.napstudentresponseset.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napstudentresponseset.RefId = ((*RefIdType)(v))
      }
      }
      return s.napstudentresponseset.RefId
    }
// Returns whether the element value for RefId is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) RefId_IsNil() bool {
    return s.napstudentresponseset.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) ReportExclusionFlag() *Bool {
    if s.napstudentresponseset.ReportExclusionFlag == nil {
    if v, ok:= BoolPointer(false); ok {
      s.napstudentresponseset.ReportExclusionFlag = ((*Bool)(v))
      }
      }
      return s.napstudentresponseset.ReportExclusionFlag
    }
// Returns whether the element value for ReportExclusionFlag is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) ReportExclusionFlag_IsNil() bool {
    return s.napstudentresponseset.ReportExclusionFlag == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.napstudentresponseset.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.napstudentresponseset.SIF_ExtendedElements = v
      }
      }
      return s.napstudentresponseset.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) SIF_ExtendedElements_IsNil() bool {
    return s.napstudentresponseset.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) SIF_Metadata() *SIF_MetadataType {
    if s.napstudentresponseset.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.napstudentresponseset.SIF_Metadata = v
      }
      }
      return s.napstudentresponseset.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) SIF_Metadata_IsNil() bool {
    return s.napstudentresponseset.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) StudentPersonalRefId() *String {
    if s.napstudentresponseset.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.napstudentresponseset.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.napstudentresponseset.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) StudentPersonalRefId_IsNil() bool {
    return s.napstudentresponseset.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPStudentResponseSet) TestletList() *NAPStudentResponseTestletListType {
    if s.napstudentresponseset.TestletList == nil {
     if v, ok:= NAPStudentResponseTestletListTypePointer(NAPStudentResponseTestletListType{}); ok {
      s.napstudentresponseset.TestletList = v
      }
      }
      return s.napstudentresponseset.TestletList
    }
// Returns whether the element value for TestletList is nil in the container NAPStudentResponseSet.
  func (s *NAPStudentResponseSet) TestletList_IsNil() bool {
    return s.napstudentresponseset.TestletList == nil
    }

// Set the value of a property to nil
func (n *NAPSubscoreType) Unset(key string) *NAPSubscoreType {
        switch key {
  case "SubscoreType":
   n.napsubscoretype.SubscoreType = nil
  case "SubscoreValue":
   n.napsubscoretype.SubscoreValue = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPSubscoreType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPSubscoreType) SetProperties(props ...Prop) *NAPSubscoreType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPSubscoreType) SetProperty(key string, value interface{}) *NAPSubscoreType {
        if n == nil {
                n, _ = NAPSubscoreTypePointer(NAPSubscoreType{})
        }
        switch key {
    case "SubscoreType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napsubscoretype.SubscoreType = ((*String)(v))
      }
    case "SubscoreValue":
    
    if v, ok:= FloatPointer(value); ok {
      n.napsubscoretype.SubscoreValue = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPSubscoreType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPSubscoreType) SubscoreType() *String {
    if s.napsubscoretype.SubscoreType == nil {
    if v, ok:= StringPointer(""); ok {
      s.napsubscoretype.SubscoreType = ((*String)(v))
      }
      }
      return s.napsubscoretype.SubscoreType
    }
// Returns whether the element value for SubscoreType is nil in the container NAPSubscoreType.
  func (s *NAPSubscoreType) SubscoreType_IsNil() bool {
    return s.napsubscoretype.SubscoreType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPSubscoreType) SubscoreValue() *Float {
    if s.napsubscoretype.SubscoreValue == nil {
    if v, ok:= FloatPointer(0); ok {
      s.napsubscoretype.SubscoreValue = ((*Float)(v))
      }
      }
      return s.napsubscoretype.SubscoreValue
    }
// Returns whether the element value for SubscoreValue is nil in the container NAPSubscoreType.
  func (s *NAPSubscoreType) SubscoreValue_IsNil() bool {
    return s.napsubscoretype.SubscoreValue == nil
    }

// Set the value of a property to nil
func (n *NAPTest) Unset(key string) *NAPTest {
        switch key {
  case "LocalCodeList":
   n.naptest.LocalCodeList = nil
  case "RefId":
   n.naptest.RefId = nil
  case "SIF_ExtendedElements":
   n.naptest.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.naptest.SIF_Metadata = nil
  case "TestContent":
   n.naptest.TestContent = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTest")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTest) SetProperties(props ...Prop) *NAPTest {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTest) SetProperty(key string, value interface{}) *NAPTest {
        if n == nil {
                n, _ = NAPTestPointer(NAPTest{})
        }
        switch key {
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.naptest.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptest.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.naptest.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.naptest.SIF_Metadata = v
      }
    case "TestContent":
    if v, ok:= NAPTestContentTypePointer(value); ok {
      n.naptest.TestContent = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTest")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTest) LocalCodeList() *LocalCodeListType {
    if s.naptest.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.naptest.LocalCodeList = v
      }
      }
      return s.naptest.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container NAPTest.
  func (s *NAPTest) LocalCodeList_IsNil() bool {
    return s.naptest.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTest) RefId() *RefIdType {
    if s.naptest.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptest.RefId = ((*RefIdType)(v))
      }
      }
      return s.naptest.RefId
    }
// Returns whether the element value for RefId is nil in the container NAPTest.
  func (s *NAPTest) RefId_IsNil() bool {
    return s.naptest.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTest) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.naptest.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.naptest.SIF_ExtendedElements = v
      }
      }
      return s.naptest.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container NAPTest.
  func (s *NAPTest) SIF_ExtendedElements_IsNil() bool {
    return s.naptest.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTest) SIF_Metadata() *SIF_MetadataType {
    if s.naptest.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.naptest.SIF_Metadata = v
      }
      }
      return s.naptest.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container NAPTest.
  func (s *NAPTest) SIF_Metadata_IsNil() bool {
    return s.naptest.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTest) TestContent() *NAPTestContentType {
    if s.naptest.TestContent == nil {
     if v, ok:= NAPTestContentTypePointer(NAPTestContentType{}); ok {
      s.naptest.TestContent = v
      }
      }
      return s.naptest.TestContent
    }
// Returns whether the element value for TestContent is nil in the container NAPTest.
  func (s *NAPTest) TestContent_IsNil() bool {
    return s.naptest.TestContent == nil
    }

// Set the value of a property to nil
func (n *NAPTestContentType) Unset(key string) *NAPTestContentType {
        switch key {
  case "Domain":
   n.naptestcontenttype.Domain = nil
  case "DomainBands":
   n.naptestcontenttype.DomainBands = nil
  case "DomainProficiency":
   n.naptestcontenttype.DomainProficiency = nil
  case "NAPTestLocalId":
   n.naptestcontenttype.NAPTestLocalId = nil
  case "StagesCount":
   n.naptestcontenttype.StagesCount = nil
  case "TestLevel":
   n.naptestcontenttype.TestLevel = nil
  case "TestName":
   n.naptestcontenttype.TestName = nil
  case "TestType":
   n.naptestcontenttype.TestType = nil
  case "TestYear":
   n.naptestcontenttype.TestYear = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestContentType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestContentType) SetProperties(props ...Prop) *NAPTestContentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestContentType) SetProperty(key string, value interface{}) *NAPTestContentType {
        if n == nil {
                n, _ = NAPTestContentTypePointer(NAPTestContentType{})
        }
        switch key {
    case "Domain":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPTestDomainType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPTestDomainType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naptestcontenttype.Domain = ((*AUCodeSetsNAPTestDomainType)(v))
      }
    case "DomainBands":
    if v, ok:= DomainBandsContainerTypePointer(value); ok {
      n.naptestcontenttype.DomainBands = v
      }
    case "DomainProficiency":
    if v, ok:= DomainProficiencyContainerTypePointer(value); ok {
      n.naptestcontenttype.DomainProficiency = v
      }
    case "NAPTestLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestcontenttype.NAPTestLocalId = ((*LocalIdType)(v))
      }
    case "StagesCount":
    
    if v, ok:= IntPointer(value); ok {
      n.naptestcontenttype.StagesCount = ((*Int)(v))
      }
    case "TestLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.naptestcontenttype.TestLevel = v
      }
    case "TestName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestcontenttype.TestName = ((*String)(v))
      }
    case "TestType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPTestTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPTestTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naptestcontenttype.TestType = ((*AUCodeSetsNAPTestTypeType)(v))
      }
    case "TestYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestcontenttype.TestYear = ((*SchoolYearType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestContentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestContentType) Domain() *AUCodeSetsNAPTestDomainType {
    if s.naptestcontenttype.Domain == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestcontenttype.Domain = ((*AUCodeSetsNAPTestDomainType)(v))
      }
      }
      return s.naptestcontenttype.Domain
    }
// Returns whether the element value for Domain is nil in the container NAPTestContentType.
  func (s *NAPTestContentType) Domain_IsNil() bool {
    return s.naptestcontenttype.Domain == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestContentType) DomainBands() *DomainBandsContainerType {
    if s.naptestcontenttype.DomainBands == nil {
     if v, ok:= DomainBandsContainerTypePointer(DomainBandsContainerType{}); ok {
      s.naptestcontenttype.DomainBands = v
      }
      }
      return s.naptestcontenttype.DomainBands
    }
// Returns whether the element value for DomainBands is nil in the container NAPTestContentType.
  func (s *NAPTestContentType) DomainBands_IsNil() bool {
    return s.naptestcontenttype.DomainBands == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestContentType) DomainProficiency() *DomainProficiencyContainerType {
    if s.naptestcontenttype.DomainProficiency == nil {
     if v, ok:= DomainProficiencyContainerTypePointer(DomainProficiencyContainerType{}); ok {
      s.naptestcontenttype.DomainProficiency = v
      }
      }
      return s.naptestcontenttype.DomainProficiency
    }
// Returns whether the element value for DomainProficiency is nil in the container NAPTestContentType.
  func (s *NAPTestContentType) DomainProficiency_IsNil() bool {
    return s.naptestcontenttype.DomainProficiency == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestContentType) NAPTestLocalId() *LocalIdType {
    if s.naptestcontenttype.NAPTestLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestcontenttype.NAPTestLocalId = ((*LocalIdType)(v))
      }
      }
      return s.naptestcontenttype.NAPTestLocalId
    }
// Returns whether the element value for NAPTestLocalId is nil in the container NAPTestContentType.
  func (s *NAPTestContentType) NAPTestLocalId_IsNil() bool {
    return s.naptestcontenttype.NAPTestLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestContentType) StagesCount() *Int {
    if s.naptestcontenttype.StagesCount == nil {
    if v, ok:= IntPointer(0); ok {
      s.naptestcontenttype.StagesCount = ((*Int)(v))
      }
      }
      return s.naptestcontenttype.StagesCount
    }
// Returns whether the element value for StagesCount is nil in the container NAPTestContentType.
  func (s *NAPTestContentType) StagesCount_IsNil() bool {
    return s.naptestcontenttype.StagesCount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestContentType) TestLevel() *YearLevelType {
    if s.naptestcontenttype.TestLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.naptestcontenttype.TestLevel = v
      }
      }
      return s.naptestcontenttype.TestLevel
    }
// Returns whether the element value for TestLevel is nil in the container NAPTestContentType.
  func (s *NAPTestContentType) TestLevel_IsNil() bool {
    return s.naptestcontenttype.TestLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestContentType) TestName() *String {
    if s.naptestcontenttype.TestName == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestcontenttype.TestName = ((*String)(v))
      }
      }
      return s.naptestcontenttype.TestName
    }
// Returns whether the element value for TestName is nil in the container NAPTestContentType.
  func (s *NAPTestContentType) TestName_IsNil() bool {
    return s.naptestcontenttype.TestName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestContentType) TestType() *AUCodeSetsNAPTestTypeType {
    if s.naptestcontenttype.TestType == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestcontenttype.TestType = ((*AUCodeSetsNAPTestTypeType)(v))
      }
      }
      return s.naptestcontenttype.TestType
    }
// Returns whether the element value for TestType is nil in the container NAPTestContentType.
  func (s *NAPTestContentType) TestType_IsNil() bool {
    return s.naptestcontenttype.TestType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestContentType) TestYear() *SchoolYearType {
    if s.naptestcontenttype.TestYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestcontenttype.TestYear = ((*SchoolYearType)(v))
      }
      }
      return s.naptestcontenttype.TestYear
    }
// Returns whether the element value for TestYear is nil in the container NAPTestContentType.
  func (s *NAPTestContentType) TestYear_IsNil() bool {
    return s.naptestcontenttype.TestYear == nil
    }

// Set the value of a property to nil
func (n *NAPTestItem) Unset(key string) *NAPTestItem {
        switch key {
  case "LocalCodeList":
   n.naptestitem.LocalCodeList = nil
  case "RefId":
   n.naptestitem.RefId = nil
  case "SIF_ExtendedElements":
   n.naptestitem.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.naptestitem.SIF_Metadata = nil
  case "TestItemContent":
   n.naptestitem.TestItemContent = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestItem")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestItem) SetProperties(props ...Prop) *NAPTestItem {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestItem) SetProperty(key string, value interface{}) *NAPTestItem {
        if n == nil {
                n, _ = NAPTestItemPointer(NAPTestItem{})
        }
        switch key {
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.naptestitem.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitem.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.naptestitem.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.naptestitem.SIF_Metadata = v
      }
    case "TestItemContent":
    if v, ok:= NAPTestItemContentTypePointer(value); ok {
      n.naptestitem.TestItemContent = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestItem")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItem) LocalCodeList() *LocalCodeListType {
    if s.naptestitem.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.naptestitem.LocalCodeList = v
      }
      }
      return s.naptestitem.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container NAPTestItem.
  func (s *NAPTestItem) LocalCodeList_IsNil() bool {
    return s.naptestitem.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItem) RefId() *RefIdType {
    if s.naptestitem.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitem.RefId = ((*RefIdType)(v))
      }
      }
      return s.naptestitem.RefId
    }
// Returns whether the element value for RefId is nil in the container NAPTestItem.
  func (s *NAPTestItem) RefId_IsNil() bool {
    return s.naptestitem.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItem) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.naptestitem.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.naptestitem.SIF_ExtendedElements = v
      }
      }
      return s.naptestitem.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container NAPTestItem.
  func (s *NAPTestItem) SIF_ExtendedElements_IsNil() bool {
    return s.naptestitem.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItem) SIF_Metadata() *SIF_MetadataType {
    if s.naptestitem.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.naptestitem.SIF_Metadata = v
      }
      }
      return s.naptestitem.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container NAPTestItem.
  func (s *NAPTestItem) SIF_Metadata_IsNil() bool {
    return s.naptestitem.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItem) TestItemContent() *NAPTestItemContentType {
    if s.naptestitem.TestItemContent == nil {
     if v, ok:= NAPTestItemContentTypePointer(NAPTestItemContentType{}); ok {
      s.naptestitem.TestItemContent = v
      }
      }
      return s.naptestitem.TestItemContent
    }
// Returns whether the element value for TestItemContent is nil in the container NAPTestItem.
  func (s *NAPTestItem) TestItemContent_IsNil() bool {
    return s.naptestitem.TestItemContent == nil
    }

// Set the value of a property to nil
func (n *NAPTestItem2Type) Unset(key string) *NAPTestItem2Type {
        switch key {
  case "SequenceNumber":
   n.naptestitem2type.SequenceNumber = nil
  case "TestItemLocalId":
   n.naptestitem2type.TestItemLocalId = nil
  case "TestItemRefId":
   n.naptestitem2type.TestItemRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestItem2Type")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestItem2Type) SetProperties(props ...Prop) *NAPTestItem2Type {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestItem2Type) SetProperty(key string, value interface{}) *NAPTestItem2Type {
        if n == nil {
                n, _ = NAPTestItem2TypePointer(NAPTestItem2Type{})
        }
        switch key {
    case "SequenceNumber":
    
    if v, ok:= IntPointer(value); ok {
      n.naptestitem2type.SequenceNumber = ((*Int)(v))
      }
    case "TestItemLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitem2type.TestItemLocalId = ((*LocalIdType)(v))
      }
    case "TestItemRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitem2type.TestItemRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestItem2Type")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItem2Type) SequenceNumber() *Int {
    if s.naptestitem2type.SequenceNumber == nil {
    if v, ok:= IntPointer(0); ok {
      s.naptestitem2type.SequenceNumber = ((*Int)(v))
      }
      }
      return s.naptestitem2type.SequenceNumber
    }
// Returns whether the element value for SequenceNumber is nil in the container NAPTestItem2Type.
  func (s *NAPTestItem2Type) SequenceNumber_IsNil() bool {
    return s.naptestitem2type.SequenceNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItem2Type) TestItemLocalId() *LocalIdType {
    if s.naptestitem2type.TestItemLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitem2type.TestItemLocalId = ((*LocalIdType)(v))
      }
      }
      return s.naptestitem2type.TestItemLocalId
    }
// Returns whether the element value for TestItemLocalId is nil in the container NAPTestItem2Type.
  func (s *NAPTestItem2Type) TestItemLocalId_IsNil() bool {
    return s.naptestitem2type.TestItemLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItem2Type) TestItemRefId() *String {
    if s.naptestitem2type.TestItemRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitem2type.TestItemRefId = ((*String)(v))
      }
      }
      return s.naptestitem2type.TestItemRefId
    }
// Returns whether the element value for TestItemRefId is nil in the container NAPTestItem2Type.
  func (s *NAPTestItem2Type) TestItemRefId_IsNil() bool {
    return s.naptestitem2type.TestItemRefId == nil
    }

// Set the value of a property to nil
func (n *NAPTestItemContentType) Unset(key string) *NAPTestItemContentType {
        switch key {
  case "ContentDescriptionList":
   n.naptestitemcontenttype.ContentDescriptionList = nil
  case "CorrectAnswer":
   n.naptestitemcontenttype.CorrectAnswer = nil
  case "ExemplarURL":
   n.naptestitemcontenttype.ExemplarURL = nil
  case "ItemDescriptor":
   n.naptestitemcontenttype.ItemDescriptor = nil
  case "ItemDifficulty":
   n.naptestitemcontenttype.ItemDifficulty = nil
  case "ItemDifficultyLogit5":
   n.naptestitemcontenttype.ItemDifficultyLogit5 = nil
  case "ItemDifficultyLogit5SE":
   n.naptestitemcontenttype.ItemDifficultyLogit5SE = nil
  case "ItemDifficultyLogit62":
   n.naptestitemcontenttype.ItemDifficultyLogit62 = nil
  case "ItemDifficultyLogit62SE":
   n.naptestitemcontenttype.ItemDifficultyLogit62SE = nil
  case "ItemName":
   n.naptestitemcontenttype.ItemName = nil
  case "ItemProficiencyBand":
   n.naptestitemcontenttype.ItemProficiencyBand = nil
  case "ItemProficiencyLevel":
   n.naptestitemcontenttype.ItemProficiencyLevel = nil
  case "ItemSubstitutedForList":
   n.naptestitemcontenttype.ItemSubstitutedForList = nil
  case "ItemType":
   n.naptestitemcontenttype.ItemType = nil
  case "MarkingType":
   n.naptestitemcontenttype.MarkingType = nil
  case "MaximumScore":
   n.naptestitemcontenttype.MaximumScore = nil
  case "MultipleChoiceOptionCount":
   n.naptestitemcontenttype.MultipleChoiceOptionCount = nil
  case "NAPTestItemLocalId":
   n.naptestitemcontenttype.NAPTestItemLocalId = nil
  case "NAPWritingRubricList":
   n.naptestitemcontenttype.NAPWritingRubricList = nil
  case "ReleasedStatus":
   n.naptestitemcontenttype.ReleasedStatus = nil
  case "StimulusList":
   n.naptestitemcontenttype.StimulusList = nil
  case "Subdomain":
   n.naptestitemcontenttype.Subdomain = nil
  case "WritingGenre":
   n.naptestitemcontenttype.WritingGenre = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestItemContentType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestItemContentType) SetProperties(props ...Prop) *NAPTestItemContentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestItemContentType) SetProperty(key string, value interface{}) *NAPTestItemContentType {
        if n == nil {
                n, _ = NAPTestItemContentTypePointer(NAPTestItemContentType{})
        }
        switch key {
    case "ContentDescriptionList":
    if v, ok:= ContentDescriptionListTypePointer(value); ok {
      n.naptestitemcontenttype.ContentDescriptionList = v
      }
    case "CorrectAnswer":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.CorrectAnswer = ((*String)(v))
      }
    case "ExemplarURL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.ExemplarURL = ((*String)(v))
      }
    case "ItemDescriptor":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.ItemDescriptor = ((*String)(v))
      }
    case "ItemDifficulty":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestitemcontenttype.ItemDifficulty = ((*Float)(v))
      }
    case "ItemDifficultyLogit5":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestitemcontenttype.ItemDifficultyLogit5 = ((*Float)(v))
      }
    case "ItemDifficultyLogit5SE":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestitemcontenttype.ItemDifficultyLogit5SE = ((*Float)(v))
      }
    case "ItemDifficultyLogit62":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestitemcontenttype.ItemDifficultyLogit62 = ((*Float)(v))
      }
    case "ItemDifficultyLogit62SE":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestitemcontenttype.ItemDifficultyLogit62SE = ((*Float)(v))
      }
    case "ItemName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.ItemName = ((*String)(v))
      }
    case "ItemProficiencyBand":
    
    if v, ok:= IntPointer(value); ok {
      n.naptestitemcontenttype.ItemProficiencyBand = ((*Int)(v))
      }
    case "ItemProficiencyLevel":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.ItemProficiencyLevel = ((*String)(v))
      }
    case "ItemSubstitutedForList":
    if v, ok:= SubstituteItemListTypePointer(value); ok {
      n.naptestitemcontenttype.ItemSubstitutedForList = v
      }
    case "ItemType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPTestItemTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPTestItemTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.ItemType = ((*AUCodeSetsNAPTestItemTypeType)(v))
      }
    case "MarkingType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPTestItemMarkingTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPTestItemMarkingTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.MarkingType = ((*AUCodeSetsNAPTestItemMarkingTypeType)(v))
      }
    case "MaximumScore":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestitemcontenttype.MaximumScore = ((*Float)(v))
      }
    case "MultipleChoiceOptionCount":
    
    if v, ok:= IntPointer(value); ok {
      n.naptestitemcontenttype.MultipleChoiceOptionCount = ((*Int)(v))
      }
    case "NAPTestItemLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.NAPTestItemLocalId = ((*LocalIdType)(v))
      }
    case "NAPWritingRubricList":
    if v, ok:= NAPWritingRubricListTypePointer(value); ok {
      n.naptestitemcontenttype.NAPWritingRubricList = v
      }
    case "ReleasedStatus":
    
    if v, ok:= BoolPointer(value); ok {
      n.naptestitemcontenttype.ReleasedStatus = ((*Bool)(v))
      }
    case "StimulusList":
    if v, ok:= StimulusListTypePointer(value); ok {
      n.naptestitemcontenttype.StimulusList = v
      }
    case "Subdomain":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.Subdomain = ((*String)(v))
      }
    case "WritingGenre":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPWritingGenreType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPWritingGenreType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naptestitemcontenttype.WritingGenre = ((*AUCodeSetsNAPWritingGenreType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestItemContentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ContentDescriptionList() *ContentDescriptionListType {
    if s.naptestitemcontenttype.ContentDescriptionList == nil {
     if v, ok:= ContentDescriptionListTypePointer(ContentDescriptionListType{}); ok {
      s.naptestitemcontenttype.ContentDescriptionList = v
      }
      }
      return s.naptestitemcontenttype.ContentDescriptionList
    }
// Returns whether the element value for ContentDescriptionList is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ContentDescriptionList_IsNil() bool {
    return s.naptestitemcontenttype.ContentDescriptionList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) CorrectAnswer() *String {
    if s.naptestitemcontenttype.CorrectAnswer == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.CorrectAnswer = ((*String)(v))
      }
      }
      return s.naptestitemcontenttype.CorrectAnswer
    }
// Returns whether the element value for CorrectAnswer is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) CorrectAnswer_IsNil() bool {
    return s.naptestitemcontenttype.CorrectAnswer == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ExemplarURL() *String {
    if s.naptestitemcontenttype.ExemplarURL == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.ExemplarURL = ((*String)(v))
      }
      }
      return s.naptestitemcontenttype.ExemplarURL
    }
// Returns whether the element value for ExemplarURL is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ExemplarURL_IsNil() bool {
    return s.naptestitemcontenttype.ExemplarURL == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemDescriptor() *String {
    if s.naptestitemcontenttype.ItemDescriptor == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.ItemDescriptor = ((*String)(v))
      }
      }
      return s.naptestitemcontenttype.ItemDescriptor
    }
// Returns whether the element value for ItemDescriptor is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemDescriptor_IsNil() bool {
    return s.naptestitemcontenttype.ItemDescriptor == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemDifficulty() *Float {
    if s.naptestitemcontenttype.ItemDifficulty == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestitemcontenttype.ItemDifficulty = ((*Float)(v))
      }
      }
      return s.naptestitemcontenttype.ItemDifficulty
    }
// Returns whether the element value for ItemDifficulty is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemDifficulty_IsNil() bool {
    return s.naptestitemcontenttype.ItemDifficulty == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemDifficultyLogit5() *Float {
    if s.naptestitemcontenttype.ItemDifficultyLogit5 == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestitemcontenttype.ItemDifficultyLogit5 = ((*Float)(v))
      }
      }
      return s.naptestitemcontenttype.ItemDifficultyLogit5
    }
// Returns whether the element value for ItemDifficultyLogit5 is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemDifficultyLogit5_IsNil() bool {
    return s.naptestitemcontenttype.ItemDifficultyLogit5 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemDifficultyLogit5SE() *Float {
    if s.naptestitemcontenttype.ItemDifficultyLogit5SE == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestitemcontenttype.ItemDifficultyLogit5SE = ((*Float)(v))
      }
      }
      return s.naptestitemcontenttype.ItemDifficultyLogit5SE
    }
// Returns whether the element value for ItemDifficultyLogit5SE is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemDifficultyLogit5SE_IsNil() bool {
    return s.naptestitemcontenttype.ItemDifficultyLogit5SE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemDifficultyLogit62() *Float {
    if s.naptestitemcontenttype.ItemDifficultyLogit62 == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestitemcontenttype.ItemDifficultyLogit62 = ((*Float)(v))
      }
      }
      return s.naptestitemcontenttype.ItemDifficultyLogit62
    }
// Returns whether the element value for ItemDifficultyLogit62 is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemDifficultyLogit62_IsNil() bool {
    return s.naptestitemcontenttype.ItemDifficultyLogit62 == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemDifficultyLogit62SE() *Float {
    if s.naptestitemcontenttype.ItemDifficultyLogit62SE == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestitemcontenttype.ItemDifficultyLogit62SE = ((*Float)(v))
      }
      }
      return s.naptestitemcontenttype.ItemDifficultyLogit62SE
    }
// Returns whether the element value for ItemDifficultyLogit62SE is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemDifficultyLogit62SE_IsNil() bool {
    return s.naptestitemcontenttype.ItemDifficultyLogit62SE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemName() *String {
    if s.naptestitemcontenttype.ItemName == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.ItemName = ((*String)(v))
      }
      }
      return s.naptestitemcontenttype.ItemName
    }
// Returns whether the element value for ItemName is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemName_IsNil() bool {
    return s.naptestitemcontenttype.ItemName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemProficiencyBand() *Int {
    if s.naptestitemcontenttype.ItemProficiencyBand == nil {
    if v, ok:= IntPointer(0); ok {
      s.naptestitemcontenttype.ItemProficiencyBand = ((*Int)(v))
      }
      }
      return s.naptestitemcontenttype.ItemProficiencyBand
    }
// Returns whether the element value for ItemProficiencyBand is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemProficiencyBand_IsNil() bool {
    return s.naptestitemcontenttype.ItemProficiencyBand == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemProficiencyLevel() *String {
    if s.naptestitemcontenttype.ItemProficiencyLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.ItemProficiencyLevel = ((*String)(v))
      }
      }
      return s.naptestitemcontenttype.ItemProficiencyLevel
    }
// Returns whether the element value for ItemProficiencyLevel is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemProficiencyLevel_IsNil() bool {
    return s.naptestitemcontenttype.ItemProficiencyLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemSubstitutedForList() *SubstituteItemListType {
    if s.naptestitemcontenttype.ItemSubstitutedForList == nil {
     if v, ok:= SubstituteItemListTypePointer(SubstituteItemListType{}); ok {
      s.naptestitemcontenttype.ItemSubstitutedForList = v
      }
      }
      return s.naptestitemcontenttype.ItemSubstitutedForList
    }
// Returns whether the element value for ItemSubstitutedForList is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemSubstitutedForList_IsNil() bool {
    return s.naptestitemcontenttype.ItemSubstitutedForList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ItemType() *AUCodeSetsNAPTestItemTypeType {
    if s.naptestitemcontenttype.ItemType == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.ItemType = ((*AUCodeSetsNAPTestItemTypeType)(v))
      }
      }
      return s.naptestitemcontenttype.ItemType
    }
// Returns whether the element value for ItemType is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ItemType_IsNil() bool {
    return s.naptestitemcontenttype.ItemType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) MarkingType() *AUCodeSetsNAPTestItemMarkingTypeType {
    if s.naptestitemcontenttype.MarkingType == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.MarkingType = ((*AUCodeSetsNAPTestItemMarkingTypeType)(v))
      }
      }
      return s.naptestitemcontenttype.MarkingType
    }
// Returns whether the element value for MarkingType is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) MarkingType_IsNil() bool {
    return s.naptestitemcontenttype.MarkingType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) MaximumScore() *Float {
    if s.naptestitemcontenttype.MaximumScore == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestitemcontenttype.MaximumScore = ((*Float)(v))
      }
      }
      return s.naptestitemcontenttype.MaximumScore
    }
// Returns whether the element value for MaximumScore is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) MaximumScore_IsNil() bool {
    return s.naptestitemcontenttype.MaximumScore == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) MultipleChoiceOptionCount() *Int {
    if s.naptestitemcontenttype.MultipleChoiceOptionCount == nil {
    if v, ok:= IntPointer(0); ok {
      s.naptestitemcontenttype.MultipleChoiceOptionCount = ((*Int)(v))
      }
      }
      return s.naptestitemcontenttype.MultipleChoiceOptionCount
    }
// Returns whether the element value for MultipleChoiceOptionCount is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) MultipleChoiceOptionCount_IsNil() bool {
    return s.naptestitemcontenttype.MultipleChoiceOptionCount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) NAPTestItemLocalId() *LocalIdType {
    if s.naptestitemcontenttype.NAPTestItemLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.NAPTestItemLocalId = ((*LocalIdType)(v))
      }
      }
      return s.naptestitemcontenttype.NAPTestItemLocalId
    }
// Returns whether the element value for NAPTestItemLocalId is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) NAPTestItemLocalId_IsNil() bool {
    return s.naptestitemcontenttype.NAPTestItemLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) NAPWritingRubricList() *NAPWritingRubricListType {
    if s.naptestitemcontenttype.NAPWritingRubricList == nil {
     if v, ok:= NAPWritingRubricListTypePointer(NAPWritingRubricListType{}); ok {
      s.naptestitemcontenttype.NAPWritingRubricList = v
      }
      }
      return s.naptestitemcontenttype.NAPWritingRubricList
    }
// Returns whether the element value for NAPWritingRubricList is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) NAPWritingRubricList_IsNil() bool {
    return s.naptestitemcontenttype.NAPWritingRubricList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) ReleasedStatus() *Bool {
    if s.naptestitemcontenttype.ReleasedStatus == nil {
    if v, ok:= BoolPointer(false); ok {
      s.naptestitemcontenttype.ReleasedStatus = ((*Bool)(v))
      }
      }
      return s.naptestitemcontenttype.ReleasedStatus
    }
// Returns whether the element value for ReleasedStatus is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) ReleasedStatus_IsNil() bool {
    return s.naptestitemcontenttype.ReleasedStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) StimulusList() *StimulusListType {
    if s.naptestitemcontenttype.StimulusList == nil {
     if v, ok:= StimulusListTypePointer(StimulusListType{}); ok {
      s.naptestitemcontenttype.StimulusList = v
      }
      }
      return s.naptestitemcontenttype.StimulusList
    }
// Returns whether the element value for StimulusList is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) StimulusList_IsNil() bool {
    return s.naptestitemcontenttype.StimulusList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) Subdomain() *String {
    if s.naptestitemcontenttype.Subdomain == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.Subdomain = ((*String)(v))
      }
      }
      return s.naptestitemcontenttype.Subdomain
    }
// Returns whether the element value for Subdomain is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) Subdomain_IsNil() bool {
    return s.naptestitemcontenttype.Subdomain == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestItemContentType) WritingGenre() *AUCodeSetsNAPWritingGenreType {
    if s.naptestitemcontenttype.WritingGenre == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestitemcontenttype.WritingGenre = ((*AUCodeSetsNAPWritingGenreType)(v))
      }
      }
      return s.naptestitemcontenttype.WritingGenre
    }
// Returns whether the element value for WritingGenre is nil in the container NAPTestItemContentType.
  func (s *NAPTestItemContentType) WritingGenre_IsNil() bool {
    return s.naptestitemcontenttype.WritingGenre == nil
    }

// Set the value of a property to nil
func (n *NAPTestScoreSummary) Unset(key string) *NAPTestScoreSummary {
        switch key {
  case "DomainBottomNational60Percent":
   n.naptestscoresummary.DomainBottomNational60Percent = nil
  case "DomainJurisdictionAverage":
   n.naptestscoresummary.DomainJurisdictionAverage = nil
  case "DomainNationalAverage":
   n.naptestscoresummary.DomainNationalAverage = nil
  case "DomainSchoolAverage":
   n.naptestscoresummary.DomainSchoolAverage = nil
  case "DomainTopNational60Percent":
   n.naptestscoresummary.DomainTopNational60Percent = nil
  case "LocalCodeList":
   n.naptestscoresummary.LocalCodeList = nil
  case "NAPTestLocalId":
   n.naptestscoresummary.NAPTestLocalId = nil
  case "NAPTestRefId":
   n.naptestscoresummary.NAPTestRefId = nil
  case "RefId":
   n.naptestscoresummary.RefId = nil
  case "SIF_ExtendedElements":
   n.naptestscoresummary.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.naptestscoresummary.SIF_Metadata = nil
  case "SchoolACARAId":
   n.naptestscoresummary.SchoolACARAId = nil
  case "SchoolInfoRefId":
   n.naptestscoresummary.SchoolInfoRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestScoreSummary")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestScoreSummary) SetProperties(props ...Prop) *NAPTestScoreSummary {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestScoreSummary) SetProperty(key string, value interface{}) *NAPTestScoreSummary {
        if n == nil {
                n, _ = NAPTestScoreSummaryPointer(NAPTestScoreSummary{})
        }
        switch key {
    case "DomainBottomNational60Percent":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestscoresummary.DomainBottomNational60Percent = ((*Float)(v))
      }
    case "DomainJurisdictionAverage":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestscoresummary.DomainJurisdictionAverage = ((*Float)(v))
      }
    case "DomainNationalAverage":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestscoresummary.DomainNationalAverage = ((*Float)(v))
      }
    case "DomainSchoolAverage":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestscoresummary.DomainSchoolAverage = ((*Float)(v))
      }
    case "DomainTopNational60Percent":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestscoresummary.DomainTopNational60Percent = ((*Float)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.naptestscoresummary.LocalCodeList = v
      }
    case "NAPTestLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestscoresummary.NAPTestLocalId = ((*LocalIdType)(v))
      }
    case "NAPTestRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestscoresummary.NAPTestRefId = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestscoresummary.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.naptestscoresummary.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.naptestscoresummary.SIF_Metadata = v
      }
    case "SchoolACARAId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestscoresummary.SchoolACARAId = ((*LocalIdType)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestscoresummary.SchoolInfoRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestScoreSummary")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) DomainBottomNational60Percent() *Float {
    if s.naptestscoresummary.DomainBottomNational60Percent == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestscoresummary.DomainBottomNational60Percent = ((*Float)(v))
      }
      }
      return s.naptestscoresummary.DomainBottomNational60Percent
    }
// Returns whether the element value for DomainBottomNational60Percent is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) DomainBottomNational60Percent_IsNil() bool {
    return s.naptestscoresummary.DomainBottomNational60Percent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) DomainJurisdictionAverage() *Float {
    if s.naptestscoresummary.DomainJurisdictionAverage == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestscoresummary.DomainJurisdictionAverage = ((*Float)(v))
      }
      }
      return s.naptestscoresummary.DomainJurisdictionAverage
    }
// Returns whether the element value for DomainJurisdictionAverage is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) DomainJurisdictionAverage_IsNil() bool {
    return s.naptestscoresummary.DomainJurisdictionAverage == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) DomainNationalAverage() *Float {
    if s.naptestscoresummary.DomainNationalAverage == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestscoresummary.DomainNationalAverage = ((*Float)(v))
      }
      }
      return s.naptestscoresummary.DomainNationalAverage
    }
// Returns whether the element value for DomainNationalAverage is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) DomainNationalAverage_IsNil() bool {
    return s.naptestscoresummary.DomainNationalAverage == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) DomainSchoolAverage() *Float {
    if s.naptestscoresummary.DomainSchoolAverage == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestscoresummary.DomainSchoolAverage = ((*Float)(v))
      }
      }
      return s.naptestscoresummary.DomainSchoolAverage
    }
// Returns whether the element value for DomainSchoolAverage is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) DomainSchoolAverage_IsNil() bool {
    return s.naptestscoresummary.DomainSchoolAverage == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) DomainTopNational60Percent() *Float {
    if s.naptestscoresummary.DomainTopNational60Percent == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestscoresummary.DomainTopNational60Percent = ((*Float)(v))
      }
      }
      return s.naptestscoresummary.DomainTopNational60Percent
    }
// Returns whether the element value for DomainTopNational60Percent is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) DomainTopNational60Percent_IsNil() bool {
    return s.naptestscoresummary.DomainTopNational60Percent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) LocalCodeList() *LocalCodeListType {
    if s.naptestscoresummary.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.naptestscoresummary.LocalCodeList = v
      }
      }
      return s.naptestscoresummary.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) LocalCodeList_IsNil() bool {
    return s.naptestscoresummary.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) NAPTestLocalId() *LocalIdType {
    if s.naptestscoresummary.NAPTestLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestscoresummary.NAPTestLocalId = ((*LocalIdType)(v))
      }
      }
      return s.naptestscoresummary.NAPTestLocalId
    }
// Returns whether the element value for NAPTestLocalId is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) NAPTestLocalId_IsNil() bool {
    return s.naptestscoresummary.NAPTestLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) NAPTestRefId() *String {
    if s.naptestscoresummary.NAPTestRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestscoresummary.NAPTestRefId = ((*String)(v))
      }
      }
      return s.naptestscoresummary.NAPTestRefId
    }
// Returns whether the element value for NAPTestRefId is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) NAPTestRefId_IsNil() bool {
    return s.naptestscoresummary.NAPTestRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) RefId() *RefIdType {
    if s.naptestscoresummary.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestscoresummary.RefId = ((*RefIdType)(v))
      }
      }
      return s.naptestscoresummary.RefId
    }
// Returns whether the element value for RefId is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) RefId_IsNil() bool {
    return s.naptestscoresummary.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.naptestscoresummary.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.naptestscoresummary.SIF_ExtendedElements = v
      }
      }
      return s.naptestscoresummary.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) SIF_ExtendedElements_IsNil() bool {
    return s.naptestscoresummary.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) SIF_Metadata() *SIF_MetadataType {
    if s.naptestscoresummary.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.naptestscoresummary.SIF_Metadata = v
      }
      }
      return s.naptestscoresummary.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) SIF_Metadata_IsNil() bool {
    return s.naptestscoresummary.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) SchoolACARAId() *LocalIdType {
    if s.naptestscoresummary.SchoolACARAId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestscoresummary.SchoolACARAId = ((*LocalIdType)(v))
      }
      }
      return s.naptestscoresummary.SchoolACARAId
    }
// Returns whether the element value for SchoolACARAId is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) SchoolACARAId_IsNil() bool {
    return s.naptestscoresummary.SchoolACARAId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestScoreSummary) SchoolInfoRefId() *String {
    if s.naptestscoresummary.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestscoresummary.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.naptestscoresummary.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container NAPTestScoreSummary.
  func (s *NAPTestScoreSummary) SchoolInfoRefId_IsNil() bool {
    return s.naptestscoresummary.SchoolInfoRefId == nil
    }

// Set the value of a property to nil
func (n *NAPTestlet) Unset(key string) *NAPTestlet {
        switch key {
  case "LocalCodeList":
   n.naptestlet.LocalCodeList = nil
  case "NAPTestLocalId":
   n.naptestlet.NAPTestLocalId = nil
  case "NAPTestRefId":
   n.naptestlet.NAPTestRefId = nil
  case "RefId":
   n.naptestlet.RefId = nil
  case "SIF_ExtendedElements":
   n.naptestlet.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.naptestlet.SIF_Metadata = nil
  case "TestItemList":
   n.naptestlet.TestItemList = nil
  case "TestletContent":
   n.naptestlet.TestletContent = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestlet")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestlet) SetProperties(props ...Prop) *NAPTestlet {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestlet) SetProperty(key string, value interface{}) *NAPTestlet {
        if n == nil {
                n, _ = NAPTestletPointer(NAPTestlet{})
        }
        switch key {
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.naptestlet.LocalCodeList = v
      }
    case "NAPTestLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestlet.NAPTestLocalId = ((*LocalIdType)(v))
      }
    case "NAPTestRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestlet.NAPTestRefId = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestlet.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.naptestlet.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.naptestlet.SIF_Metadata = v
      }
    case "TestItemList":
    if v, ok:= NAPTestItemListTypePointer(value); ok {
      n.naptestlet.TestItemList = v
      }
    case "TestletContent":
    if v, ok:= NAPTestletContentTypePointer(value); ok {
      n.naptestlet.TestletContent = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestlet")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestlet) LocalCodeList() *LocalCodeListType {
    if s.naptestlet.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.naptestlet.LocalCodeList = v
      }
      }
      return s.naptestlet.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container NAPTestlet.
  func (s *NAPTestlet) LocalCodeList_IsNil() bool {
    return s.naptestlet.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestlet) NAPTestLocalId() *LocalIdType {
    if s.naptestlet.NAPTestLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestlet.NAPTestLocalId = ((*LocalIdType)(v))
      }
      }
      return s.naptestlet.NAPTestLocalId
    }
// Returns whether the element value for NAPTestLocalId is nil in the container NAPTestlet.
  func (s *NAPTestlet) NAPTestLocalId_IsNil() bool {
    return s.naptestlet.NAPTestLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestlet) NAPTestRefId() *String {
    if s.naptestlet.NAPTestRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestlet.NAPTestRefId = ((*String)(v))
      }
      }
      return s.naptestlet.NAPTestRefId
    }
// Returns whether the element value for NAPTestRefId is nil in the container NAPTestlet.
  func (s *NAPTestlet) NAPTestRefId_IsNil() bool {
    return s.naptestlet.NAPTestRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestlet) RefId() *RefIdType {
    if s.naptestlet.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestlet.RefId = ((*RefIdType)(v))
      }
      }
      return s.naptestlet.RefId
    }
// Returns whether the element value for RefId is nil in the container NAPTestlet.
  func (s *NAPTestlet) RefId_IsNil() bool {
    return s.naptestlet.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestlet) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.naptestlet.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.naptestlet.SIF_ExtendedElements = v
      }
      }
      return s.naptestlet.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container NAPTestlet.
  func (s *NAPTestlet) SIF_ExtendedElements_IsNil() bool {
    return s.naptestlet.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestlet) SIF_Metadata() *SIF_MetadataType {
    if s.naptestlet.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.naptestlet.SIF_Metadata = v
      }
      }
      return s.naptestlet.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container NAPTestlet.
  func (s *NAPTestlet) SIF_Metadata_IsNil() bool {
    return s.naptestlet.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestlet) TestItemList() *NAPTestItemListType {
    if s.naptestlet.TestItemList == nil {
     if v, ok:= NAPTestItemListTypePointer(NAPTestItemListType{}); ok {
      s.naptestlet.TestItemList = v
      }
      }
      return s.naptestlet.TestItemList
    }
// Returns whether the element value for TestItemList is nil in the container NAPTestlet.
  func (s *NAPTestlet) TestItemList_IsNil() bool {
    return s.naptestlet.TestItemList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestlet) TestletContent() *NAPTestletContentType {
    if s.naptestlet.TestletContent == nil {
     if v, ok:= NAPTestletContentTypePointer(NAPTestletContentType{}); ok {
      s.naptestlet.TestletContent = v
      }
      }
      return s.naptestlet.TestletContent
    }
// Returns whether the element value for TestletContent is nil in the container NAPTestlet.
  func (s *NAPTestlet) TestletContent_IsNil() bool {
    return s.naptestlet.TestletContent == nil
    }

// Set the value of a property to nil
func (n *NAPTestletCodeFrameType) Unset(key string) *NAPTestletCodeFrameType {
        switch key {
  case "NAPTestletRefId":
   n.naptestletcodeframetype.NAPTestletRefId = nil
  case "TestItemList":
   n.naptestletcodeframetype.TestItemList = nil
  case "TestletContent":
   n.naptestletcodeframetype.TestletContent = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestletCodeFrameType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestletCodeFrameType) SetProperties(props ...Prop) *NAPTestletCodeFrameType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestletCodeFrameType) SetProperty(key string, value interface{}) *NAPTestletCodeFrameType {
        if n == nil {
                n, _ = NAPTestletCodeFrameTypePointer(NAPTestletCodeFrameType{})
        }
        switch key {
    case "NAPTestletRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletcodeframetype.NAPTestletRefId = ((*String)(v))
      }
    case "TestItemList":
    if v, ok:= CodeFrameTestItemListTypePointer(value); ok {
      n.naptestletcodeframetype.TestItemList = v
      }
    case "TestletContent":
    if v, ok:= NAPTestletContentTypePointer(value); ok {
      n.naptestletcodeframetype.TestletContent = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestletCodeFrameType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletCodeFrameType) NAPTestletRefId() *String {
    if s.naptestletcodeframetype.NAPTestletRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletcodeframetype.NAPTestletRefId = ((*String)(v))
      }
      }
      return s.naptestletcodeframetype.NAPTestletRefId
    }
// Returns whether the element value for NAPTestletRefId is nil in the container NAPTestletCodeFrameType.
  func (s *NAPTestletCodeFrameType) NAPTestletRefId_IsNil() bool {
    return s.naptestletcodeframetype.NAPTestletRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletCodeFrameType) TestItemList() *CodeFrameTestItemListType {
    if s.naptestletcodeframetype.TestItemList == nil {
     if v, ok:= CodeFrameTestItemListTypePointer(CodeFrameTestItemListType{}); ok {
      s.naptestletcodeframetype.TestItemList = v
      }
      }
      return s.naptestletcodeframetype.TestItemList
    }
// Returns whether the element value for TestItemList is nil in the container NAPTestletCodeFrameType.
  func (s *NAPTestletCodeFrameType) TestItemList_IsNil() bool {
    return s.naptestletcodeframetype.TestItemList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletCodeFrameType) TestletContent() *NAPTestletContentType {
    if s.naptestletcodeframetype.TestletContent == nil {
     if v, ok:= NAPTestletContentTypePointer(NAPTestletContentType{}); ok {
      s.naptestletcodeframetype.TestletContent = v
      }
      }
      return s.naptestletcodeframetype.TestletContent
    }
// Returns whether the element value for TestletContent is nil in the container NAPTestletCodeFrameType.
  func (s *NAPTestletCodeFrameType) TestletContent_IsNil() bool {
    return s.naptestletcodeframetype.TestletContent == nil
    }

// Set the value of a property to nil
func (n *NAPTestletContentType) Unset(key string) *NAPTestletContentType {
        switch key {
  case "LocationInStage":
   n.naptestletcontenttype.LocationInStage = nil
  case "NAPTestletLocalId":
   n.naptestletcontenttype.NAPTestletLocalId = nil
  case "Node":
   n.naptestletcontenttype.Node = nil
  case "TestletMaximumScore":
   n.naptestletcontenttype.TestletMaximumScore = nil
  case "TestletName":
   n.naptestletcontenttype.TestletName = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestletContentType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestletContentType) SetProperties(props ...Prop) *NAPTestletContentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestletContentType) SetProperty(key string, value interface{}) *NAPTestletContentType {
        if n == nil {
                n, _ = NAPTestletContentTypePointer(NAPTestletContentType{})
        }
        switch key {
    case "LocationInStage":
    
    if v, ok:= IntPointer(value); ok {
      n.naptestletcontenttype.LocationInStage = ((*Int)(v))
      }
    case "NAPTestletLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletcontenttype.NAPTestletLocalId = ((*LocalIdType)(v))
      }
    case "Node":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletcontenttype.Node = ((*String)(v))
      }
    case "TestletMaximumScore":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestletcontenttype.TestletMaximumScore = ((*Float)(v))
      }
    case "TestletName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletcontenttype.TestletName = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestletContentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletContentType) LocationInStage() *Int {
    if s.naptestletcontenttype.LocationInStage == nil {
    if v, ok:= IntPointer(0); ok {
      s.naptestletcontenttype.LocationInStage = ((*Int)(v))
      }
      }
      return s.naptestletcontenttype.LocationInStage
    }
// Returns whether the element value for LocationInStage is nil in the container NAPTestletContentType.
  func (s *NAPTestletContentType) LocationInStage_IsNil() bool {
    return s.naptestletcontenttype.LocationInStage == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletContentType) NAPTestletLocalId() *LocalIdType {
    if s.naptestletcontenttype.NAPTestletLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletcontenttype.NAPTestletLocalId = ((*LocalIdType)(v))
      }
      }
      return s.naptestletcontenttype.NAPTestletLocalId
    }
// Returns whether the element value for NAPTestletLocalId is nil in the container NAPTestletContentType.
  func (s *NAPTestletContentType) NAPTestletLocalId_IsNil() bool {
    return s.naptestletcontenttype.NAPTestletLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletContentType) Node() *String {
    if s.naptestletcontenttype.Node == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletcontenttype.Node = ((*String)(v))
      }
      }
      return s.naptestletcontenttype.Node
    }
// Returns whether the element value for Node is nil in the container NAPTestletContentType.
  func (s *NAPTestletContentType) Node_IsNil() bool {
    return s.naptestletcontenttype.Node == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletContentType) TestletMaximumScore() *Float {
    if s.naptestletcontenttype.TestletMaximumScore == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestletcontenttype.TestletMaximumScore = ((*Float)(v))
      }
      }
      return s.naptestletcontenttype.TestletMaximumScore
    }
// Returns whether the element value for TestletMaximumScore is nil in the container NAPTestletContentType.
  func (s *NAPTestletContentType) TestletMaximumScore_IsNil() bool {
    return s.naptestletcontenttype.TestletMaximumScore == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletContentType) TestletName() *String {
    if s.naptestletcontenttype.TestletName == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletcontenttype.TestletName = ((*String)(v))
      }
      }
      return s.naptestletcontenttype.TestletName
    }
// Returns whether the element value for TestletName is nil in the container NAPTestletContentType.
  func (s *NAPTestletContentType) TestletName_IsNil() bool {
    return s.naptestletcontenttype.TestletName == nil
    }

// Set the value of a property to nil
func (n *NAPTestletResponseItemType) Unset(key string) *NAPTestletResponseItemType {
        switch key {
  case "ItemWeight":
   n.naptestletresponseitemtype.ItemWeight = nil
  case "LapsedTimeItem":
   n.naptestletresponseitemtype.LapsedTimeItem = nil
  case "NAPTestItemLocalId":
   n.naptestletresponseitemtype.NAPTestItemLocalId = nil
  case "NAPTestItemRefId":
   n.naptestletresponseitemtype.NAPTestItemRefId = nil
  case "Response":
   n.naptestletresponseitemtype.Response = nil
  case "ResponseCorrectness":
   n.naptestletresponseitemtype.ResponseCorrectness = nil
  case "Score":
   n.naptestletresponseitemtype.Score = nil
  case "SequenceNumber":
   n.naptestletresponseitemtype.SequenceNumber = nil
  case "SubscoreList":
   n.naptestletresponseitemtype.SubscoreList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestletResponseItemType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestletResponseItemType) SetProperties(props ...Prop) *NAPTestletResponseItemType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestletResponseItemType) SetProperty(key string, value interface{}) *NAPTestletResponseItemType {
        if n == nil {
                n, _ = NAPTestletResponseItemTypePointer(NAPTestletResponseItemType{})
        }
        switch key {
    case "ItemWeight":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestletresponseitemtype.ItemWeight = ((*Float)(v))
      }
    case "LapsedTimeItem":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletresponseitemtype.LapsedTimeItem = ((*String)(v))
      }
    case "NAPTestItemLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletresponseitemtype.NAPTestItemLocalId = ((*LocalIdType)(v))
      }
    case "NAPTestItemRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletresponseitemtype.NAPTestItemRefId = ((*String)(v))
      }
    case "Response":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletresponseitemtype.Response = ((*String)(v))
      }
    case "ResponseCorrectness":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNAPResponseCorrectnessType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNAPResponseCorrectnessType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.naptestletresponseitemtype.ResponseCorrectness = ((*AUCodeSetsNAPResponseCorrectnessType)(v))
      }
    case "Score":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestletresponseitemtype.Score = ((*Float)(v))
      }
    case "SequenceNumber":
    
    if v, ok:= IntPointer(value); ok {
      n.naptestletresponseitemtype.SequenceNumber = ((*Int)(v))
      }
    case "SubscoreList":
    if v, ok:= NAPSubscoreListTypePointer(value); ok {
      n.naptestletresponseitemtype.SubscoreList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestletResponseItemType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseItemType) ItemWeight() *Float {
    if s.naptestletresponseitemtype.ItemWeight == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestletresponseitemtype.ItemWeight = ((*Float)(v))
      }
      }
      return s.naptestletresponseitemtype.ItemWeight
    }
// Returns whether the element value for ItemWeight is nil in the container NAPTestletResponseItemType.
  func (s *NAPTestletResponseItemType) ItemWeight_IsNil() bool {
    return s.naptestletresponseitemtype.ItemWeight == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseItemType) LapsedTimeItem() *String {
    if s.naptestletresponseitemtype.LapsedTimeItem == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletresponseitemtype.LapsedTimeItem = ((*String)(v))
      }
      }
      return s.naptestletresponseitemtype.LapsedTimeItem
    }
// Returns whether the element value for LapsedTimeItem is nil in the container NAPTestletResponseItemType.
  func (s *NAPTestletResponseItemType) LapsedTimeItem_IsNil() bool {
    return s.naptestletresponseitemtype.LapsedTimeItem == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseItemType) NAPTestItemLocalId() *LocalIdType {
    if s.naptestletresponseitemtype.NAPTestItemLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletresponseitemtype.NAPTestItemLocalId = ((*LocalIdType)(v))
      }
      }
      return s.naptestletresponseitemtype.NAPTestItemLocalId
    }
// Returns whether the element value for NAPTestItemLocalId is nil in the container NAPTestletResponseItemType.
  func (s *NAPTestletResponseItemType) NAPTestItemLocalId_IsNil() bool {
    return s.naptestletresponseitemtype.NAPTestItemLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseItemType) NAPTestItemRefId() *String {
    if s.naptestletresponseitemtype.NAPTestItemRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletresponseitemtype.NAPTestItemRefId = ((*String)(v))
      }
      }
      return s.naptestletresponseitemtype.NAPTestItemRefId
    }
// Returns whether the element value for NAPTestItemRefId is nil in the container NAPTestletResponseItemType.
  func (s *NAPTestletResponseItemType) NAPTestItemRefId_IsNil() bool {
    return s.naptestletresponseitemtype.NAPTestItemRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseItemType) Response() *String {
    if s.naptestletresponseitemtype.Response == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletresponseitemtype.Response = ((*String)(v))
      }
      }
      return s.naptestletresponseitemtype.Response
    }
// Returns whether the element value for Response is nil in the container NAPTestletResponseItemType.
  func (s *NAPTestletResponseItemType) Response_IsNil() bool {
    return s.naptestletresponseitemtype.Response == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseItemType) ResponseCorrectness() *AUCodeSetsNAPResponseCorrectnessType {
    if s.naptestletresponseitemtype.ResponseCorrectness == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletresponseitemtype.ResponseCorrectness = ((*AUCodeSetsNAPResponseCorrectnessType)(v))
      }
      }
      return s.naptestletresponseitemtype.ResponseCorrectness
    }
// Returns whether the element value for ResponseCorrectness is nil in the container NAPTestletResponseItemType.
  func (s *NAPTestletResponseItemType) ResponseCorrectness_IsNil() bool {
    return s.naptestletresponseitemtype.ResponseCorrectness == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseItemType) Score() *Float {
    if s.naptestletresponseitemtype.Score == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestletresponseitemtype.Score = ((*Float)(v))
      }
      }
      return s.naptestletresponseitemtype.Score
    }
// Returns whether the element value for Score is nil in the container NAPTestletResponseItemType.
  func (s *NAPTestletResponseItemType) Score_IsNil() bool {
    return s.naptestletresponseitemtype.Score == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseItemType) SequenceNumber() *Int {
    if s.naptestletresponseitemtype.SequenceNumber == nil {
    if v, ok:= IntPointer(0); ok {
      s.naptestletresponseitemtype.SequenceNumber = ((*Int)(v))
      }
      }
      return s.naptestletresponseitemtype.SequenceNumber
    }
// Returns whether the element value for SequenceNumber is nil in the container NAPTestletResponseItemType.
  func (s *NAPTestletResponseItemType) SequenceNumber_IsNil() bool {
    return s.naptestletresponseitemtype.SequenceNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseItemType) SubscoreList() *NAPSubscoreListType {
    if s.naptestletresponseitemtype.SubscoreList == nil {
     if v, ok:= NAPSubscoreListTypePointer(NAPSubscoreListType{}); ok {
      s.naptestletresponseitemtype.SubscoreList = v
      }
      }
      return s.naptestletresponseitemtype.SubscoreList
    }
// Returns whether the element value for SubscoreList is nil in the container NAPTestletResponseItemType.
  func (s *NAPTestletResponseItemType) SubscoreList_IsNil() bool {
    return s.naptestletresponseitemtype.SubscoreList == nil
    }

// Set the value of a property to nil
func (n *NAPTestletResponseType) Unset(key string) *NAPTestletResponseType {
        switch key {
  case "ItemResponseList":
   n.naptestletresponsetype.ItemResponseList = nil
  case "NAPTestletLocalId":
   n.naptestletresponsetype.NAPTestletLocalId = nil
  case "NAPTestletRefId":
   n.naptestletresponsetype.NAPTestletRefId = nil
  case "TestletSubScore":
   n.naptestletresponsetype.TestletSubScore = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestletResponseType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPTestletResponseType) SetProperties(props ...Prop) *NAPTestletResponseType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPTestletResponseType) SetProperty(key string, value interface{}) *NAPTestletResponseType {
        if n == nil {
                n, _ = NAPTestletResponseTypePointer(NAPTestletResponseType{})
        }
        switch key {
    case "ItemResponseList":
    if v, ok:= NAPTestletItemResponseListTypePointer(value); ok {
      n.naptestletresponsetype.ItemResponseList = v
      }
    case "NAPTestletLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletresponsetype.NAPTestletLocalId = ((*LocalIdType)(v))
      }
    case "NAPTestletRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.naptestletresponsetype.NAPTestletRefId = ((*String)(v))
      }
    case "TestletSubScore":
    
    if v, ok:= FloatPointer(value); ok {
      n.naptestletresponsetype.TestletSubScore = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPTestletResponseType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseType) ItemResponseList() *NAPTestletItemResponseListType {
    if s.naptestletresponsetype.ItemResponseList == nil {
     if v, ok:= NAPTestletItemResponseListTypePointer(NAPTestletItemResponseListType{}); ok {
      s.naptestletresponsetype.ItemResponseList = v
      }
      }
      return s.naptestletresponsetype.ItemResponseList
    }
// Returns whether the element value for ItemResponseList is nil in the container NAPTestletResponseType.
  func (s *NAPTestletResponseType) ItemResponseList_IsNil() bool {
    return s.naptestletresponsetype.ItemResponseList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseType) NAPTestletLocalId() *LocalIdType {
    if s.naptestletresponsetype.NAPTestletLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletresponsetype.NAPTestletLocalId = ((*LocalIdType)(v))
      }
      }
      return s.naptestletresponsetype.NAPTestletLocalId
    }
// Returns whether the element value for NAPTestletLocalId is nil in the container NAPTestletResponseType.
  func (s *NAPTestletResponseType) NAPTestletLocalId_IsNil() bool {
    return s.naptestletresponsetype.NAPTestletLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseType) NAPTestletRefId() *String {
    if s.naptestletresponsetype.NAPTestletRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.naptestletresponsetype.NAPTestletRefId = ((*String)(v))
      }
      }
      return s.naptestletresponsetype.NAPTestletRefId
    }
// Returns whether the element value for NAPTestletRefId is nil in the container NAPTestletResponseType.
  func (s *NAPTestletResponseType) NAPTestletRefId_IsNil() bool {
    return s.naptestletresponsetype.NAPTestletRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPTestletResponseType) TestletSubScore() *Float {
    if s.naptestletresponsetype.TestletSubScore == nil {
    if v, ok:= FloatPointer(0); ok {
      s.naptestletresponsetype.TestletSubScore = ((*Float)(v))
      }
      }
      return s.naptestletresponsetype.TestletSubScore
    }
// Returns whether the element value for TestletSubScore is nil in the container NAPTestletResponseType.
  func (s *NAPTestletResponseType) TestletSubScore_IsNil() bool {
    return s.naptestletresponsetype.TestletSubScore == nil
    }

// Set the value of a property to nil
func (n *NAPWritingRubricType) Unset(key string) *NAPWritingRubricType {
        switch key {
  case "Descriptor":
   n.napwritingrubrictype.Descriptor = nil
  case "RubricType":
   n.napwritingrubrictype.RubricType = nil
  case "ScoreList":
   n.napwritingrubrictype.ScoreList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPWritingRubricType")
        }
        return n
}

// Set a sequence of properties
func (n *NAPWritingRubricType) SetProperties(props ...Prop) *NAPWritingRubricType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NAPWritingRubricType) SetProperty(key string, value interface{}) *NAPWritingRubricType {
        if n == nil {
                n, _ = NAPWritingRubricTypePointer(NAPWritingRubricType{})
        }
        switch key {
    case "Descriptor":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napwritingrubrictype.Descriptor = ((*String)(v))
      }
    case "RubricType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.napwritingrubrictype.RubricType = ((*String)(v))
      }
    case "ScoreList":
    if v, ok:= ScoreListTypePointer(value); ok {
      n.napwritingrubrictype.ScoreList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NAPWritingRubricType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPWritingRubricType) Descriptor() *String {
    if s.napwritingrubrictype.Descriptor == nil {
    if v, ok:= StringPointer(""); ok {
      s.napwritingrubrictype.Descriptor = ((*String)(v))
      }
      }
      return s.napwritingrubrictype.Descriptor
    }
// Returns whether the element value for Descriptor is nil in the container NAPWritingRubricType.
  func (s *NAPWritingRubricType) Descriptor_IsNil() bool {
    return s.napwritingrubrictype.Descriptor == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPWritingRubricType) RubricType() *String {
    if s.napwritingrubrictype.RubricType == nil {
    if v, ok:= StringPointer(""); ok {
      s.napwritingrubrictype.RubricType = ((*String)(v))
      }
      }
      return s.napwritingrubrictype.RubricType
    }
// Returns whether the element value for RubricType is nil in the container NAPWritingRubricType.
  func (s *NAPWritingRubricType) RubricType_IsNil() bool {
    return s.napwritingrubrictype.RubricType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NAPWritingRubricType) ScoreList() *ScoreListType {
    if s.napwritingrubrictype.ScoreList == nil {
     if v, ok:= ScoreListTypePointer(ScoreListType{}); ok {
      s.napwritingrubrictype.ScoreList = v
      }
      }
      return s.napwritingrubrictype.ScoreList
    }
// Returns whether the element value for ScoreList is nil in the container NAPWritingRubricType.
  func (s *NAPWritingRubricType) ScoreList_IsNil() bool {
    return s.napwritingrubrictype.ScoreList == nil
    }

// Set the value of a property to nil
func (n *NCCDType) Unset(key string) *NCCDType {
        switch key {
  case "CategoryOfDisability":
   n.nccdtype.CategoryOfDisability = nil
  case "DateOfAssessment":
   n.nccdtype.DateOfAssessment = nil
  case "DisabilityCategoryConsideredList":
   n.nccdtype.DisabilityCategoryConsideredList = nil
  case "LevelOfAdjustment":
   n.nccdtype.LevelOfAdjustment = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NCCDType")
        }
        return n
}

// Set a sequence of properties
func (n *NCCDType) SetProperties(props ...Prop) *NCCDType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NCCDType) SetProperty(key string, value interface{}) *NCCDType {
        if n == nil {
                n, _ = NCCDTypePointer(NCCDType{})
        }
        switch key {
    case "CategoryOfDisability":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNCCDDisabilityType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNCCDDisabilityType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.nccdtype.CategoryOfDisability = ((*AUCodeSetsNCCDDisabilityType)(v))
      }
    case "DateOfAssessment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nccdtype.DateOfAssessment = ((*String)(v))
      }
    case "DisabilityCategoryConsideredList":
    if v, ok:= DisabilityCategoryListTypePointer(value); ok {
      n.nccdtype.DisabilityCategoryConsideredList = v
      }
    case "LevelOfAdjustment":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNCCDAdjustmentType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNCCDAdjustmentType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.nccdtype.LevelOfAdjustment = ((*AUCodeSetsNCCDAdjustmentType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NCCDType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NCCDType) CategoryOfDisability() *AUCodeSetsNCCDDisabilityType {
    if s.nccdtype.CategoryOfDisability == nil {
    if v, ok:= StringPointer(""); ok {
      s.nccdtype.CategoryOfDisability = ((*AUCodeSetsNCCDDisabilityType)(v))
      }
      }
      return s.nccdtype.CategoryOfDisability
    }
// Returns whether the element value for CategoryOfDisability is nil in the container NCCDType.
  func (s *NCCDType) CategoryOfDisability_IsNil() bool {
    return s.nccdtype.CategoryOfDisability == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NCCDType) DateOfAssessment() *String {
    if s.nccdtype.DateOfAssessment == nil {
    if v, ok:= StringPointer(""); ok {
      s.nccdtype.DateOfAssessment = ((*String)(v))
      }
      }
      return s.nccdtype.DateOfAssessment
    }
// Returns whether the element value for DateOfAssessment is nil in the container NCCDType.
  func (s *NCCDType) DateOfAssessment_IsNil() bool {
    return s.nccdtype.DateOfAssessment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NCCDType) DisabilityCategoryConsideredList() *DisabilityCategoryListType {
    if s.nccdtype.DisabilityCategoryConsideredList == nil {
     if v, ok:= DisabilityCategoryListTypePointer(DisabilityCategoryListType{}); ok {
      s.nccdtype.DisabilityCategoryConsideredList = v
      }
      }
      return s.nccdtype.DisabilityCategoryConsideredList
    }
// Returns whether the element value for DisabilityCategoryConsideredList is nil in the container NCCDType.
  func (s *NCCDType) DisabilityCategoryConsideredList_IsNil() bool {
    return s.nccdtype.DisabilityCategoryConsideredList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NCCDType) LevelOfAdjustment() *AUCodeSetsNCCDAdjustmentType {
    if s.nccdtype.LevelOfAdjustment == nil {
    if v, ok:= StringPointer(""); ok {
      s.nccdtype.LevelOfAdjustment = ((*AUCodeSetsNCCDAdjustmentType)(v))
      }
      }
      return s.nccdtype.LevelOfAdjustment
    }
// Returns whether the element value for LevelOfAdjustment is nil in the container NCCDType.
  func (s *NCCDType) LevelOfAdjustment_IsNil() bool {
    return s.nccdtype.LevelOfAdjustment == nil
    }

// Set the value of a property to nil
func (n *NameOfRecordType) Unset(key string) *NameOfRecordType {
        switch key {
  case "Type":
   n.nameofrecordtype.Type = nil
  case "FamilyName":
   n.nameofrecordtype.FamilyName = nil
  case "FamilyNameFirst":
   n.nameofrecordtype.FamilyNameFirst = nil
  case "FullName":
   n.nameofrecordtype.FullName = nil
  case "GivenName":
   n.nameofrecordtype.GivenName = nil
  case "MiddleName":
   n.nameofrecordtype.MiddleName = nil
  case "PreferredFamilyName":
   n.nameofrecordtype.PreferredFamilyName = nil
  case "PreferredFamilyNameFirst":
   n.nameofrecordtype.PreferredFamilyNameFirst = nil
  case "PreferredGivenName":
   n.nameofrecordtype.PreferredGivenName = nil
  case "Suffix":
   n.nameofrecordtype.Suffix = nil
  case "Title":
   n.nameofrecordtype.Title = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NameOfRecordType")
        }
        return n
}

// Set a sequence of properties
func (n *NameOfRecordType) SetProperties(props ...Prop) *NameOfRecordType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NameOfRecordType) SetProperty(key string, value interface{}) *NameOfRecordType {
        if n == nil {
                n, _ = NameOfRecordTypePointer(NameOfRecordType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.Type = ((*String)(v))
      }
    case "FamilyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.FamilyName = ((*String)(v))
      }
    case "FamilyNameFirst":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.FamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "FullName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.FullName = ((*String)(v))
      }
    case "GivenName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.GivenName = ((*String)(v))
      }
    case "MiddleName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.MiddleName = ((*String)(v))
      }
    case "PreferredFamilyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.PreferredFamilyName = ((*String)(v))
      }
    case "PreferredFamilyNameFirst":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.PreferredFamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "PreferredGivenName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.PreferredGivenName = ((*String)(v))
      }
    case "Suffix":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.Suffix = ((*String)(v))
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nameofrecordtype.Title = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NameOfRecordType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) Type() *String {
    if s.nameofrecordtype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.Type = ((*String)(v))
      }
      }
      return s.nameofrecordtype.Type
    }
// Returns whether the element value for Type is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) Type_IsNil() bool {
    return s.nameofrecordtype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) FamilyName() *String {
    if s.nameofrecordtype.FamilyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.FamilyName = ((*String)(v))
      }
      }
      return s.nameofrecordtype.FamilyName
    }
// Returns whether the element value for FamilyName is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) FamilyName_IsNil() bool {
    return s.nameofrecordtype.FamilyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) FamilyNameFirst() *AUCodeSetsYesOrNoCategoryType {
    if s.nameofrecordtype.FamilyNameFirst == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.FamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.nameofrecordtype.FamilyNameFirst
    }
// Returns whether the element value for FamilyNameFirst is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) FamilyNameFirst_IsNil() bool {
    return s.nameofrecordtype.FamilyNameFirst == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) FullName() *String {
    if s.nameofrecordtype.FullName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.FullName = ((*String)(v))
      }
      }
      return s.nameofrecordtype.FullName
    }
// Returns whether the element value for FullName is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) FullName_IsNil() bool {
    return s.nameofrecordtype.FullName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) GivenName() *String {
    if s.nameofrecordtype.GivenName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.GivenName = ((*String)(v))
      }
      }
      return s.nameofrecordtype.GivenName
    }
// Returns whether the element value for GivenName is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) GivenName_IsNil() bool {
    return s.nameofrecordtype.GivenName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) MiddleName() *String {
    if s.nameofrecordtype.MiddleName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.MiddleName = ((*String)(v))
      }
      }
      return s.nameofrecordtype.MiddleName
    }
// Returns whether the element value for MiddleName is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) MiddleName_IsNil() bool {
    return s.nameofrecordtype.MiddleName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) PreferredFamilyName() *String {
    if s.nameofrecordtype.PreferredFamilyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.PreferredFamilyName = ((*String)(v))
      }
      }
      return s.nameofrecordtype.PreferredFamilyName
    }
// Returns whether the element value for PreferredFamilyName is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) PreferredFamilyName_IsNil() bool {
    return s.nameofrecordtype.PreferredFamilyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) PreferredFamilyNameFirst() *AUCodeSetsYesOrNoCategoryType {
    if s.nameofrecordtype.PreferredFamilyNameFirst == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.PreferredFamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.nameofrecordtype.PreferredFamilyNameFirst
    }
// Returns whether the element value for PreferredFamilyNameFirst is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) PreferredFamilyNameFirst_IsNil() bool {
    return s.nameofrecordtype.PreferredFamilyNameFirst == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) PreferredGivenName() *String {
    if s.nameofrecordtype.PreferredGivenName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.PreferredGivenName = ((*String)(v))
      }
      }
      return s.nameofrecordtype.PreferredGivenName
    }
// Returns whether the element value for PreferredGivenName is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) PreferredGivenName_IsNil() bool {
    return s.nameofrecordtype.PreferredGivenName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) Suffix() *String {
    if s.nameofrecordtype.Suffix == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.Suffix = ((*String)(v))
      }
      }
      return s.nameofrecordtype.Suffix
    }
// Returns whether the element value for Suffix is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) Suffix_IsNil() bool {
    return s.nameofrecordtype.Suffix == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameOfRecordType) Title() *String {
    if s.nameofrecordtype.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.nameofrecordtype.Title = ((*String)(v))
      }
      }
      return s.nameofrecordtype.Title
    }
// Returns whether the element value for Title is nil in the container NameOfRecordType.
  func (s *NameOfRecordType) Title_IsNil() bool {
    return s.nameofrecordtype.Title == nil
    }

// Set the value of a property to nil
func (n *NameType) Unset(key string) *NameType {
        switch key {
  case "Type":
   n.nametype.Type = nil
  case "FamilyName":
   n.nametype.FamilyName = nil
  case "FamilyNameFirst":
   n.nametype.FamilyNameFirst = nil
  case "FullName":
   n.nametype.FullName = nil
  case "GivenName":
   n.nametype.GivenName = nil
  case "MiddleName":
   n.nametype.MiddleName = nil
  case "PreferredFamilyName":
   n.nametype.PreferredFamilyName = nil
  case "PreferredFamilyNameFirst":
   n.nametype.PreferredFamilyNameFirst = nil
  case "PreferredGivenName":
   n.nametype.PreferredGivenName = nil
  case "Suffix":
   n.nametype.Suffix = nil
  case "Title":
   n.nametype.Title = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NameType")
        }
        return n
}

// Set a sequence of properties
func (n *NameType) SetProperties(props ...Prop) *NameType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NameType) SetProperty(key string, value interface{}) *NameType {
        if n == nil {
                n, _ = NameTypePointer(NameType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNameUsageTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNameUsageTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.nametype.Type = ((*AUCodeSetsNameUsageTypeType)(v))
      }
    case "FamilyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nametype.FamilyName = ((*String)(v))
      }
    case "FamilyNameFirst":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.nametype.FamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "FullName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nametype.FullName = ((*String)(v))
      }
    case "GivenName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nametype.GivenName = ((*String)(v))
      }
    case "MiddleName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nametype.MiddleName = ((*String)(v))
      }
    case "PreferredFamilyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nametype.PreferredFamilyName = ((*String)(v))
      }
    case "PreferredFamilyNameFirst":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.nametype.PreferredFamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "PreferredGivenName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nametype.PreferredGivenName = ((*String)(v))
      }
    case "Suffix":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nametype.Suffix = ((*String)(v))
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.nametype.Title = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NameType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) Type() *AUCodeSetsNameUsageTypeType {
    if s.nametype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.Type = ((*AUCodeSetsNameUsageTypeType)(v))
      }
      }
      return s.nametype.Type
    }
// Returns whether the element value for Type is nil in the container NameType.
  func (s *NameType) Type_IsNil() bool {
    return s.nametype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) FamilyName() *String {
    if s.nametype.FamilyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.FamilyName = ((*String)(v))
      }
      }
      return s.nametype.FamilyName
    }
// Returns whether the element value for FamilyName is nil in the container NameType.
  func (s *NameType) FamilyName_IsNil() bool {
    return s.nametype.FamilyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) FamilyNameFirst() *AUCodeSetsYesOrNoCategoryType {
    if s.nametype.FamilyNameFirst == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.FamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.nametype.FamilyNameFirst
    }
// Returns whether the element value for FamilyNameFirst is nil in the container NameType.
  func (s *NameType) FamilyNameFirst_IsNil() bool {
    return s.nametype.FamilyNameFirst == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) FullName() *String {
    if s.nametype.FullName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.FullName = ((*String)(v))
      }
      }
      return s.nametype.FullName
    }
// Returns whether the element value for FullName is nil in the container NameType.
  func (s *NameType) FullName_IsNil() bool {
    return s.nametype.FullName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) GivenName() *String {
    if s.nametype.GivenName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.GivenName = ((*String)(v))
      }
      }
      return s.nametype.GivenName
    }
// Returns whether the element value for GivenName is nil in the container NameType.
  func (s *NameType) GivenName_IsNil() bool {
    return s.nametype.GivenName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) MiddleName() *String {
    if s.nametype.MiddleName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.MiddleName = ((*String)(v))
      }
      }
      return s.nametype.MiddleName
    }
// Returns whether the element value for MiddleName is nil in the container NameType.
  func (s *NameType) MiddleName_IsNil() bool {
    return s.nametype.MiddleName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) PreferredFamilyName() *String {
    if s.nametype.PreferredFamilyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.PreferredFamilyName = ((*String)(v))
      }
      }
      return s.nametype.PreferredFamilyName
    }
// Returns whether the element value for PreferredFamilyName is nil in the container NameType.
  func (s *NameType) PreferredFamilyName_IsNil() bool {
    return s.nametype.PreferredFamilyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) PreferredFamilyNameFirst() *AUCodeSetsYesOrNoCategoryType {
    if s.nametype.PreferredFamilyNameFirst == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.PreferredFamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.nametype.PreferredFamilyNameFirst
    }
// Returns whether the element value for PreferredFamilyNameFirst is nil in the container NameType.
  func (s *NameType) PreferredFamilyNameFirst_IsNil() bool {
    return s.nametype.PreferredFamilyNameFirst == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) PreferredGivenName() *String {
    if s.nametype.PreferredGivenName == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.PreferredGivenName = ((*String)(v))
      }
      }
      return s.nametype.PreferredGivenName
    }
// Returns whether the element value for PreferredGivenName is nil in the container NameType.
  func (s *NameType) PreferredGivenName_IsNil() bool {
    return s.nametype.PreferredGivenName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) Suffix() *String {
    if s.nametype.Suffix == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.Suffix = ((*String)(v))
      }
      }
      return s.nametype.Suffix
    }
// Returns whether the element value for Suffix is nil in the container NameType.
  func (s *NameType) Suffix_IsNil() bool {
    return s.nametype.Suffix == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NameType) Title() *String {
    if s.nametype.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.nametype.Title = ((*String)(v))
      }
      }
      return s.nametype.Title
    }
// Returns whether the element value for Title is nil in the container NameType.
  func (s *NameType) Title_IsNil() bool {
    return s.nametype.Title == nil
    }

// Set the value of a property to nil
func (n *NeverShareWithType) Unset(key string) *NeverShareWithType {
        switch key {
  case "NeverShareWithComments":
   n.neversharewithtype.NeverShareWithComments = nil
  case "NeverShareWithLocalId":
   n.neversharewithtype.NeverShareWithLocalId = nil
  case "NeverShareWithName":
   n.neversharewithtype.NeverShareWithName = nil
  case "NeverShareWithObjectTypeName":
   n.neversharewithtype.NeverShareWithObjectTypeName = nil
  case "NeverShareWithParty":
   n.neversharewithtype.NeverShareWithParty = nil
  case "NeverShareWithPurpose":
   n.neversharewithtype.NeverShareWithPurpose = nil
  case "NeverShareWithRefId":
   n.neversharewithtype.NeverShareWithRefId = nil
  case "NeverShareWithRelationship":
   n.neversharewithtype.NeverShareWithRelationship = nil
  case "NeverShareWithRole":
   n.neversharewithtype.NeverShareWithRole = nil
  case "NeverShareWithURL":
   n.neversharewithtype.NeverShareWithURL = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NeverShareWithType")
        }
        return n
}

// Set a sequence of properties
func (n *NeverShareWithType) SetProperties(props ...Prop) *NeverShareWithType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *NeverShareWithType) SetProperty(key string, value interface{}) *NeverShareWithType {
        if n == nil {
                n, _ = NeverShareWithTypePointer(NeverShareWithType{})
        }
        switch key {
    case "NeverShareWithComments":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithComments = ((*String)(v))
      }
    case "NeverShareWithLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithLocalId = ((*LocalIdType)(v))
      }
    case "NeverShareWithName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithName = ((*String)(v))
      }
    case "NeverShareWithObjectTypeName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithObjectTypeName = ((*String)(v))
      }
    case "NeverShareWithParty":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithParty = ((*String)(v))
      }
    case "NeverShareWithPurpose":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithPurpose = ((*String)(v))
      }
    case "NeverShareWithRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithRefId = ((*String)(v))
      }
    case "NeverShareWithRelationship":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithRelationship = ((*String)(v))
      }
    case "NeverShareWithRole":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithRole = ((*String)(v))
      }
    case "NeverShareWithURL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.neversharewithtype.NeverShareWithURL = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "NeverShareWithType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithComments() *String {
    if s.neversharewithtype.NeverShareWithComments == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithComments = ((*String)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithComments
    }
// Returns whether the element value for NeverShareWithComments is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithComments_IsNil() bool {
    return s.neversharewithtype.NeverShareWithComments == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithLocalId() *LocalIdType {
    if s.neversharewithtype.NeverShareWithLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithLocalId = ((*LocalIdType)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithLocalId
    }
// Returns whether the element value for NeverShareWithLocalId is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithLocalId_IsNil() bool {
    return s.neversharewithtype.NeverShareWithLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithName() *String {
    if s.neversharewithtype.NeverShareWithName == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithName = ((*String)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithName
    }
// Returns whether the element value for NeverShareWithName is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithName_IsNil() bool {
    return s.neversharewithtype.NeverShareWithName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithObjectTypeName() *String {
    if s.neversharewithtype.NeverShareWithObjectTypeName == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithObjectTypeName = ((*String)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithObjectTypeName
    }
// Returns whether the element value for NeverShareWithObjectTypeName is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithObjectTypeName_IsNil() bool {
    return s.neversharewithtype.NeverShareWithObjectTypeName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithParty() *String {
    if s.neversharewithtype.NeverShareWithParty == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithParty = ((*String)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithParty
    }
// Returns whether the element value for NeverShareWithParty is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithParty_IsNil() bool {
    return s.neversharewithtype.NeverShareWithParty == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithPurpose() *String {
    if s.neversharewithtype.NeverShareWithPurpose == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithPurpose = ((*String)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithPurpose
    }
// Returns whether the element value for NeverShareWithPurpose is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithPurpose_IsNil() bool {
    return s.neversharewithtype.NeverShareWithPurpose == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithRefId() *String {
    if s.neversharewithtype.NeverShareWithRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithRefId = ((*String)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithRefId
    }
// Returns whether the element value for NeverShareWithRefId is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithRefId_IsNil() bool {
    return s.neversharewithtype.NeverShareWithRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithRelationship() *String {
    if s.neversharewithtype.NeverShareWithRelationship == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithRelationship = ((*String)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithRelationship
    }
// Returns whether the element value for NeverShareWithRelationship is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithRelationship_IsNil() bool {
    return s.neversharewithtype.NeverShareWithRelationship == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithRole() *String {
    if s.neversharewithtype.NeverShareWithRole == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithRole = ((*String)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithRole
    }
// Returns whether the element value for NeverShareWithRole is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithRole_IsNil() bool {
    return s.neversharewithtype.NeverShareWithRole == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *NeverShareWithType) NeverShareWithURL() *String {
    if s.neversharewithtype.NeverShareWithURL == nil {
    if v, ok:= StringPointer(""); ok {
      s.neversharewithtype.NeverShareWithURL = ((*String)(v))
      }
      }
      return s.neversharewithtype.NeverShareWithURL
    }
// Returns whether the element value for NeverShareWithURL is nil in the container NeverShareWithType.
  func (s *NeverShareWithType) NeverShareWithURL_IsNil() bool {
    return s.neversharewithtype.NeverShareWithURL == nil
    }

// Set the value of a property to nil
func (n *OtherCodeListType_OtherCode) Unset(key string) *OtherCodeListType_OtherCode {
        switch key {
  case "Codeset":
   n.othercodelisttype_othercode.Codeset = nil
  case "Value":
   n.othercodelisttype_othercode.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "OtherCodeListType_OtherCode")
        }
        return n
}

// Set a sequence of properties
func (n *OtherCodeListType_OtherCode) SetProperties(props ...Prop) *OtherCodeListType_OtherCode {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *OtherCodeListType_OtherCode) SetProperty(key string, value interface{}) *OtherCodeListType_OtherCode {
        if n == nil {
                n, _ = OtherCodeListType_OtherCodePointer(OtherCodeListType_OtherCode{})
        }
        switch key {
    case "Codeset":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othercodelisttype_othercode.Codeset = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othercodelisttype_othercode.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "OtherCodeListType_OtherCode")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherCodeListType_OtherCode) Codeset() *String {
    if s.othercodelisttype_othercode.Codeset == nil {
    if v, ok:= StringPointer(""); ok {
      s.othercodelisttype_othercode.Codeset = ((*String)(v))
      }
      }
      return s.othercodelisttype_othercode.Codeset
    }
// Returns whether the element value for Codeset is nil in the container OtherCodeListType_OtherCode.
  func (s *OtherCodeListType_OtherCode) Codeset_IsNil() bool {
    return s.othercodelisttype_othercode.Codeset == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherCodeListType_OtherCode) Value() *String {
    if s.othercodelisttype_othercode.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.othercodelisttype_othercode.Value = ((*String)(v))
      }
      }
      return s.othercodelisttype_othercode.Value
    }
// Returns whether the element value for Value is nil in the container OtherCodeListType_OtherCode.
  func (s *OtherCodeListType_OtherCode) Value_IsNil() bool {
    return s.othercodelisttype_othercode.Value == nil
    }

// Set the value of a property to nil
func (n *OtherIdType) Unset(key string) *OtherIdType {
        switch key {
  case "Type":
   n.otheridtype.Type = nil
  case "Value":
   n.otheridtype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "OtherIdType")
        }
        return n
}

// Set a sequence of properties
func (n *OtherIdType) SetProperties(props ...Prop) *OtherIdType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *OtherIdType) SetProperty(key string, value interface{}) *OtherIdType {
        if n == nil {
                n, _ = OtherIdTypePointer(OtherIdType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.otheridtype.Type = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.otheridtype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "OtherIdType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherIdType) Type() *String {
    if s.otheridtype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.otheridtype.Type = ((*String)(v))
      }
      }
      return s.otheridtype.Type
    }
// Returns whether the element value for Type is nil in the container OtherIdType.
  func (s *OtherIdType) Type_IsNil() bool {
    return s.otheridtype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherIdType) Value() *String {
    if s.otheridtype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.otheridtype.Value = ((*String)(v))
      }
      }
      return s.otheridtype.Value
    }
// Returns whether the element value for Value is nil in the container OtherIdType.
  func (s *OtherIdType) Value_IsNil() bool {
    return s.otheridtype.Value == nil
    }

// Set the value of a property to nil
func (n *OtherNameType) Unset(key string) *OtherNameType {
        switch key {
  case "Type":
   n.othernametype.Type = nil
  case "FamilyName":
   n.othernametype.FamilyName = nil
  case "FamilyNameFirst":
   n.othernametype.FamilyNameFirst = nil
  case "FullName":
   n.othernametype.FullName = nil
  case "GivenName":
   n.othernametype.GivenName = nil
  case "MiddleName":
   n.othernametype.MiddleName = nil
  case "PreferredFamilyName":
   n.othernametype.PreferredFamilyName = nil
  case "PreferredFamilyNameFirst":
   n.othernametype.PreferredFamilyNameFirst = nil
  case "PreferredGivenName":
   n.othernametype.PreferredGivenName = nil
  case "Suffix":
   n.othernametype.Suffix = nil
  case "Title":
   n.othernametype.Title = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "OtherNameType")
        }
        return n
}

// Set a sequence of properties
func (n *OtherNameType) SetProperties(props ...Prop) *OtherNameType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *OtherNameType) SetProperty(key string, value interface{}) *OtherNameType {
        if n == nil {
                n, _ = OtherNameTypePointer(OtherNameType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNameUsageTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNameUsageTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.othernametype.Type = ((*AUCodeSetsNameUsageTypeType)(v))
      }
    case "FamilyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othernametype.FamilyName = ((*String)(v))
      }
    case "FamilyNameFirst":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.othernametype.FamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "FullName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othernametype.FullName = ((*String)(v))
      }
    case "GivenName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othernametype.GivenName = ((*String)(v))
      }
    case "MiddleName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othernametype.MiddleName = ((*String)(v))
      }
    case "PreferredFamilyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othernametype.PreferredFamilyName = ((*String)(v))
      }
    case "PreferredFamilyNameFirst":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.othernametype.PreferredFamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "PreferredGivenName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othernametype.PreferredGivenName = ((*String)(v))
      }
    case "Suffix":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othernametype.Suffix = ((*String)(v))
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.othernametype.Title = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "OtherNameType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) Type() *AUCodeSetsNameUsageTypeType {
    if s.othernametype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.Type = ((*AUCodeSetsNameUsageTypeType)(v))
      }
      }
      return s.othernametype.Type
    }
// Returns whether the element value for Type is nil in the container OtherNameType.
  func (s *OtherNameType) Type_IsNil() bool {
    return s.othernametype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) FamilyName() *String {
    if s.othernametype.FamilyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.FamilyName = ((*String)(v))
      }
      }
      return s.othernametype.FamilyName
    }
// Returns whether the element value for FamilyName is nil in the container OtherNameType.
  func (s *OtherNameType) FamilyName_IsNil() bool {
    return s.othernametype.FamilyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) FamilyNameFirst() *AUCodeSetsYesOrNoCategoryType {
    if s.othernametype.FamilyNameFirst == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.FamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.othernametype.FamilyNameFirst
    }
// Returns whether the element value for FamilyNameFirst is nil in the container OtherNameType.
  func (s *OtherNameType) FamilyNameFirst_IsNil() bool {
    return s.othernametype.FamilyNameFirst == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) FullName() *String {
    if s.othernametype.FullName == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.FullName = ((*String)(v))
      }
      }
      return s.othernametype.FullName
    }
// Returns whether the element value for FullName is nil in the container OtherNameType.
  func (s *OtherNameType) FullName_IsNil() bool {
    return s.othernametype.FullName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) GivenName() *String {
    if s.othernametype.GivenName == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.GivenName = ((*String)(v))
      }
      }
      return s.othernametype.GivenName
    }
// Returns whether the element value for GivenName is nil in the container OtherNameType.
  func (s *OtherNameType) GivenName_IsNil() bool {
    return s.othernametype.GivenName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) MiddleName() *String {
    if s.othernametype.MiddleName == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.MiddleName = ((*String)(v))
      }
      }
      return s.othernametype.MiddleName
    }
// Returns whether the element value for MiddleName is nil in the container OtherNameType.
  func (s *OtherNameType) MiddleName_IsNil() bool {
    return s.othernametype.MiddleName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) PreferredFamilyName() *String {
    if s.othernametype.PreferredFamilyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.PreferredFamilyName = ((*String)(v))
      }
      }
      return s.othernametype.PreferredFamilyName
    }
// Returns whether the element value for PreferredFamilyName is nil in the container OtherNameType.
  func (s *OtherNameType) PreferredFamilyName_IsNil() bool {
    return s.othernametype.PreferredFamilyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) PreferredFamilyNameFirst() *AUCodeSetsYesOrNoCategoryType {
    if s.othernametype.PreferredFamilyNameFirst == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.PreferredFamilyNameFirst = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.othernametype.PreferredFamilyNameFirst
    }
// Returns whether the element value for PreferredFamilyNameFirst is nil in the container OtherNameType.
  func (s *OtherNameType) PreferredFamilyNameFirst_IsNil() bool {
    return s.othernametype.PreferredFamilyNameFirst == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) PreferredGivenName() *String {
    if s.othernametype.PreferredGivenName == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.PreferredGivenName = ((*String)(v))
      }
      }
      return s.othernametype.PreferredGivenName
    }
// Returns whether the element value for PreferredGivenName is nil in the container OtherNameType.
  func (s *OtherNameType) PreferredGivenName_IsNil() bool {
    return s.othernametype.PreferredGivenName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) Suffix() *String {
    if s.othernametype.Suffix == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.Suffix = ((*String)(v))
      }
      }
      return s.othernametype.Suffix
    }
// Returns whether the element value for Suffix is nil in the container OtherNameType.
  func (s *OtherNameType) Suffix_IsNil() bool {
    return s.othernametype.Suffix == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherNameType) Title() *String {
    if s.othernametype.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.othernametype.Title = ((*String)(v))
      }
      }
      return s.othernametype.Title
    }
// Returns whether the element value for Title is nil in the container OtherNameType.
  func (s *OtherNameType) Title_IsNil() bool {
    return s.othernametype.Title == nil
    }

// Set the value of a property to nil
func (n *OtherWellbeingResponseContainerType) Unset(key string) *OtherWellbeingResponseContainerType {
        switch key {
  case "OtherResponseDate":
   n.otherwellbeingresponsecontainertype.OtherResponseDate = nil
  case "OtherResponseDescription":
   n.otherwellbeingresponsecontainertype.OtherResponseDescription = nil
  case "OtherResponseNotes":
   n.otherwellbeingresponsecontainertype.OtherResponseNotes = nil
  case "OtherResponseType":
   n.otherwellbeingresponsecontainertype.OtherResponseType = nil
  case "Status":
   n.otherwellbeingresponsecontainertype.Status = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "OtherWellbeingResponseContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *OtherWellbeingResponseContainerType) SetProperties(props ...Prop) *OtherWellbeingResponseContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *OtherWellbeingResponseContainerType) SetProperty(key string, value interface{}) *OtherWellbeingResponseContainerType {
        if n == nil {
                n, _ = OtherWellbeingResponseContainerTypePointer(OtherWellbeingResponseContainerType{})
        }
        switch key {
    case "OtherResponseDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.otherwellbeingresponsecontainertype.OtherResponseDate = ((*String)(v))
      }
    case "OtherResponseDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.otherwellbeingresponsecontainertype.OtherResponseDescription = ((*String)(v))
      }
    case "OtherResponseNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.otherwellbeingresponsecontainertype.OtherResponseNotes = ((*String)(v))
      }
    case "OtherResponseType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.otherwellbeingresponsecontainertype.OtherResponseType = ((*String)(v))
      }
    case "Status":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.otherwellbeingresponsecontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "OtherWellbeingResponseContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherWellbeingResponseContainerType) OtherResponseDate() *String {
    if s.otherwellbeingresponsecontainertype.OtherResponseDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.otherwellbeingresponsecontainertype.OtherResponseDate = ((*String)(v))
      }
      }
      return s.otherwellbeingresponsecontainertype.OtherResponseDate
    }
// Returns whether the element value for OtherResponseDate is nil in the container OtherWellbeingResponseContainerType.
  func (s *OtherWellbeingResponseContainerType) OtherResponseDate_IsNil() bool {
    return s.otherwellbeingresponsecontainertype.OtherResponseDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherWellbeingResponseContainerType) OtherResponseDescription() *String {
    if s.otherwellbeingresponsecontainertype.OtherResponseDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.otherwellbeingresponsecontainertype.OtherResponseDescription = ((*String)(v))
      }
      }
      return s.otherwellbeingresponsecontainertype.OtherResponseDescription
    }
// Returns whether the element value for OtherResponseDescription is nil in the container OtherWellbeingResponseContainerType.
  func (s *OtherWellbeingResponseContainerType) OtherResponseDescription_IsNil() bool {
    return s.otherwellbeingresponsecontainertype.OtherResponseDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherWellbeingResponseContainerType) OtherResponseNotes() *String {
    if s.otherwellbeingresponsecontainertype.OtherResponseNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.otherwellbeingresponsecontainertype.OtherResponseNotes = ((*String)(v))
      }
      }
      return s.otherwellbeingresponsecontainertype.OtherResponseNotes
    }
// Returns whether the element value for OtherResponseNotes is nil in the container OtherWellbeingResponseContainerType.
  func (s *OtherWellbeingResponseContainerType) OtherResponseNotes_IsNil() bool {
    return s.otherwellbeingresponsecontainertype.OtherResponseNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherWellbeingResponseContainerType) OtherResponseType() *String {
    if s.otherwellbeingresponsecontainertype.OtherResponseType == nil {
    if v, ok:= StringPointer(""); ok {
      s.otherwellbeingresponsecontainertype.OtherResponseType = ((*String)(v))
      }
      }
      return s.otherwellbeingresponsecontainertype.OtherResponseType
    }
// Returns whether the element value for OtherResponseType is nil in the container OtherWellbeingResponseContainerType.
  func (s *OtherWellbeingResponseContainerType) OtherResponseType_IsNil() bool {
    return s.otherwellbeingresponsecontainertype.OtherResponseType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *OtherWellbeingResponseContainerType) Status() *AUCodeSetsWellbeingStatusType {
    if s.otherwellbeingresponsecontainertype.Status == nil {
    if v, ok:= StringPointer(""); ok {
      s.otherwellbeingresponsecontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
      }
      return s.otherwellbeingresponsecontainertype.Status
    }
// Returns whether the element value for Status is nil in the container OtherWellbeingResponseContainerType.
  func (s *OtherWellbeingResponseContainerType) Status_IsNil() bool {
    return s.otherwellbeingresponsecontainertype.Status == nil
    }

// Set the value of a property to nil
func (n *PassportType) Unset(key string) *PassportType {
        switch key {
  case "Country":
   n.passporttype.Country = nil
  case "ExpiryDate":
   n.passporttype.ExpiryDate = nil
  case "Number":
   n.passporttype.Number = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PassportType")
        }
        return n
}

// Set a sequence of properties
func (n *PassportType) SetProperties(props ...Prop) *PassportType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PassportType) SetProperty(key string, value interface{}) *PassportType {
        if n == nil {
                n, _ = PassportTypePointer(PassportType{})
        }
        switch key {
    case "Country":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.passporttype.Country = ((*CountryType)(v))
      }
    case "ExpiryDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.passporttype.ExpiryDate = ((*String)(v))
      }
    case "Number":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.passporttype.Number = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PassportType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PassportType) Country() *CountryType {
    if s.passporttype.Country == nil {
    if v, ok:= StringPointer(""); ok {
      s.passporttype.Country = ((*CountryType)(v))
      }
      }
      return s.passporttype.Country
    }
// Returns whether the element value for Country is nil in the container PassportType.
  func (s *PassportType) Country_IsNil() bool {
    return s.passporttype.Country == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PassportType) ExpiryDate() *String {
    if s.passporttype.ExpiryDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.passporttype.ExpiryDate = ((*String)(v))
      }
      }
      return s.passporttype.ExpiryDate
    }
// Returns whether the element value for ExpiryDate is nil in the container PassportType.
  func (s *PassportType) ExpiryDate_IsNil() bool {
    return s.passporttype.ExpiryDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PassportType) Number() *String {
    if s.passporttype.Number == nil {
    if v, ok:= StringPointer(""); ok {
      s.passporttype.Number = ((*String)(v))
      }
      }
      return s.passporttype.Number
    }
// Returns whether the element value for Number is nil in the container PassportType.
  func (s *PassportType) Number_IsNil() bool {
    return s.passporttype.Number == nil
    }

// Set the value of a property to nil
func (n *PasswordListType_Password) Unset(key string) *PasswordListType_Password {
        switch key {
  case "Algorithm":
   n.passwordlisttype_password.Algorithm = nil
  case "KeyName":
   n.passwordlisttype_password.KeyName = nil
  case "Value":
   n.passwordlisttype_password.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PasswordListType_Password")
        }
        return n
}

// Set a sequence of properties
func (n *PasswordListType_Password) SetProperties(props ...Prop) *PasswordListType_Password {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PasswordListType_Password) SetProperty(key string, value interface{}) *PasswordListType_Password {
        if n == nil {
                n, _ = PasswordListType_PasswordPointer(PasswordListType_Password{})
        }
        switch key {
    case "Algorithm":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.passwordlisttype_password.Algorithm = ((*String)(v))
      }
    case "KeyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.passwordlisttype_password.KeyName = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.passwordlisttype_password.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PasswordListType_Password")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PasswordListType_Password) Algorithm() *String {
    if s.passwordlisttype_password.Algorithm == nil {
    if v, ok:= StringPointer(""); ok {
      s.passwordlisttype_password.Algorithm = ((*String)(v))
      }
      }
      return s.passwordlisttype_password.Algorithm
    }
// Returns whether the element value for Algorithm is nil in the container PasswordListType_Password.
  func (s *PasswordListType_Password) Algorithm_IsNil() bool {
    return s.passwordlisttype_password.Algorithm == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PasswordListType_Password) KeyName() *String {
    if s.passwordlisttype_password.KeyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.passwordlisttype_password.KeyName = ((*String)(v))
      }
      }
      return s.passwordlisttype_password.KeyName
    }
// Returns whether the element value for KeyName is nil in the container PasswordListType_Password.
  func (s *PasswordListType_Password) KeyName_IsNil() bool {
    return s.passwordlisttype_password.KeyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PasswordListType_Password) Value() *String {
    if s.passwordlisttype_password.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.passwordlisttype_password.Value = ((*String)(v))
      }
      }
      return s.passwordlisttype_password.Value
    }
// Returns whether the element value for Value is nil in the container PasswordListType_Password.
  func (s *PasswordListType_Password) Value_IsNil() bool {
    return s.passwordlisttype_password.Value == nil
    }

// Set the value of a property to nil
func (n *PaymentReceipt) Unset(key string) *PaymentReceipt {
        switch key {
  case "AccountCodeList":
   n.paymentreceipt.AccountCodeList = nil
  case "AccountingPeriod":
   n.paymentreceipt.AccountingPeriod = nil
  case "ChargedLocationInfoRefId":
   n.paymentreceipt.ChargedLocationInfoRefId = nil
  case "ChequeNumber":
   n.paymentreceipt.ChequeNumber = nil
  case "DebtorRefId":
   n.paymentreceipt.DebtorRefId = nil
  case "FinancialAccountRefIdList":
   n.paymentreceipt.FinancialAccountRefIdList = nil
  case "InvoiceRefId":
   n.paymentreceipt.InvoiceRefId = nil
  case "LocalCodeList":
   n.paymentreceipt.LocalCodeList = nil
  case "LocalId":
   n.paymentreceipt.LocalId = nil
  case "PaymentReceiptLineList":
   n.paymentreceipt.PaymentReceiptLineList = nil
  case "ReceivedTransactionId":
   n.paymentreceipt.ReceivedTransactionId = nil
  case "RefId":
   n.paymentreceipt.RefId = nil
  case "SIF_ExtendedElements":
   n.paymentreceipt.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.paymentreceipt.SIF_Metadata = nil
  case "TaxAmount":
   n.paymentreceipt.TaxAmount = nil
  case "TaxRate":
   n.paymentreceipt.TaxRate = nil
  case "TransactionAmount":
   n.paymentreceipt.TransactionAmount = nil
  case "TransactionDate":
   n.paymentreceipt.TransactionDate = nil
  case "TransactionDescription":
   n.paymentreceipt.TransactionDescription = nil
  case "TransactionMethod":
   n.paymentreceipt.TransactionMethod = nil
  case "TransactionNote":
   n.paymentreceipt.TransactionNote = nil
  case "TransactionType":
   n.paymentreceipt.TransactionType = nil
  case "VendorInfoRefId":
   n.paymentreceipt.VendorInfoRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PaymentReceipt")
        }
        return n
}

// Set a sequence of properties
func (n *PaymentReceipt) SetProperties(props ...Prop) *PaymentReceipt {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PaymentReceipt) SetProperty(key string, value interface{}) *PaymentReceipt {
        if n == nil {
                n, _ = PaymentReceiptPointer(PaymentReceipt{})
        }
        switch key {
    case "AccountCodeList":
    if v, ok:= AccountCodeListTypePointer(value); ok {
      n.paymentreceipt.AccountCodeList = v
      }
    case "AccountingPeriod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.AccountingPeriod = ((*LocalIdType)(v))
      }
    case "ChargedLocationInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.ChargedLocationInfoRefId = ((*String)(v))
      }
    case "ChequeNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.ChequeNumber = ((*String)(v))
      }
    case "DebtorRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.DebtorRefId = ((*String)(v))
      }
    case "FinancialAccountRefIdList":
    if v, ok:= FinancialAccountRefIdListTypePointer(value); ok {
      n.paymentreceipt.FinancialAccountRefIdList = v
      }
    case "InvoiceRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.InvoiceRefId = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.paymentreceipt.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.LocalId = ((*LocalIdType)(v))
      }
    case "PaymentReceiptLineList":
    if v, ok:= PaymentReceiptLineListTypePointer(value); ok {
      n.paymentreceipt.PaymentReceiptLineList = v
      }
    case "ReceivedTransactionId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.ReceivedTransactionId = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.paymentreceipt.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.paymentreceipt.SIF_Metadata = v
      }
    case "TaxAmount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.paymentreceipt.TaxAmount = v
      }
    case "TaxRate":
    
    if v, ok:= FloatPointer(value); ok {
      n.paymentreceipt.TaxRate = ((*Float)(v))
      }
    case "TransactionAmount":
    if v, ok:= DebitOrCreditAmountTypePointer(value); ok {
      n.paymentreceipt.TransactionAmount = v
      }
    case "TransactionDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.TransactionDate = ((*String)(v))
      }
    case "TransactionDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.TransactionDescription = ((*String)(v))
      }
    case "TransactionMethod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.TransactionMethod = ((*String)(v))
      }
    case "TransactionNote":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.TransactionNote = ((*String)(v))
      }
    case "TransactionType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.TransactionType = ((*String)(v))
      }
    case "VendorInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceipt.VendorInfoRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PaymentReceipt")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) AccountCodeList() *AccountCodeListType {
    if s.paymentreceipt.AccountCodeList == nil {
     if v, ok:= AccountCodeListTypePointer(AccountCodeListType{}); ok {
      s.paymentreceipt.AccountCodeList = v
      }
      }
      return s.paymentreceipt.AccountCodeList
    }
// Returns whether the element value for AccountCodeList is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) AccountCodeList_IsNil() bool {
    return s.paymentreceipt.AccountCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) AccountingPeriod() *LocalIdType {
    if s.paymentreceipt.AccountingPeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.AccountingPeriod = ((*LocalIdType)(v))
      }
      }
      return s.paymentreceipt.AccountingPeriod
    }
// Returns whether the element value for AccountingPeriod is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) AccountingPeriod_IsNil() bool {
    return s.paymentreceipt.AccountingPeriod == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) ChargedLocationInfoRefId() *String {
    if s.paymentreceipt.ChargedLocationInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.ChargedLocationInfoRefId = ((*String)(v))
      }
      }
      return s.paymentreceipt.ChargedLocationInfoRefId
    }
// Returns whether the element value for ChargedLocationInfoRefId is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) ChargedLocationInfoRefId_IsNil() bool {
    return s.paymentreceipt.ChargedLocationInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) ChequeNumber() *String {
    if s.paymentreceipt.ChequeNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.ChequeNumber = ((*String)(v))
      }
      }
      return s.paymentreceipt.ChequeNumber
    }
// Returns whether the element value for ChequeNumber is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) ChequeNumber_IsNil() bool {
    return s.paymentreceipt.ChequeNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) DebtorRefId() *String {
    if s.paymentreceipt.DebtorRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.DebtorRefId = ((*String)(v))
      }
      }
      return s.paymentreceipt.DebtorRefId
    }
// Returns whether the element value for DebtorRefId is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) DebtorRefId_IsNil() bool {
    return s.paymentreceipt.DebtorRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) FinancialAccountRefIdList() *FinancialAccountRefIdListType {
    if s.paymentreceipt.FinancialAccountRefIdList == nil {
     if v, ok:= FinancialAccountRefIdListTypePointer(FinancialAccountRefIdListType{}); ok {
      s.paymentreceipt.FinancialAccountRefIdList = v
      }
      }
      return s.paymentreceipt.FinancialAccountRefIdList
    }
// Returns whether the element value for FinancialAccountRefIdList is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) FinancialAccountRefIdList_IsNil() bool {
    return s.paymentreceipt.FinancialAccountRefIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) InvoiceRefId() *String {
    if s.paymentreceipt.InvoiceRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.InvoiceRefId = ((*String)(v))
      }
      }
      return s.paymentreceipt.InvoiceRefId
    }
// Returns whether the element value for InvoiceRefId is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) InvoiceRefId_IsNil() bool {
    return s.paymentreceipt.InvoiceRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) LocalCodeList() *LocalCodeListType {
    if s.paymentreceipt.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.paymentreceipt.LocalCodeList = v
      }
      }
      return s.paymentreceipt.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) LocalCodeList_IsNil() bool {
    return s.paymentreceipt.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) LocalId() *LocalIdType {
    if s.paymentreceipt.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.paymentreceipt.LocalId
    }
// Returns whether the element value for LocalId is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) LocalId_IsNil() bool {
    return s.paymentreceipt.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) PaymentReceiptLineList() *PaymentReceiptLineListType {
    if s.paymentreceipt.PaymentReceiptLineList == nil {
     if v, ok:= PaymentReceiptLineListTypePointer(PaymentReceiptLineListType{}); ok {
      s.paymentreceipt.PaymentReceiptLineList = v
      }
      }
      return s.paymentreceipt.PaymentReceiptLineList
    }
// Returns whether the element value for PaymentReceiptLineList is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) PaymentReceiptLineList_IsNil() bool {
    return s.paymentreceipt.PaymentReceiptLineList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) ReceivedTransactionId() *String {
    if s.paymentreceipt.ReceivedTransactionId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.ReceivedTransactionId = ((*String)(v))
      }
      }
      return s.paymentreceipt.ReceivedTransactionId
    }
// Returns whether the element value for ReceivedTransactionId is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) ReceivedTransactionId_IsNil() bool {
    return s.paymentreceipt.ReceivedTransactionId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) RefId() *RefIdType {
    if s.paymentreceipt.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.RefId = ((*RefIdType)(v))
      }
      }
      return s.paymentreceipt.RefId
    }
// Returns whether the element value for RefId is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) RefId_IsNil() bool {
    return s.paymentreceipt.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.paymentreceipt.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.paymentreceipt.SIF_ExtendedElements = v
      }
      }
      return s.paymentreceipt.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) SIF_ExtendedElements_IsNil() bool {
    return s.paymentreceipt.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) SIF_Metadata() *SIF_MetadataType {
    if s.paymentreceipt.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.paymentreceipt.SIF_Metadata = v
      }
      }
      return s.paymentreceipt.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) SIF_Metadata_IsNil() bool {
    return s.paymentreceipt.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) TaxAmount() *MonetaryAmountType {
    if s.paymentreceipt.TaxAmount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.paymentreceipt.TaxAmount = v
      }
      }
      return s.paymentreceipt.TaxAmount
    }
// Returns whether the element value for TaxAmount is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) TaxAmount_IsNil() bool {
    return s.paymentreceipt.TaxAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) TaxRate() *Float {
    if s.paymentreceipt.TaxRate == nil {
    if v, ok:= FloatPointer(0); ok {
      s.paymentreceipt.TaxRate = ((*Float)(v))
      }
      }
      return s.paymentreceipt.TaxRate
    }
// Returns whether the element value for TaxRate is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) TaxRate_IsNil() bool {
    return s.paymentreceipt.TaxRate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) TransactionAmount() *DebitOrCreditAmountType {
    if s.paymentreceipt.TransactionAmount == nil {
     if v, ok:= DebitOrCreditAmountTypePointer(DebitOrCreditAmountType{}); ok {
      s.paymentreceipt.TransactionAmount = v
      }
      }
      return s.paymentreceipt.TransactionAmount
    }
// Returns whether the element value for TransactionAmount is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) TransactionAmount_IsNil() bool {
    return s.paymentreceipt.TransactionAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) TransactionDate() *String {
    if s.paymentreceipt.TransactionDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.TransactionDate = ((*String)(v))
      }
      }
      return s.paymentreceipt.TransactionDate
    }
// Returns whether the element value for TransactionDate is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) TransactionDate_IsNil() bool {
    return s.paymentreceipt.TransactionDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) TransactionDescription() *String {
    if s.paymentreceipt.TransactionDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.TransactionDescription = ((*String)(v))
      }
      }
      return s.paymentreceipt.TransactionDescription
    }
// Returns whether the element value for TransactionDescription is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) TransactionDescription_IsNil() bool {
    return s.paymentreceipt.TransactionDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) TransactionMethod() *String {
    if s.paymentreceipt.TransactionMethod == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.TransactionMethod = ((*String)(v))
      }
      }
      return s.paymentreceipt.TransactionMethod
    }
// Returns whether the element value for TransactionMethod is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) TransactionMethod_IsNil() bool {
    return s.paymentreceipt.TransactionMethod == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) TransactionNote() *String {
    if s.paymentreceipt.TransactionNote == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.TransactionNote = ((*String)(v))
      }
      }
      return s.paymentreceipt.TransactionNote
    }
// Returns whether the element value for TransactionNote is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) TransactionNote_IsNil() bool {
    return s.paymentreceipt.TransactionNote == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) TransactionType() *String {
    if s.paymentreceipt.TransactionType == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.TransactionType = ((*String)(v))
      }
      }
      return s.paymentreceipt.TransactionType
    }
// Returns whether the element value for TransactionType is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) TransactionType_IsNil() bool {
    return s.paymentreceipt.TransactionType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceipt) VendorInfoRefId() *String {
    if s.paymentreceipt.VendorInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceipt.VendorInfoRefId = ((*String)(v))
      }
      }
      return s.paymentreceipt.VendorInfoRefId
    }
// Returns whether the element value for VendorInfoRefId is nil in the container PaymentReceipt.
  func (s *PaymentReceipt) VendorInfoRefId_IsNil() bool {
    return s.paymentreceipt.VendorInfoRefId == nil
    }

// Set the value of a property to nil
func (n *PaymentReceiptLineType) Unset(key string) *PaymentReceiptLineType {
        switch key {
  case "AccountCode":
   n.paymentreceiptlinetype.AccountCode = nil
  case "FinancialAccountRefId":
   n.paymentreceiptlinetype.FinancialAccountRefId = nil
  case "InvoiceRefId":
   n.paymentreceiptlinetype.InvoiceRefId = nil
  case "LocalId":
   n.paymentreceiptlinetype.LocalId = nil
  case "LocalPaymentReceiptLineId":
   n.paymentreceiptlinetype.LocalPaymentReceiptLineId = nil
  case "TaxAmount":
   n.paymentreceiptlinetype.TaxAmount = nil
  case "TaxRate":
   n.paymentreceiptlinetype.TaxRate = nil
  case "TransactionAmount":
   n.paymentreceiptlinetype.TransactionAmount = nil
  case "TransactionDescription":
   n.paymentreceiptlinetype.TransactionDescription = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PaymentReceiptLineType")
        }
        return n
}

// Set a sequence of properties
func (n *PaymentReceiptLineType) SetProperties(props ...Prop) *PaymentReceiptLineType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PaymentReceiptLineType) SetProperty(key string, value interface{}) *PaymentReceiptLineType {
        if n == nil {
                n, _ = PaymentReceiptLineTypePointer(PaymentReceiptLineType{})
        }
        switch key {
    case "AccountCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceiptlinetype.AccountCode = ((*String)(v))
      }
    case "FinancialAccountRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceiptlinetype.FinancialAccountRefId = ((*String)(v))
      }
    case "InvoiceRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceiptlinetype.InvoiceRefId = ((*String)(v))
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceiptlinetype.LocalId = ((*LocalIdType)(v))
      }
    case "LocalPaymentReceiptLineId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceiptlinetype.LocalPaymentReceiptLineId = ((*LocalIdType)(v))
      }
    case "TaxAmount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.paymentreceiptlinetype.TaxAmount = v
      }
    case "TaxRate":
    
    if v, ok:= FloatPointer(value); ok {
      n.paymentreceiptlinetype.TaxRate = ((*Float)(v))
      }
    case "TransactionAmount":
    if v, ok:= DebitOrCreditAmountTypePointer(value); ok {
      n.paymentreceiptlinetype.TransactionAmount = v
      }
    case "TransactionDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.paymentreceiptlinetype.TransactionDescription = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PaymentReceiptLineType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceiptLineType) AccountCode() *String {
    if s.paymentreceiptlinetype.AccountCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceiptlinetype.AccountCode = ((*String)(v))
      }
      }
      return s.paymentreceiptlinetype.AccountCode
    }
// Returns whether the element value for AccountCode is nil in the container PaymentReceiptLineType.
  func (s *PaymentReceiptLineType) AccountCode_IsNil() bool {
    return s.paymentreceiptlinetype.AccountCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceiptLineType) FinancialAccountRefId() *String {
    if s.paymentreceiptlinetype.FinancialAccountRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceiptlinetype.FinancialAccountRefId = ((*String)(v))
      }
      }
      return s.paymentreceiptlinetype.FinancialAccountRefId
    }
// Returns whether the element value for FinancialAccountRefId is nil in the container PaymentReceiptLineType.
  func (s *PaymentReceiptLineType) FinancialAccountRefId_IsNil() bool {
    return s.paymentreceiptlinetype.FinancialAccountRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceiptLineType) InvoiceRefId() *String {
    if s.paymentreceiptlinetype.InvoiceRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceiptlinetype.InvoiceRefId = ((*String)(v))
      }
      }
      return s.paymentreceiptlinetype.InvoiceRefId
    }
// Returns whether the element value for InvoiceRefId is nil in the container PaymentReceiptLineType.
  func (s *PaymentReceiptLineType) InvoiceRefId_IsNil() bool {
    return s.paymentreceiptlinetype.InvoiceRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceiptLineType) LocalId() *LocalIdType {
    if s.paymentreceiptlinetype.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceiptlinetype.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.paymentreceiptlinetype.LocalId
    }
// Returns whether the element value for LocalId is nil in the container PaymentReceiptLineType.
  func (s *PaymentReceiptLineType) LocalId_IsNil() bool {
    return s.paymentreceiptlinetype.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceiptLineType) LocalPaymentReceiptLineId() *LocalIdType {
    if s.paymentreceiptlinetype.LocalPaymentReceiptLineId == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceiptlinetype.LocalPaymentReceiptLineId = ((*LocalIdType)(v))
      }
      }
      return s.paymentreceiptlinetype.LocalPaymentReceiptLineId
    }
// Returns whether the element value for LocalPaymentReceiptLineId is nil in the container PaymentReceiptLineType.
  func (s *PaymentReceiptLineType) LocalPaymentReceiptLineId_IsNil() bool {
    return s.paymentreceiptlinetype.LocalPaymentReceiptLineId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceiptLineType) TaxAmount() *MonetaryAmountType {
    if s.paymentreceiptlinetype.TaxAmount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.paymentreceiptlinetype.TaxAmount = v
      }
      }
      return s.paymentreceiptlinetype.TaxAmount
    }
// Returns whether the element value for TaxAmount is nil in the container PaymentReceiptLineType.
  func (s *PaymentReceiptLineType) TaxAmount_IsNil() bool {
    return s.paymentreceiptlinetype.TaxAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceiptLineType) TaxRate() *Float {
    if s.paymentreceiptlinetype.TaxRate == nil {
    if v, ok:= FloatPointer(0); ok {
      s.paymentreceiptlinetype.TaxRate = ((*Float)(v))
      }
      }
      return s.paymentreceiptlinetype.TaxRate
    }
// Returns whether the element value for TaxRate is nil in the container PaymentReceiptLineType.
  func (s *PaymentReceiptLineType) TaxRate_IsNil() bool {
    return s.paymentreceiptlinetype.TaxRate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceiptLineType) TransactionAmount() *DebitOrCreditAmountType {
    if s.paymentreceiptlinetype.TransactionAmount == nil {
     if v, ok:= DebitOrCreditAmountTypePointer(DebitOrCreditAmountType{}); ok {
      s.paymentreceiptlinetype.TransactionAmount = v
      }
      }
      return s.paymentreceiptlinetype.TransactionAmount
    }
// Returns whether the element value for TransactionAmount is nil in the container PaymentReceiptLineType.
  func (s *PaymentReceiptLineType) TransactionAmount_IsNil() bool {
    return s.paymentreceiptlinetype.TransactionAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PaymentReceiptLineType) TransactionDescription() *String {
    if s.paymentreceiptlinetype.TransactionDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.paymentreceiptlinetype.TransactionDescription = ((*String)(v))
      }
      }
      return s.paymentreceiptlinetype.TransactionDescription
    }
// Returns whether the element value for TransactionDescription is nil in the container PaymentReceiptLineType.
  func (s *PaymentReceiptLineType) TransactionDescription_IsNil() bool {
    return s.paymentreceiptlinetype.TransactionDescription == nil
    }

// Set the value of a property to nil
func (n *PeriodAttendanceType) Unset(key string) *PeriodAttendanceType {
        switch key {
  case "AttendanceCode":
   n.periodattendancetype.AttendanceCode = nil
  case "AttendanceNote":
   n.periodattendancetype.AttendanceNote = nil
  case "AttendanceStatus":
   n.periodattendancetype.AttendanceStatus = nil
  case "AttendanceType":
   n.periodattendancetype.AttendanceType = nil
  case "Date":
   n.periodattendancetype.Date = nil
  case "DayId":
   n.periodattendancetype.DayId = nil
  case "EndTime":
   n.periodattendancetype.EndTime = nil
  case "RoomList":
   n.periodattendancetype.RoomList = nil
  case "ScheduledActivityRefId":
   n.periodattendancetype.ScheduledActivityRefId = nil
  case "SessionInfoRefId":
   n.periodattendancetype.SessionInfoRefId = nil
  case "StartTime":
   n.periodattendancetype.StartTime = nil
  case "TeacherList":
   n.periodattendancetype.TeacherList = nil
  case "TimeIn":
   n.periodattendancetype.TimeIn = nil
  case "TimeOut":
   n.periodattendancetype.TimeOut = nil
  case "TimeTableCellRefId":
   n.periodattendancetype.TimeTableCellRefId = nil
  case "TimeTableSubjectRefId":
   n.periodattendancetype.TimeTableSubjectRefId = nil
  case "TimetablePeriod":
   n.periodattendancetype.TimetablePeriod = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PeriodAttendanceType")
        }
        return n
}

// Set a sequence of properties
func (n *PeriodAttendanceType) SetProperties(props ...Prop) *PeriodAttendanceType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PeriodAttendanceType) SetProperty(key string, value interface{}) *PeriodAttendanceType {
        if n == nil {
                n, _ = PeriodAttendanceTypePointer(PeriodAttendanceType{})
        }
        switch key {
    case "AttendanceCode":
    if v, ok:= AttendanceCodeTypePointer(value); ok {
      n.periodattendancetype.AttendanceCode = v
      }
    case "AttendanceNote":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.AttendanceNote = ((*String)(v))
      }
    case "AttendanceStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAttendanceStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAttendanceStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.AttendanceStatus = ((*AUCodeSetsAttendanceStatusType)(v))
      }
    case "AttendanceType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.AttendanceType = ((*String)(v))
      }
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.Date = ((*String)(v))
      }
    case "DayId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.DayId = ((*LocalIdType)(v))
      }
    case "EndTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.EndTime = ((*String)(v))
      }
    case "RoomList":
    if v, ok:= RoomListTypePointer(value); ok {
      n.periodattendancetype.RoomList = v
      }
    case "ScheduledActivityRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.ScheduledActivityRefId = ((*String)(v))
      }
    case "SessionInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.SessionInfoRefId = ((*String)(v))
      }
    case "StartTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.StartTime = ((*String)(v))
      }
    case "TeacherList":
    if v, ok:= ScheduledTeacherListTypePointer(value); ok {
      n.periodattendancetype.TeacherList = v
      }
    case "TimeIn":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.TimeIn = ((*String)(v))
      }
    case "TimeOut":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.TimeOut = ((*String)(v))
      }
    case "TimeTableCellRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.TimeTableCellRefId = ((*String)(v))
      }
    case "TimeTableSubjectRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
    case "TimetablePeriod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.periodattendancetype.TimetablePeriod = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PeriodAttendanceType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) AttendanceCode() *AttendanceCodeType {
    if s.periodattendancetype.AttendanceCode == nil {
     if v, ok:= AttendanceCodeTypePointer(AttendanceCodeType{}); ok {
      s.periodattendancetype.AttendanceCode = v
      }
      }
      return s.periodattendancetype.AttendanceCode
    }
// Returns whether the element value for AttendanceCode is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) AttendanceCode_IsNil() bool {
    return s.periodattendancetype.AttendanceCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) AttendanceNote() *String {
    if s.periodattendancetype.AttendanceNote == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.AttendanceNote = ((*String)(v))
      }
      }
      return s.periodattendancetype.AttendanceNote
    }
// Returns whether the element value for AttendanceNote is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) AttendanceNote_IsNil() bool {
    return s.periodattendancetype.AttendanceNote == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) AttendanceStatus() *AUCodeSetsAttendanceStatusType {
    if s.periodattendancetype.AttendanceStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.AttendanceStatus = ((*AUCodeSetsAttendanceStatusType)(v))
      }
      }
      return s.periodattendancetype.AttendanceStatus
    }
// Returns whether the element value for AttendanceStatus is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) AttendanceStatus_IsNil() bool {
    return s.periodattendancetype.AttendanceStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) AttendanceType() *String {
    if s.periodattendancetype.AttendanceType == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.AttendanceType = ((*String)(v))
      }
      }
      return s.periodattendancetype.AttendanceType
    }
// Returns whether the element value for AttendanceType is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) AttendanceType_IsNil() bool {
    return s.periodattendancetype.AttendanceType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) Date() *String {
    if s.periodattendancetype.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.Date = ((*String)(v))
      }
      }
      return s.periodattendancetype.Date
    }
// Returns whether the element value for Date is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) Date_IsNil() bool {
    return s.periodattendancetype.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) DayId() *LocalIdType {
    if s.periodattendancetype.DayId == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.DayId = ((*LocalIdType)(v))
      }
      }
      return s.periodattendancetype.DayId
    }
// Returns whether the element value for DayId is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) DayId_IsNil() bool {
    return s.periodattendancetype.DayId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) EndTime() *String {
    if s.periodattendancetype.EndTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.EndTime = ((*String)(v))
      }
      }
      return s.periodattendancetype.EndTime
    }
// Returns whether the element value for EndTime is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) EndTime_IsNil() bool {
    return s.periodattendancetype.EndTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) RoomList() *RoomListType {
    if s.periodattendancetype.RoomList == nil {
     if v, ok:= RoomListTypePointer(RoomListType{}); ok {
      s.periodattendancetype.RoomList = v
      }
      }
      return s.periodattendancetype.RoomList
    }
// Returns whether the element value for RoomList is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) RoomList_IsNil() bool {
    return s.periodattendancetype.RoomList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) ScheduledActivityRefId() *String {
    if s.periodattendancetype.ScheduledActivityRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.ScheduledActivityRefId = ((*String)(v))
      }
      }
      return s.periodattendancetype.ScheduledActivityRefId
    }
// Returns whether the element value for ScheduledActivityRefId is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) ScheduledActivityRefId_IsNil() bool {
    return s.periodattendancetype.ScheduledActivityRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) SessionInfoRefId() *String {
    if s.periodattendancetype.SessionInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.SessionInfoRefId = ((*String)(v))
      }
      }
      return s.periodattendancetype.SessionInfoRefId
    }
// Returns whether the element value for SessionInfoRefId is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) SessionInfoRefId_IsNil() bool {
    return s.periodattendancetype.SessionInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) StartTime() *String {
    if s.periodattendancetype.StartTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.StartTime = ((*String)(v))
      }
      }
      return s.periodattendancetype.StartTime
    }
// Returns whether the element value for StartTime is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) StartTime_IsNil() bool {
    return s.periodattendancetype.StartTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) TeacherList() *ScheduledTeacherListType {
    if s.periodattendancetype.TeacherList == nil {
     if v, ok:= ScheduledTeacherListTypePointer(ScheduledTeacherListType{}); ok {
      s.periodattendancetype.TeacherList = v
      }
      }
      return s.periodattendancetype.TeacherList
    }
// Returns whether the element value for TeacherList is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) TeacherList_IsNil() bool {
    return s.periodattendancetype.TeacherList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) TimeIn() *String {
    if s.periodattendancetype.TimeIn == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.TimeIn = ((*String)(v))
      }
      }
      return s.periodattendancetype.TimeIn
    }
// Returns whether the element value for TimeIn is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) TimeIn_IsNil() bool {
    return s.periodattendancetype.TimeIn == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) TimeOut() *String {
    if s.periodattendancetype.TimeOut == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.TimeOut = ((*String)(v))
      }
      }
      return s.periodattendancetype.TimeOut
    }
// Returns whether the element value for TimeOut is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) TimeOut_IsNil() bool {
    return s.periodattendancetype.TimeOut == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) TimeTableCellRefId() *String {
    if s.periodattendancetype.TimeTableCellRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.TimeTableCellRefId = ((*String)(v))
      }
      }
      return s.periodattendancetype.TimeTableCellRefId
    }
// Returns whether the element value for TimeTableCellRefId is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) TimeTableCellRefId_IsNil() bool {
    return s.periodattendancetype.TimeTableCellRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) TimeTableSubjectRefId() *RefIdType {
    if s.periodattendancetype.TimeTableSubjectRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
      }
      return s.periodattendancetype.TimeTableSubjectRefId
    }
// Returns whether the element value for TimeTableSubjectRefId is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) TimeTableSubjectRefId_IsNil() bool {
    return s.periodattendancetype.TimeTableSubjectRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PeriodAttendanceType) TimetablePeriod() *String {
    if s.periodattendancetype.TimetablePeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.periodattendancetype.TimetablePeriod = ((*String)(v))
      }
      }
      return s.periodattendancetype.TimetablePeriod
    }
// Returns whether the element value for TimetablePeriod is nil in the container PeriodAttendanceType.
  func (s *PeriodAttendanceType) TimetablePeriod_IsNil() bool {
    return s.periodattendancetype.TimetablePeriod == nil
    }

// Set the value of a property to nil
func (n *PermissionToParticipateType) Unset(key string) *PermissionToParticipateType {
        switch key {
  case "Permission":
   n.permissiontoparticipatetype.Permission = nil
  case "PermissionCategory":
   n.permissiontoparticipatetype.PermissionCategory = nil
  case "PermissionComments":
   n.permissiontoparticipatetype.PermissionComments = nil
  case "PermissionEndDate":
   n.permissiontoparticipatetype.PermissionEndDate = nil
  case "PermissionGranteeName":
   n.permissiontoparticipatetype.PermissionGranteeName = nil
  case "PermissionGranteeObjectTypeName":
   n.permissiontoparticipatetype.PermissionGranteeObjectTypeName = nil
  case "PermissionGranteeRefId":
   n.permissiontoparticipatetype.PermissionGranteeRefId = nil
  case "PermissionGranteeRelationship":
   n.permissiontoparticipatetype.PermissionGranteeRelationship = nil
  case "PermissionStartDate":
   n.permissiontoparticipatetype.PermissionStartDate = nil
  case "PermissionValue":
   n.permissiontoparticipatetype.PermissionValue = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PermissionToParticipateType")
        }
        return n
}

// Set a sequence of properties
func (n *PermissionToParticipateType) SetProperties(props ...Prop) *PermissionToParticipateType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PermissionToParticipateType) SetProperty(key string, value interface{}) *PermissionToParticipateType {
        if n == nil {
                n, _ = PermissionToParticipateTypePointer(PermissionToParticipateType{})
        }
        switch key {
    case "Permission":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.Permission = ((*String)(v))
      }
    case "PermissionCategory":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.PermissionCategory = ((*String)(v))
      }
    case "PermissionComments":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.PermissionComments = ((*String)(v))
      }
    case "PermissionEndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.PermissionEndDate = ((*String)(v))
      }
    case "PermissionGranteeName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.PermissionGranteeName = ((*String)(v))
      }
    case "PermissionGranteeObjectTypeName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.PermissionGranteeObjectTypeName = ((*String)(v))
      }
    case "PermissionGranteeRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.PermissionGranteeRefId = ((*String)(v))
      }
    case "PermissionGranteeRelationship":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.PermissionGranteeRelationship = ((*String)(v))
      }
    case "PermissionStartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.PermissionStartDate = ((*String)(v))
      }
    case "PermissionValue":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.permissiontoparticipatetype.PermissionValue = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PermissionToParticipateType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) Permission() *String {
    if s.permissiontoparticipatetype.Permission == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.Permission = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.Permission
    }
// Returns whether the element value for Permission is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) Permission_IsNil() bool {
    return s.permissiontoparticipatetype.Permission == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) PermissionCategory() *String {
    if s.permissiontoparticipatetype.PermissionCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.PermissionCategory = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.PermissionCategory
    }
// Returns whether the element value for PermissionCategory is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) PermissionCategory_IsNil() bool {
    return s.permissiontoparticipatetype.PermissionCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) PermissionComments() *String {
    if s.permissiontoparticipatetype.PermissionComments == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.PermissionComments = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.PermissionComments
    }
// Returns whether the element value for PermissionComments is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) PermissionComments_IsNil() bool {
    return s.permissiontoparticipatetype.PermissionComments == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) PermissionEndDate() *String {
    if s.permissiontoparticipatetype.PermissionEndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.PermissionEndDate = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.PermissionEndDate
    }
// Returns whether the element value for PermissionEndDate is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) PermissionEndDate_IsNil() bool {
    return s.permissiontoparticipatetype.PermissionEndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) PermissionGranteeName() *String {
    if s.permissiontoparticipatetype.PermissionGranteeName == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.PermissionGranteeName = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.PermissionGranteeName
    }
// Returns whether the element value for PermissionGranteeName is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) PermissionGranteeName_IsNil() bool {
    return s.permissiontoparticipatetype.PermissionGranteeName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) PermissionGranteeObjectTypeName() *String {
    if s.permissiontoparticipatetype.PermissionGranteeObjectTypeName == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.PermissionGranteeObjectTypeName = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.PermissionGranteeObjectTypeName
    }
// Returns whether the element value for PermissionGranteeObjectTypeName is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) PermissionGranteeObjectTypeName_IsNil() bool {
    return s.permissiontoparticipatetype.PermissionGranteeObjectTypeName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) PermissionGranteeRefId() *String {
    if s.permissiontoparticipatetype.PermissionGranteeRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.PermissionGranteeRefId = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.PermissionGranteeRefId
    }
// Returns whether the element value for PermissionGranteeRefId is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) PermissionGranteeRefId_IsNil() bool {
    return s.permissiontoparticipatetype.PermissionGranteeRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) PermissionGranteeRelationship() *String {
    if s.permissiontoparticipatetype.PermissionGranteeRelationship == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.PermissionGranteeRelationship = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.PermissionGranteeRelationship
    }
// Returns whether the element value for PermissionGranteeRelationship is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) PermissionGranteeRelationship_IsNil() bool {
    return s.permissiontoparticipatetype.PermissionGranteeRelationship == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) PermissionStartDate() *String {
    if s.permissiontoparticipatetype.PermissionStartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.PermissionStartDate = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.PermissionStartDate
    }
// Returns whether the element value for PermissionStartDate is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) PermissionStartDate_IsNil() bool {
    return s.permissiontoparticipatetype.PermissionStartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PermissionToParticipateType) PermissionValue() *String {
    if s.permissiontoparticipatetype.PermissionValue == nil {
    if v, ok:= StringPointer(""); ok {
      s.permissiontoparticipatetype.PermissionValue = ((*String)(v))
      }
      }
      return s.permissiontoparticipatetype.PermissionValue
    }
// Returns whether the element value for PermissionValue is nil in the container PermissionToParticipateType.
  func (s *PermissionToParticipateType) PermissionValue_IsNil() bool {
    return s.permissiontoparticipatetype.PermissionValue == nil
    }

// Set the value of a property to nil
func (n *PersonInfoType) Unset(key string) *PersonInfoType {
        switch key {
  case "AddressList":
   n.personinfotype.AddressList = nil
  case "Demographics":
   n.personinfotype.Demographics = nil
  case "EmailList":
   n.personinfotype.EmailList = nil
  case "HouseholdContactInfoList":
   n.personinfotype.HouseholdContactInfoList = nil
  case "Name":
   n.personinfotype.Name = nil
  case "OtherNames":
   n.personinfotype.OtherNames = nil
  case "PhoneNumberList":
   n.personinfotype.PhoneNumberList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *PersonInfoType) SetProperties(props ...Prop) *PersonInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PersonInfoType) SetProperty(key string, value interface{}) *PersonInfoType {
        if n == nil {
                n, _ = PersonInfoTypePointer(PersonInfoType{})
        }
        switch key {
    case "AddressList":
    if v, ok:= AddressListTypePointer(value); ok {
      n.personinfotype.AddressList = v
      }
    case "Demographics":
    if v, ok:= DemographicsTypePointer(value); ok {
      n.personinfotype.Demographics = v
      }
    case "EmailList":
    if v, ok:= EmailListTypePointer(value); ok {
      n.personinfotype.EmailList = v
      }
    case "HouseholdContactInfoList":
    if v, ok:= HouseholdContactInfoListTypePointer(value); ok {
      n.personinfotype.HouseholdContactInfoList = v
      }
    case "Name":
    if v, ok:= NameOfRecordTypePointer(value); ok {
      n.personinfotype.Name = v
      }
    case "OtherNames":
    if v, ok:= OtherNamesTypePointer(value); ok {
      n.personinfotype.OtherNames = v
      }
    case "PhoneNumberList":
    if v, ok:= PhoneNumberListTypePointer(value); ok {
      n.personinfotype.PhoneNumberList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInfoType) AddressList() *AddressListType {
    if s.personinfotype.AddressList == nil {
     if v, ok:= AddressListTypePointer(AddressListType{}); ok {
      s.personinfotype.AddressList = v
      }
      }
      return s.personinfotype.AddressList
    }
// Returns whether the element value for AddressList is nil in the container PersonInfoType.
  func (s *PersonInfoType) AddressList_IsNil() bool {
    return s.personinfotype.AddressList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInfoType) Demographics() *DemographicsType {
    if s.personinfotype.Demographics == nil {
     if v, ok:= DemographicsTypePointer(DemographicsType{}); ok {
      s.personinfotype.Demographics = v
      }
      }
      return s.personinfotype.Demographics
    }
// Returns whether the element value for Demographics is nil in the container PersonInfoType.
  func (s *PersonInfoType) Demographics_IsNil() bool {
    return s.personinfotype.Demographics == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInfoType) EmailList() *EmailListType {
    if s.personinfotype.EmailList == nil {
     if v, ok:= EmailListTypePointer(EmailListType{}); ok {
      s.personinfotype.EmailList = v
      }
      }
      return s.personinfotype.EmailList
    }
// Returns whether the element value for EmailList is nil in the container PersonInfoType.
  func (s *PersonInfoType) EmailList_IsNil() bool {
    return s.personinfotype.EmailList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInfoType) HouseholdContactInfoList() *HouseholdContactInfoListType {
    if s.personinfotype.HouseholdContactInfoList == nil {
     if v, ok:= HouseholdContactInfoListTypePointer(HouseholdContactInfoListType{}); ok {
      s.personinfotype.HouseholdContactInfoList = v
      }
      }
      return s.personinfotype.HouseholdContactInfoList
    }
// Returns whether the element value for HouseholdContactInfoList is nil in the container PersonInfoType.
  func (s *PersonInfoType) HouseholdContactInfoList_IsNil() bool {
    return s.personinfotype.HouseholdContactInfoList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInfoType) Name() *NameOfRecordType {
    if s.personinfotype.Name == nil {
     if v, ok:= NameOfRecordTypePointer(NameOfRecordType{}); ok {
      s.personinfotype.Name = v
      }
      }
      return s.personinfotype.Name
    }
// Returns whether the element value for Name is nil in the container PersonInfoType.
  func (s *PersonInfoType) Name_IsNil() bool {
    return s.personinfotype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInfoType) OtherNames() *OtherNamesType {
    if s.personinfotype.OtherNames == nil {
     if v, ok:= OtherNamesTypePointer(OtherNamesType{}); ok {
      s.personinfotype.OtherNames = v
      }
      }
      return s.personinfotype.OtherNames
    }
// Returns whether the element value for OtherNames is nil in the container PersonInfoType.
  func (s *PersonInfoType) OtherNames_IsNil() bool {
    return s.personinfotype.OtherNames == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInfoType) PhoneNumberList() *PhoneNumberListType {
    if s.personinfotype.PhoneNumberList == nil {
     if v, ok:= PhoneNumberListTypePointer(PhoneNumberListType{}); ok {
      s.personinfotype.PhoneNumberList = v
      }
      }
      return s.personinfotype.PhoneNumberList
    }
// Returns whether the element value for PhoneNumberList is nil in the container PersonInfoType.
  func (s *PersonInfoType) PhoneNumberList_IsNil() bool {
    return s.personinfotype.PhoneNumberList == nil
    }

// Set the value of a property to nil
func (n *PersonInvolvementType) Unset(key string) *PersonInvolvementType {
        switch key {
  case "HowInvolved":
   n.personinvolvementtype.HowInvolved = nil
  case "PersonRefId":
   n.personinvolvementtype.PersonRefId = nil
  case "ShortName":
   n.personinvolvementtype.ShortName = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonInvolvementType")
        }
        return n
}

// Set a sequence of properties
func (n *PersonInvolvementType) SetProperties(props ...Prop) *PersonInvolvementType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PersonInvolvementType) SetProperty(key string, value interface{}) *PersonInvolvementType {
        if n == nil {
                n, _ = PersonInvolvementTypePointer(PersonInvolvementType{})
        }
        switch key {
    case "HowInvolved":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personinvolvementtype.HowInvolved = ((*String)(v))
      }
    case "PersonRefId":
    if v, ok:= PersonInvolvementType_PersonRefIdPointer(value); ok {
      n.personinvolvementtype.PersonRefId = v
      }
    case "ShortName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personinvolvementtype.ShortName = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonInvolvementType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInvolvementType) HowInvolved() *String {
    if s.personinvolvementtype.HowInvolved == nil {
    if v, ok:= StringPointer(""); ok {
      s.personinvolvementtype.HowInvolved = ((*String)(v))
      }
      }
      return s.personinvolvementtype.HowInvolved
    }
// Returns whether the element value for HowInvolved is nil in the container PersonInvolvementType.
  func (s *PersonInvolvementType) HowInvolved_IsNil() bool {
    return s.personinvolvementtype.HowInvolved == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInvolvementType) PersonRefId() *PersonInvolvementType_PersonRefId {
    if s.personinvolvementtype.PersonRefId == nil {
     if v, ok:= PersonInvolvementType_PersonRefIdPointer(PersonInvolvementType_PersonRefId{}); ok {
      s.personinvolvementtype.PersonRefId = v
      }
      }
      return s.personinvolvementtype.PersonRefId
    }
// Returns whether the element value for PersonRefId is nil in the container PersonInvolvementType.
  func (s *PersonInvolvementType) PersonRefId_IsNil() bool {
    return s.personinvolvementtype.PersonRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInvolvementType) ShortName() *String {
    if s.personinvolvementtype.ShortName == nil {
    if v, ok:= StringPointer(""); ok {
      s.personinvolvementtype.ShortName = ((*String)(v))
      }
      }
      return s.personinvolvementtype.ShortName
    }
// Returns whether the element value for ShortName is nil in the container PersonInvolvementType.
  func (s *PersonInvolvementType) ShortName_IsNil() bool {
    return s.personinvolvementtype.ShortName == nil
    }

// Set the value of a property to nil
func (n *PersonInvolvementType_PersonRefId) Unset(key string) *PersonInvolvementType_PersonRefId {
        switch key {
  case "SIF_RefObject":
   n.personinvolvementtype_personrefid.SIF_RefObject = nil
  case "Value":
   n.personinvolvementtype_personrefid.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonInvolvementType_PersonRefId")
        }
        return n
}

// Set a sequence of properties
func (n *PersonInvolvementType_PersonRefId) SetProperties(props ...Prop) *PersonInvolvementType_PersonRefId {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PersonInvolvementType_PersonRefId) SetProperty(key string, value interface{}) *PersonInvolvementType_PersonRefId {
        if n == nil {
                n, _ = PersonInvolvementType_PersonRefIdPointer(PersonInvolvementType_PersonRefId{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personinvolvementtype_personrefid.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personinvolvementtype_personrefid.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonInvolvementType_PersonRefId")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInvolvementType_PersonRefId) SIF_RefObject() *String {
    if s.personinvolvementtype_personrefid.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.personinvolvementtype_personrefid.SIF_RefObject = ((*String)(v))
      }
      }
      return s.personinvolvementtype_personrefid.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container PersonInvolvementType_PersonRefId.
  func (s *PersonInvolvementType_PersonRefId) SIF_RefObject_IsNil() bool {
    return s.personinvolvementtype_personrefid.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonInvolvementType_PersonRefId) Value() *String {
    if s.personinvolvementtype_personrefid.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.personinvolvementtype_personrefid.Value = ((*String)(v))
      }
      }
      return s.personinvolvementtype_personrefid.Value
    }
// Returns whether the element value for Value is nil in the container PersonInvolvementType_PersonRefId.
  func (s *PersonInvolvementType_PersonRefId) Value_IsNil() bool {
    return s.personinvolvementtype_personrefid.Value == nil
    }

// Set the value of a property to nil
func (n *PersonPicture) Unset(key string) *PersonPicture {
        switch key {
  case "LocalCodeList":
   n.personpicture.LocalCodeList = nil
  case "OKToPublish":
   n.personpicture.OKToPublish = nil
  case "ParentObjectRefId":
   n.personpicture.ParentObjectRefId = nil
  case "PictureSource":
   n.personpicture.PictureSource = nil
  case "PublishingPermissionList":
   n.personpicture.PublishingPermissionList = nil
  case "RefId":
   n.personpicture.RefId = nil
  case "SIF_ExtendedElements":
   n.personpicture.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.personpicture.SIF_Metadata = nil
  case "SchoolYear":
   n.personpicture.SchoolYear = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonPicture")
        }
        return n
}

// Set a sequence of properties
func (n *PersonPicture) SetProperties(props ...Prop) *PersonPicture {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PersonPicture) SetProperty(key string, value interface{}) *PersonPicture {
        if n == nil {
                n, _ = PersonPicturePointer(PersonPicture{})
        }
        switch key {
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.personpicture.LocalCodeList = v
      }
    case "OKToPublish":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.personpicture.OKToPublish = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "ParentObjectRefId":
    if v, ok:= PersonPicture_ParentObjectRefIdPointer(value); ok {
      n.personpicture.ParentObjectRefId = v
      }
    case "PictureSource":
    if v, ok:= PictureSourceTypePointer(value); ok {
      n.personpicture.PictureSource = v
      }
    case "PublishingPermissionList":
    if v, ok:= PublishingPermissionListTypePointer(value); ok {
      n.personpicture.PublishingPermissionList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personpicture.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.personpicture.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.personpicture.SIF_Metadata = v
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personpicture.SchoolYear = ((*SchoolYearType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonPicture")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture) LocalCodeList() *LocalCodeListType {
    if s.personpicture.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.personpicture.LocalCodeList = v
      }
      }
      return s.personpicture.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container PersonPicture.
  func (s *PersonPicture) LocalCodeList_IsNil() bool {
    return s.personpicture.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture) OKToPublish() *AUCodeSetsYesOrNoCategoryType {
    if s.personpicture.OKToPublish == nil {
    if v, ok:= StringPointer(""); ok {
      s.personpicture.OKToPublish = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.personpicture.OKToPublish
    }
// Returns whether the element value for OKToPublish is nil in the container PersonPicture.
  func (s *PersonPicture) OKToPublish_IsNil() bool {
    return s.personpicture.OKToPublish == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture) ParentObjectRefId() *PersonPicture_ParentObjectRefId {
    if s.personpicture.ParentObjectRefId == nil {
     if v, ok:= PersonPicture_ParentObjectRefIdPointer(PersonPicture_ParentObjectRefId{}); ok {
      s.personpicture.ParentObjectRefId = v
      }
      }
      return s.personpicture.ParentObjectRefId
    }
// Returns whether the element value for ParentObjectRefId is nil in the container PersonPicture.
  func (s *PersonPicture) ParentObjectRefId_IsNil() bool {
    return s.personpicture.ParentObjectRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture) PictureSource() *PictureSourceType {
    if s.personpicture.PictureSource == nil {
     if v, ok:= PictureSourceTypePointer(PictureSourceType{}); ok {
      s.personpicture.PictureSource = v
      }
      }
      return s.personpicture.PictureSource
    }
// Returns whether the element value for PictureSource is nil in the container PersonPicture.
  func (s *PersonPicture) PictureSource_IsNil() bool {
    return s.personpicture.PictureSource == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture) PublishingPermissionList() *PublishingPermissionListType {
    if s.personpicture.PublishingPermissionList == nil {
     if v, ok:= PublishingPermissionListTypePointer(PublishingPermissionListType{}); ok {
      s.personpicture.PublishingPermissionList = v
      }
      }
      return s.personpicture.PublishingPermissionList
    }
// Returns whether the element value for PublishingPermissionList is nil in the container PersonPicture.
  func (s *PersonPicture) PublishingPermissionList_IsNil() bool {
    return s.personpicture.PublishingPermissionList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture) RefId() *RefIdType {
    if s.personpicture.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.personpicture.RefId = ((*RefIdType)(v))
      }
      }
      return s.personpicture.RefId
    }
// Returns whether the element value for RefId is nil in the container PersonPicture.
  func (s *PersonPicture) RefId_IsNil() bool {
    return s.personpicture.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.personpicture.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.personpicture.SIF_ExtendedElements = v
      }
      }
      return s.personpicture.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container PersonPicture.
  func (s *PersonPicture) SIF_ExtendedElements_IsNil() bool {
    return s.personpicture.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture) SIF_Metadata() *SIF_MetadataType {
    if s.personpicture.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.personpicture.SIF_Metadata = v
      }
      }
      return s.personpicture.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container PersonPicture.
  func (s *PersonPicture) SIF_Metadata_IsNil() bool {
    return s.personpicture.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture) SchoolYear() *SchoolYearType {
    if s.personpicture.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.personpicture.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.personpicture.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container PersonPicture.
  func (s *PersonPicture) SchoolYear_IsNil() bool {
    return s.personpicture.SchoolYear == nil
    }

// Set the value of a property to nil
func (n *PersonPicture_ParentObjectRefId) Unset(key string) *PersonPicture_ParentObjectRefId {
        switch key {
  case "SIF_RefObject":
   n.personpicture_parentobjectrefid.SIF_RefObject = nil
  case "Value":
   n.personpicture_parentobjectrefid.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonPicture_ParentObjectRefId")
        }
        return n
}

// Set a sequence of properties
func (n *PersonPicture_ParentObjectRefId) SetProperties(props ...Prop) *PersonPicture_ParentObjectRefId {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PersonPicture_ParentObjectRefId) SetProperty(key string, value interface{}) *PersonPicture_ParentObjectRefId {
        if n == nil {
                n, _ = PersonPicture_ParentObjectRefIdPointer(PersonPicture_ParentObjectRefId{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personpicture_parentobjectrefid.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personpicture_parentobjectrefid.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonPicture_ParentObjectRefId")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture_ParentObjectRefId) SIF_RefObject() *String {
    if s.personpicture_parentobjectrefid.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.personpicture_parentobjectrefid.SIF_RefObject = ((*String)(v))
      }
      }
      return s.personpicture_parentobjectrefid.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container PersonPicture_ParentObjectRefId.
  func (s *PersonPicture_ParentObjectRefId) SIF_RefObject_IsNil() bool {
    return s.personpicture_parentobjectrefid.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPicture_ParentObjectRefId) Value() *String {
    if s.personpicture_parentobjectrefid.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.personpicture_parentobjectrefid.Value = ((*String)(v))
      }
      }
      return s.personpicture_parentobjectrefid.Value
    }
// Returns whether the element value for Value is nil in the container PersonPicture_ParentObjectRefId.
  func (s *PersonPicture_ParentObjectRefId) Value_IsNil() bool {
    return s.personpicture_parentobjectrefid.Value == nil
    }

// Set the value of a property to nil
func (n *PersonPrivacyObligationDocument) Unset(key string) *PersonPrivacyObligationDocument {
        switch key {
  case "ApplicableLawList":
   n.personprivacyobligationdocument.ApplicableLawList = nil
  case "ConsentToSharingOfData":
   n.personprivacyobligationdocument.ConsentToSharingOfData = nil
  case "ContactForRequestsObjectTypeName":
   n.personprivacyobligationdocument.ContactForRequestsObjectTypeName = nil
  case "ContactForRequestsRefId":
   n.personprivacyobligationdocument.ContactForRequestsRefId = nil
  case "EndDate":
   n.personprivacyobligationdocument.EndDate = nil
  case "LocalCodeList":
   n.personprivacyobligationdocument.LocalCodeList = nil
  case "ParentObjectTypeName":
   n.personprivacyobligationdocument.ParentObjectTypeName = nil
  case "ParentRefId":
   n.personprivacyobligationdocument.ParentRefId = nil
  case "PermissionToParticipateList":
   n.personprivacyobligationdocument.PermissionToParticipateList = nil
  case "RefId":
   n.personprivacyobligationdocument.RefId = nil
  case "SIF_ExtendedElements":
   n.personprivacyobligationdocument.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.personprivacyobligationdocument.SIF_Metadata = nil
  case "SchoolYear":
   n.personprivacyobligationdocument.SchoolYear = nil
  case "SettingLocationList":
   n.personprivacyobligationdocument.SettingLocationList = nil
  case "StartDate":
   n.personprivacyobligationdocument.StartDate = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonPrivacyObligationDocument")
        }
        return n
}

// Set a sequence of properties
func (n *PersonPrivacyObligationDocument) SetProperties(props ...Prop) *PersonPrivacyObligationDocument {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PersonPrivacyObligationDocument) SetProperty(key string, value interface{}) *PersonPrivacyObligationDocument {
        if n == nil {
                n, _ = PersonPrivacyObligationDocumentPointer(PersonPrivacyObligationDocument{})
        }
        switch key {
    case "ApplicableLawList":
    if v, ok:= ApplicableLawListTypePointer(value); ok {
      n.personprivacyobligationdocument.ApplicableLawList = v
      }
    case "ConsentToSharingOfData":
    if v, ok:= ConsentToSharingOfDataContainerTypePointer(value); ok {
      n.personprivacyobligationdocument.ConsentToSharingOfData = v
      }
    case "ContactForRequestsObjectTypeName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personprivacyobligationdocument.ContactForRequestsObjectTypeName = ((*String)(v))
      }
    case "ContactForRequestsRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personprivacyobligationdocument.ContactForRequestsRefId = ((*String)(v))
      }
    case "EndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personprivacyobligationdocument.EndDate = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.personprivacyobligationdocument.LocalCodeList = v
      }
    case "ParentObjectTypeName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personprivacyobligationdocument.ParentObjectTypeName = ((*String)(v))
      }
    case "ParentRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personprivacyobligationdocument.ParentRefId = ((*String)(v))
      }
    case "PermissionToParticipateList":
    if v, ok:= PermissionToParticipateListTypePointer(value); ok {
      n.personprivacyobligationdocument.PermissionToParticipateList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personprivacyobligationdocument.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.personprivacyobligationdocument.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.personprivacyobligationdocument.SIF_Metadata = v
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personprivacyobligationdocument.SchoolYear = ((*SchoolYearType)(v))
      }
    case "SettingLocationList":
    if v, ok:= SettingLocationListTypePointer(value); ok {
      n.personprivacyobligationdocument.SettingLocationList = v
      }
    case "StartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personprivacyobligationdocument.StartDate = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonPrivacyObligationDocument")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) ApplicableLawList() *ApplicableLawListType {
    if s.personprivacyobligationdocument.ApplicableLawList == nil {
     if v, ok:= ApplicableLawListTypePointer(ApplicableLawListType{}); ok {
      s.personprivacyobligationdocument.ApplicableLawList = v
      }
      }
      return s.personprivacyobligationdocument.ApplicableLawList
    }
// Returns whether the element value for ApplicableLawList is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) ApplicableLawList_IsNil() bool {
    return s.personprivacyobligationdocument.ApplicableLawList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) ConsentToSharingOfData() *ConsentToSharingOfDataContainerType {
    if s.personprivacyobligationdocument.ConsentToSharingOfData == nil {
     if v, ok:= ConsentToSharingOfDataContainerTypePointer(ConsentToSharingOfDataContainerType{}); ok {
      s.personprivacyobligationdocument.ConsentToSharingOfData = v
      }
      }
      return s.personprivacyobligationdocument.ConsentToSharingOfData
    }
// Returns whether the element value for ConsentToSharingOfData is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) ConsentToSharingOfData_IsNil() bool {
    return s.personprivacyobligationdocument.ConsentToSharingOfData == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) ContactForRequestsObjectTypeName() *String {
    if s.personprivacyobligationdocument.ContactForRequestsObjectTypeName == nil {
    if v, ok:= StringPointer(""); ok {
      s.personprivacyobligationdocument.ContactForRequestsObjectTypeName = ((*String)(v))
      }
      }
      return s.personprivacyobligationdocument.ContactForRequestsObjectTypeName
    }
// Returns whether the element value for ContactForRequestsObjectTypeName is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) ContactForRequestsObjectTypeName_IsNil() bool {
    return s.personprivacyobligationdocument.ContactForRequestsObjectTypeName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) ContactForRequestsRefId() *String {
    if s.personprivacyobligationdocument.ContactForRequestsRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.personprivacyobligationdocument.ContactForRequestsRefId = ((*String)(v))
      }
      }
      return s.personprivacyobligationdocument.ContactForRequestsRefId
    }
// Returns whether the element value for ContactForRequestsRefId is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) ContactForRequestsRefId_IsNil() bool {
    return s.personprivacyobligationdocument.ContactForRequestsRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) EndDate() *String {
    if s.personprivacyobligationdocument.EndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.personprivacyobligationdocument.EndDate = ((*String)(v))
      }
      }
      return s.personprivacyobligationdocument.EndDate
    }
// Returns whether the element value for EndDate is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) EndDate_IsNil() bool {
    return s.personprivacyobligationdocument.EndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) LocalCodeList() *LocalCodeListType {
    if s.personprivacyobligationdocument.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.personprivacyobligationdocument.LocalCodeList = v
      }
      }
      return s.personprivacyobligationdocument.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) LocalCodeList_IsNil() bool {
    return s.personprivacyobligationdocument.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) ParentObjectTypeName() *String {
    if s.personprivacyobligationdocument.ParentObjectTypeName == nil {
    if v, ok:= StringPointer(""); ok {
      s.personprivacyobligationdocument.ParentObjectTypeName = ((*String)(v))
      }
      }
      return s.personprivacyobligationdocument.ParentObjectTypeName
    }
// Returns whether the element value for ParentObjectTypeName is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) ParentObjectTypeName_IsNil() bool {
    return s.personprivacyobligationdocument.ParentObjectTypeName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) ParentRefId() *String {
    if s.personprivacyobligationdocument.ParentRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.personprivacyobligationdocument.ParentRefId = ((*String)(v))
      }
      }
      return s.personprivacyobligationdocument.ParentRefId
    }
// Returns whether the element value for ParentRefId is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) ParentRefId_IsNil() bool {
    return s.personprivacyobligationdocument.ParentRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) PermissionToParticipateList() *PermissionToParticipateListType {
    if s.personprivacyobligationdocument.PermissionToParticipateList == nil {
     if v, ok:= PermissionToParticipateListTypePointer(PermissionToParticipateListType{}); ok {
      s.personprivacyobligationdocument.PermissionToParticipateList = v
      }
      }
      return s.personprivacyobligationdocument.PermissionToParticipateList
    }
// Returns whether the element value for PermissionToParticipateList is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) PermissionToParticipateList_IsNil() bool {
    return s.personprivacyobligationdocument.PermissionToParticipateList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) RefId() *RefIdType {
    if s.personprivacyobligationdocument.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.personprivacyobligationdocument.RefId = ((*RefIdType)(v))
      }
      }
      return s.personprivacyobligationdocument.RefId
    }
// Returns whether the element value for RefId is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) RefId_IsNil() bool {
    return s.personprivacyobligationdocument.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.personprivacyobligationdocument.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.personprivacyobligationdocument.SIF_ExtendedElements = v
      }
      }
      return s.personprivacyobligationdocument.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) SIF_ExtendedElements_IsNil() bool {
    return s.personprivacyobligationdocument.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) SIF_Metadata() *SIF_MetadataType {
    if s.personprivacyobligationdocument.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.personprivacyobligationdocument.SIF_Metadata = v
      }
      }
      return s.personprivacyobligationdocument.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) SIF_Metadata_IsNil() bool {
    return s.personprivacyobligationdocument.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) SchoolYear() *SchoolYearType {
    if s.personprivacyobligationdocument.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.personprivacyobligationdocument.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.personprivacyobligationdocument.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) SchoolYear_IsNil() bool {
    return s.personprivacyobligationdocument.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) SettingLocationList() *SettingLocationListType {
    if s.personprivacyobligationdocument.SettingLocationList == nil {
     if v, ok:= SettingLocationListTypePointer(SettingLocationListType{}); ok {
      s.personprivacyobligationdocument.SettingLocationList = v
      }
      }
      return s.personprivacyobligationdocument.SettingLocationList
    }
// Returns whether the element value for SettingLocationList is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) SettingLocationList_IsNil() bool {
    return s.personprivacyobligationdocument.SettingLocationList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonPrivacyObligationDocument) StartDate() *String {
    if s.personprivacyobligationdocument.StartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.personprivacyobligationdocument.StartDate = ((*String)(v))
      }
      }
      return s.personprivacyobligationdocument.StartDate
    }
// Returns whether the element value for StartDate is nil in the container PersonPrivacyObligationDocument.
  func (s *PersonPrivacyObligationDocument) StartDate_IsNil() bool {
    return s.personprivacyobligationdocument.StartDate == nil
    }

// Set the value of a property to nil
func (n *PersonalisedPlan) Unset(key string) *PersonalisedPlan {
        switch key {
  case "AssociatedAttachment":
   n.personalisedplan.AssociatedAttachment = nil
  case "DocumentList":
   n.personalisedplan.DocumentList = nil
  case "LocalCodeList":
   n.personalisedplan.LocalCodeList = nil
  case "LocalId":
   n.personalisedplan.LocalId = nil
  case "PersonalisedPlanCategory":
   n.personalisedplan.PersonalisedPlanCategory = nil
  case "PersonalisedPlanEndDate":
   n.personalisedplan.PersonalisedPlanEndDate = nil
  case "PersonalisedPlanNotes":
   n.personalisedplan.PersonalisedPlanNotes = nil
  case "PersonalisedPlanReviewDate":
   n.personalisedplan.PersonalisedPlanReviewDate = nil
  case "PersonalisedPlanStartDate":
   n.personalisedplan.PersonalisedPlanStartDate = nil
  case "RefId":
   n.personalisedplan.RefId = nil
  case "SIF_ExtendedElements":
   n.personalisedplan.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.personalisedplan.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.personalisedplan.SchoolInfoRefId = nil
  case "StudentPersonalRefId":
   n.personalisedplan.StudentPersonalRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonalisedPlan")
        }
        return n
}

// Set a sequence of properties
func (n *PersonalisedPlan) SetProperties(props ...Prop) *PersonalisedPlan {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PersonalisedPlan) SetProperty(key string, value interface{}) *PersonalisedPlan {
        if n == nil {
                n, _ = PersonalisedPlanPointer(PersonalisedPlan{})
        }
        switch key {
    case "AssociatedAttachment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.AssociatedAttachment = ((*String)(v))
      }
    case "DocumentList":
    if v, ok:= WellbeingDocumentListTypePointer(value); ok {
      n.personalisedplan.DocumentList = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.personalisedplan.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.LocalId = ((*LocalIdType)(v))
      }
    case "PersonalisedPlanCategory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsPersonalisedPlanType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsPersonalisedPlanType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.PersonalisedPlanCategory = ((*AUCodeSetsPersonalisedPlanType)(v))
      }
    case "PersonalisedPlanEndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.PersonalisedPlanEndDate = ((*String)(v))
      }
    case "PersonalisedPlanNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.PersonalisedPlanNotes = ((*String)(v))
      }
    case "PersonalisedPlanReviewDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.PersonalisedPlanReviewDate = ((*String)(v))
      }
    case "PersonalisedPlanStartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.PersonalisedPlanStartDate = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.personalisedplan.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.personalisedplan.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.SchoolInfoRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.personalisedplan.StudentPersonalRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PersonalisedPlan")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) AssociatedAttachment() *String {
    if s.personalisedplan.AssociatedAttachment == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.AssociatedAttachment = ((*String)(v))
      }
      }
      return s.personalisedplan.AssociatedAttachment
    }
// Returns whether the element value for AssociatedAttachment is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) AssociatedAttachment_IsNil() bool {
    return s.personalisedplan.AssociatedAttachment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) DocumentList() *WellbeingDocumentListType {
    if s.personalisedplan.DocumentList == nil {
     if v, ok:= WellbeingDocumentListTypePointer(WellbeingDocumentListType{}); ok {
      s.personalisedplan.DocumentList = v
      }
      }
      return s.personalisedplan.DocumentList
    }
// Returns whether the element value for DocumentList is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) DocumentList_IsNil() bool {
    return s.personalisedplan.DocumentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) LocalCodeList() *LocalCodeListType {
    if s.personalisedplan.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.personalisedplan.LocalCodeList = v
      }
      }
      return s.personalisedplan.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) LocalCodeList_IsNil() bool {
    return s.personalisedplan.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) LocalId() *LocalIdType {
    if s.personalisedplan.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.personalisedplan.LocalId
    }
// Returns whether the element value for LocalId is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) LocalId_IsNil() bool {
    return s.personalisedplan.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) PersonalisedPlanCategory() *AUCodeSetsPersonalisedPlanType {
    if s.personalisedplan.PersonalisedPlanCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.PersonalisedPlanCategory = ((*AUCodeSetsPersonalisedPlanType)(v))
      }
      }
      return s.personalisedplan.PersonalisedPlanCategory
    }
// Returns whether the element value for PersonalisedPlanCategory is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) PersonalisedPlanCategory_IsNil() bool {
    return s.personalisedplan.PersonalisedPlanCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) PersonalisedPlanEndDate() *String {
    if s.personalisedplan.PersonalisedPlanEndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.PersonalisedPlanEndDate = ((*String)(v))
      }
      }
      return s.personalisedplan.PersonalisedPlanEndDate
    }
// Returns whether the element value for PersonalisedPlanEndDate is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) PersonalisedPlanEndDate_IsNil() bool {
    return s.personalisedplan.PersonalisedPlanEndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) PersonalisedPlanNotes() *String {
    if s.personalisedplan.PersonalisedPlanNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.PersonalisedPlanNotes = ((*String)(v))
      }
      }
      return s.personalisedplan.PersonalisedPlanNotes
    }
// Returns whether the element value for PersonalisedPlanNotes is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) PersonalisedPlanNotes_IsNil() bool {
    return s.personalisedplan.PersonalisedPlanNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) PersonalisedPlanReviewDate() *String {
    if s.personalisedplan.PersonalisedPlanReviewDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.PersonalisedPlanReviewDate = ((*String)(v))
      }
      }
      return s.personalisedplan.PersonalisedPlanReviewDate
    }
// Returns whether the element value for PersonalisedPlanReviewDate is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) PersonalisedPlanReviewDate_IsNil() bool {
    return s.personalisedplan.PersonalisedPlanReviewDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) PersonalisedPlanStartDate() *String {
    if s.personalisedplan.PersonalisedPlanStartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.PersonalisedPlanStartDate = ((*String)(v))
      }
      }
      return s.personalisedplan.PersonalisedPlanStartDate
    }
// Returns whether the element value for PersonalisedPlanStartDate is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) PersonalisedPlanStartDate_IsNil() bool {
    return s.personalisedplan.PersonalisedPlanStartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) RefId() *RefIdType {
    if s.personalisedplan.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.RefId = ((*RefIdType)(v))
      }
      }
      return s.personalisedplan.RefId
    }
// Returns whether the element value for RefId is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) RefId_IsNil() bool {
    return s.personalisedplan.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.personalisedplan.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.personalisedplan.SIF_ExtendedElements = v
      }
      }
      return s.personalisedplan.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) SIF_ExtendedElements_IsNil() bool {
    return s.personalisedplan.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) SIF_Metadata() *SIF_MetadataType {
    if s.personalisedplan.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.personalisedplan.SIF_Metadata = v
      }
      }
      return s.personalisedplan.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) SIF_Metadata_IsNil() bool {
    return s.personalisedplan.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) SchoolInfoRefId() *String {
    if s.personalisedplan.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.personalisedplan.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) SchoolInfoRefId_IsNil() bool {
    return s.personalisedplan.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PersonalisedPlan) StudentPersonalRefId() *String {
    if s.personalisedplan.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.personalisedplan.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.personalisedplan.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container PersonalisedPlan.
  func (s *PersonalisedPlan) StudentPersonalRefId_IsNil() bool {
    return s.personalisedplan.StudentPersonalRefId == nil
    }

// Set the value of a property to nil
func (n *PhoneNumberType) Unset(key string) *PhoneNumberType {
        switch key {
  case "Extension":
   n.phonenumbertype.Extension = nil
  case "ListedStatus":
   n.phonenumbertype.ListedStatus = nil
  case "Number":
   n.phonenumbertype.Number = nil
  case "Preference":
   n.phonenumbertype.Preference = nil
  case "Type":
   n.phonenumbertype.Type = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PhoneNumberType")
        }
        return n
}

// Set a sequence of properties
func (n *PhoneNumberType) SetProperties(props ...Prop) *PhoneNumberType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PhoneNumberType) SetProperty(key string, value interface{}) *PhoneNumberType {
        if n == nil {
                n, _ = PhoneNumberTypePointer(PhoneNumberType{})
        }
        switch key {
    case "Extension":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.phonenumbertype.Extension = ((*String)(v))
      }
    case "ListedStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.phonenumbertype.ListedStatus = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "Number":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.phonenumbertype.Number = ((*String)(v))
      }
    case "Preference":
    
    if v, ok:= IntPointer(value); ok {
      n.phonenumbertype.Preference = ((*Int)(v))
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsTelephoneNumberTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsTelephoneNumberTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.phonenumbertype.Type = ((*AUCodeSetsTelephoneNumberTypeType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PhoneNumberType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PhoneNumberType) Extension() *String {
    if s.phonenumbertype.Extension == nil {
    if v, ok:= StringPointer(""); ok {
      s.phonenumbertype.Extension = ((*String)(v))
      }
      }
      return s.phonenumbertype.Extension
    }
// Returns whether the element value for Extension is nil in the container PhoneNumberType.
  func (s *PhoneNumberType) Extension_IsNil() bool {
    return s.phonenumbertype.Extension == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PhoneNumberType) ListedStatus() *AUCodeSetsYesOrNoCategoryType {
    if s.phonenumbertype.ListedStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.phonenumbertype.ListedStatus = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.phonenumbertype.ListedStatus
    }
// Returns whether the element value for ListedStatus is nil in the container PhoneNumberType.
  func (s *PhoneNumberType) ListedStatus_IsNil() bool {
    return s.phonenumbertype.ListedStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PhoneNumberType) Number() *String {
    if s.phonenumbertype.Number == nil {
    if v, ok:= StringPointer(""); ok {
      s.phonenumbertype.Number = ((*String)(v))
      }
      }
      return s.phonenumbertype.Number
    }
// Returns whether the element value for Number is nil in the container PhoneNumberType.
  func (s *PhoneNumberType) Number_IsNil() bool {
    return s.phonenumbertype.Number == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PhoneNumberType) Preference() *Int {
    if s.phonenumbertype.Preference == nil {
    if v, ok:= IntPointer(0); ok {
      s.phonenumbertype.Preference = ((*Int)(v))
      }
      }
      return s.phonenumbertype.Preference
    }
// Returns whether the element value for Preference is nil in the container PhoneNumberType.
  func (s *PhoneNumberType) Preference_IsNil() bool {
    return s.phonenumbertype.Preference == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PhoneNumberType) Type() *AUCodeSetsTelephoneNumberTypeType {
    if s.phonenumbertype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.phonenumbertype.Type = ((*AUCodeSetsTelephoneNumberTypeType)(v))
      }
      }
      return s.phonenumbertype.Type
    }
// Returns whether the element value for Type is nil in the container PhoneNumberType.
  func (s *PhoneNumberType) Type_IsNil() bool {
    return s.phonenumbertype.Type == nil
    }

// Set the value of a property to nil
func (n *PictureSourceType) Unset(key string) *PictureSourceType {
        switch key {
  case "Type":
   n.picturesourcetype.Type = nil
  case "Value":
   n.picturesourcetype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PictureSourceType")
        }
        return n
}

// Set a sequence of properties
func (n *PictureSourceType) SetProperties(props ...Prop) *PictureSourceType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PictureSourceType) SetProperty(key string, value interface{}) *PictureSourceType {
        if n == nil {
                n, _ = PictureSourceTypePointer(PictureSourceType{})
        }
        switch key {
    case "Type":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsPictureSourceType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsPictureSourceType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.picturesourcetype.Type = ((*AUCodeSetsPictureSourceType)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.picturesourcetype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PictureSourceType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PictureSourceType) Type() *AUCodeSetsPictureSourceType {
    if s.picturesourcetype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.picturesourcetype.Type = ((*AUCodeSetsPictureSourceType)(v))
      }
      }
      return s.picturesourcetype.Type
    }
// Returns whether the element value for Type is nil in the container PictureSourceType.
  func (s *PictureSourceType) Type_IsNil() bool {
    return s.picturesourcetype.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PictureSourceType) Value() *String {
    if s.picturesourcetype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.picturesourcetype.Value = ((*String)(v))
      }
      }
      return s.picturesourcetype.Value
    }
// Returns whether the element value for Value is nil in the container PictureSourceType.
  func (s *PictureSourceType) Value_IsNil() bool {
    return s.picturesourcetype.Value == nil
    }

// Set the value of a property to nil
func (n *PlanRequiredContainerType) Unset(key string) *PlanRequiredContainerType {
        switch key {
  case "PlanRequiredList":
   n.planrequiredcontainertype.PlanRequiredList = nil
  case "Status":
   n.planrequiredcontainertype.Status = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PlanRequiredContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *PlanRequiredContainerType) SetProperties(props ...Prop) *PlanRequiredContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PlanRequiredContainerType) SetProperty(key string, value interface{}) *PlanRequiredContainerType {
        if n == nil {
                n, _ = PlanRequiredContainerTypePointer(PlanRequiredContainerType{})
        }
        switch key {
    case "PlanRequiredList":
    if v, ok:= PlanRequiredListTypePointer(value); ok {
      n.planrequiredcontainertype.PlanRequiredList = v
      }
    case "Status":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.planrequiredcontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PlanRequiredContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PlanRequiredContainerType) PlanRequiredList() *PlanRequiredListType {
    if s.planrequiredcontainertype.PlanRequiredList == nil {
     if v, ok:= PlanRequiredListTypePointer(PlanRequiredListType{}); ok {
      s.planrequiredcontainertype.PlanRequiredList = v
      }
      }
      return s.planrequiredcontainertype.PlanRequiredList
    }
// Returns whether the element value for PlanRequiredList is nil in the container PlanRequiredContainerType.
  func (s *PlanRequiredContainerType) PlanRequiredList_IsNil() bool {
    return s.planrequiredcontainertype.PlanRequiredList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PlanRequiredContainerType) Status() *AUCodeSetsWellbeingStatusType {
    if s.planrequiredcontainertype.Status == nil {
    if v, ok:= StringPointer(""); ok {
      s.planrequiredcontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
      }
      return s.planrequiredcontainertype.Status
    }
// Returns whether the element value for Status is nil in the container PlanRequiredContainerType.
  func (s *PlanRequiredContainerType) Status_IsNil() bool {
    return s.planrequiredcontainertype.Status == nil
    }

// Set the value of a property to nil
func (n *PreviousSchoolType) Unset(key string) *PreviousSchoolType {
        switch key {
  case "ACARAId":
   n.previousschooltype.ACARAId = nil
  case "City":
   n.previousschooltype.City = nil
  case "ExitReason":
   n.previousschooltype.ExitReason = nil
  case "Name":
   n.previousschooltype.Name = nil
  case "Sector":
   n.previousschooltype.Sector = nil
  case "State":
   n.previousschooltype.State = nil
  case "System":
   n.previousschooltype.System = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PreviousSchoolType")
        }
        return n
}

// Set a sequence of properties
func (n *PreviousSchoolType) SetProperties(props ...Prop) *PreviousSchoolType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PreviousSchoolType) SetProperty(key string, value interface{}) *PreviousSchoolType {
        if n == nil {
                n, _ = PreviousSchoolTypePointer(PreviousSchoolType{})
        }
        switch key {
    case "ACARAId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.previousschooltype.ACARAId = ((*String)(v))
      }
    case "City":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.previousschooltype.City = ((*String)(v))
      }
    case "ExitReason":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.previousschooltype.ExitReason = ((*String)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.previousschooltype.Name = ((*String)(v))
      }
    case "Sector":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolSectorCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolSectorCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.previousschooltype.Sector = ((*AUCodeSetsSchoolSectorCodeType)(v))
      }
    case "State":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.previousschooltype.State = ((*StateProvinceType)(v))
      }
    case "System":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolSystemType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolSystemType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.previousschooltype.System = ((*AUCodeSetsSchoolSystemType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PreviousSchoolType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PreviousSchoolType) ACARAId() *String {
    if s.previousschooltype.ACARAId == nil {
    if v, ok:= StringPointer(""); ok {
      s.previousschooltype.ACARAId = ((*String)(v))
      }
      }
      return s.previousschooltype.ACARAId
    }
// Returns whether the element value for ACARAId is nil in the container PreviousSchoolType.
  func (s *PreviousSchoolType) ACARAId_IsNil() bool {
    return s.previousschooltype.ACARAId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PreviousSchoolType) City() *String {
    if s.previousschooltype.City == nil {
    if v, ok:= StringPointer(""); ok {
      s.previousschooltype.City = ((*String)(v))
      }
      }
      return s.previousschooltype.City
    }
// Returns whether the element value for City is nil in the container PreviousSchoolType.
  func (s *PreviousSchoolType) City_IsNil() bool {
    return s.previousschooltype.City == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PreviousSchoolType) ExitReason() *String {
    if s.previousschooltype.ExitReason == nil {
    if v, ok:= StringPointer(""); ok {
      s.previousschooltype.ExitReason = ((*String)(v))
      }
      }
      return s.previousschooltype.ExitReason
    }
// Returns whether the element value for ExitReason is nil in the container PreviousSchoolType.
  func (s *PreviousSchoolType) ExitReason_IsNil() bool {
    return s.previousschooltype.ExitReason == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PreviousSchoolType) Name() *String {
    if s.previousschooltype.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.previousschooltype.Name = ((*String)(v))
      }
      }
      return s.previousschooltype.Name
    }
// Returns whether the element value for Name is nil in the container PreviousSchoolType.
  func (s *PreviousSchoolType) Name_IsNil() bool {
    return s.previousschooltype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PreviousSchoolType) Sector() *AUCodeSetsSchoolSectorCodeType {
    if s.previousschooltype.Sector == nil {
    if v, ok:= StringPointer(""); ok {
      s.previousschooltype.Sector = ((*AUCodeSetsSchoolSectorCodeType)(v))
      }
      }
      return s.previousschooltype.Sector
    }
// Returns whether the element value for Sector is nil in the container PreviousSchoolType.
  func (s *PreviousSchoolType) Sector_IsNil() bool {
    return s.previousschooltype.Sector == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PreviousSchoolType) State() *StateProvinceType {
    if s.previousschooltype.State == nil {
    if v, ok:= StringPointer(""); ok {
      s.previousschooltype.State = ((*StateProvinceType)(v))
      }
      }
      return s.previousschooltype.State
    }
// Returns whether the element value for State is nil in the container PreviousSchoolType.
  func (s *PreviousSchoolType) State_IsNil() bool {
    return s.previousschooltype.State == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PreviousSchoolType) System() *AUCodeSetsSchoolSystemType {
    if s.previousschooltype.System == nil {
    if v, ok:= StringPointer(""); ok {
      s.previousschooltype.System = ((*AUCodeSetsSchoolSystemType)(v))
      }
      }
      return s.previousschooltype.System
    }
// Returns whether the element value for System is nil in the container PreviousSchoolType.
  func (s *PreviousSchoolType) System_IsNil() bool {
    return s.previousschooltype.System == nil
    }

// Set the value of a property to nil
func (n *PrincipalInfoType) Unset(key string) *PrincipalInfoType {
        switch key {
  case "ContactName":
   n.principalinfotype.ContactName = nil
  case "ContactTitle":
   n.principalinfotype.ContactTitle = nil
  case "EmailList":
   n.principalinfotype.EmailList = nil
  case "PhoneNumberList":
   n.principalinfotype.PhoneNumberList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PrincipalInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *PrincipalInfoType) SetProperties(props ...Prop) *PrincipalInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PrincipalInfoType) SetProperty(key string, value interface{}) *PrincipalInfoType {
        if n == nil {
                n, _ = PrincipalInfoTypePointer(PrincipalInfoType{})
        }
        switch key {
    case "ContactName":
    if v, ok:= NameOfRecordTypePointer(value); ok {
      n.principalinfotype.ContactName = v
      }
    case "ContactTitle":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.principalinfotype.ContactTitle = ((*String)(v))
      }
    case "EmailList":
    if v, ok:= EmailListTypePointer(value); ok {
      n.principalinfotype.EmailList = v
      }
    case "PhoneNumberList":
    if v, ok:= PhoneNumberListTypePointer(value); ok {
      n.principalinfotype.PhoneNumberList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PrincipalInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PrincipalInfoType) ContactName() *NameOfRecordType {
    if s.principalinfotype.ContactName == nil {
     if v, ok:= NameOfRecordTypePointer(NameOfRecordType{}); ok {
      s.principalinfotype.ContactName = v
      }
      }
      return s.principalinfotype.ContactName
    }
// Returns whether the element value for ContactName is nil in the container PrincipalInfoType.
  func (s *PrincipalInfoType) ContactName_IsNil() bool {
    return s.principalinfotype.ContactName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PrincipalInfoType) ContactTitle() *String {
    if s.principalinfotype.ContactTitle == nil {
    if v, ok:= StringPointer(""); ok {
      s.principalinfotype.ContactTitle = ((*String)(v))
      }
      }
      return s.principalinfotype.ContactTitle
    }
// Returns whether the element value for ContactTitle is nil in the container PrincipalInfoType.
  func (s *PrincipalInfoType) ContactTitle_IsNil() bool {
    return s.principalinfotype.ContactTitle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PrincipalInfoType) EmailList() *EmailListType {
    if s.principalinfotype.EmailList == nil {
     if v, ok:= EmailListTypePointer(EmailListType{}); ok {
      s.principalinfotype.EmailList = v
      }
      }
      return s.principalinfotype.EmailList
    }
// Returns whether the element value for EmailList is nil in the container PrincipalInfoType.
  func (s *PrincipalInfoType) EmailList_IsNil() bool {
    return s.principalinfotype.EmailList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PrincipalInfoType) PhoneNumberList() *PhoneNumberListType {
    if s.principalinfotype.PhoneNumberList == nil {
     if v, ok:= PhoneNumberListTypePointer(PhoneNumberListType{}); ok {
      s.principalinfotype.PhoneNumberList = v
      }
      }
      return s.principalinfotype.PhoneNumberList
    }
// Returns whether the element value for PhoneNumberList is nil in the container PrincipalInfoType.
  func (s *PrincipalInfoType) PhoneNumberList_IsNil() bool {
    return s.principalinfotype.PhoneNumberList == nil
    }

// Set the value of a property to nil
func (n *PrivateHealthInsuranceType) Unset(key string) *PrivateHealthInsuranceType {
        switch key {
  case "Company":
   n.privatehealthinsurancetype.Company = nil
  case "Number":
   n.privatehealthinsurancetype.Number = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PrivateHealthInsuranceType")
        }
        return n
}

// Set a sequence of properties
func (n *PrivateHealthInsuranceType) SetProperties(props ...Prop) *PrivateHealthInsuranceType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PrivateHealthInsuranceType) SetProperty(key string, value interface{}) *PrivateHealthInsuranceType {
        if n == nil {
                n, _ = PrivateHealthInsuranceTypePointer(PrivateHealthInsuranceType{})
        }
        switch key {
    case "Company":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.privatehealthinsurancetype.Company = ((*String)(v))
      }
    case "Number":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.privatehealthinsurancetype.Number = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PrivateHealthInsuranceType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PrivateHealthInsuranceType) Company() *String {
    if s.privatehealthinsurancetype.Company == nil {
    if v, ok:= StringPointer(""); ok {
      s.privatehealthinsurancetype.Company = ((*String)(v))
      }
      }
      return s.privatehealthinsurancetype.Company
    }
// Returns whether the element value for Company is nil in the container PrivateHealthInsuranceType.
  func (s *PrivateHealthInsuranceType) Company_IsNil() bool {
    return s.privatehealthinsurancetype.Company == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PrivateHealthInsuranceType) Number() *String {
    if s.privatehealthinsurancetype.Number == nil {
    if v, ok:= StringPointer(""); ok {
      s.privatehealthinsurancetype.Number = ((*String)(v))
      }
      }
      return s.privatehealthinsurancetype.Number
    }
// Returns whether the element value for Number is nil in the container PrivateHealthInsuranceType.
  func (s *PrivateHealthInsuranceType) Number_IsNil() bool {
    return s.privatehealthinsurancetype.Number == nil
    }

// Set the value of a property to nil
func (n *ProgramAvailabilityType) Unset(key string) *ProgramAvailabilityType {
        switch key {
  case "Code":
   n.programavailabilitytype.Code = nil
  case "OtherCodeList":
   n.programavailabilitytype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ProgramAvailabilityType")
        }
        return n
}

// Set a sequence of properties
func (n *ProgramAvailabilityType) SetProperties(props ...Prop) *ProgramAvailabilityType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ProgramAvailabilityType) SetProperty(key string, value interface{}) *ProgramAvailabilityType {
        if n == nil {
                n, _ = ProgramAvailabilityTypePointer(ProgramAvailabilityType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSets0211ProgramAvailabilityType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSets0211ProgramAvailabilityType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.programavailabilitytype.Code = ((*AUCodeSets0211ProgramAvailabilityType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.programavailabilitytype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ProgramAvailabilityType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ProgramAvailabilityType) Code() *AUCodeSets0211ProgramAvailabilityType {
    if s.programavailabilitytype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.programavailabilitytype.Code = ((*AUCodeSets0211ProgramAvailabilityType)(v))
      }
      }
      return s.programavailabilitytype.Code
    }
// Returns whether the element value for Code is nil in the container ProgramAvailabilityType.
  func (s *ProgramAvailabilityType) Code_IsNil() bool {
    return s.programavailabilitytype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ProgramAvailabilityType) OtherCodeList() *OtherCodeListType {
    if s.programavailabilitytype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.programavailabilitytype.OtherCodeList = v
      }
      }
      return s.programavailabilitytype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container ProgramAvailabilityType.
  func (s *ProgramAvailabilityType) OtherCodeList_IsNil() bool {
    return s.programavailabilitytype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *ProgramFundingSourceType) Unset(key string) *ProgramFundingSourceType {
        switch key {
  case "Code":
   n.programfundingsourcetype.Code = nil
  case "OtherCodeList":
   n.programfundingsourcetype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ProgramFundingSourceType")
        }
        return n
}

// Set a sequence of properties
func (n *ProgramFundingSourceType) SetProperties(props ...Prop) *ProgramFundingSourceType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ProgramFundingSourceType) SetProperty(key string, value interface{}) *ProgramFundingSourceType {
        if n == nil {
                n, _ = ProgramFundingSourceTypePointer(ProgramFundingSourceType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsProgramFundingSourceCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsProgramFundingSourceCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.programfundingsourcetype.Code = ((*AUCodeSetsProgramFundingSourceCodeType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.programfundingsourcetype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ProgramFundingSourceType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ProgramFundingSourceType) Code() *AUCodeSetsProgramFundingSourceCodeType {
    if s.programfundingsourcetype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.programfundingsourcetype.Code = ((*AUCodeSetsProgramFundingSourceCodeType)(v))
      }
      }
      return s.programfundingsourcetype.Code
    }
// Returns whether the element value for Code is nil in the container ProgramFundingSourceType.
  func (s *ProgramFundingSourceType) Code_IsNil() bool {
    return s.programfundingsourcetype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ProgramFundingSourceType) OtherCodeList() *OtherCodeListType {
    if s.programfundingsourcetype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.programfundingsourcetype.OtherCodeList = v
      }
      }
      return s.programfundingsourcetype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container ProgramFundingSourceType.
  func (s *ProgramFundingSourceType) OtherCodeList_IsNil() bool {
    return s.programfundingsourcetype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *ProgramStatusType) Unset(key string) *ProgramStatusType {
        switch key {
  case "Code":
   n.programstatustype.Code = nil
  case "OtherCodeList":
   n.programstatustype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ProgramStatusType")
        }
        return n
}

// Set a sequence of properties
func (n *ProgramStatusType) SetProperties(props ...Prop) *ProgramStatusType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ProgramStatusType) SetProperty(key string, value interface{}) *ProgramStatusType {
        if n == nil {
                n, _ = ProgramStatusTypePointer(ProgramStatusType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.programstatustype.Code = ((*String)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.programstatustype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ProgramStatusType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ProgramStatusType) Code() *String {
    if s.programstatustype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.programstatustype.Code = ((*String)(v))
      }
      }
      return s.programstatustype.Code
    }
// Returns whether the element value for Code is nil in the container ProgramStatusType.
  func (s *ProgramStatusType) Code_IsNil() bool {
    return s.programstatustype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ProgramStatusType) OtherCodeList() *OtherCodeListType {
    if s.programstatustype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.programstatustype.OtherCodeList = v
      }
      }
      return s.programstatustype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container ProgramStatusType.
  func (s *ProgramStatusType) OtherCodeList_IsNil() bool {
    return s.programstatustype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *PromotionInfoType) Unset(key string) *PromotionInfoType {
        switch key {
  case "PromotionStatus":
   n.promotioninfotype.PromotionStatus = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PromotionInfoType")
        }
        return n
}

// Set a sequence of properties
func (n *PromotionInfoType) SetProperties(props ...Prop) *PromotionInfoType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PromotionInfoType) SetProperty(key string, value interface{}) *PromotionInfoType {
        if n == nil {
                n, _ = PromotionInfoTypePointer(PromotionInfoType{})
        }
        switch key {
    case "PromotionStatus":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.promotioninfotype.PromotionStatus = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PromotionInfoType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PromotionInfoType) PromotionStatus() *String {
    if s.promotioninfotype.PromotionStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.promotioninfotype.PromotionStatus = ((*String)(v))
      }
      }
      return s.promotioninfotype.PromotionStatus
    }
// Returns whether the element value for PromotionStatus is nil in the container PromotionInfoType.
  func (s *PromotionInfoType) PromotionStatus_IsNil() bool {
    return s.promotioninfotype.PromotionStatus == nil
    }

// Set the value of a property to nil
func (n *PublishingPermissionType) Unset(key string) *PublishingPermissionType {
        switch key {
  case "PermissionCategory":
   n.publishingpermissiontype.PermissionCategory = nil
  case "PermissionValue":
   n.publishingpermissiontype.PermissionValue = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PublishingPermissionType")
        }
        return n
}

// Set a sequence of properties
func (n *PublishingPermissionType) SetProperties(props ...Prop) *PublishingPermissionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PublishingPermissionType) SetProperty(key string, value interface{}) *PublishingPermissionType {
        if n == nil {
                n, _ = PublishingPermissionTypePointer(PublishingPermissionType{})
        }
        switch key {
    case "PermissionCategory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsPermissionCategoryCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsPermissionCategoryCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.publishingpermissiontype.PermissionCategory = ((*AUCodeSetsPermissionCategoryCodeType)(v))
      }
    case "PermissionValue":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.publishingpermissiontype.PermissionValue = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PublishingPermissionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PublishingPermissionType) PermissionCategory() *AUCodeSetsPermissionCategoryCodeType {
    if s.publishingpermissiontype.PermissionCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.publishingpermissiontype.PermissionCategory = ((*AUCodeSetsPermissionCategoryCodeType)(v))
      }
      }
      return s.publishingpermissiontype.PermissionCategory
    }
// Returns whether the element value for PermissionCategory is nil in the container PublishingPermissionType.
  func (s *PublishingPermissionType) PermissionCategory_IsNil() bool {
    return s.publishingpermissiontype.PermissionCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PublishingPermissionType) PermissionValue() *AUCodeSetsYesOrNoCategoryType {
    if s.publishingpermissiontype.PermissionValue == nil {
    if v, ok:= StringPointer(""); ok {
      s.publishingpermissiontype.PermissionValue = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.publishingpermissiontype.PermissionValue
    }
// Returns whether the element value for PermissionValue is nil in the container PublishingPermissionType.
  func (s *PublishingPermissionType) PermissionValue_IsNil() bool {
    return s.publishingpermissiontype.PermissionValue == nil
    }

// Set the value of a property to nil
func (n *PurchaseOrder) Unset(key string) *PurchaseOrder {
        switch key {
  case "ChargedLocationInfoRefId":
   n.purchaseorder.ChargedLocationInfoRefId = nil
  case "CreationDate":
   n.purchaseorder.CreationDate = nil
  case "EmployeePersonalRefId":
   n.purchaseorder.EmployeePersonalRefId = nil
  case "FormNumber":
   n.purchaseorder.FormNumber = nil
  case "FullyDelivered":
   n.purchaseorder.FullyDelivered = nil
  case "LocalCodeList":
   n.purchaseorder.LocalCodeList = nil
  case "LocalId":
   n.purchaseorder.LocalId = nil
  case "OriginalPurchaseOrderRefId":
   n.purchaseorder.OriginalPurchaseOrderRefId = nil
  case "PurchasingItems":
   n.purchaseorder.PurchasingItems = nil
  case "RefId":
   n.purchaseorder.RefId = nil
  case "SIF_ExtendedElements":
   n.purchaseorder.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.purchaseorder.SIF_Metadata = nil
  case "TaxAmount":
   n.purchaseorder.TaxAmount = nil
  case "TaxRate":
   n.purchaseorder.TaxRate = nil
  case "TotalAmount":
   n.purchaseorder.TotalAmount = nil
  case "UpdateDate":
   n.purchaseorder.UpdateDate = nil
  case "VendorInfoRefId":
   n.purchaseorder.VendorInfoRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PurchaseOrder")
        }
        return n
}

// Set a sequence of properties
func (n *PurchaseOrder) SetProperties(props ...Prop) *PurchaseOrder {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PurchaseOrder) SetProperty(key string, value interface{}) *PurchaseOrder {
        if n == nil {
                n, _ = PurchaseOrderPointer(PurchaseOrder{})
        }
        switch key {
    case "ChargedLocationInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.ChargedLocationInfoRefId = ((*String)(v))
      }
    case "CreationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.CreationDate = ((*String)(v))
      }
    case "EmployeePersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.EmployeePersonalRefId = ((*String)(v))
      }
    case "FormNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.FormNumber = ((*String)(v))
      }
    case "FullyDelivered":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.FullyDelivered = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.purchaseorder.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.LocalId = ((*LocalIdType)(v))
      }
    case "OriginalPurchaseOrderRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.OriginalPurchaseOrderRefId = ((*String)(v))
      }
    case "PurchasingItems":
    if v, ok:= PurchasingItemsTypePointer(value); ok {
      n.purchaseorder.PurchasingItems = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.purchaseorder.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.purchaseorder.SIF_Metadata = v
      }
    case "TaxAmount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.purchaseorder.TaxAmount = v
      }
    case "TaxRate":
    
    if v, ok:= FloatPointer(value); ok {
      n.purchaseorder.TaxRate = ((*Float)(v))
      }
    case "TotalAmount":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.purchaseorder.TotalAmount = v
      }
    case "UpdateDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.UpdateDate = ((*String)(v))
      }
    case "VendorInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchaseorder.VendorInfoRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PurchaseOrder")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) ChargedLocationInfoRefId() *String {
    if s.purchaseorder.ChargedLocationInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.ChargedLocationInfoRefId = ((*String)(v))
      }
      }
      return s.purchaseorder.ChargedLocationInfoRefId
    }
// Returns whether the element value for ChargedLocationInfoRefId is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) ChargedLocationInfoRefId_IsNil() bool {
    return s.purchaseorder.ChargedLocationInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) CreationDate() *String {
    if s.purchaseorder.CreationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.CreationDate = ((*String)(v))
      }
      }
      return s.purchaseorder.CreationDate
    }
// Returns whether the element value for CreationDate is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) CreationDate_IsNil() bool {
    return s.purchaseorder.CreationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) EmployeePersonalRefId() *String {
    if s.purchaseorder.EmployeePersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.EmployeePersonalRefId = ((*String)(v))
      }
      }
      return s.purchaseorder.EmployeePersonalRefId
    }
// Returns whether the element value for EmployeePersonalRefId is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) EmployeePersonalRefId_IsNil() bool {
    return s.purchaseorder.EmployeePersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) FormNumber() *String {
    if s.purchaseorder.FormNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.FormNumber = ((*String)(v))
      }
      }
      return s.purchaseorder.FormNumber
    }
// Returns whether the element value for FormNumber is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) FormNumber_IsNil() bool {
    return s.purchaseorder.FormNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) FullyDelivered() *AUCodeSetsYesOrNoCategoryType {
    if s.purchaseorder.FullyDelivered == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.FullyDelivered = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.purchaseorder.FullyDelivered
    }
// Returns whether the element value for FullyDelivered is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) FullyDelivered_IsNil() bool {
    return s.purchaseorder.FullyDelivered == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) LocalCodeList() *LocalCodeListType {
    if s.purchaseorder.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.purchaseorder.LocalCodeList = v
      }
      }
      return s.purchaseorder.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) LocalCodeList_IsNil() bool {
    return s.purchaseorder.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) LocalId() *LocalIdType {
    if s.purchaseorder.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.purchaseorder.LocalId
    }
// Returns whether the element value for LocalId is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) LocalId_IsNil() bool {
    return s.purchaseorder.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) OriginalPurchaseOrderRefId() *String {
    if s.purchaseorder.OriginalPurchaseOrderRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.OriginalPurchaseOrderRefId = ((*String)(v))
      }
      }
      return s.purchaseorder.OriginalPurchaseOrderRefId
    }
// Returns whether the element value for OriginalPurchaseOrderRefId is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) OriginalPurchaseOrderRefId_IsNil() bool {
    return s.purchaseorder.OriginalPurchaseOrderRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) PurchasingItems() *PurchasingItemsType {
    if s.purchaseorder.PurchasingItems == nil {
     if v, ok:= PurchasingItemsTypePointer(PurchasingItemsType{}); ok {
      s.purchaseorder.PurchasingItems = v
      }
      }
      return s.purchaseorder.PurchasingItems
    }
// Returns whether the element value for PurchasingItems is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) PurchasingItems_IsNil() bool {
    return s.purchaseorder.PurchasingItems == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) RefId() *RefIdType {
    if s.purchaseorder.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.RefId = ((*RefIdType)(v))
      }
      }
      return s.purchaseorder.RefId
    }
// Returns whether the element value for RefId is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) RefId_IsNil() bool {
    return s.purchaseorder.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.purchaseorder.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.purchaseorder.SIF_ExtendedElements = v
      }
      }
      return s.purchaseorder.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) SIF_ExtendedElements_IsNil() bool {
    return s.purchaseorder.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) SIF_Metadata() *SIF_MetadataType {
    if s.purchaseorder.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.purchaseorder.SIF_Metadata = v
      }
      }
      return s.purchaseorder.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) SIF_Metadata_IsNil() bool {
    return s.purchaseorder.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) TaxAmount() *MonetaryAmountType {
    if s.purchaseorder.TaxAmount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.purchaseorder.TaxAmount = v
      }
      }
      return s.purchaseorder.TaxAmount
    }
// Returns whether the element value for TaxAmount is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) TaxAmount_IsNil() bool {
    return s.purchaseorder.TaxAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) TaxRate() *Float {
    if s.purchaseorder.TaxRate == nil {
    if v, ok:= FloatPointer(0); ok {
      s.purchaseorder.TaxRate = ((*Float)(v))
      }
      }
      return s.purchaseorder.TaxRate
    }
// Returns whether the element value for TaxRate is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) TaxRate_IsNil() bool {
    return s.purchaseorder.TaxRate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) TotalAmount() *MonetaryAmountType {
    if s.purchaseorder.TotalAmount == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.purchaseorder.TotalAmount = v
      }
      }
      return s.purchaseorder.TotalAmount
    }
// Returns whether the element value for TotalAmount is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) TotalAmount_IsNil() bool {
    return s.purchaseorder.TotalAmount == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) UpdateDate() *String {
    if s.purchaseorder.UpdateDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.UpdateDate = ((*String)(v))
      }
      }
      return s.purchaseorder.UpdateDate
    }
// Returns whether the element value for UpdateDate is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) UpdateDate_IsNil() bool {
    return s.purchaseorder.UpdateDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchaseOrder) VendorInfoRefId() *String {
    if s.purchaseorder.VendorInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchaseorder.VendorInfoRefId = ((*String)(v))
      }
      }
      return s.purchaseorder.VendorInfoRefId
    }
// Returns whether the element value for VendorInfoRefId is nil in the container PurchaseOrder.
  func (s *PurchaseOrder) VendorInfoRefId_IsNil() bool {
    return s.purchaseorder.VendorInfoRefId == nil
    }

// Set the value of a property to nil
func (n *PurchasingItemType) Unset(key string) *PurchasingItemType {
        switch key {
  case "CancelledOrder":
   n.purchasingitemtype.CancelledOrder = nil
  case "ExpenseAccounts":
   n.purchasingitemtype.ExpenseAccounts = nil
  case "ItemDescription":
   n.purchasingitemtype.ItemDescription = nil
  case "ItemNumber":
   n.purchasingitemtype.ItemNumber = nil
  case "LocalItemId":
   n.purchasingitemtype.LocalItemId = nil
  case "Quantity":
   n.purchasingitemtype.Quantity = nil
  case "QuantityDelivered":
   n.purchasingitemtype.QuantityDelivered = nil
  case "TaxRate":
   n.purchasingitemtype.TaxRate = nil
  case "TotalCost":
   n.purchasingitemtype.TotalCost = nil
  case "UnitCost":
   n.purchasingitemtype.UnitCost = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PurchasingItemType")
        }
        return n
}

// Set a sequence of properties
func (n *PurchasingItemType) SetProperties(props ...Prop) *PurchasingItemType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *PurchasingItemType) SetProperty(key string, value interface{}) *PurchasingItemType {
        if n == nil {
                n, _ = PurchasingItemTypePointer(PurchasingItemType{})
        }
        switch key {
    case "CancelledOrder":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.purchasingitemtype.CancelledOrder = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "ExpenseAccounts":
    if v, ok:= ExpenseAccountsTypePointer(value); ok {
      n.purchasingitemtype.ExpenseAccounts = v
      }
    case "ItemDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchasingitemtype.ItemDescription = ((*String)(v))
      }
    case "ItemNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchasingitemtype.ItemNumber = ((*String)(v))
      }
    case "LocalItemId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchasingitemtype.LocalItemId = ((*LocalIdType)(v))
      }
    case "Quantity":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchasingitemtype.Quantity = ((*String)(v))
      }
    case "QuantityDelivered":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.purchasingitemtype.QuantityDelivered = ((*String)(v))
      }
    case "TaxRate":
    
    if v, ok:= FloatPointer(value); ok {
      n.purchasingitemtype.TaxRate = ((*Float)(v))
      }
    case "TotalCost":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.purchasingitemtype.TotalCost = v
      }
    case "UnitCost":
    if v, ok:= MonetaryAmountTypePointer(value); ok {
      n.purchasingitemtype.UnitCost = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "PurchasingItemType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) CancelledOrder() *AUCodeSetsYesOrNoCategoryType {
    if s.purchasingitemtype.CancelledOrder == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchasingitemtype.CancelledOrder = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.purchasingitemtype.CancelledOrder
    }
// Returns whether the element value for CancelledOrder is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) CancelledOrder_IsNil() bool {
    return s.purchasingitemtype.CancelledOrder == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) ExpenseAccounts() *ExpenseAccountsType {
    if s.purchasingitemtype.ExpenseAccounts == nil {
     if v, ok:= ExpenseAccountsTypePointer(ExpenseAccountsType{}); ok {
      s.purchasingitemtype.ExpenseAccounts = v
      }
      }
      return s.purchasingitemtype.ExpenseAccounts
    }
// Returns whether the element value for ExpenseAccounts is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) ExpenseAccounts_IsNil() bool {
    return s.purchasingitemtype.ExpenseAccounts == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) ItemDescription() *String {
    if s.purchasingitemtype.ItemDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchasingitemtype.ItemDescription = ((*String)(v))
      }
      }
      return s.purchasingitemtype.ItemDescription
    }
// Returns whether the element value for ItemDescription is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) ItemDescription_IsNil() bool {
    return s.purchasingitemtype.ItemDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) ItemNumber() *String {
    if s.purchasingitemtype.ItemNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchasingitemtype.ItemNumber = ((*String)(v))
      }
      }
      return s.purchasingitemtype.ItemNumber
    }
// Returns whether the element value for ItemNumber is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) ItemNumber_IsNil() bool {
    return s.purchasingitemtype.ItemNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) LocalItemId() *LocalIdType {
    if s.purchasingitemtype.LocalItemId == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchasingitemtype.LocalItemId = ((*LocalIdType)(v))
      }
      }
      return s.purchasingitemtype.LocalItemId
    }
// Returns whether the element value for LocalItemId is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) LocalItemId_IsNil() bool {
    return s.purchasingitemtype.LocalItemId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) Quantity() *String {
    if s.purchasingitemtype.Quantity == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchasingitemtype.Quantity = ((*String)(v))
      }
      }
      return s.purchasingitemtype.Quantity
    }
// Returns whether the element value for Quantity is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) Quantity_IsNil() bool {
    return s.purchasingitemtype.Quantity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) QuantityDelivered() *String {
    if s.purchasingitemtype.QuantityDelivered == nil {
    if v, ok:= StringPointer(""); ok {
      s.purchasingitemtype.QuantityDelivered = ((*String)(v))
      }
      }
      return s.purchasingitemtype.QuantityDelivered
    }
// Returns whether the element value for QuantityDelivered is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) QuantityDelivered_IsNil() bool {
    return s.purchasingitemtype.QuantityDelivered == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) TaxRate() *Float {
    if s.purchasingitemtype.TaxRate == nil {
    if v, ok:= FloatPointer(0); ok {
      s.purchasingitemtype.TaxRate = ((*Float)(v))
      }
      }
      return s.purchasingitemtype.TaxRate
    }
// Returns whether the element value for TaxRate is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) TaxRate_IsNil() bool {
    return s.purchasingitemtype.TaxRate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) TotalCost() *MonetaryAmountType {
    if s.purchasingitemtype.TotalCost == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.purchasingitemtype.TotalCost = v
      }
      }
      return s.purchasingitemtype.TotalCost
    }
// Returns whether the element value for TotalCost is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) TotalCost_IsNil() bool {
    return s.purchasingitemtype.TotalCost == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *PurchasingItemType) UnitCost() *MonetaryAmountType {
    if s.purchasingitemtype.UnitCost == nil {
     if v, ok:= MonetaryAmountTypePointer(MonetaryAmountType{}); ok {
      s.purchasingitemtype.UnitCost = v
      }
      }
      return s.purchasingitemtype.UnitCost
    }
// Returns whether the element value for UnitCost is nil in the container PurchasingItemType.
  func (s *PurchasingItemType) UnitCost_IsNil() bool {
    return s.purchasingitemtype.UnitCost == nil
    }

// Set the value of a property to nil
func (n *ReferenceDataType) Unset(key string) *ReferenceDataType {
        switch key {
  case "Description":
   n.referencedatatype.Description = nil
  case "MIMEType":
   n.referencedatatype.MIMEType = nil
  case "URL":
   n.referencedatatype.URL = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReferenceDataType")
        }
        return n
}

// Set a sequence of properties
func (n *ReferenceDataType) SetProperties(props ...Prop) *ReferenceDataType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ReferenceDataType) SetProperty(key string, value interface{}) *ReferenceDataType {
        if n == nil {
                n, _ = ReferenceDataTypePointer(ReferenceDataType{})
        }
        switch key {
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.referencedatatype.Description = ((*String)(v))
      }
    case "MIMEType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.referencedatatype.MIMEType = ((*String)(v))
      }
    case "URL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.referencedatatype.URL = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReferenceDataType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReferenceDataType) Description() *String {
    if s.referencedatatype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.referencedatatype.Description = ((*String)(v))
      }
      }
      return s.referencedatatype.Description
    }
// Returns whether the element value for Description is nil in the container ReferenceDataType.
  func (s *ReferenceDataType) Description_IsNil() bool {
    return s.referencedatatype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReferenceDataType) MIMEType() *String {
    if s.referencedatatype.MIMEType == nil {
    if v, ok:= StringPointer(""); ok {
      s.referencedatatype.MIMEType = ((*String)(v))
      }
      }
      return s.referencedatatype.MIMEType
    }
// Returns whether the element value for MIMEType is nil in the container ReferenceDataType.
  func (s *ReferenceDataType) MIMEType_IsNil() bool {
    return s.referencedatatype.MIMEType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReferenceDataType) URL() *String {
    if s.referencedatatype.URL == nil {
    if v, ok:= StringPointer(""); ok {
      s.referencedatatype.URL = ((*String)(v))
      }
      }
      return s.referencedatatype.URL
    }
// Returns whether the element value for URL is nil in the container ReferenceDataType.
  func (s *ReferenceDataType) URL_IsNil() bool {
    return s.referencedatatype.URL == nil
    }

// Set the value of a property to nil
func (n *ReferralSourceType) Unset(key string) *ReferralSourceType {
        switch key {
  case "Code":
   n.referralsourcetype.Code = nil
  case "OtherCodeList":
   n.referralsourcetype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReferralSourceType")
        }
        return n
}

// Set a sequence of properties
func (n *ReferralSourceType) SetProperties(props ...Prop) *ReferralSourceType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ReferralSourceType) SetProperty(key string, value interface{}) *ReferralSourceType {
        if n == nil {
                n, _ = ReferralSourceTypePointer(ReferralSourceType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSets0792IdentificationProcedureType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSets0792IdentificationProcedureType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.referralsourcetype.Code = ((*AUCodeSets0792IdentificationProcedureType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.referralsourcetype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReferralSourceType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReferralSourceType) Code() *AUCodeSets0792IdentificationProcedureType {
    if s.referralsourcetype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.referralsourcetype.Code = ((*AUCodeSets0792IdentificationProcedureType)(v))
      }
      }
      return s.referralsourcetype.Code
    }
// Returns whether the element value for Code is nil in the container ReferralSourceType.
  func (s *ReferralSourceType) Code_IsNil() bool {
    return s.referralsourcetype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReferralSourceType) OtherCodeList() *OtherCodeListType {
    if s.referralsourcetype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.referralsourcetype.OtherCodeList = v
      }
      }
      return s.referralsourcetype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container ReferralSourceType.
  func (s *ReferralSourceType) OtherCodeList_IsNil() bool {
    return s.referralsourcetype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *RelatedLearningStandardItemRefIdType) Unset(key string) *RelatedLearningStandardItemRefIdType {
        switch key {
  case "RelationshipType":
   n.relatedlearningstandarditemrefidtype.RelationshipType = nil
  case "Value":
   n.relatedlearningstandarditemrefidtype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "RelatedLearningStandardItemRefIdType")
        }
        return n
}

// Set a sequence of properties
func (n *RelatedLearningStandardItemRefIdType) SetProperties(props ...Prop) *RelatedLearningStandardItemRefIdType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *RelatedLearningStandardItemRefIdType) SetProperty(key string, value interface{}) *RelatedLearningStandardItemRefIdType {
        if n == nil {
                n, _ = RelatedLearningStandardItemRefIdTypePointer(RelatedLearningStandardItemRefIdType{})
        }
        switch key {
    case "RelationshipType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.relatedlearningstandarditemrefidtype.RelationshipType = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.relatedlearningstandarditemrefidtype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "RelatedLearningStandardItemRefIdType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RelatedLearningStandardItemRefIdType) RelationshipType() *String {
    if s.relatedlearningstandarditemrefidtype.RelationshipType == nil {
    if v, ok:= StringPointer(""); ok {
      s.relatedlearningstandarditemrefidtype.RelationshipType = ((*String)(v))
      }
      }
      return s.relatedlearningstandarditemrefidtype.RelationshipType
    }
// Returns whether the element value for RelationshipType is nil in the container RelatedLearningStandardItemRefIdType.
  func (s *RelatedLearningStandardItemRefIdType) RelationshipType_IsNil() bool {
    return s.relatedlearningstandarditemrefidtype.RelationshipType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RelatedLearningStandardItemRefIdType) Value() *String {
    if s.relatedlearningstandarditemrefidtype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.relatedlearningstandarditemrefidtype.Value = ((*String)(v))
      }
      }
      return s.relatedlearningstandarditemrefidtype.Value
    }
// Returns whether the element value for Value is nil in the container RelatedLearningStandardItemRefIdType.
  func (s *RelatedLearningStandardItemRefIdType) Value_IsNil() bool {
    return s.relatedlearningstandarditemrefidtype.Value == nil
    }

// Set the value of a property to nil
func (n *RelationshipType) Unset(key string) *RelationshipType {
        switch key {
  case "Code":
   n.relationshiptype.Code = nil
  case "OtherCodeList":
   n.relationshiptype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "RelationshipType")
        }
        return n
}

// Set a sequence of properties
func (n *RelationshipType) SetProperties(props ...Prop) *RelationshipType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *RelationshipType) SetProperty(key string, value interface{}) *RelationshipType {
        if n == nil {
                n, _ = RelationshipTypePointer(RelationshipType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsRelationshipToStudentType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsRelationshipToStudentType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.relationshiptype.Code = ((*AUCodeSetsRelationshipToStudentType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.relationshiptype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "RelationshipType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RelationshipType) Code() *AUCodeSetsRelationshipToStudentType {
    if s.relationshiptype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.relationshiptype.Code = ((*AUCodeSetsRelationshipToStudentType)(v))
      }
      }
      return s.relationshiptype.Code
    }
// Returns whether the element value for Code is nil in the container RelationshipType.
  func (s *RelationshipType) Code_IsNil() bool {
    return s.relationshiptype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RelationshipType) OtherCodeList() *OtherCodeListType {
    if s.relationshiptype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.relationshiptype.OtherCodeList = v
      }
      }
      return s.relationshiptype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container RelationshipType.
  func (s *RelationshipType) OtherCodeList_IsNil() bool {
    return s.relationshiptype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *ReligionType) Unset(key string) *ReligionType {
        switch key {
  case "Code":
   n.religiontype.Code = nil
  case "OtherCodeList":
   n.religiontype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReligionType")
        }
        return n
}

// Set a sequence of properties
func (n *ReligionType) SetProperties(props ...Prop) *ReligionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ReligionType) SetProperty(key string, value interface{}) *ReligionType {
        if n == nil {
                n, _ = ReligionTypePointer(ReligionType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.religiontype.Code = ((*AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.religiontype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReligionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReligionType) Code() *AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType {
    if s.religiontype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.religiontype.Code = ((*AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType)(v))
      }
      }
      return s.religiontype.Code
    }
// Returns whether the element value for Code is nil in the container ReligionType.
  func (s *ReligionType) Code_IsNil() bool {
    return s.religiontype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReligionType) OtherCodeList() *OtherCodeListType {
    if s.religiontype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.religiontype.OtherCodeList = v
      }
      }
      return s.religiontype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container ReligionType.
  func (s *ReligionType) OtherCodeList_IsNil() bool {
    return s.religiontype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *ReligiousEventType) Unset(key string) *ReligiousEventType {
        switch key {
  case "Date":
   n.religiouseventtype.Date = nil
  case "Type":
   n.religiouseventtype.Type = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReligiousEventType")
        }
        return n
}

// Set a sequence of properties
func (n *ReligiousEventType) SetProperties(props ...Prop) *ReligiousEventType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ReligiousEventType) SetProperty(key string, value interface{}) *ReligiousEventType {
        if n == nil {
                n, _ = ReligiousEventTypePointer(ReligiousEventType{})
        }
        switch key {
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.religiouseventtype.Date = ((*String)(v))
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.religiouseventtype.Type = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReligiousEventType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReligiousEventType) Date() *String {
    if s.religiouseventtype.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.religiouseventtype.Date = ((*String)(v))
      }
      }
      return s.religiouseventtype.Date
    }
// Returns whether the element value for Date is nil in the container ReligiousEventType.
  func (s *ReligiousEventType) Date_IsNil() bool {
    return s.religiouseventtype.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReligiousEventType) Type() *String {
    if s.religiouseventtype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.religiouseventtype.Type = ((*String)(v))
      }
      }
      return s.religiouseventtype.Type
    }
// Returns whether the element value for Type is nil in the container ReligiousEventType.
  func (s *ReligiousEventType) Type_IsNil() bool {
    return s.religiouseventtype.Type == nil
    }

// Set the value of a property to nil
func (n *ReportingAuthorityType) Unset(key string) *ReportingAuthorityType {
        switch key {
  case "AuthorityId":
   n.reportingauthoritytype.AuthorityId = nil
  case "Name":
   n.reportingauthoritytype.Name = nil
  case "System":
   n.reportingauthoritytype.System = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReportingAuthorityType")
        }
        return n
}

// Set a sequence of properties
func (n *ReportingAuthorityType) SetProperties(props ...Prop) *ReportingAuthorityType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ReportingAuthorityType) SetProperty(key string, value interface{}) *ReportingAuthorityType {
        if n == nil {
                n, _ = ReportingAuthorityTypePointer(ReportingAuthorityType{})
        }
        switch key {
    case "AuthorityId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.reportingauthoritytype.AuthorityId = ((*String)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.reportingauthoritytype.Name = ((*String)(v))
      }
    case "System":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.reportingauthoritytype.System = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ReportingAuthorityType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReportingAuthorityType) AuthorityId() *String {
    if s.reportingauthoritytype.AuthorityId == nil {
    if v, ok:= StringPointer(""); ok {
      s.reportingauthoritytype.AuthorityId = ((*String)(v))
      }
      }
      return s.reportingauthoritytype.AuthorityId
    }
// Returns whether the element value for AuthorityId is nil in the container ReportingAuthorityType.
  func (s *ReportingAuthorityType) AuthorityId_IsNil() bool {
    return s.reportingauthoritytype.AuthorityId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReportingAuthorityType) Name() *String {
    if s.reportingauthoritytype.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.reportingauthoritytype.Name = ((*String)(v))
      }
      }
      return s.reportingauthoritytype.Name
    }
// Returns whether the element value for Name is nil in the container ReportingAuthorityType.
  func (s *ReportingAuthorityType) Name_IsNil() bool {
    return s.reportingauthoritytype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ReportingAuthorityType) System() *String {
    if s.reportingauthoritytype.System == nil {
    if v, ok:= StringPointer(""); ok {
      s.reportingauthoritytype.System = ((*String)(v))
      }
      }
      return s.reportingauthoritytype.System
    }
// Returns whether the element value for System is nil in the container ReportingAuthorityType.
  func (s *ReportingAuthorityType) System_IsNil() bool {
    return s.reportingauthoritytype.System == nil
    }

// Set the value of a property to nil
func (n *ResourceBooking) Unset(key string) *ResourceBooking {
        switch key {
  case "Booker":
   n.resourcebooking.Booker = nil
  case "FinishDateTime":
   n.resourcebooking.FinishDateTime = nil
  case "FromPeriod":
   n.resourcebooking.FromPeriod = nil
  case "KeepOld":
   n.resourcebooking.KeepOld = nil
  case "LocalCodeList":
   n.resourcebooking.LocalCodeList = nil
  case "Reason":
   n.resourcebooking.Reason = nil
  case "RefId":
   n.resourcebooking.RefId = nil
  case "ResourceLocalId":
   n.resourcebooking.ResourceLocalId = nil
  case "ResourceRefId":
   n.resourcebooking.ResourceRefId = nil
  case "SIF_ExtendedElements":
   n.resourcebooking.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.resourcebooking.SIF_Metadata = nil
  case "ScheduledActivityRefId":
   n.resourcebooking.ScheduledActivityRefId = nil
  case "StartDateTime":
   n.resourcebooking.StartDateTime = nil
  case "ToPeriod":
   n.resourcebooking.ToPeriod = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ResourceBooking")
        }
        return n
}

// Set a sequence of properties
func (n *ResourceBooking) SetProperties(props ...Prop) *ResourceBooking {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ResourceBooking) SetProperty(key string, value interface{}) *ResourceBooking {
        if n == nil {
                n, _ = ResourceBookingPointer(ResourceBooking{})
        }
        switch key {
    case "Booker":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking.Booker = ((*String)(v))
      }
    case "FinishDateTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking.FinishDateTime = ((*String)(v))
      }
    case "FromPeriod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking.FromPeriod = ((*LocalIdType)(v))
      }
    case "KeepOld":
    
    if v, ok:= BoolPointer(value); ok {
      n.resourcebooking.KeepOld = ((*Bool)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.resourcebooking.LocalCodeList = v
      }
    case "Reason":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking.Reason = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking.RefId = ((*RefIdType)(v))
      }
    case "ResourceLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking.ResourceLocalId = ((*LocalIdType)(v))
      }
    case "ResourceRefId":
    if v, ok:= ResourceBooking_ResourceRefIdPointer(value); ok {
      n.resourcebooking.ResourceRefId = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.resourcebooking.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.resourcebooking.SIF_Metadata = v
      }
    case "ScheduledActivityRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking.ScheduledActivityRefId = ((*String)(v))
      }
    case "StartDateTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking.StartDateTime = ((*String)(v))
      }
    case "ToPeriod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking.ToPeriod = ((*LocalIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ResourceBooking")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) Booker() *String {
    if s.resourcebooking.Booker == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking.Booker = ((*String)(v))
      }
      }
      return s.resourcebooking.Booker
    }
// Returns whether the element value for Booker is nil in the container ResourceBooking.
  func (s *ResourceBooking) Booker_IsNil() bool {
    return s.resourcebooking.Booker == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) FinishDateTime() *String {
    if s.resourcebooking.FinishDateTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking.FinishDateTime = ((*String)(v))
      }
      }
      return s.resourcebooking.FinishDateTime
    }
// Returns whether the element value for FinishDateTime is nil in the container ResourceBooking.
  func (s *ResourceBooking) FinishDateTime_IsNil() bool {
    return s.resourcebooking.FinishDateTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) FromPeriod() *LocalIdType {
    if s.resourcebooking.FromPeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking.FromPeriod = ((*LocalIdType)(v))
      }
      }
      return s.resourcebooking.FromPeriod
    }
// Returns whether the element value for FromPeriod is nil in the container ResourceBooking.
  func (s *ResourceBooking) FromPeriod_IsNil() bool {
    return s.resourcebooking.FromPeriod == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) KeepOld() *Bool {
    if s.resourcebooking.KeepOld == nil {
    if v, ok:= BoolPointer(false); ok {
      s.resourcebooking.KeepOld = ((*Bool)(v))
      }
      }
      return s.resourcebooking.KeepOld
    }
// Returns whether the element value for KeepOld is nil in the container ResourceBooking.
  func (s *ResourceBooking) KeepOld_IsNil() bool {
    return s.resourcebooking.KeepOld == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) LocalCodeList() *LocalCodeListType {
    if s.resourcebooking.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.resourcebooking.LocalCodeList = v
      }
      }
      return s.resourcebooking.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container ResourceBooking.
  func (s *ResourceBooking) LocalCodeList_IsNil() bool {
    return s.resourcebooking.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) Reason() *String {
    if s.resourcebooking.Reason == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking.Reason = ((*String)(v))
      }
      }
      return s.resourcebooking.Reason
    }
// Returns whether the element value for Reason is nil in the container ResourceBooking.
  func (s *ResourceBooking) Reason_IsNil() bool {
    return s.resourcebooking.Reason == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) RefId() *RefIdType {
    if s.resourcebooking.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking.RefId = ((*RefIdType)(v))
      }
      }
      return s.resourcebooking.RefId
    }
// Returns whether the element value for RefId is nil in the container ResourceBooking.
  func (s *ResourceBooking) RefId_IsNil() bool {
    return s.resourcebooking.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) ResourceLocalId() *LocalIdType {
    if s.resourcebooking.ResourceLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking.ResourceLocalId = ((*LocalIdType)(v))
      }
      }
      return s.resourcebooking.ResourceLocalId
    }
// Returns whether the element value for ResourceLocalId is nil in the container ResourceBooking.
  func (s *ResourceBooking) ResourceLocalId_IsNil() bool {
    return s.resourcebooking.ResourceLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) ResourceRefId() *ResourceBooking_ResourceRefId {
    if s.resourcebooking.ResourceRefId == nil {
     if v, ok:= ResourceBooking_ResourceRefIdPointer(ResourceBooking_ResourceRefId{}); ok {
      s.resourcebooking.ResourceRefId = v
      }
      }
      return s.resourcebooking.ResourceRefId
    }
// Returns whether the element value for ResourceRefId is nil in the container ResourceBooking.
  func (s *ResourceBooking) ResourceRefId_IsNil() bool {
    return s.resourcebooking.ResourceRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.resourcebooking.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.resourcebooking.SIF_ExtendedElements = v
      }
      }
      return s.resourcebooking.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container ResourceBooking.
  func (s *ResourceBooking) SIF_ExtendedElements_IsNil() bool {
    return s.resourcebooking.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) SIF_Metadata() *SIF_MetadataType {
    if s.resourcebooking.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.resourcebooking.SIF_Metadata = v
      }
      }
      return s.resourcebooking.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container ResourceBooking.
  func (s *ResourceBooking) SIF_Metadata_IsNil() bool {
    return s.resourcebooking.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) ScheduledActivityRefId() *String {
    if s.resourcebooking.ScheduledActivityRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking.ScheduledActivityRefId = ((*String)(v))
      }
      }
      return s.resourcebooking.ScheduledActivityRefId
    }
// Returns whether the element value for ScheduledActivityRefId is nil in the container ResourceBooking.
  func (s *ResourceBooking) ScheduledActivityRefId_IsNil() bool {
    return s.resourcebooking.ScheduledActivityRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) StartDateTime() *String {
    if s.resourcebooking.StartDateTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking.StartDateTime = ((*String)(v))
      }
      }
      return s.resourcebooking.StartDateTime
    }
// Returns whether the element value for StartDateTime is nil in the container ResourceBooking.
  func (s *ResourceBooking) StartDateTime_IsNil() bool {
    return s.resourcebooking.StartDateTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking) ToPeriod() *LocalIdType {
    if s.resourcebooking.ToPeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking.ToPeriod = ((*LocalIdType)(v))
      }
      }
      return s.resourcebooking.ToPeriod
    }
// Returns whether the element value for ToPeriod is nil in the container ResourceBooking.
  func (s *ResourceBooking) ToPeriod_IsNil() bool {
    return s.resourcebooking.ToPeriod == nil
    }

// Set the value of a property to nil
func (n *ResourceBooking_ResourceRefId) Unset(key string) *ResourceBooking_ResourceRefId {
        switch key {
  case "SIF_RefObject":
   n.resourcebooking_resourcerefid.SIF_RefObject = nil
  case "Value":
   n.resourcebooking_resourcerefid.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ResourceBooking_ResourceRefId")
        }
        return n
}

// Set a sequence of properties
func (n *ResourceBooking_ResourceRefId) SetProperties(props ...Prop) *ResourceBooking_ResourceRefId {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ResourceBooking_ResourceRefId) SetProperty(key string, value interface{}) *ResourceBooking_ResourceRefId {
        if n == nil {
                n, _ = ResourceBooking_ResourceRefIdPointer(ResourceBooking_ResourceRefId{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking_resourcerefid.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcebooking_resourcerefid.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ResourceBooking_ResourceRefId")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking_ResourceRefId) SIF_RefObject() *String {
    if s.resourcebooking_resourcerefid.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking_resourcerefid.SIF_RefObject = ((*String)(v))
      }
      }
      return s.resourcebooking_resourcerefid.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container ResourceBooking_ResourceRefId.
  func (s *ResourceBooking_ResourceRefId) SIF_RefObject_IsNil() bool {
    return s.resourcebooking_resourcerefid.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourceBooking_ResourceRefId) Value() *String {
    if s.resourcebooking_resourcerefid.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcebooking_resourcerefid.Value = ((*String)(v))
      }
      }
      return s.resourcebooking_resourcerefid.Value
    }
// Returns whether the element value for Value is nil in the container ResourceBooking_ResourceRefId.
  func (s *ResourceBooking_ResourceRefId) Value_IsNil() bool {
    return s.resourcebooking_resourcerefid.Value == nil
    }

// Set the value of a property to nil
func (n *ResourcesType) Unset(key string) *ResourcesType {
        switch key {
  case "ResourceType":
   n.resourcestype.ResourceType = nil
  case "Value":
   n.resourcestype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ResourcesType")
        }
        return n
}

// Set a sequence of properties
func (n *ResourcesType) SetProperties(props ...Prop) *ResourcesType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ResourcesType) SetProperty(key string, value interface{}) *ResourcesType {
        if n == nil {
                n, _ = ResourcesTypePointer(ResourcesType{})
        }
        switch key {
    case "ResourceType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcestype.ResourceType = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.resourcestype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ResourcesType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourcesType) ResourceType() *String {
    if s.resourcestype.ResourceType == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcestype.ResourceType = ((*String)(v))
      }
      }
      return s.resourcestype.ResourceType
    }
// Returns whether the element value for ResourceType is nil in the container ResourcesType.
  func (s *ResourcesType) ResourceType_IsNil() bool {
    return s.resourcestype.ResourceType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ResourcesType) Value() *String {
    if s.resourcestype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.resourcestype.Value = ((*String)(v))
      }
      }
      return s.resourcestype.Value
    }
// Returns whether the element value for Value is nil in the container ResourcesType.
  func (s *ResourcesType) Value_IsNil() bool {
    return s.resourcestype.Value == nil
    }

// Set the value of a property to nil
func (n *RoomInfo) Unset(key string) *RoomInfo {
        switch key {
  case "AvailableForTimetable":
   n.roominfo.AvailableForTimetable = nil
  case "Building":
   n.roominfo.Building = nil
  case "Capacity":
   n.roominfo.Capacity = nil
  case "Description":
   n.roominfo.Description = nil
  case "HomeroomNumber":
   n.roominfo.HomeroomNumber = nil
  case "LocalCodeList":
   n.roominfo.LocalCodeList = nil
  case "LocalId":
   n.roominfo.LocalId = nil
  case "PhoneNumber":
   n.roominfo.PhoneNumber = nil
  case "RefId":
   n.roominfo.RefId = nil
  case "RoomNumber":
   n.roominfo.RoomNumber = nil
  case "RoomType":
   n.roominfo.RoomType = nil
  case "SIF_ExtendedElements":
   n.roominfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.roominfo.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.roominfo.SchoolInfoRefId = nil
  case "Size":
   n.roominfo.Size = nil
  case "StaffList":
   n.roominfo.StaffList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "RoomInfo")
        }
        return n
}

// Set a sequence of properties
func (n *RoomInfo) SetProperties(props ...Prop) *RoomInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *RoomInfo) SetProperty(key string, value interface{}) *RoomInfo {
        if n == nil {
                n, _ = RoomInfoPointer(RoomInfo{})
        }
        switch key {
    case "AvailableForTimetable":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.roominfo.AvailableForTimetable = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "Building":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.roominfo.Building = ((*String)(v))
      }
    case "Capacity":
    
    if v, ok:= IntPointer(value); ok {
      n.roominfo.Capacity = ((*Int)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.roominfo.Description = ((*String)(v))
      }
    case "HomeroomNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.roominfo.HomeroomNumber = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.roominfo.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.roominfo.LocalId = ((*LocalIdType)(v))
      }
    case "PhoneNumber":
    if v, ok:= PhoneNumberTypePointer(value); ok {
      n.roominfo.PhoneNumber = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.roominfo.RefId = ((*RefIdType)(v))
      }
    case "RoomNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.roominfo.RoomNumber = ((*String)(v))
      }
    case "RoomType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.roominfo.RoomType = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.roominfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.roominfo.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.roominfo.SchoolInfoRefId = ((*String)(v))
      }
    case "Size":
    
    if v, ok:= FloatPointer(value); ok {
      n.roominfo.Size = ((*Float)(v))
      }
    case "StaffList":
    if v, ok:= StaffListTypePointer(value); ok {
      n.roominfo.StaffList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "RoomInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) AvailableForTimetable() *AUCodeSetsYesOrNoCategoryType {
    if s.roominfo.AvailableForTimetable == nil {
    if v, ok:= StringPointer(""); ok {
      s.roominfo.AvailableForTimetable = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.roominfo.AvailableForTimetable
    }
// Returns whether the element value for AvailableForTimetable is nil in the container RoomInfo.
  func (s *RoomInfo) AvailableForTimetable_IsNil() bool {
    return s.roominfo.AvailableForTimetable == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) Building() *String {
    if s.roominfo.Building == nil {
    if v, ok:= StringPointer(""); ok {
      s.roominfo.Building = ((*String)(v))
      }
      }
      return s.roominfo.Building
    }
// Returns whether the element value for Building is nil in the container RoomInfo.
  func (s *RoomInfo) Building_IsNil() bool {
    return s.roominfo.Building == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) Capacity() *Int {
    if s.roominfo.Capacity == nil {
    if v, ok:= IntPointer(0); ok {
      s.roominfo.Capacity = ((*Int)(v))
      }
      }
      return s.roominfo.Capacity
    }
// Returns whether the element value for Capacity is nil in the container RoomInfo.
  func (s *RoomInfo) Capacity_IsNil() bool {
    return s.roominfo.Capacity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) Description() *String {
    if s.roominfo.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.roominfo.Description = ((*String)(v))
      }
      }
      return s.roominfo.Description
    }
// Returns whether the element value for Description is nil in the container RoomInfo.
  func (s *RoomInfo) Description_IsNil() bool {
    return s.roominfo.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) HomeroomNumber() *String {
    if s.roominfo.HomeroomNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.roominfo.HomeroomNumber = ((*String)(v))
      }
      }
      return s.roominfo.HomeroomNumber
    }
// Returns whether the element value for HomeroomNumber is nil in the container RoomInfo.
  func (s *RoomInfo) HomeroomNumber_IsNil() bool {
    return s.roominfo.HomeroomNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) LocalCodeList() *LocalCodeListType {
    if s.roominfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.roominfo.LocalCodeList = v
      }
      }
      return s.roominfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container RoomInfo.
  func (s *RoomInfo) LocalCodeList_IsNil() bool {
    return s.roominfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) LocalId() *LocalIdType {
    if s.roominfo.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.roominfo.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.roominfo.LocalId
    }
// Returns whether the element value for LocalId is nil in the container RoomInfo.
  func (s *RoomInfo) LocalId_IsNil() bool {
    return s.roominfo.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) PhoneNumber() *PhoneNumberType {
    if s.roominfo.PhoneNumber == nil {
     if v, ok:= PhoneNumberTypePointer(PhoneNumberType{}); ok {
      s.roominfo.PhoneNumber = v
      }
      }
      return s.roominfo.PhoneNumber
    }
// Returns whether the element value for PhoneNumber is nil in the container RoomInfo.
  func (s *RoomInfo) PhoneNumber_IsNil() bool {
    return s.roominfo.PhoneNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) RefId() *RefIdType {
    if s.roominfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.roominfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.roominfo.RefId
    }
// Returns whether the element value for RefId is nil in the container RoomInfo.
  func (s *RoomInfo) RefId_IsNil() bool {
    return s.roominfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) RoomNumber() *String {
    if s.roominfo.RoomNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.roominfo.RoomNumber = ((*String)(v))
      }
      }
      return s.roominfo.RoomNumber
    }
// Returns whether the element value for RoomNumber is nil in the container RoomInfo.
  func (s *RoomInfo) RoomNumber_IsNil() bool {
    return s.roominfo.RoomNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) RoomType() *String {
    if s.roominfo.RoomType == nil {
    if v, ok:= StringPointer(""); ok {
      s.roominfo.RoomType = ((*String)(v))
      }
      }
      return s.roominfo.RoomType
    }
// Returns whether the element value for RoomType is nil in the container RoomInfo.
  func (s *RoomInfo) RoomType_IsNil() bool {
    return s.roominfo.RoomType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.roominfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.roominfo.SIF_ExtendedElements = v
      }
      }
      return s.roominfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container RoomInfo.
  func (s *RoomInfo) SIF_ExtendedElements_IsNil() bool {
    return s.roominfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) SIF_Metadata() *SIF_MetadataType {
    if s.roominfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.roominfo.SIF_Metadata = v
      }
      }
      return s.roominfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container RoomInfo.
  func (s *RoomInfo) SIF_Metadata_IsNil() bool {
    return s.roominfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) SchoolInfoRefId() *String {
    if s.roominfo.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.roominfo.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.roominfo.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container RoomInfo.
  func (s *RoomInfo) SchoolInfoRefId_IsNil() bool {
    return s.roominfo.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) Size() *Float {
    if s.roominfo.Size == nil {
    if v, ok:= FloatPointer(0); ok {
      s.roominfo.Size = ((*Float)(v))
      }
      }
      return s.roominfo.Size
    }
// Returns whether the element value for Size is nil in the container RoomInfo.
  func (s *RoomInfo) Size_IsNil() bool {
    return s.roominfo.Size == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *RoomInfo) StaffList() *StaffListType {
    if s.roominfo.StaffList == nil {
     if v, ok:= StaffListTypePointer(StaffListType{}); ok {
      s.roominfo.StaffList = v
      }
      }
      return s.roominfo.StaffList
    }
// Returns whether the element value for StaffList is nil in the container RoomInfo.
  func (s *RoomInfo) StaffList_IsNil() bool {
    return s.roominfo.StaffList == nil
    }

// Set the value of a property to nil
func (n *SIF_ExtendedElementsType_SIF_ExtendedElement) Unset(key string) *SIF_ExtendedElementsType_SIF_ExtendedElement {
        switch key {
  case "Name":
   n.sif_extendedelementstype_sif_extendedelement.Name = nil
  case "SIF_Action":
   n.sif_extendedelementstype_sif_extendedelement.SIF_Action = nil
  case "Type":
   n.sif_extendedelementstype_sif_extendedelement.Type = nil
  case "Value":
   n.sif_extendedelementstype_sif_extendedelement.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SIF_ExtendedElementsType_SIF_ExtendedElement")
        }
        return n
}

// Set a sequence of properties
func (n *SIF_ExtendedElementsType_SIF_ExtendedElement) SetProperties(props ...Prop) *SIF_ExtendedElementsType_SIF_ExtendedElement {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SIF_ExtendedElementsType_SIF_ExtendedElement) SetProperty(key string, value interface{}) *SIF_ExtendedElementsType_SIF_ExtendedElement {
        if n == nil {
                n, _ = SIF_ExtendedElementsType_SIF_ExtendedElementPointer(SIF_ExtendedElementsType_SIF_ExtendedElement{})
        }
        switch key {
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sif_extendedelementstype_sif_extendedelement.Name = ((*String)(v))
      }
    case "SIF_Action":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sif_extendedelementstype_sif_extendedelement.SIF_Action = ((*String)(v))
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sif_extendedelementstype_sif_extendedelement.Type = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sif_extendedelementstype_sif_extendedelement.Value = ((*ExtendedContentType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SIF_ExtendedElementsType_SIF_ExtendedElement")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SIF_ExtendedElementsType_SIF_ExtendedElement) Name() *String {
    if s.sif_extendedelementstype_sif_extendedelement.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.sif_extendedelementstype_sif_extendedelement.Name = ((*String)(v))
      }
      }
      return s.sif_extendedelementstype_sif_extendedelement.Name
    }
// Returns whether the element value for Name is nil in the container SIF_ExtendedElementsType_SIF_ExtendedElement.
  func (s *SIF_ExtendedElementsType_SIF_ExtendedElement) Name_IsNil() bool {
    return s.sif_extendedelementstype_sif_extendedelement.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SIF_ExtendedElementsType_SIF_ExtendedElement) SIF_Action() *String {
    if s.sif_extendedelementstype_sif_extendedelement.SIF_Action == nil {
    if v, ok:= StringPointer(""); ok {
      s.sif_extendedelementstype_sif_extendedelement.SIF_Action = ((*String)(v))
      }
      }
      return s.sif_extendedelementstype_sif_extendedelement.SIF_Action
    }
// Returns whether the element value for SIF_Action is nil in the container SIF_ExtendedElementsType_SIF_ExtendedElement.
  func (s *SIF_ExtendedElementsType_SIF_ExtendedElement) SIF_Action_IsNil() bool {
    return s.sif_extendedelementstype_sif_extendedelement.SIF_Action == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SIF_ExtendedElementsType_SIF_ExtendedElement) Type() *String {
    if s.sif_extendedelementstype_sif_extendedelement.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.sif_extendedelementstype_sif_extendedelement.Type = ((*String)(v))
      }
      }
      return s.sif_extendedelementstype_sif_extendedelement.Type
    }
// Returns whether the element value for Type is nil in the container SIF_ExtendedElementsType_SIF_ExtendedElement.
  func (s *SIF_ExtendedElementsType_SIF_ExtendedElement) Type_IsNil() bool {
    return s.sif_extendedelementstype_sif_extendedelement.Type == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SIF_ExtendedElementsType_SIF_ExtendedElement) Value() *ExtendedContentType {
    if s.sif_extendedelementstype_sif_extendedelement.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.sif_extendedelementstype_sif_extendedelement.Value = ((*ExtendedContentType)(v))
      }
      }
      return s.sif_extendedelementstype_sif_extendedelement.Value
    }
// Returns whether the element value for Value is nil in the container SIF_ExtendedElementsType_SIF_ExtendedElement.
  func (s *SIF_ExtendedElementsType_SIF_ExtendedElement) Value_IsNil() bool {
    return s.sif_extendedelementstype_sif_extendedelement.Value == nil
    }

// Set the value of a property to nil
func (n *SIF_MetadataType) Unset(key string) *SIF_MetadataType {
        switch key {
  case "ETag":
   n.sif_metadatatype.ETag = nil
  case "LifeCycle":
   n.sif_metadatatype.LifeCycle = nil
  case "TimeElements":
   n.sif_metadatatype.TimeElements = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SIF_MetadataType")
        }
        return n
}

// Set a sequence of properties
func (n *SIF_MetadataType) SetProperties(props ...Prop) *SIF_MetadataType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SIF_MetadataType) SetProperty(key string, value interface{}) *SIF_MetadataType {
        if n == nil {
                n, _ = SIF_MetadataTypePointer(SIF_MetadataType{})
        }
        switch key {
    case "ETag":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sif_metadatatype.ETag = ((*String)(v))
      }
    case "LifeCycle":
    if v, ok:= LifeCycleTypePointer(value); ok {
      n.sif_metadatatype.LifeCycle = v
      }
    case "TimeElements":
    if v, ok:= TimeElementListTypePointer(value); ok {
      n.sif_metadatatype.TimeElements = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SIF_MetadataType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SIF_MetadataType) ETag() *String {
    if s.sif_metadatatype.ETag == nil {
    if v, ok:= StringPointer(""); ok {
      s.sif_metadatatype.ETag = ((*String)(v))
      }
      }
      return s.sif_metadatatype.ETag
    }
// Returns whether the element value for ETag is nil in the container SIF_MetadataType.
  func (s *SIF_MetadataType) ETag_IsNil() bool {
    return s.sif_metadatatype.ETag == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SIF_MetadataType) LifeCycle() *LifeCycleType {
    if s.sif_metadatatype.LifeCycle == nil {
     if v, ok:= LifeCycleTypePointer(LifeCycleType{}); ok {
      s.sif_metadatatype.LifeCycle = v
      }
      }
      return s.sif_metadatatype.LifeCycle
    }
// Returns whether the element value for LifeCycle is nil in the container SIF_MetadataType.
  func (s *SIF_MetadataType) LifeCycle_IsNil() bool {
    return s.sif_metadatatype.LifeCycle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SIF_MetadataType) TimeElements() *TimeElementListType {
    if s.sif_metadatatype.TimeElements == nil {
     if v, ok:= TimeElementListTypePointer(TimeElementListType{}); ok {
      s.sif_metadatatype.TimeElements = v
      }
      }
      return s.sif_metadatatype.TimeElements
    }
// Returns whether the element value for TimeElements is nil in the container SIF_MetadataType.
  func (s *SIF_MetadataType) TimeElements_IsNil() bool {
    return s.sif_metadatatype.TimeElements == nil
    }

// Set the value of a property to nil
func (n *STDNAttachmentType) Unset(key string) *STDNAttachmentType {
        switch key {
  case "Description":
   n.stdnattachmenttype.Description = nil
  case "Field":
   n.stdnattachmenttype.Field = nil
  case "FileName":
   n.stdnattachmenttype.FileName = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "STDNAttachmentType")
        }
        return n
}

// Set a sequence of properties
func (n *STDNAttachmentType) SetProperties(props ...Prop) *STDNAttachmentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *STDNAttachmentType) SetProperty(key string, value interface{}) *STDNAttachmentType {
        if n == nil {
                n, _ = STDNAttachmentTypePointer(STDNAttachmentType{})
        }
        switch key {
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stdnattachmenttype.Description = ((*String)(v))
      }
    case "Field":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stdnattachmenttype.Field = ((*String)(v))
      }
    case "FileName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stdnattachmenttype.FileName = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "STDNAttachmentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNAttachmentType) Description() *String {
    if s.stdnattachmenttype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnattachmenttype.Description = ((*String)(v))
      }
      }
      return s.stdnattachmenttype.Description
    }
// Returns whether the element value for Description is nil in the container STDNAttachmentType.
  func (s *STDNAttachmentType) Description_IsNil() bool {
    return s.stdnattachmenttype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNAttachmentType) Field() *String {
    if s.stdnattachmenttype.Field == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnattachmenttype.Field = ((*String)(v))
      }
      }
      return s.stdnattachmenttype.Field
    }
// Returns whether the element value for Field is nil in the container STDNAttachmentType.
  func (s *STDNAttachmentType) Field_IsNil() bool {
    return s.stdnattachmenttype.Field == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNAttachmentType) FileName() *String {
    if s.stdnattachmenttype.FileName == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnattachmenttype.FileName = ((*String)(v))
      }
      }
      return s.stdnattachmenttype.FileName
    }
// Returns whether the element value for FileName is nil in the container STDNAttachmentType.
  func (s *STDNAttachmentType) FileName_IsNil() bool {
    return s.stdnattachmenttype.FileName == nil
    }

// Set the value of a property to nil
func (n *STDNGradeType) Unset(key string) *STDNGradeType {
        switch key {
  case "Grade":
   n.stdngradetype.Grade = nil
  case "LearningArea":
   n.stdngradetype.LearningArea = nil
  case "Subject":
   n.stdngradetype.Subject = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "STDNGradeType")
        }
        return n
}

// Set a sequence of properties
func (n *STDNGradeType) SetProperties(props ...Prop) *STDNGradeType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *STDNGradeType) SetProperty(key string, value interface{}) *STDNGradeType {
        if n == nil {
                n, _ = STDNGradeTypePointer(STDNGradeType{})
        }
        switch key {
    case "Grade":
    if v, ok:= GradeTypePointer(value); ok {
      n.stdngradetype.Grade = v
      }
    case "LearningArea":
    if v, ok:= ACStrandSubjectAreaTypePointer(value); ok {
      n.stdngradetype.LearningArea = v
      }
    case "Subject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stdngradetype.Subject = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "STDNGradeType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNGradeType) Grade() *GradeType {
    if s.stdngradetype.Grade == nil {
     if v, ok:= GradeTypePointer(GradeType{}); ok {
      s.stdngradetype.Grade = v
      }
      }
      return s.stdngradetype.Grade
    }
// Returns whether the element value for Grade is nil in the container STDNGradeType.
  func (s *STDNGradeType) Grade_IsNil() bool {
    return s.stdngradetype.Grade == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNGradeType) LearningArea() *ACStrandSubjectAreaType {
    if s.stdngradetype.LearningArea == nil {
     if v, ok:= ACStrandSubjectAreaTypePointer(ACStrandSubjectAreaType{}); ok {
      s.stdngradetype.LearningArea = v
      }
      }
      return s.stdngradetype.LearningArea
    }
// Returns whether the element value for LearningArea is nil in the container STDNGradeType.
  func (s *STDNGradeType) LearningArea_IsNil() bool {
    return s.stdngradetype.LearningArea == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNGradeType) Subject() *String {
    if s.stdngradetype.Subject == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdngradetype.Subject = ((*String)(v))
      }
      }
      return s.stdngradetype.Subject
    }
// Returns whether the element value for Subject is nil in the container STDNGradeType.
  func (s *STDNGradeType) Subject_IsNil() bool {
    return s.stdngradetype.Subject == nil
    }

// Set the value of a property to nil
func (n *STDNSupportNeedsType) Unset(key string) *STDNSupportNeedsType {
        switch key {
  case "AcceleratedProgram":
   n.stdnsupportneedstype.AcceleratedProgram = nil
  case "AdjustedEducationProgram":
   n.stdnsupportneedstype.AdjustedEducationProgram = nil
  case "CareerGuidanceFileHeld":
   n.stdnsupportneedstype.CareerGuidanceFileHeld = nil
  case "NegotiatedCurriculumPlan":
   n.stdnsupportneedstype.NegotiatedCurriculumPlan = nil
  case "OtherLearningSupport":
   n.stdnsupportneedstype.OtherLearningSupport = nil
  case "OtherLearningSupportText":
   n.stdnsupportneedstype.OtherLearningSupportText = nil
  case "SchoolCounsellorFileHeld":
   n.stdnsupportneedstype.SchoolCounsellorFileHeld = nil
  case "YoungCarersRole":
   n.stdnsupportneedstype.YoungCarersRole = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "STDNSupportNeedsType")
        }
        return n
}

// Set a sequence of properties
func (n *STDNSupportNeedsType) SetProperties(props ...Prop) *STDNSupportNeedsType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *STDNSupportNeedsType) SetProperty(key string, value interface{}) *STDNSupportNeedsType {
        if n == nil {
                n, _ = STDNSupportNeedsTypePointer(STDNSupportNeedsType{})
        }
        switch key {
    case "AcceleratedProgram":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.stdnsupportneedstype.AcceleratedProgram = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "AdjustedEducationProgram":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.stdnsupportneedstype.AdjustedEducationProgram = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "CareerGuidanceFileHeld":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.stdnsupportneedstype.CareerGuidanceFileHeld = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "NegotiatedCurriculumPlan":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.stdnsupportneedstype.NegotiatedCurriculumPlan = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "OtherLearningSupport":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.stdnsupportneedstype.OtherLearningSupport = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "OtherLearningSupportText":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stdnsupportneedstype.OtherLearningSupportText = ((*String)(v))
      }
    case "SchoolCounsellorFileHeld":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.stdnsupportneedstype.SchoolCounsellorFileHeld = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "YoungCarersRole":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.stdnsupportneedstype.YoungCarersRole = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "STDNSupportNeedsType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNSupportNeedsType) AcceleratedProgram() *AUCodeSetsYesOrNoCategoryType {
    if s.stdnsupportneedstype.AcceleratedProgram == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnsupportneedstype.AcceleratedProgram = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.stdnsupportneedstype.AcceleratedProgram
    }
// Returns whether the element value for AcceleratedProgram is nil in the container STDNSupportNeedsType.
  func (s *STDNSupportNeedsType) AcceleratedProgram_IsNil() bool {
    return s.stdnsupportneedstype.AcceleratedProgram == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNSupportNeedsType) AdjustedEducationProgram() *AUCodeSetsYesOrNoCategoryType {
    if s.stdnsupportneedstype.AdjustedEducationProgram == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnsupportneedstype.AdjustedEducationProgram = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.stdnsupportneedstype.AdjustedEducationProgram
    }
// Returns whether the element value for AdjustedEducationProgram is nil in the container STDNSupportNeedsType.
  func (s *STDNSupportNeedsType) AdjustedEducationProgram_IsNil() bool {
    return s.stdnsupportneedstype.AdjustedEducationProgram == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNSupportNeedsType) CareerGuidanceFileHeld() *AUCodeSetsYesOrNoCategoryType {
    if s.stdnsupportneedstype.CareerGuidanceFileHeld == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnsupportneedstype.CareerGuidanceFileHeld = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.stdnsupportneedstype.CareerGuidanceFileHeld
    }
// Returns whether the element value for CareerGuidanceFileHeld is nil in the container STDNSupportNeedsType.
  func (s *STDNSupportNeedsType) CareerGuidanceFileHeld_IsNil() bool {
    return s.stdnsupportneedstype.CareerGuidanceFileHeld == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNSupportNeedsType) NegotiatedCurriculumPlan() *AUCodeSetsYesOrNoCategoryType {
    if s.stdnsupportneedstype.NegotiatedCurriculumPlan == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnsupportneedstype.NegotiatedCurriculumPlan = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.stdnsupportneedstype.NegotiatedCurriculumPlan
    }
// Returns whether the element value for NegotiatedCurriculumPlan is nil in the container STDNSupportNeedsType.
  func (s *STDNSupportNeedsType) NegotiatedCurriculumPlan_IsNil() bool {
    return s.stdnsupportneedstype.NegotiatedCurriculumPlan == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNSupportNeedsType) OtherLearningSupport() *AUCodeSetsYesOrNoCategoryType {
    if s.stdnsupportneedstype.OtherLearningSupport == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnsupportneedstype.OtherLearningSupport = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.stdnsupportneedstype.OtherLearningSupport
    }
// Returns whether the element value for OtherLearningSupport is nil in the container STDNSupportNeedsType.
  func (s *STDNSupportNeedsType) OtherLearningSupport_IsNil() bool {
    return s.stdnsupportneedstype.OtherLearningSupport == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNSupportNeedsType) OtherLearningSupportText() *String {
    if s.stdnsupportneedstype.OtherLearningSupportText == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnsupportneedstype.OtherLearningSupportText = ((*String)(v))
      }
      }
      return s.stdnsupportneedstype.OtherLearningSupportText
    }
// Returns whether the element value for OtherLearningSupportText is nil in the container STDNSupportNeedsType.
  func (s *STDNSupportNeedsType) OtherLearningSupportText_IsNil() bool {
    return s.stdnsupportneedstype.OtherLearningSupportText == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNSupportNeedsType) SchoolCounsellorFileHeld() *AUCodeSetsYesOrNoCategoryType {
    if s.stdnsupportneedstype.SchoolCounsellorFileHeld == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnsupportneedstype.SchoolCounsellorFileHeld = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.stdnsupportneedstype.SchoolCounsellorFileHeld
    }
// Returns whether the element value for SchoolCounsellorFileHeld is nil in the container STDNSupportNeedsType.
  func (s *STDNSupportNeedsType) SchoolCounsellorFileHeld_IsNil() bool {
    return s.stdnsupportneedstype.SchoolCounsellorFileHeld == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *STDNSupportNeedsType) YoungCarersRole() *AUCodeSetsYesOrNoCategoryType {
    if s.stdnsupportneedstype.YoungCarersRole == nil {
    if v, ok:= StringPointer(""); ok {
      s.stdnsupportneedstype.YoungCarersRole = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.stdnsupportneedstype.YoungCarersRole
    }
// Returns whether the element value for YoungCarersRole is nil in the container STDNSupportNeedsType.
  func (s *STDNSupportNeedsType) YoungCarersRole_IsNil() bool {
    return s.stdnsupportneedstype.YoungCarersRole == nil
    }

// Set the value of a property to nil
func (n *ScheduledActivity) Unset(key string) *ScheduledActivity {
        switch key {
  case "ActivityComment":
   n.scheduledactivity.ActivityComment = nil
  case "ActivityDate":
   n.scheduledactivity.ActivityDate = nil
  case "ActivityEndDate":
   n.scheduledactivity.ActivityEndDate = nil
  case "ActivityName":
   n.scheduledactivity.ActivityName = nil
  case "ActivityType":
   n.scheduledactivity.ActivityType = nil
  case "AddressList":
   n.scheduledactivity.AddressList = nil
  case "CellType":
   n.scheduledactivity.CellType = nil
  case "DayId":
   n.scheduledactivity.DayId = nil
  case "FinishTime":
   n.scheduledactivity.FinishTime = nil
  case "LocalCodeList":
   n.scheduledactivity.LocalCodeList = nil
  case "Location":
   n.scheduledactivity.Location = nil
  case "Override":
   n.scheduledactivity.Override = nil
  case "OverridePatch":
   n.scheduledactivity.OverridePatch = nil
  case "PeriodId":
   n.scheduledactivity.PeriodId = nil
  case "RefId":
   n.scheduledactivity.RefId = nil
  case "RoomList":
   n.scheduledactivity.RoomList = nil
  case "SIF_ExtendedElements":
   n.scheduledactivity.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.scheduledactivity.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.scheduledactivity.SchoolInfoRefId = nil
  case "StartTime":
   n.scheduledactivity.StartTime = nil
  case "StudentList":
   n.scheduledactivity.StudentList = nil
  case "TeacherList":
   n.scheduledactivity.TeacherList = nil
  case "TeachingGroupList":
   n.scheduledactivity.TeachingGroupList = nil
  case "TimeTableCellRefId":
   n.scheduledactivity.TimeTableCellRefId = nil
  case "TimeTableChangeReasonList":
   n.scheduledactivity.TimeTableChangeReasonList = nil
  case "TimeTableRefId":
   n.scheduledactivity.TimeTableRefId = nil
  case "TimeTableSubjectRefId":
   n.scheduledactivity.TimeTableSubjectRefId = nil
  case "YearLevels":
   n.scheduledactivity.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ScheduledActivity")
        }
        return n
}

// Set a sequence of properties
func (n *ScheduledActivity) SetProperties(props ...Prop) *ScheduledActivity {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ScheduledActivity) SetProperty(key string, value interface{}) *ScheduledActivity {
        if n == nil {
                n, _ = ScheduledActivityPointer(ScheduledActivity{})
        }
        switch key {
    case "ActivityComment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.ActivityComment = ((*String)(v))
      }
    case "ActivityDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.ActivityDate = ((*String)(v))
      }
    case "ActivityEndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.ActivityEndDate = ((*String)(v))
      }
    case "ActivityName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.ActivityName = ((*String)(v))
      }
    case "ActivityType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsScheduledActivityTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsScheduledActivityTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.ActivityType = ((*AUCodeSetsScheduledActivityTypeType)(v))
      }
    case "AddressList":
    if v, ok:= AddressListTypePointer(value); ok {
      n.scheduledactivity.AddressList = v
      }
    case "CellType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.CellType = ((*String)(v))
      }
    case "DayId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.DayId = ((*LocalIdType)(v))
      }
    case "FinishTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.FinishTime = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.scheduledactivity.LocalCodeList = v
      }
    case "Location":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.Location = ((*String)(v))
      }
    case "Override":
    if v, ok:= ScheduledActivityOverrideTypePointer(value); ok {
      n.scheduledactivity.Override = v
      }
    case "OverridePatch":
    
    if v, ok:= BoolPointer(value); ok {
      n.scheduledactivity.OverridePatch = ((*Bool)(v))
      }
    case "PeriodId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.PeriodId = ((*LocalIdType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.RefId = ((*RefIdType)(v))
      }
    case "RoomList":
    if v, ok:= RoomListTypePointer(value); ok {
      n.scheduledactivity.RoomList = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.scheduledactivity.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.scheduledactivity.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.SchoolInfoRefId = ((*String)(v))
      }
    case "StartTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.StartTime = ((*String)(v))
      }
    case "StudentList":
    if v, ok:= StudentsTypePointer(value); ok {
      n.scheduledactivity.StudentList = v
      }
    case "TeacherList":
    if v, ok:= ScheduledTeacherListTypePointer(value); ok {
      n.scheduledactivity.TeacherList = v
      }
    case "TeachingGroupList":
    if v, ok:= TeachingGroupListTypePointer(value); ok {
      n.scheduledactivity.TeachingGroupList = v
      }
    case "TimeTableCellRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.TimeTableCellRefId = ((*String)(v))
      }
    case "TimeTableChangeReasonList":
    if v, ok:= TimeTableChangeReasonListTypePointer(value); ok {
      n.scheduledactivity.TimeTableChangeReasonList = v
      }
    case "TimeTableRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.TimeTableRefId = ((*String)(v))
      }
    case "TimeTableSubjectRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivity.TimeTableSubjectRefId = ((*String)(v))
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.scheduledactivity.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ScheduledActivity")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) ActivityComment() *String {
    if s.scheduledactivity.ActivityComment == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.ActivityComment = ((*String)(v))
      }
      }
      return s.scheduledactivity.ActivityComment
    }
// Returns whether the element value for ActivityComment is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) ActivityComment_IsNil() bool {
    return s.scheduledactivity.ActivityComment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) ActivityDate() *String {
    if s.scheduledactivity.ActivityDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.ActivityDate = ((*String)(v))
      }
      }
      return s.scheduledactivity.ActivityDate
    }
// Returns whether the element value for ActivityDate is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) ActivityDate_IsNil() bool {
    return s.scheduledactivity.ActivityDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) ActivityEndDate() *String {
    if s.scheduledactivity.ActivityEndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.ActivityEndDate = ((*String)(v))
      }
      }
      return s.scheduledactivity.ActivityEndDate
    }
// Returns whether the element value for ActivityEndDate is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) ActivityEndDate_IsNil() bool {
    return s.scheduledactivity.ActivityEndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) ActivityName() *String {
    if s.scheduledactivity.ActivityName == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.ActivityName = ((*String)(v))
      }
      }
      return s.scheduledactivity.ActivityName
    }
// Returns whether the element value for ActivityName is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) ActivityName_IsNil() bool {
    return s.scheduledactivity.ActivityName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) ActivityType() *AUCodeSetsScheduledActivityTypeType {
    if s.scheduledactivity.ActivityType == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.ActivityType = ((*AUCodeSetsScheduledActivityTypeType)(v))
      }
      }
      return s.scheduledactivity.ActivityType
    }
// Returns whether the element value for ActivityType is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) ActivityType_IsNil() bool {
    return s.scheduledactivity.ActivityType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) AddressList() *AddressListType {
    if s.scheduledactivity.AddressList == nil {
     if v, ok:= AddressListTypePointer(AddressListType{}); ok {
      s.scheduledactivity.AddressList = v
      }
      }
      return s.scheduledactivity.AddressList
    }
// Returns whether the element value for AddressList is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) AddressList_IsNil() bool {
    return s.scheduledactivity.AddressList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) CellType() *String {
    if s.scheduledactivity.CellType == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.CellType = ((*String)(v))
      }
      }
      return s.scheduledactivity.CellType
    }
// Returns whether the element value for CellType is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) CellType_IsNil() bool {
    return s.scheduledactivity.CellType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) DayId() *LocalIdType {
    if s.scheduledactivity.DayId == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.DayId = ((*LocalIdType)(v))
      }
      }
      return s.scheduledactivity.DayId
    }
// Returns whether the element value for DayId is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) DayId_IsNil() bool {
    return s.scheduledactivity.DayId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) FinishTime() *String {
    if s.scheduledactivity.FinishTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.FinishTime = ((*String)(v))
      }
      }
      return s.scheduledactivity.FinishTime
    }
// Returns whether the element value for FinishTime is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) FinishTime_IsNil() bool {
    return s.scheduledactivity.FinishTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) LocalCodeList() *LocalCodeListType {
    if s.scheduledactivity.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.scheduledactivity.LocalCodeList = v
      }
      }
      return s.scheduledactivity.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) LocalCodeList_IsNil() bool {
    return s.scheduledactivity.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) Location() *String {
    if s.scheduledactivity.Location == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.Location = ((*String)(v))
      }
      }
      return s.scheduledactivity.Location
    }
// Returns whether the element value for Location is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) Location_IsNil() bool {
    return s.scheduledactivity.Location == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) Override() *ScheduledActivityOverrideType {
    if s.scheduledactivity.Override == nil {
     if v, ok:= ScheduledActivityOverrideTypePointer(ScheduledActivityOverrideType{}); ok {
      s.scheduledactivity.Override = v
      }
      }
      return s.scheduledactivity.Override
    }
// Returns whether the element value for Override is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) Override_IsNil() bool {
    return s.scheduledactivity.Override == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) OverridePatch() *Bool {
    if s.scheduledactivity.OverridePatch == nil {
    if v, ok:= BoolPointer(false); ok {
      s.scheduledactivity.OverridePatch = ((*Bool)(v))
      }
      }
      return s.scheduledactivity.OverridePatch
    }
// Returns whether the element value for OverridePatch is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) OverridePatch_IsNil() bool {
    return s.scheduledactivity.OverridePatch == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) PeriodId() *LocalIdType {
    if s.scheduledactivity.PeriodId == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.PeriodId = ((*LocalIdType)(v))
      }
      }
      return s.scheduledactivity.PeriodId
    }
// Returns whether the element value for PeriodId is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) PeriodId_IsNil() bool {
    return s.scheduledactivity.PeriodId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) RefId() *RefIdType {
    if s.scheduledactivity.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.RefId = ((*RefIdType)(v))
      }
      }
      return s.scheduledactivity.RefId
    }
// Returns whether the element value for RefId is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) RefId_IsNil() bool {
    return s.scheduledactivity.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) RoomList() *RoomListType {
    if s.scheduledactivity.RoomList == nil {
     if v, ok:= RoomListTypePointer(RoomListType{}); ok {
      s.scheduledactivity.RoomList = v
      }
      }
      return s.scheduledactivity.RoomList
    }
// Returns whether the element value for RoomList is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) RoomList_IsNil() bool {
    return s.scheduledactivity.RoomList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.scheduledactivity.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.scheduledactivity.SIF_ExtendedElements = v
      }
      }
      return s.scheduledactivity.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) SIF_ExtendedElements_IsNil() bool {
    return s.scheduledactivity.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) SIF_Metadata() *SIF_MetadataType {
    if s.scheduledactivity.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.scheduledactivity.SIF_Metadata = v
      }
      }
      return s.scheduledactivity.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) SIF_Metadata_IsNil() bool {
    return s.scheduledactivity.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) SchoolInfoRefId() *String {
    if s.scheduledactivity.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.scheduledactivity.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) SchoolInfoRefId_IsNil() bool {
    return s.scheduledactivity.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) StartTime() *String {
    if s.scheduledactivity.StartTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.StartTime = ((*String)(v))
      }
      }
      return s.scheduledactivity.StartTime
    }
// Returns whether the element value for StartTime is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) StartTime_IsNil() bool {
    return s.scheduledactivity.StartTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) StudentList() *StudentsType {
    if s.scheduledactivity.StudentList == nil {
     if v, ok:= StudentsTypePointer(StudentsType{}); ok {
      s.scheduledactivity.StudentList = v
      }
      }
      return s.scheduledactivity.StudentList
    }
// Returns whether the element value for StudentList is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) StudentList_IsNil() bool {
    return s.scheduledactivity.StudentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) TeacherList() *ScheduledTeacherListType {
    if s.scheduledactivity.TeacherList == nil {
     if v, ok:= ScheduledTeacherListTypePointer(ScheduledTeacherListType{}); ok {
      s.scheduledactivity.TeacherList = v
      }
      }
      return s.scheduledactivity.TeacherList
    }
// Returns whether the element value for TeacherList is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) TeacherList_IsNil() bool {
    return s.scheduledactivity.TeacherList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) TeachingGroupList() *TeachingGroupListType {
    if s.scheduledactivity.TeachingGroupList == nil {
     if v, ok:= TeachingGroupListTypePointer(TeachingGroupListType{}); ok {
      s.scheduledactivity.TeachingGroupList = v
      }
      }
      return s.scheduledactivity.TeachingGroupList
    }
// Returns whether the element value for TeachingGroupList is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) TeachingGroupList_IsNil() bool {
    return s.scheduledactivity.TeachingGroupList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) TimeTableCellRefId() *String {
    if s.scheduledactivity.TimeTableCellRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.TimeTableCellRefId = ((*String)(v))
      }
      }
      return s.scheduledactivity.TimeTableCellRefId
    }
// Returns whether the element value for TimeTableCellRefId is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) TimeTableCellRefId_IsNil() bool {
    return s.scheduledactivity.TimeTableCellRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) TimeTableChangeReasonList() *TimeTableChangeReasonListType {
    if s.scheduledactivity.TimeTableChangeReasonList == nil {
     if v, ok:= TimeTableChangeReasonListTypePointer(TimeTableChangeReasonListType{}); ok {
      s.scheduledactivity.TimeTableChangeReasonList = v
      }
      }
      return s.scheduledactivity.TimeTableChangeReasonList
    }
// Returns whether the element value for TimeTableChangeReasonList is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) TimeTableChangeReasonList_IsNil() bool {
    return s.scheduledactivity.TimeTableChangeReasonList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) TimeTableRefId() *String {
    if s.scheduledactivity.TimeTableRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.TimeTableRefId = ((*String)(v))
      }
      }
      return s.scheduledactivity.TimeTableRefId
    }
// Returns whether the element value for TimeTableRefId is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) TimeTableRefId_IsNil() bool {
    return s.scheduledactivity.TimeTableRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) TimeTableSubjectRefId() *String {
    if s.scheduledactivity.TimeTableSubjectRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivity.TimeTableSubjectRefId = ((*String)(v))
      }
      }
      return s.scheduledactivity.TimeTableSubjectRefId
    }
// Returns whether the element value for TimeTableSubjectRefId is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) TimeTableSubjectRefId_IsNil() bool {
    return s.scheduledactivity.TimeTableSubjectRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivity) YearLevels() *YearLevelsType {
    if s.scheduledactivity.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.scheduledactivity.YearLevels = v
      }
      }
      return s.scheduledactivity.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container ScheduledActivity.
  func (s *ScheduledActivity) YearLevels_IsNil() bool {
    return s.scheduledactivity.YearLevels == nil
    }

// Set the value of a property to nil
func (n *ScheduledActivityOverrideType) Unset(key string) *ScheduledActivityOverrideType {
        switch key {
  case "DateOfOverride":
   n.scheduledactivityoverridetype.DateOfOverride = nil
  case "Value":
   n.scheduledactivityoverridetype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ScheduledActivityOverrideType")
        }
        return n
}

// Set a sequence of properties
func (n *ScheduledActivityOverrideType) SetProperties(props ...Prop) *ScheduledActivityOverrideType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ScheduledActivityOverrideType) SetProperty(key string, value interface{}) *ScheduledActivityOverrideType {
        if n == nil {
                n, _ = ScheduledActivityOverrideTypePointer(ScheduledActivityOverrideType{})
        }
        switch key {
    case "DateOfOverride":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivityoverridetype.DateOfOverride = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scheduledactivityoverridetype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ScheduledActivityOverrideType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivityOverrideType) DateOfOverride() *String {
    if s.scheduledactivityoverridetype.DateOfOverride == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivityoverridetype.DateOfOverride = ((*String)(v))
      }
      }
      return s.scheduledactivityoverridetype.DateOfOverride
    }
// Returns whether the element value for DateOfOverride is nil in the container ScheduledActivityOverrideType.
  func (s *ScheduledActivityOverrideType) DateOfOverride_IsNil() bool {
    return s.scheduledactivityoverridetype.DateOfOverride == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScheduledActivityOverrideType) Value() *String {
    if s.scheduledactivityoverridetype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.scheduledactivityoverridetype.Value = ((*String)(v))
      }
      }
      return s.scheduledactivityoverridetype.Value
    }
// Returns whether the element value for Value is nil in the container ScheduledActivityOverrideType.
  func (s *ScheduledActivityOverrideType) Value_IsNil() bool {
    return s.scheduledactivityoverridetype.Value == nil
    }

// Set the value of a property to nil
func (n *SchoolContactType) Unset(key string) *SchoolContactType {
        switch key {
  case "ContactInfo":
   n.schoolcontacttype.ContactInfo = nil
  case "PublishInDirectory":
   n.schoolcontacttype.PublishInDirectory = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolContactType")
        }
        return n
}

// Set a sequence of properties
func (n *SchoolContactType) SetProperties(props ...Prop) *SchoolContactType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SchoolContactType) SetProperty(key string, value interface{}) *SchoolContactType {
        if n == nil {
                n, _ = SchoolContactTypePointer(SchoolContactType{})
        }
        switch key {
    case "ContactInfo":
    if v, ok:= ContactInfoTypePointer(value); ok {
      n.schoolcontacttype.ContactInfo = v
      }
    case "PublishInDirectory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolcontacttype.PublishInDirectory = ((*PublishInDirectoryType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolContactType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolContactType) ContactInfo() *ContactInfoType {
    if s.schoolcontacttype.ContactInfo == nil {
     if v, ok:= ContactInfoTypePointer(ContactInfoType{}); ok {
      s.schoolcontacttype.ContactInfo = v
      }
      }
      return s.schoolcontacttype.ContactInfo
    }
// Returns whether the element value for ContactInfo is nil in the container SchoolContactType.
  func (s *SchoolContactType) ContactInfo_IsNil() bool {
    return s.schoolcontacttype.ContactInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolContactType) PublishInDirectory() *PublishInDirectoryType {
    if s.schoolcontacttype.PublishInDirectory == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcontacttype.PublishInDirectory = ((*PublishInDirectoryType)(v))
      }
      }
      return s.schoolcontacttype.PublishInDirectory
    }
// Returns whether the element value for PublishInDirectory is nil in the container SchoolContactType.
  func (s *SchoolContactType) PublishInDirectory_IsNil() bool {
    return s.schoolcontacttype.PublishInDirectory == nil
    }

// Set the value of a property to nil
func (n *SchoolCourseInfo) Unset(key string) *SchoolCourseInfo {
        switch key {
  case "CoreAcademicCourse":
   n.schoolcourseinfo.CoreAcademicCourse = nil
  case "CourseCode":
   n.schoolcourseinfo.CourseCode = nil
  case "CourseContent":
   n.schoolcourseinfo.CourseContent = nil
  case "CourseCredits":
   n.schoolcourseinfo.CourseCredits = nil
  case "CourseTitle":
   n.schoolcourseinfo.CourseTitle = nil
  case "Department":
   n.schoolcourseinfo.Department = nil
  case "Description":
   n.schoolcourseinfo.Description = nil
  case "DistrictCourseCode":
   n.schoolcourseinfo.DistrictCourseCode = nil
  case "GraduationRequirement":
   n.schoolcourseinfo.GraduationRequirement = nil
  case "InstructionalLevel":
   n.schoolcourseinfo.InstructionalLevel = nil
  case "LocalCodeList":
   n.schoolcourseinfo.LocalCodeList = nil
  case "RefId":
   n.schoolcourseinfo.RefId = nil
  case "SIF_ExtendedElements":
   n.schoolcourseinfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.schoolcourseinfo.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.schoolcourseinfo.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.schoolcourseinfo.SchoolLocalId = nil
  case "SchoolYear":
   n.schoolcourseinfo.SchoolYear = nil
  case "StateCourseCode":
   n.schoolcourseinfo.StateCourseCode = nil
  case "SubjectAreaList":
   n.schoolcourseinfo.SubjectAreaList = nil
  case "TermInfoRefId":
   n.schoolcourseinfo.TermInfoRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolCourseInfo")
        }
        return n
}

// Set a sequence of properties
func (n *SchoolCourseInfo) SetProperties(props ...Prop) *SchoolCourseInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SchoolCourseInfo) SetProperty(key string, value interface{}) *SchoolCourseInfo {
        if n == nil {
                n, _ = SchoolCourseInfoPointer(SchoolCourseInfo{})
        }
        switch key {
    case "CoreAcademicCourse":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.CoreAcademicCourse = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "CourseCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.CourseCode = ((*String)(v))
      }
    case "CourseContent":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.CourseContent = ((*String)(v))
      }
    case "CourseCredits":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.CourseCredits = ((*String)(v))
      }
    case "CourseTitle":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.CourseTitle = ((*String)(v))
      }
    case "Department":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.Department = ((*String)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.Description = ((*String)(v))
      }
    case "DistrictCourseCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.DistrictCourseCode = ((*String)(v))
      }
    case "GraduationRequirement":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.GraduationRequirement = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "InstructionalLevel":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.InstructionalLevel = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.schoolcourseinfo.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.schoolcourseinfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.schoolcourseinfo.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StateCourseCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.StateCourseCode = ((*String)(v))
      }
    case "SubjectAreaList":
    if v, ok:= SubjectAreaListTypePointer(value); ok {
      n.schoolcourseinfo.SubjectAreaList = v
      }
    case "TermInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfo.TermInfoRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolCourseInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) CoreAcademicCourse() *AUCodeSetsYesOrNoCategoryType {
    if s.schoolcourseinfo.CoreAcademicCourse == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.CoreAcademicCourse = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.schoolcourseinfo.CoreAcademicCourse
    }
// Returns whether the element value for CoreAcademicCourse is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) CoreAcademicCourse_IsNil() bool {
    return s.schoolcourseinfo.CoreAcademicCourse == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) CourseCode() *String {
    if s.schoolcourseinfo.CourseCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.CourseCode = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.CourseCode
    }
// Returns whether the element value for CourseCode is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) CourseCode_IsNil() bool {
    return s.schoolcourseinfo.CourseCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) CourseContent() *String {
    if s.schoolcourseinfo.CourseContent == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.CourseContent = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.CourseContent
    }
// Returns whether the element value for CourseContent is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) CourseContent_IsNil() bool {
    return s.schoolcourseinfo.CourseContent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) CourseCredits() *String {
    if s.schoolcourseinfo.CourseCredits == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.CourseCredits = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.CourseCredits
    }
// Returns whether the element value for CourseCredits is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) CourseCredits_IsNil() bool {
    return s.schoolcourseinfo.CourseCredits == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) CourseTitle() *String {
    if s.schoolcourseinfo.CourseTitle == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.CourseTitle = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.CourseTitle
    }
// Returns whether the element value for CourseTitle is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) CourseTitle_IsNil() bool {
    return s.schoolcourseinfo.CourseTitle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) Department() *String {
    if s.schoolcourseinfo.Department == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.Department = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.Department
    }
// Returns whether the element value for Department is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) Department_IsNil() bool {
    return s.schoolcourseinfo.Department == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) Description() *String {
    if s.schoolcourseinfo.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.Description = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.Description
    }
// Returns whether the element value for Description is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) Description_IsNil() bool {
    return s.schoolcourseinfo.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) DistrictCourseCode() *String {
    if s.schoolcourseinfo.DistrictCourseCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.DistrictCourseCode = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.DistrictCourseCode
    }
// Returns whether the element value for DistrictCourseCode is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) DistrictCourseCode_IsNil() bool {
    return s.schoolcourseinfo.DistrictCourseCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) GraduationRequirement() *AUCodeSetsYesOrNoCategoryType {
    if s.schoolcourseinfo.GraduationRequirement == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.GraduationRequirement = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.schoolcourseinfo.GraduationRequirement
    }
// Returns whether the element value for GraduationRequirement is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) GraduationRequirement_IsNil() bool {
    return s.schoolcourseinfo.GraduationRequirement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) InstructionalLevel() *String {
    if s.schoolcourseinfo.InstructionalLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.InstructionalLevel = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.InstructionalLevel
    }
// Returns whether the element value for InstructionalLevel is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) InstructionalLevel_IsNil() bool {
    return s.schoolcourseinfo.InstructionalLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) LocalCodeList() *LocalCodeListType {
    if s.schoolcourseinfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.schoolcourseinfo.LocalCodeList = v
      }
      }
      return s.schoolcourseinfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) LocalCodeList_IsNil() bool {
    return s.schoolcourseinfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) RefId() *RefIdType {
    if s.schoolcourseinfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.schoolcourseinfo.RefId
    }
// Returns whether the element value for RefId is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) RefId_IsNil() bool {
    return s.schoolcourseinfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.schoolcourseinfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.schoolcourseinfo.SIF_ExtendedElements = v
      }
      }
      return s.schoolcourseinfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) SIF_ExtendedElements_IsNil() bool {
    return s.schoolcourseinfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) SIF_Metadata() *SIF_MetadataType {
    if s.schoolcourseinfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.schoolcourseinfo.SIF_Metadata = v
      }
      }
      return s.schoolcourseinfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) SIF_Metadata_IsNil() bool {
    return s.schoolcourseinfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) SchoolInfoRefId() *String {
    if s.schoolcourseinfo.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) SchoolInfoRefId_IsNil() bool {
    return s.schoolcourseinfo.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) SchoolLocalId() *LocalIdType {
    if s.schoolcourseinfo.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.schoolcourseinfo.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) SchoolLocalId_IsNil() bool {
    return s.schoolcourseinfo.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) SchoolYear() *SchoolYearType {
    if s.schoolcourseinfo.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.schoolcourseinfo.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) SchoolYear_IsNil() bool {
    return s.schoolcourseinfo.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) StateCourseCode() *String {
    if s.schoolcourseinfo.StateCourseCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.StateCourseCode = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.StateCourseCode
    }
// Returns whether the element value for StateCourseCode is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) StateCourseCode_IsNil() bool {
    return s.schoolcourseinfo.StateCourseCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) SubjectAreaList() *SubjectAreaListType {
    if s.schoolcourseinfo.SubjectAreaList == nil {
     if v, ok:= SubjectAreaListTypePointer(SubjectAreaListType{}); ok {
      s.schoolcourseinfo.SubjectAreaList = v
      }
      }
      return s.schoolcourseinfo.SubjectAreaList
    }
// Returns whether the element value for SubjectAreaList is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) SubjectAreaList_IsNil() bool {
    return s.schoolcourseinfo.SubjectAreaList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfo) TermInfoRefId() *String {
    if s.schoolcourseinfo.TermInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfo.TermInfoRefId = ((*String)(v))
      }
      }
      return s.schoolcourseinfo.TermInfoRefId
    }
// Returns whether the element value for TermInfoRefId is nil in the container SchoolCourseInfo.
  func (s *SchoolCourseInfo) TermInfoRefId_IsNil() bool {
    return s.schoolcourseinfo.TermInfoRefId == nil
    }

// Set the value of a property to nil
func (n *SchoolCourseInfoOverrideType) Unset(key string) *SchoolCourseInfoOverrideType {
        switch key {
  case "CourseCode":
   n.schoolcourseinfooverridetype.CourseCode = nil
  case "CourseCredits":
   n.schoolcourseinfooverridetype.CourseCredits = nil
  case "CourseTitle":
   n.schoolcourseinfooverridetype.CourseTitle = nil
  case "DistrictCourseCode":
   n.schoolcourseinfooverridetype.DistrictCourseCode = nil
  case "InstructionalLevel":
   n.schoolcourseinfooverridetype.InstructionalLevel = nil
  case "Override":
   n.schoolcourseinfooverridetype.Override = nil
  case "StateCourseCode":
   n.schoolcourseinfooverridetype.StateCourseCode = nil
  case "SubjectArea":
   n.schoolcourseinfooverridetype.SubjectArea = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolCourseInfoOverrideType")
        }
        return n
}

// Set a sequence of properties
func (n *SchoolCourseInfoOverrideType) SetProperties(props ...Prop) *SchoolCourseInfoOverrideType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SchoolCourseInfoOverrideType) SetProperty(key string, value interface{}) *SchoolCourseInfoOverrideType {
        if n == nil {
                n, _ = SchoolCourseInfoOverrideTypePointer(SchoolCourseInfoOverrideType{})
        }
        switch key {
    case "CourseCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfooverridetype.CourseCode = ((*String)(v))
      }
    case "CourseCredits":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfooverridetype.CourseCredits = ((*String)(v))
      }
    case "CourseTitle":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfooverridetype.CourseTitle = ((*String)(v))
      }
    case "DistrictCourseCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfooverridetype.DistrictCourseCode = ((*String)(v))
      }
    case "InstructionalLevel":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfooverridetype.InstructionalLevel = ((*String)(v))
      }
    case "Override":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfooverridetype.Override = ((*String)(v))
      }
    case "StateCourseCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolcourseinfooverridetype.StateCourseCode = ((*String)(v))
      }
    case "SubjectArea":
    if v, ok:= SubjectAreaTypePointer(value); ok {
      n.schoolcourseinfooverridetype.SubjectArea = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolCourseInfoOverrideType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfoOverrideType) CourseCode() *String {
    if s.schoolcourseinfooverridetype.CourseCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfooverridetype.CourseCode = ((*String)(v))
      }
      }
      return s.schoolcourseinfooverridetype.CourseCode
    }
// Returns whether the element value for CourseCode is nil in the container SchoolCourseInfoOverrideType.
  func (s *SchoolCourseInfoOverrideType) CourseCode_IsNil() bool {
    return s.schoolcourseinfooverridetype.CourseCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfoOverrideType) CourseCredits() *String {
    if s.schoolcourseinfooverridetype.CourseCredits == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfooverridetype.CourseCredits = ((*String)(v))
      }
      }
      return s.schoolcourseinfooverridetype.CourseCredits
    }
// Returns whether the element value for CourseCredits is nil in the container SchoolCourseInfoOverrideType.
  func (s *SchoolCourseInfoOverrideType) CourseCredits_IsNil() bool {
    return s.schoolcourseinfooverridetype.CourseCredits == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfoOverrideType) CourseTitle() *String {
    if s.schoolcourseinfooverridetype.CourseTitle == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfooverridetype.CourseTitle = ((*String)(v))
      }
      }
      return s.schoolcourseinfooverridetype.CourseTitle
    }
// Returns whether the element value for CourseTitle is nil in the container SchoolCourseInfoOverrideType.
  func (s *SchoolCourseInfoOverrideType) CourseTitle_IsNil() bool {
    return s.schoolcourseinfooverridetype.CourseTitle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfoOverrideType) DistrictCourseCode() *String {
    if s.schoolcourseinfooverridetype.DistrictCourseCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfooverridetype.DistrictCourseCode = ((*String)(v))
      }
      }
      return s.schoolcourseinfooverridetype.DistrictCourseCode
    }
// Returns whether the element value for DistrictCourseCode is nil in the container SchoolCourseInfoOverrideType.
  func (s *SchoolCourseInfoOverrideType) DistrictCourseCode_IsNil() bool {
    return s.schoolcourseinfooverridetype.DistrictCourseCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfoOverrideType) InstructionalLevel() *String {
    if s.schoolcourseinfooverridetype.InstructionalLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfooverridetype.InstructionalLevel = ((*String)(v))
      }
      }
      return s.schoolcourseinfooverridetype.InstructionalLevel
    }
// Returns whether the element value for InstructionalLevel is nil in the container SchoolCourseInfoOverrideType.
  func (s *SchoolCourseInfoOverrideType) InstructionalLevel_IsNil() bool {
    return s.schoolcourseinfooverridetype.InstructionalLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfoOverrideType) Override() *String {
    if s.schoolcourseinfooverridetype.Override == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfooverridetype.Override = ((*String)(v))
      }
      }
      return s.schoolcourseinfooverridetype.Override
    }
// Returns whether the element value for Override is nil in the container SchoolCourseInfoOverrideType.
  func (s *SchoolCourseInfoOverrideType) Override_IsNil() bool {
    return s.schoolcourseinfooverridetype.Override == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfoOverrideType) StateCourseCode() *String {
    if s.schoolcourseinfooverridetype.StateCourseCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolcourseinfooverridetype.StateCourseCode = ((*String)(v))
      }
      }
      return s.schoolcourseinfooverridetype.StateCourseCode
    }
// Returns whether the element value for StateCourseCode is nil in the container SchoolCourseInfoOverrideType.
  func (s *SchoolCourseInfoOverrideType) StateCourseCode_IsNil() bool {
    return s.schoolcourseinfooverridetype.StateCourseCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolCourseInfoOverrideType) SubjectArea() *SubjectAreaType {
    if s.schoolcourseinfooverridetype.SubjectArea == nil {
     if v, ok:= SubjectAreaTypePointer(SubjectAreaType{}); ok {
      s.schoolcourseinfooverridetype.SubjectArea = v
      }
      }
      return s.schoolcourseinfooverridetype.SubjectArea
    }
// Returns whether the element value for SubjectArea is nil in the container SchoolCourseInfoOverrideType.
  func (s *SchoolCourseInfoOverrideType) SubjectArea_IsNil() bool {
    return s.schoolcourseinfooverridetype.SubjectArea == nil
    }

// Set the value of a property to nil
func (n *SchoolInfo) Unset(key string) *SchoolInfo {
        switch key {
  case "ACARAId":
   n.schoolinfo.ACARAId = nil
  case "ACECQAProviderId":
   n.schoolinfo.ACECQAProviderId = nil
  case "ACECQAServiceId":
   n.schoolinfo.ACECQAServiceId = nil
  case "ARIA":
   n.schoolinfo.ARIA = nil
  case "AddressList":
   n.schoolinfo.AddressList = nil
  case "BoardingSchoolStatus":
   n.schoolinfo.BoardingSchoolStatus = nil
  case "Campus":
   n.schoolinfo.Campus = nil
  case "CommonwealthId":
   n.schoolinfo.CommonwealthId = nil
  case "EarlyChildhoodProviderName":
   n.schoolinfo.EarlyChildhoodProviderName = nil
  case "EarlyChildhoodProviderType":
   n.schoolinfo.EarlyChildhoodProviderType = nil
  case "Entity_Close":
   n.schoolinfo.Entity_Close = nil
  case "Entity_Open":
   n.schoolinfo.Entity_Open = nil
  case "FederalElectorate":
   n.schoolinfo.FederalElectorate = nil
  case "IndependentSchool":
   n.schoolinfo.IndependentSchool = nil
  case "JurisdictionLowerHouse":
   n.schoolinfo.JurisdictionLowerHouse = nil
  case "LEAInfoRefId":
   n.schoolinfo.LEAInfoRefId = nil
  case "LocalCodeList":
   n.schoolinfo.LocalCodeList = nil
  case "LocalGovernmentArea":
   n.schoolinfo.LocalGovernmentArea = nil
  case "LocalId":
   n.schoolinfo.LocalId = nil
  case "NonGovSystemicStatus":
   n.schoolinfo.NonGovSystemicStatus = nil
  case "OperationalStatus":
   n.schoolinfo.OperationalStatus = nil
  case "OtherIdList":
   n.schoolinfo.OtherIdList = nil
  case "OtherLEA":
   n.schoolinfo.OtherLEA = nil
  case "ParentCommonwealthId":
   n.schoolinfo.ParentCommonwealthId = nil
  case "PhoneNumberList":
   n.schoolinfo.PhoneNumberList = nil
  case "PrincipalInfo":
   n.schoolinfo.PrincipalInfo = nil
  case "RefId":
   n.schoolinfo.RefId = nil
  case "ReligiousAffiliation":
   n.schoolinfo.ReligiousAffiliation = nil
  case "SIF_ExtendedElements":
   n.schoolinfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.schoolinfo.SIF_Metadata = nil
  case "SLA":
   n.schoolinfo.SLA = nil
  case "SchoolCoEdStatus":
   n.schoolinfo.SchoolCoEdStatus = nil
  case "SchoolContactList":
   n.schoolinfo.SchoolContactList = nil
  case "SchoolDistrict":
   n.schoolinfo.SchoolDistrict = nil
  case "SchoolDistrictLocalId":
   n.schoolinfo.SchoolDistrictLocalId = nil
  case "SchoolEmailList":
   n.schoolinfo.SchoolEmailList = nil
  case "SchoolFocusList":
   n.schoolinfo.SchoolFocusList = nil
  case "SchoolGeographicLocation":
   n.schoolinfo.SchoolGeographicLocation = nil
  case "SchoolGroupList":
   n.schoolinfo.SchoolGroupList = nil
  case "SchoolName":
   n.schoolinfo.SchoolName = nil
  case "SchoolSector":
   n.schoolinfo.SchoolSector = nil
  case "SchoolTimeZone":
   n.schoolinfo.SchoolTimeZone = nil
  case "SchoolType":
   n.schoolinfo.SchoolType = nil
  case "SchoolURL":
   n.schoolinfo.SchoolURL = nil
  case "SessionType":
   n.schoolinfo.SessionType = nil
  case "StateProvinceId":
   n.schoolinfo.StateProvinceId = nil
  case "System":
   n.schoolinfo.System = nil
  case "TotalEnrollments":
   n.schoolinfo.TotalEnrollments = nil
  case "YearLevelEnrollmentList":
   n.schoolinfo.YearLevelEnrollmentList = nil
  case "YearLevels":
   n.schoolinfo.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolInfo")
        }
        return n
}

// Set a sequence of properties
func (n *SchoolInfo) SetProperties(props ...Prop) *SchoolInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SchoolInfo) SetProperty(key string, value interface{}) *SchoolInfo {
        if n == nil {
                n, _ = SchoolInfoPointer(SchoolInfo{})
        }
        switch key {
    case "ACARAId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.ACARAId = ((*String)(v))
      }
    case "ACECQAProviderId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.ACECQAProviderId = ((*String)(v))
      }
    case "ACECQAServiceId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.ACECQAServiceId = ((*String)(v))
      }
    case "ARIA":
    
    if v, ok:= FloatPointer(value); ok {
      n.schoolinfo.ARIA = ((*Float)(v))
      }
    case "AddressList":
    if v, ok:= AddressListTypePointer(value); ok {
      n.schoolinfo.AddressList = v
      }
    case "BoardingSchoolStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.BoardingSchoolStatus = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "Campus":
    if v, ok:= CampusContainerTypePointer(value); ok {
      n.schoolinfo.Campus = v
      }
    case "CommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.CommonwealthId = ((*String)(v))
      }
    case "EarlyChildhoodProviderName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.EarlyChildhoodProviderName = ((*String)(v))
      }
    case "EarlyChildhoodProviderType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEarlyChildhoodProviderTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEarlyChildhoodProviderTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.EarlyChildhoodProviderType = ((*AUCodeSetsEarlyChildhoodProviderTypeType)(v))
      }
    case "Entity_Close":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.Entity_Close = ((*String)(v))
      }
    case "Entity_Open":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.Entity_Open = ((*String)(v))
      }
    case "FederalElectorate":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsFederalElectorateType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsFederalElectorateType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.FederalElectorate = ((*AUCodeSetsFederalElectorateType)(v))
      }
    case "IndependentSchool":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.IndependentSchool = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "JurisdictionLowerHouse":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.JurisdictionLowerHouse = ((*String)(v))
      }
    case "LEAInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.LEAInfoRefId = ((*RefIdType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.schoolinfo.LocalCodeList = v
      }
    case "LocalGovernmentArea":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.LocalGovernmentArea = ((*String)(v))
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.LocalId = ((*LocalIdType)(v))
      }
    case "NonGovSystemicStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSystemicStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSystemicStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.NonGovSystemicStatus = ((*AUCodeSetsSystemicStatusType)(v))
      }
    case "OperationalStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsOperationalStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsOperationalStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.OperationalStatus = ((*OperationalStatusType)(v))
      }
    case "OtherIdList":
    if v, ok:= OtherIdListTypePointer(value); ok {
      n.schoolinfo.OtherIdList = v
      }
    case "OtherLEA":
    if v, ok:= SchoolInfo_OtherLEAPointer(value); ok {
      n.schoolinfo.OtherLEA = v
      }
    case "ParentCommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.ParentCommonwealthId = ((*String)(v))
      }
    case "PhoneNumberList":
    if v, ok:= PhoneNumberListTypePointer(value); ok {
      n.schoolinfo.PhoneNumberList = v
      }
    case "PrincipalInfo":
    if v, ok:= PrincipalInfoTypePointer(value); ok {
      n.schoolinfo.PrincipalInfo = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.RefId = ((*RefIdType)(v))
      }
    case "ReligiousAffiliation":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.ReligiousAffiliation = ((*AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.schoolinfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.schoolinfo.SIF_Metadata = v
      }
    case "SLA":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SLA = ((*String)(v))
      }
    case "SchoolCoEdStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolCoEdStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolCoEdStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SchoolCoEdStatus = ((*AUCodeSetsSchoolCoEdStatusType)(v))
      }
    case "SchoolContactList":
    if v, ok:= SchoolContactListTypePointer(value); ok {
      n.schoolinfo.SchoolContactList = v
      }
    case "SchoolDistrict":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SchoolDistrict = ((*String)(v))
      }
    case "SchoolDistrictLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SchoolDistrictLocalId = ((*LocalIdType)(v))
      }
    case "SchoolEmailList":
    if v, ok:= EmailListTypePointer(value); ok {
      n.schoolinfo.SchoolEmailList = v
      }
    case "SchoolFocusList":
    if v, ok:= SchoolFocusListTypePointer(value); ok {
      n.schoolinfo.SchoolFocusList = v
      }
    case "SchoolGeographicLocation":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolLocationType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolLocationType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SchoolGeographicLocation = ((*AUCodeSetsSchoolLocationType)(v))
      }
    case "SchoolGroupList":
    if v, ok:= SchoolGroupListTypePointer(value); ok {
      n.schoolinfo.SchoolGroupList = v
      }
    case "SchoolName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SchoolName = ((*String)(v))
      }
    case "SchoolSector":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolSectorCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolSectorCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SchoolSector = ((*AUCodeSetsSchoolSectorCodeType)(v))
      }
    case "SchoolTimeZone":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAustralianTimeZoneType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAustralianTimeZoneType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SchoolTimeZone = ((*AUCodeSetsAustralianTimeZoneType)(v))
      }
    case "SchoolType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolLevelType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolLevelType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SchoolType = ((*AUCodeSetsSchoolLevelType)(v))
      }
    case "SchoolURL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SchoolURL = ((*SchoolURLType)(v))
      }
    case "SessionType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSessionTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSessionTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.SessionType = ((*AUCodeSetsSessionTypeType)(v))
      }
    case "StateProvinceId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.StateProvinceId = ((*StateProvinceIdType)(v))
      }
    case "System":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolSystemType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolSystemType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schoolinfo.System = ((*AUCodeSetsSchoolSystemType)(v))
      }
    case "TotalEnrollments":
    if v, ok:= TotalEnrollmentsTypePointer(value); ok {
      n.schoolinfo.TotalEnrollments = v
      }
    case "YearLevelEnrollmentList":
    if v, ok:= YearLevelEnrollmentListTypePointer(value); ok {
      n.schoolinfo.YearLevelEnrollmentList = v
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.schoolinfo.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) ACARAId() *String {
    if s.schoolinfo.ACARAId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.ACARAId = ((*String)(v))
      }
      }
      return s.schoolinfo.ACARAId
    }
// Returns whether the element value for ACARAId is nil in the container SchoolInfo.
  func (s *SchoolInfo) ACARAId_IsNil() bool {
    return s.schoolinfo.ACARAId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) ACECQAProviderId() *String {
    if s.schoolinfo.ACECQAProviderId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.ACECQAProviderId = ((*String)(v))
      }
      }
      return s.schoolinfo.ACECQAProviderId
    }
// Returns whether the element value for ACECQAProviderId is nil in the container SchoolInfo.
  func (s *SchoolInfo) ACECQAProviderId_IsNil() bool {
    return s.schoolinfo.ACECQAProviderId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) ACECQAServiceId() *String {
    if s.schoolinfo.ACECQAServiceId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.ACECQAServiceId = ((*String)(v))
      }
      }
      return s.schoolinfo.ACECQAServiceId
    }
// Returns whether the element value for ACECQAServiceId is nil in the container SchoolInfo.
  func (s *SchoolInfo) ACECQAServiceId_IsNil() bool {
    return s.schoolinfo.ACECQAServiceId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) ARIA() *Float {
    if s.schoolinfo.ARIA == nil {
    if v, ok:= FloatPointer(0); ok {
      s.schoolinfo.ARIA = ((*Float)(v))
      }
      }
      return s.schoolinfo.ARIA
    }
// Returns whether the element value for ARIA is nil in the container SchoolInfo.
  func (s *SchoolInfo) ARIA_IsNil() bool {
    return s.schoolinfo.ARIA == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) AddressList() *AddressListType {
    if s.schoolinfo.AddressList == nil {
     if v, ok:= AddressListTypePointer(AddressListType{}); ok {
      s.schoolinfo.AddressList = v
      }
      }
      return s.schoolinfo.AddressList
    }
// Returns whether the element value for AddressList is nil in the container SchoolInfo.
  func (s *SchoolInfo) AddressList_IsNil() bool {
    return s.schoolinfo.AddressList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) BoardingSchoolStatus() *AUCodeSetsYesOrNoCategoryType {
    if s.schoolinfo.BoardingSchoolStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.BoardingSchoolStatus = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.schoolinfo.BoardingSchoolStatus
    }
// Returns whether the element value for BoardingSchoolStatus is nil in the container SchoolInfo.
  func (s *SchoolInfo) BoardingSchoolStatus_IsNil() bool {
    return s.schoolinfo.BoardingSchoolStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) Campus() *CampusContainerType {
    if s.schoolinfo.Campus == nil {
     if v, ok:= CampusContainerTypePointer(CampusContainerType{}); ok {
      s.schoolinfo.Campus = v
      }
      }
      return s.schoolinfo.Campus
    }
// Returns whether the element value for Campus is nil in the container SchoolInfo.
  func (s *SchoolInfo) Campus_IsNil() bool {
    return s.schoolinfo.Campus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) CommonwealthId() *String {
    if s.schoolinfo.CommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.CommonwealthId = ((*String)(v))
      }
      }
      return s.schoolinfo.CommonwealthId
    }
// Returns whether the element value for CommonwealthId is nil in the container SchoolInfo.
  func (s *SchoolInfo) CommonwealthId_IsNil() bool {
    return s.schoolinfo.CommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) EarlyChildhoodProviderName() *String {
    if s.schoolinfo.EarlyChildhoodProviderName == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.EarlyChildhoodProviderName = ((*String)(v))
      }
      }
      return s.schoolinfo.EarlyChildhoodProviderName
    }
// Returns whether the element value for EarlyChildhoodProviderName is nil in the container SchoolInfo.
  func (s *SchoolInfo) EarlyChildhoodProviderName_IsNil() bool {
    return s.schoolinfo.EarlyChildhoodProviderName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) EarlyChildhoodProviderType() *AUCodeSetsEarlyChildhoodProviderTypeType {
    if s.schoolinfo.EarlyChildhoodProviderType == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.EarlyChildhoodProviderType = ((*AUCodeSetsEarlyChildhoodProviderTypeType)(v))
      }
      }
      return s.schoolinfo.EarlyChildhoodProviderType
    }
// Returns whether the element value for EarlyChildhoodProviderType is nil in the container SchoolInfo.
  func (s *SchoolInfo) EarlyChildhoodProviderType_IsNil() bool {
    return s.schoolinfo.EarlyChildhoodProviderType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) Entity_Close() *String {
    if s.schoolinfo.Entity_Close == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.Entity_Close = ((*String)(v))
      }
      }
      return s.schoolinfo.Entity_Close
    }
// Returns whether the element value for Entity_Close is nil in the container SchoolInfo.
  func (s *SchoolInfo) Entity_Close_IsNil() bool {
    return s.schoolinfo.Entity_Close == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) Entity_Open() *String {
    if s.schoolinfo.Entity_Open == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.Entity_Open = ((*String)(v))
      }
      }
      return s.schoolinfo.Entity_Open
    }
// Returns whether the element value for Entity_Open is nil in the container SchoolInfo.
  func (s *SchoolInfo) Entity_Open_IsNil() bool {
    return s.schoolinfo.Entity_Open == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) FederalElectorate() *AUCodeSetsFederalElectorateType {
    if s.schoolinfo.FederalElectorate == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.FederalElectorate = ((*AUCodeSetsFederalElectorateType)(v))
      }
      }
      return s.schoolinfo.FederalElectorate
    }
// Returns whether the element value for FederalElectorate is nil in the container SchoolInfo.
  func (s *SchoolInfo) FederalElectorate_IsNil() bool {
    return s.schoolinfo.FederalElectorate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) IndependentSchool() *AUCodeSetsYesOrNoCategoryType {
    if s.schoolinfo.IndependentSchool == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.IndependentSchool = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.schoolinfo.IndependentSchool
    }
// Returns whether the element value for IndependentSchool is nil in the container SchoolInfo.
  func (s *SchoolInfo) IndependentSchool_IsNil() bool {
    return s.schoolinfo.IndependentSchool == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) JurisdictionLowerHouse() *String {
    if s.schoolinfo.JurisdictionLowerHouse == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.JurisdictionLowerHouse = ((*String)(v))
      }
      }
      return s.schoolinfo.JurisdictionLowerHouse
    }
// Returns whether the element value for JurisdictionLowerHouse is nil in the container SchoolInfo.
  func (s *SchoolInfo) JurisdictionLowerHouse_IsNil() bool {
    return s.schoolinfo.JurisdictionLowerHouse == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) LEAInfoRefId() *RefIdType {
    if s.schoolinfo.LEAInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.LEAInfoRefId = ((*RefIdType)(v))
      }
      }
      return s.schoolinfo.LEAInfoRefId
    }
// Returns whether the element value for LEAInfoRefId is nil in the container SchoolInfo.
  func (s *SchoolInfo) LEAInfoRefId_IsNil() bool {
    return s.schoolinfo.LEAInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) LocalCodeList() *LocalCodeListType {
    if s.schoolinfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.schoolinfo.LocalCodeList = v
      }
      }
      return s.schoolinfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container SchoolInfo.
  func (s *SchoolInfo) LocalCodeList_IsNil() bool {
    return s.schoolinfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) LocalGovernmentArea() *String {
    if s.schoolinfo.LocalGovernmentArea == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.LocalGovernmentArea = ((*String)(v))
      }
      }
      return s.schoolinfo.LocalGovernmentArea
    }
// Returns whether the element value for LocalGovernmentArea is nil in the container SchoolInfo.
  func (s *SchoolInfo) LocalGovernmentArea_IsNil() bool {
    return s.schoolinfo.LocalGovernmentArea == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) LocalId() *LocalIdType {
    if s.schoolinfo.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.schoolinfo.LocalId
    }
// Returns whether the element value for LocalId is nil in the container SchoolInfo.
  func (s *SchoolInfo) LocalId_IsNil() bool {
    return s.schoolinfo.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) NonGovSystemicStatus() *AUCodeSetsSystemicStatusType {
    if s.schoolinfo.NonGovSystemicStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.NonGovSystemicStatus = ((*AUCodeSetsSystemicStatusType)(v))
      }
      }
      return s.schoolinfo.NonGovSystemicStatus
    }
// Returns whether the element value for NonGovSystemicStatus is nil in the container SchoolInfo.
  func (s *SchoolInfo) NonGovSystemicStatus_IsNil() bool {
    return s.schoolinfo.NonGovSystemicStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) OperationalStatus() *OperationalStatusType {
    if s.schoolinfo.OperationalStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.OperationalStatus = ((*OperationalStatusType)(v))
      }
      }
      return s.schoolinfo.OperationalStatus
    }
// Returns whether the element value for OperationalStatus is nil in the container SchoolInfo.
  func (s *SchoolInfo) OperationalStatus_IsNil() bool {
    return s.schoolinfo.OperationalStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) OtherIdList() *OtherIdListType {
    if s.schoolinfo.OtherIdList == nil {
     if v, ok:= OtherIdListTypePointer(OtherIdListType{}); ok {
      s.schoolinfo.OtherIdList = v
      }
      }
      return s.schoolinfo.OtherIdList
    }
// Returns whether the element value for OtherIdList is nil in the container SchoolInfo.
  func (s *SchoolInfo) OtherIdList_IsNil() bool {
    return s.schoolinfo.OtherIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) OtherLEA() *SchoolInfo_OtherLEA {
    if s.schoolinfo.OtherLEA == nil {
     if v, ok:= SchoolInfo_OtherLEAPointer(SchoolInfo_OtherLEA{}); ok {
      s.schoolinfo.OtherLEA = v
      }
      }
      return s.schoolinfo.OtherLEA
    }
// Returns whether the element value for OtherLEA is nil in the container SchoolInfo.
  func (s *SchoolInfo) OtherLEA_IsNil() bool {
    return s.schoolinfo.OtherLEA == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) ParentCommonwealthId() *String {
    if s.schoolinfo.ParentCommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.ParentCommonwealthId = ((*String)(v))
      }
      }
      return s.schoolinfo.ParentCommonwealthId
    }
// Returns whether the element value for ParentCommonwealthId is nil in the container SchoolInfo.
  func (s *SchoolInfo) ParentCommonwealthId_IsNil() bool {
    return s.schoolinfo.ParentCommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) PhoneNumberList() *PhoneNumberListType {
    if s.schoolinfo.PhoneNumberList == nil {
     if v, ok:= PhoneNumberListTypePointer(PhoneNumberListType{}); ok {
      s.schoolinfo.PhoneNumberList = v
      }
      }
      return s.schoolinfo.PhoneNumberList
    }
// Returns whether the element value for PhoneNumberList is nil in the container SchoolInfo.
  func (s *SchoolInfo) PhoneNumberList_IsNil() bool {
    return s.schoolinfo.PhoneNumberList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) PrincipalInfo() *PrincipalInfoType {
    if s.schoolinfo.PrincipalInfo == nil {
     if v, ok:= PrincipalInfoTypePointer(PrincipalInfoType{}); ok {
      s.schoolinfo.PrincipalInfo = v
      }
      }
      return s.schoolinfo.PrincipalInfo
    }
// Returns whether the element value for PrincipalInfo is nil in the container SchoolInfo.
  func (s *SchoolInfo) PrincipalInfo_IsNil() bool {
    return s.schoolinfo.PrincipalInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) RefId() *RefIdType {
    if s.schoolinfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.schoolinfo.RefId
    }
// Returns whether the element value for RefId is nil in the container SchoolInfo.
  func (s *SchoolInfo) RefId_IsNil() bool {
    return s.schoolinfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) ReligiousAffiliation() *AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType {
    if s.schoolinfo.ReligiousAffiliation == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.ReligiousAffiliation = ((*AUCodeSetsAustralianStandardClassificationOfReligiousGroupsASCRGType)(v))
      }
      }
      return s.schoolinfo.ReligiousAffiliation
    }
// Returns whether the element value for ReligiousAffiliation is nil in the container SchoolInfo.
  func (s *SchoolInfo) ReligiousAffiliation_IsNil() bool {
    return s.schoolinfo.ReligiousAffiliation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.schoolinfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.schoolinfo.SIF_ExtendedElements = v
      }
      }
      return s.schoolinfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container SchoolInfo.
  func (s *SchoolInfo) SIF_ExtendedElements_IsNil() bool {
    return s.schoolinfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SIF_Metadata() *SIF_MetadataType {
    if s.schoolinfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.schoolinfo.SIF_Metadata = v
      }
      }
      return s.schoolinfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container SchoolInfo.
  func (s *SchoolInfo) SIF_Metadata_IsNil() bool {
    return s.schoolinfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SLA() *String {
    if s.schoolinfo.SLA == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SLA = ((*String)(v))
      }
      }
      return s.schoolinfo.SLA
    }
// Returns whether the element value for SLA is nil in the container SchoolInfo.
  func (s *SchoolInfo) SLA_IsNil() bool {
    return s.schoolinfo.SLA == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolCoEdStatus() *AUCodeSetsSchoolCoEdStatusType {
    if s.schoolinfo.SchoolCoEdStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SchoolCoEdStatus = ((*AUCodeSetsSchoolCoEdStatusType)(v))
      }
      }
      return s.schoolinfo.SchoolCoEdStatus
    }
// Returns whether the element value for SchoolCoEdStatus is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolCoEdStatus_IsNil() bool {
    return s.schoolinfo.SchoolCoEdStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolContactList() *SchoolContactListType {
    if s.schoolinfo.SchoolContactList == nil {
     if v, ok:= SchoolContactListTypePointer(SchoolContactListType{}); ok {
      s.schoolinfo.SchoolContactList = v
      }
      }
      return s.schoolinfo.SchoolContactList
    }
// Returns whether the element value for SchoolContactList is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolContactList_IsNil() bool {
    return s.schoolinfo.SchoolContactList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolDistrict() *String {
    if s.schoolinfo.SchoolDistrict == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SchoolDistrict = ((*String)(v))
      }
      }
      return s.schoolinfo.SchoolDistrict
    }
// Returns whether the element value for SchoolDistrict is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolDistrict_IsNil() bool {
    return s.schoolinfo.SchoolDistrict == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolDistrictLocalId() *LocalIdType {
    if s.schoolinfo.SchoolDistrictLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SchoolDistrictLocalId = ((*LocalIdType)(v))
      }
      }
      return s.schoolinfo.SchoolDistrictLocalId
    }
// Returns whether the element value for SchoolDistrictLocalId is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolDistrictLocalId_IsNil() bool {
    return s.schoolinfo.SchoolDistrictLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolEmailList() *EmailListType {
    if s.schoolinfo.SchoolEmailList == nil {
     if v, ok:= EmailListTypePointer(EmailListType{}); ok {
      s.schoolinfo.SchoolEmailList = v
      }
      }
      return s.schoolinfo.SchoolEmailList
    }
// Returns whether the element value for SchoolEmailList is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolEmailList_IsNil() bool {
    return s.schoolinfo.SchoolEmailList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolFocusList() *SchoolFocusListType {
    if s.schoolinfo.SchoolFocusList == nil {
     if v, ok:= SchoolFocusListTypePointer(SchoolFocusListType{}); ok {
      s.schoolinfo.SchoolFocusList = v
      }
      }
      return s.schoolinfo.SchoolFocusList
    }
// Returns whether the element value for SchoolFocusList is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolFocusList_IsNil() bool {
    return s.schoolinfo.SchoolFocusList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolGeographicLocation() *AUCodeSetsSchoolLocationType {
    if s.schoolinfo.SchoolGeographicLocation == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SchoolGeographicLocation = ((*AUCodeSetsSchoolLocationType)(v))
      }
      }
      return s.schoolinfo.SchoolGeographicLocation
    }
// Returns whether the element value for SchoolGeographicLocation is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolGeographicLocation_IsNil() bool {
    return s.schoolinfo.SchoolGeographicLocation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolGroupList() *SchoolGroupListType {
    if s.schoolinfo.SchoolGroupList == nil {
     if v, ok:= SchoolGroupListTypePointer(SchoolGroupListType{}); ok {
      s.schoolinfo.SchoolGroupList = v
      }
      }
      return s.schoolinfo.SchoolGroupList
    }
// Returns whether the element value for SchoolGroupList is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolGroupList_IsNil() bool {
    return s.schoolinfo.SchoolGroupList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolName() *String {
    if s.schoolinfo.SchoolName == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SchoolName = ((*String)(v))
      }
      }
      return s.schoolinfo.SchoolName
    }
// Returns whether the element value for SchoolName is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolName_IsNil() bool {
    return s.schoolinfo.SchoolName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolSector() *AUCodeSetsSchoolSectorCodeType {
    if s.schoolinfo.SchoolSector == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SchoolSector = ((*AUCodeSetsSchoolSectorCodeType)(v))
      }
      }
      return s.schoolinfo.SchoolSector
    }
// Returns whether the element value for SchoolSector is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolSector_IsNil() bool {
    return s.schoolinfo.SchoolSector == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolTimeZone() *AUCodeSetsAustralianTimeZoneType {
    if s.schoolinfo.SchoolTimeZone == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SchoolTimeZone = ((*AUCodeSetsAustralianTimeZoneType)(v))
      }
      }
      return s.schoolinfo.SchoolTimeZone
    }
// Returns whether the element value for SchoolTimeZone is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolTimeZone_IsNil() bool {
    return s.schoolinfo.SchoolTimeZone == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolType() *AUCodeSetsSchoolLevelType {
    if s.schoolinfo.SchoolType == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SchoolType = ((*AUCodeSetsSchoolLevelType)(v))
      }
      }
      return s.schoolinfo.SchoolType
    }
// Returns whether the element value for SchoolType is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolType_IsNil() bool {
    return s.schoolinfo.SchoolType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SchoolURL() *SchoolURLType {
    if s.schoolinfo.SchoolURL == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SchoolURL = ((*SchoolURLType)(v))
      }
      }
      return s.schoolinfo.SchoolURL
    }
// Returns whether the element value for SchoolURL is nil in the container SchoolInfo.
  func (s *SchoolInfo) SchoolURL_IsNil() bool {
    return s.schoolinfo.SchoolURL == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) SessionType() *AUCodeSetsSessionTypeType {
    if s.schoolinfo.SessionType == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.SessionType = ((*AUCodeSetsSessionTypeType)(v))
      }
      }
      return s.schoolinfo.SessionType
    }
// Returns whether the element value for SessionType is nil in the container SchoolInfo.
  func (s *SchoolInfo) SessionType_IsNil() bool {
    return s.schoolinfo.SessionType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) StateProvinceId() *StateProvinceIdType {
    if s.schoolinfo.StateProvinceId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.StateProvinceId = ((*StateProvinceIdType)(v))
      }
      }
      return s.schoolinfo.StateProvinceId
    }
// Returns whether the element value for StateProvinceId is nil in the container SchoolInfo.
  func (s *SchoolInfo) StateProvinceId_IsNil() bool {
    return s.schoolinfo.StateProvinceId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) System() *AUCodeSetsSchoolSystemType {
    if s.schoolinfo.System == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo.System = ((*AUCodeSetsSchoolSystemType)(v))
      }
      }
      return s.schoolinfo.System
    }
// Returns whether the element value for System is nil in the container SchoolInfo.
  func (s *SchoolInfo) System_IsNil() bool {
    return s.schoolinfo.System == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) TotalEnrollments() *TotalEnrollmentsType {
    if s.schoolinfo.TotalEnrollments == nil {
     if v, ok:= TotalEnrollmentsTypePointer(TotalEnrollmentsType{}); ok {
      s.schoolinfo.TotalEnrollments = v
      }
      }
      return s.schoolinfo.TotalEnrollments
    }
// Returns whether the element value for TotalEnrollments is nil in the container SchoolInfo.
  func (s *SchoolInfo) TotalEnrollments_IsNil() bool {
    return s.schoolinfo.TotalEnrollments == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) YearLevelEnrollmentList() *YearLevelEnrollmentListType {
    if s.schoolinfo.YearLevelEnrollmentList == nil {
     if v, ok:= YearLevelEnrollmentListTypePointer(YearLevelEnrollmentListType{}); ok {
      s.schoolinfo.YearLevelEnrollmentList = v
      }
      }
      return s.schoolinfo.YearLevelEnrollmentList
    }
// Returns whether the element value for YearLevelEnrollmentList is nil in the container SchoolInfo.
  func (s *SchoolInfo) YearLevelEnrollmentList_IsNil() bool {
    return s.schoolinfo.YearLevelEnrollmentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo) YearLevels() *YearLevelsType {
    if s.schoolinfo.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.schoolinfo.YearLevels = v
      }
      }
      return s.schoolinfo.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container SchoolInfo.
  func (s *SchoolInfo) YearLevels_IsNil() bool {
    return s.schoolinfo.YearLevels == nil
    }

// Set the value of a property to nil
func (n *SchoolInfo_OtherLEA) Unset(key string) *SchoolInfo_OtherLEA {
        switch key {
  case "SIF_RefObject":
   n.schoolinfo_otherlea.SIF_RefObject = nil
  case "Value":
   n.schoolinfo_otherlea.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolInfo_OtherLEA")
        }
        return n
}

// Set a sequence of properties
func (n *SchoolInfo_OtherLEA) SetProperties(props ...Prop) *SchoolInfo_OtherLEA {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SchoolInfo_OtherLEA) SetProperty(key string, value interface{}) *SchoolInfo_OtherLEA {
        if n == nil {
                n, _ = SchoolInfo_OtherLEAPointer(SchoolInfo_OtherLEA{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo_otherlea.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolinfo_otherlea.Value = ((*RefIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolInfo_OtherLEA")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo_OtherLEA) SIF_RefObject() *String {
    if s.schoolinfo_otherlea.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo_otherlea.SIF_RefObject = ((*String)(v))
      }
      }
      return s.schoolinfo_otherlea.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container SchoolInfo_OtherLEA.
  func (s *SchoolInfo_OtherLEA) SIF_RefObject_IsNil() bool {
    return s.schoolinfo_otherlea.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolInfo_OtherLEA) Value() *RefIdType {
    if s.schoolinfo_otherlea.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolinfo_otherlea.Value = ((*RefIdType)(v))
      }
      }
      return s.schoolinfo_otherlea.Value
    }
// Returns whether the element value for Value is nil in the container SchoolInfo_OtherLEA.
  func (s *SchoolInfo_OtherLEA) Value_IsNil() bool {
    return s.schoolinfo_otherlea.Value == nil
    }

// Set the value of a property to nil
func (n *SchoolProgramType) Unset(key string) *SchoolProgramType {
        switch key {
  case "Category":
   n.schoolprogramtype.Category = nil
  case "OtherCodeList":
   n.schoolprogramtype.OtherCodeList = nil
  case "Type":
   n.schoolprogramtype.Type = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolProgramType")
        }
        return n
}

// Set a sequence of properties
func (n *SchoolProgramType) SetProperties(props ...Prop) *SchoolProgramType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SchoolProgramType) SetProperty(key string, value interface{}) *SchoolProgramType {
        if n == nil {
                n, _ = SchoolProgramTypePointer(SchoolProgramType{})
        }
        switch key {
    case "Category":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolprogramtype.Category = ((*String)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.schoolprogramtype.OtherCodeList = v
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolprogramtype.Type = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolProgramType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolProgramType) Category() *String {
    if s.schoolprogramtype.Category == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolprogramtype.Category = ((*String)(v))
      }
      }
      return s.schoolprogramtype.Category
    }
// Returns whether the element value for Category is nil in the container SchoolProgramType.
  func (s *SchoolProgramType) Category_IsNil() bool {
    return s.schoolprogramtype.Category == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolProgramType) OtherCodeList() *OtherCodeListType {
    if s.schoolprogramtype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.schoolprogramtype.OtherCodeList = v
      }
      }
      return s.schoolprogramtype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container SchoolProgramType.
  func (s *SchoolProgramType) OtherCodeList_IsNil() bool {
    return s.schoolprogramtype.OtherCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolProgramType) Type() *String {
    if s.schoolprogramtype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolprogramtype.Type = ((*String)(v))
      }
      }
      return s.schoolprogramtype.Type
    }
// Returns whether the element value for Type is nil in the container SchoolProgramType.
  func (s *SchoolProgramType) Type_IsNil() bool {
    return s.schoolprogramtype.Type == nil
    }

// Set the value of a property to nil
func (n *SchoolPrograms) Unset(key string) *SchoolPrograms {
        switch key {
  case "LocalCodeList":
   n.schoolprograms.LocalCodeList = nil
  case "RefId":
   n.schoolprograms.RefId = nil
  case "SIF_ExtendedElements":
   n.schoolprograms.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.schoolprograms.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.schoolprograms.SchoolInfoRefId = nil
  case "SchoolProgramList":
   n.schoolprograms.SchoolProgramList = nil
  case "SchoolYear":
   n.schoolprograms.SchoolYear = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolPrograms")
        }
        return n
}

// Set a sequence of properties
func (n *SchoolPrograms) SetProperties(props ...Prop) *SchoolPrograms {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SchoolPrograms) SetProperty(key string, value interface{}) *SchoolPrograms {
        if n == nil {
                n, _ = SchoolProgramsPointer(SchoolPrograms{})
        }
        switch key {
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.schoolprograms.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolprograms.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.schoolprograms.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.schoolprograms.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolprograms.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolProgramList":
    if v, ok:= SchoolProgramListTypePointer(value); ok {
      n.schoolprograms.SchoolProgramList = v
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schoolprograms.SchoolYear = ((*SchoolYearType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolPrograms")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolPrograms) LocalCodeList() *LocalCodeListType {
    if s.schoolprograms.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.schoolprograms.LocalCodeList = v
      }
      }
      return s.schoolprograms.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container SchoolPrograms.
  func (s *SchoolPrograms) LocalCodeList_IsNil() bool {
    return s.schoolprograms.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolPrograms) RefId() *RefIdType {
    if s.schoolprograms.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolprograms.RefId = ((*RefIdType)(v))
      }
      }
      return s.schoolprograms.RefId
    }
// Returns whether the element value for RefId is nil in the container SchoolPrograms.
  func (s *SchoolPrograms) RefId_IsNil() bool {
    return s.schoolprograms.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolPrograms) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.schoolprograms.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.schoolprograms.SIF_ExtendedElements = v
      }
      }
      return s.schoolprograms.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container SchoolPrograms.
  func (s *SchoolPrograms) SIF_ExtendedElements_IsNil() bool {
    return s.schoolprograms.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolPrograms) SIF_Metadata() *SIF_MetadataType {
    if s.schoolprograms.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.schoolprograms.SIF_Metadata = v
      }
      }
      return s.schoolprograms.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container SchoolPrograms.
  func (s *SchoolPrograms) SIF_Metadata_IsNil() bool {
    return s.schoolprograms.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolPrograms) SchoolInfoRefId() *String {
    if s.schoolprograms.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolprograms.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.schoolprograms.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container SchoolPrograms.
  func (s *SchoolPrograms) SchoolInfoRefId_IsNil() bool {
    return s.schoolprograms.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolPrograms) SchoolProgramList() *SchoolProgramListType {
    if s.schoolprograms.SchoolProgramList == nil {
     if v, ok:= SchoolProgramListTypePointer(SchoolProgramListType{}); ok {
      s.schoolprograms.SchoolProgramList = v
      }
      }
      return s.schoolprograms.SchoolProgramList
    }
// Returns whether the element value for SchoolProgramList is nil in the container SchoolPrograms.
  func (s *SchoolPrograms) SchoolProgramList_IsNil() bool {
    return s.schoolprograms.SchoolProgramList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolPrograms) SchoolYear() *SchoolYearType {
    if s.schoolprograms.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.schoolprograms.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.schoolprograms.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container SchoolPrograms.
  func (s *SchoolPrograms) SchoolYear_IsNil() bool {
    return s.schoolprograms.SchoolYear == nil
    }

// Set the value of a property to nil
func (n *SchoolTravelType) Unset(key string) *SchoolTravelType {
        switch key {
  case "TravelAccompaniment":
   n.schooltraveltype.TravelAccompaniment = nil
  case "TravelDetails":
   n.schooltraveltype.TravelDetails = nil
  case "TravelMode":
   n.schooltraveltype.TravelMode = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolTravelType")
        }
        return n
}

// Set a sequence of properties
func (n *SchoolTravelType) SetProperties(props ...Prop) *SchoolTravelType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SchoolTravelType) SetProperty(key string, value interface{}) *SchoolTravelType {
        if n == nil {
                n, _ = SchoolTravelTypePointer(SchoolTravelType{})
        }
        switch key {
    case "TravelAccompaniment":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAccompanimentType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAccompanimentType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schooltraveltype.TravelAccompaniment = ((*AUCodeSetsAccompanimentType)(v))
      }
    case "TravelDetails":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.schooltraveltype.TravelDetails = ((*String)(v))
      }
    case "TravelMode":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsTravelModeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsTravelModeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.schooltraveltype.TravelMode = ((*AUCodeSetsTravelModeType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SchoolTravelType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolTravelType) TravelAccompaniment() *AUCodeSetsAccompanimentType {
    if s.schooltraveltype.TravelAccompaniment == nil {
    if v, ok:= StringPointer(""); ok {
      s.schooltraveltype.TravelAccompaniment = ((*AUCodeSetsAccompanimentType)(v))
      }
      }
      return s.schooltraveltype.TravelAccompaniment
    }
// Returns whether the element value for TravelAccompaniment is nil in the container SchoolTravelType.
  func (s *SchoolTravelType) TravelAccompaniment_IsNil() bool {
    return s.schooltraveltype.TravelAccompaniment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolTravelType) TravelDetails() *String {
    if s.schooltraveltype.TravelDetails == nil {
    if v, ok:= StringPointer(""); ok {
      s.schooltraveltype.TravelDetails = ((*String)(v))
      }
      }
      return s.schooltraveltype.TravelDetails
    }
// Returns whether the element value for TravelDetails is nil in the container SchoolTravelType.
  func (s *SchoolTravelType) TravelDetails_IsNil() bool {
    return s.schooltraveltype.TravelDetails == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SchoolTravelType) TravelMode() *AUCodeSetsTravelModeType {
    if s.schooltraveltype.TravelMode == nil {
    if v, ok:= StringPointer(""); ok {
      s.schooltraveltype.TravelMode = ((*AUCodeSetsTravelModeType)(v))
      }
      }
      return s.schooltraveltype.TravelMode
    }
// Returns whether the element value for TravelMode is nil in the container SchoolTravelType.
  func (s *SchoolTravelType) TravelMode_IsNil() bool {
    return s.schooltraveltype.TravelMode == nil
    }

// Set the value of a property to nil
func (n *ScoreDescriptionType) Unset(key string) *ScoreDescriptionType {
        switch key {
  case "Descriptor":
   n.scoredescriptiontype.Descriptor = nil
  case "ScoreValue":
   n.scoredescriptiontype.ScoreValue = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ScoreDescriptionType")
        }
        return n
}

// Set a sequence of properties
func (n *ScoreDescriptionType) SetProperties(props ...Prop) *ScoreDescriptionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ScoreDescriptionType) SetProperty(key string, value interface{}) *ScoreDescriptionType {
        if n == nil {
                n, _ = ScoreDescriptionTypePointer(ScoreDescriptionType{})
        }
        switch key {
    case "Descriptor":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.scoredescriptiontype.Descriptor = ((*String)(v))
      }
    case "ScoreValue":
    
    if v, ok:= FloatPointer(value); ok {
      n.scoredescriptiontype.ScoreValue = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ScoreDescriptionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScoreDescriptionType) Descriptor() *String {
    if s.scoredescriptiontype.Descriptor == nil {
    if v, ok:= StringPointer(""); ok {
      s.scoredescriptiontype.Descriptor = ((*String)(v))
      }
      }
      return s.scoredescriptiontype.Descriptor
    }
// Returns whether the element value for Descriptor is nil in the container ScoreDescriptionType.
  func (s *ScoreDescriptionType) Descriptor_IsNil() bool {
    return s.scoredescriptiontype.Descriptor == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScoreDescriptionType) ScoreValue() *Float {
    if s.scoredescriptiontype.ScoreValue == nil {
    if v, ok:= FloatPointer(0); ok {
      s.scoredescriptiontype.ScoreValue = ((*Float)(v))
      }
      }
      return s.scoredescriptiontype.ScoreValue
    }
// Returns whether the element value for ScoreValue is nil in the container ScoreDescriptionType.
  func (s *ScoreDescriptionType) ScoreValue_IsNil() bool {
    return s.scoredescriptiontype.ScoreValue == nil
    }

// Set the value of a property to nil
func (n *ScoreType) Unset(key string) *ScoreType {
        switch key {
  case "MaxScoreValue":
   n.scoretype.MaxScoreValue = nil
  case "ScoreDescriptionList":
   n.scoretype.ScoreDescriptionList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ScoreType")
        }
        return n
}

// Set a sequence of properties
func (n *ScoreType) SetProperties(props ...Prop) *ScoreType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ScoreType) SetProperty(key string, value interface{}) *ScoreType {
        if n == nil {
                n, _ = ScoreTypePointer(ScoreType{})
        }
        switch key {
    case "MaxScoreValue":
    
    if v, ok:= FloatPointer(value); ok {
      n.scoretype.MaxScoreValue = ((*Float)(v))
      }
    case "ScoreDescriptionList":
    if v, ok:= ScoreDescriptionListTypePointer(value); ok {
      n.scoretype.ScoreDescriptionList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ScoreType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScoreType) MaxScoreValue() *Float {
    if s.scoretype.MaxScoreValue == nil {
    if v, ok:= FloatPointer(0); ok {
      s.scoretype.MaxScoreValue = ((*Float)(v))
      }
      }
      return s.scoretype.MaxScoreValue
    }
// Returns whether the element value for MaxScoreValue is nil in the container ScoreType.
  func (s *ScoreType) MaxScoreValue_IsNil() bool {
    return s.scoretype.MaxScoreValue == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ScoreType) ScoreDescriptionList() *ScoreDescriptionListType {
    if s.scoretype.ScoreDescriptionList == nil {
     if v, ok:= ScoreDescriptionListTypePointer(ScoreDescriptionListType{}); ok {
      s.scoretype.ScoreDescriptionList = v
      }
      }
      return s.scoretype.ScoreDescriptionList
    }
// Returns whether the element value for ScoreDescriptionList is nil in the container ScoreType.
  func (s *ScoreType) ScoreDescriptionList_IsNil() bool {
    return s.scoretype.ScoreDescriptionList == nil
    }

// Set the value of a property to nil
func (n *SectionInfo) Unset(key string) *SectionInfo {
        switch key {
  case "CountForAttendance":
   n.sectioninfo.CountForAttendance = nil
  case "CourseSectionCode":
   n.sectioninfo.CourseSectionCode = nil
  case "Description":
   n.sectioninfo.Description = nil
  case "LanguageOfInstruction":
   n.sectioninfo.LanguageOfInstruction = nil
  case "LocalCodeList":
   n.sectioninfo.LocalCodeList = nil
  case "LocalId":
   n.sectioninfo.LocalId = nil
  case "LocationOfInstruction":
   n.sectioninfo.LocationOfInstruction = nil
  case "MediumOfInstruction":
   n.sectioninfo.MediumOfInstruction = nil
  case "RefId":
   n.sectioninfo.RefId = nil
  case "SIF_ExtendedElements":
   n.sectioninfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.sectioninfo.SIF_Metadata = nil
  case "SchoolCourseInfoOverride":
   n.sectioninfo.SchoolCourseInfoOverride = nil
  case "SchoolCourseInfoRefId":
   n.sectioninfo.SchoolCourseInfoRefId = nil
  case "SchoolYear":
   n.sectioninfo.SchoolYear = nil
  case "SectionCode":
   n.sectioninfo.SectionCode = nil
  case "SummerSchool":
   n.sectioninfo.SummerSchool = nil
  case "TermInfoRefId":
   n.sectioninfo.TermInfoRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SectionInfo")
        }
        return n
}

// Set a sequence of properties
func (n *SectionInfo) SetProperties(props ...Prop) *SectionInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SectionInfo) SetProperty(key string, value interface{}) *SectionInfo {
        if n == nil {
                n, _ = SectionInfoPointer(SectionInfo{})
        }
        switch key {
    case "CountForAttendance":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.CountForAttendance = ((*String)(v))
      }
    case "CourseSectionCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.CourseSectionCode = ((*String)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.Description = ((*String)(v))
      }
    case "LanguageOfInstruction":
    if v, ok:= LanguageOfInstructionTypePointer(value); ok {
      n.sectioninfo.LanguageOfInstruction = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.sectioninfo.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.LocalId = ((*LocalIdType)(v))
      }
    case "LocationOfInstruction":
    if v, ok:= LocationOfInstructionTypePointer(value); ok {
      n.sectioninfo.LocationOfInstruction = v
      }
    case "MediumOfInstruction":
    if v, ok:= MediumOfInstructionTypePointer(value); ok {
      n.sectioninfo.MediumOfInstruction = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.sectioninfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.sectioninfo.SIF_Metadata = v
      }
    case "SchoolCourseInfoOverride":
    if v, ok:= SchoolCourseInfoOverrideTypePointer(value); ok {
      n.sectioninfo.SchoolCourseInfoOverride = v
      }
    case "SchoolCourseInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.SchoolCourseInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.SchoolYear = ((*SchoolYearType)(v))
      }
    case "SectionCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.SectionCode = ((*String)(v))
      }
    case "SummerSchool":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.SummerSchool = ((*String)(v))
      }
    case "TermInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sectioninfo.TermInfoRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SectionInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) CountForAttendance() *String {
    if s.sectioninfo.CountForAttendance == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.CountForAttendance = ((*String)(v))
      }
      }
      return s.sectioninfo.CountForAttendance
    }
// Returns whether the element value for CountForAttendance is nil in the container SectionInfo.
  func (s *SectionInfo) CountForAttendance_IsNil() bool {
    return s.sectioninfo.CountForAttendance == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) CourseSectionCode() *String {
    if s.sectioninfo.CourseSectionCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.CourseSectionCode = ((*String)(v))
      }
      }
      return s.sectioninfo.CourseSectionCode
    }
// Returns whether the element value for CourseSectionCode is nil in the container SectionInfo.
  func (s *SectionInfo) CourseSectionCode_IsNil() bool {
    return s.sectioninfo.CourseSectionCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) Description() *String {
    if s.sectioninfo.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.Description = ((*String)(v))
      }
      }
      return s.sectioninfo.Description
    }
// Returns whether the element value for Description is nil in the container SectionInfo.
  func (s *SectionInfo) Description_IsNil() bool {
    return s.sectioninfo.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) LanguageOfInstruction() *LanguageOfInstructionType {
    if s.sectioninfo.LanguageOfInstruction == nil {
     if v, ok:= LanguageOfInstructionTypePointer(LanguageOfInstructionType{}); ok {
      s.sectioninfo.LanguageOfInstruction = v
      }
      }
      return s.sectioninfo.LanguageOfInstruction
    }
// Returns whether the element value for LanguageOfInstruction is nil in the container SectionInfo.
  func (s *SectionInfo) LanguageOfInstruction_IsNil() bool {
    return s.sectioninfo.LanguageOfInstruction == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) LocalCodeList() *LocalCodeListType {
    if s.sectioninfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.sectioninfo.LocalCodeList = v
      }
      }
      return s.sectioninfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container SectionInfo.
  func (s *SectionInfo) LocalCodeList_IsNil() bool {
    return s.sectioninfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) LocalId() *LocalIdType {
    if s.sectioninfo.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.sectioninfo.LocalId
    }
// Returns whether the element value for LocalId is nil in the container SectionInfo.
  func (s *SectionInfo) LocalId_IsNil() bool {
    return s.sectioninfo.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) LocationOfInstruction() *LocationOfInstructionType {
    if s.sectioninfo.LocationOfInstruction == nil {
     if v, ok:= LocationOfInstructionTypePointer(LocationOfInstructionType{}); ok {
      s.sectioninfo.LocationOfInstruction = v
      }
      }
      return s.sectioninfo.LocationOfInstruction
    }
// Returns whether the element value for LocationOfInstruction is nil in the container SectionInfo.
  func (s *SectionInfo) LocationOfInstruction_IsNil() bool {
    return s.sectioninfo.LocationOfInstruction == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) MediumOfInstruction() *MediumOfInstructionType {
    if s.sectioninfo.MediumOfInstruction == nil {
     if v, ok:= MediumOfInstructionTypePointer(MediumOfInstructionType{}); ok {
      s.sectioninfo.MediumOfInstruction = v
      }
      }
      return s.sectioninfo.MediumOfInstruction
    }
// Returns whether the element value for MediumOfInstruction is nil in the container SectionInfo.
  func (s *SectionInfo) MediumOfInstruction_IsNil() bool {
    return s.sectioninfo.MediumOfInstruction == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) RefId() *RefIdType {
    if s.sectioninfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.sectioninfo.RefId
    }
// Returns whether the element value for RefId is nil in the container SectionInfo.
  func (s *SectionInfo) RefId_IsNil() bool {
    return s.sectioninfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.sectioninfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.sectioninfo.SIF_ExtendedElements = v
      }
      }
      return s.sectioninfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container SectionInfo.
  func (s *SectionInfo) SIF_ExtendedElements_IsNil() bool {
    return s.sectioninfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) SIF_Metadata() *SIF_MetadataType {
    if s.sectioninfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.sectioninfo.SIF_Metadata = v
      }
      }
      return s.sectioninfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container SectionInfo.
  func (s *SectionInfo) SIF_Metadata_IsNil() bool {
    return s.sectioninfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) SchoolCourseInfoOverride() *SchoolCourseInfoOverrideType {
    if s.sectioninfo.SchoolCourseInfoOverride == nil {
     if v, ok:= SchoolCourseInfoOverrideTypePointer(SchoolCourseInfoOverrideType{}); ok {
      s.sectioninfo.SchoolCourseInfoOverride = v
      }
      }
      return s.sectioninfo.SchoolCourseInfoOverride
    }
// Returns whether the element value for SchoolCourseInfoOverride is nil in the container SectionInfo.
  func (s *SectionInfo) SchoolCourseInfoOverride_IsNil() bool {
    return s.sectioninfo.SchoolCourseInfoOverride == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) SchoolCourseInfoRefId() *String {
    if s.sectioninfo.SchoolCourseInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.SchoolCourseInfoRefId = ((*String)(v))
      }
      }
      return s.sectioninfo.SchoolCourseInfoRefId
    }
// Returns whether the element value for SchoolCourseInfoRefId is nil in the container SectionInfo.
  func (s *SectionInfo) SchoolCourseInfoRefId_IsNil() bool {
    return s.sectioninfo.SchoolCourseInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) SchoolYear() *SchoolYearType {
    if s.sectioninfo.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.sectioninfo.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container SectionInfo.
  func (s *SectionInfo) SchoolYear_IsNil() bool {
    return s.sectioninfo.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) SectionCode() *String {
    if s.sectioninfo.SectionCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.SectionCode = ((*String)(v))
      }
      }
      return s.sectioninfo.SectionCode
    }
// Returns whether the element value for SectionCode is nil in the container SectionInfo.
  func (s *SectionInfo) SectionCode_IsNil() bool {
    return s.sectioninfo.SectionCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) SummerSchool() *String {
    if s.sectioninfo.SummerSchool == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.SummerSchool = ((*String)(v))
      }
      }
      return s.sectioninfo.SummerSchool
    }
// Returns whether the element value for SummerSchool is nil in the container SectionInfo.
  func (s *SectionInfo) SummerSchool_IsNil() bool {
    return s.sectioninfo.SummerSchool == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SectionInfo) TermInfoRefId() *String {
    if s.sectioninfo.TermInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sectioninfo.TermInfoRefId = ((*String)(v))
      }
      }
      return s.sectioninfo.TermInfoRefId
    }
// Returns whether the element value for TermInfoRefId is nil in the container SectionInfo.
  func (s *SectionInfo) TermInfoRefId_IsNil() bool {
    return s.sectioninfo.TermInfoRefId == nil
    }

// Set the value of a property to nil
func (n *SessionInfo) Unset(key string) *SessionInfo {
        switch key {
  case "DayId":
   n.sessioninfo.DayId = nil
  case "FinishTime":
   n.sessioninfo.FinishTime = nil
  case "LocalCodeList":
   n.sessioninfo.LocalCodeList = nil
  case "LocalId":
   n.sessioninfo.LocalId = nil
  case "PeriodId":
   n.sessioninfo.PeriodId = nil
  case "RefId":
   n.sessioninfo.RefId = nil
  case "RollMarked":
   n.sessioninfo.RollMarked = nil
  case "RoomNumber":
   n.sessioninfo.RoomNumber = nil
  case "SIF_ExtendedElements":
   n.sessioninfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.sessioninfo.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.sessioninfo.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.sessioninfo.SchoolLocalId = nil
  case "SchoolYear":
   n.sessioninfo.SchoolYear = nil
  case "SessionDate":
   n.sessioninfo.SessionDate = nil
  case "StaffPersonalLocalId":
   n.sessioninfo.StaffPersonalLocalId = nil
  case "StartTime":
   n.sessioninfo.StartTime = nil
  case "TeachingGroupLocalId":
   n.sessioninfo.TeachingGroupLocalId = nil
  case "TimeTableCellRefId":
   n.sessioninfo.TimeTableCellRefId = nil
  case "TimeTableSubjectLocalId":
   n.sessioninfo.TimeTableSubjectLocalId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SessionInfo")
        }
        return n
}

// Set a sequence of properties
func (n *SessionInfo) SetProperties(props ...Prop) *SessionInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SessionInfo) SetProperty(key string, value interface{}) *SessionInfo {
        if n == nil {
                n, _ = SessionInfoPointer(SessionInfo{})
        }
        switch key {
    case "DayId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.DayId = ((*LocalIdType)(v))
      }
    case "FinishTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.FinishTime = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.sessioninfo.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.LocalId = ((*LocalIdType)(v))
      }
    case "PeriodId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.PeriodId = ((*LocalIdType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.RefId = ((*RefIdType)(v))
      }
    case "RollMarked":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.RollMarked = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "RoomNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.RoomNumber = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.sessioninfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.sessioninfo.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.SchoolYear = ((*SchoolYearType)(v))
      }
    case "SessionDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.SessionDate = ((*String)(v))
      }
    case "StaffPersonalLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.StaffPersonalLocalId = ((*LocalIdType)(v))
      }
    case "StartTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.StartTime = ((*String)(v))
      }
    case "TeachingGroupLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.TeachingGroupLocalId = ((*LocalIdType)(v))
      }
    case "TimeTableCellRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.TimeTableCellRefId = ((*String)(v))
      }
    case "TimeTableSubjectLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sessioninfo.TimeTableSubjectLocalId = ((*LocalIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SessionInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) DayId() *LocalIdType {
    if s.sessioninfo.DayId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.DayId = ((*LocalIdType)(v))
      }
      }
      return s.sessioninfo.DayId
    }
// Returns whether the element value for DayId is nil in the container SessionInfo.
  func (s *SessionInfo) DayId_IsNil() bool {
    return s.sessioninfo.DayId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) FinishTime() *String {
    if s.sessioninfo.FinishTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.FinishTime = ((*String)(v))
      }
      }
      return s.sessioninfo.FinishTime
    }
// Returns whether the element value for FinishTime is nil in the container SessionInfo.
  func (s *SessionInfo) FinishTime_IsNil() bool {
    return s.sessioninfo.FinishTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) LocalCodeList() *LocalCodeListType {
    if s.sessioninfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.sessioninfo.LocalCodeList = v
      }
      }
      return s.sessioninfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container SessionInfo.
  func (s *SessionInfo) LocalCodeList_IsNil() bool {
    return s.sessioninfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) LocalId() *LocalIdType {
    if s.sessioninfo.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.sessioninfo.LocalId
    }
// Returns whether the element value for LocalId is nil in the container SessionInfo.
  func (s *SessionInfo) LocalId_IsNil() bool {
    return s.sessioninfo.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) PeriodId() *LocalIdType {
    if s.sessioninfo.PeriodId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.PeriodId = ((*LocalIdType)(v))
      }
      }
      return s.sessioninfo.PeriodId
    }
// Returns whether the element value for PeriodId is nil in the container SessionInfo.
  func (s *SessionInfo) PeriodId_IsNil() bool {
    return s.sessioninfo.PeriodId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) RefId() *RefIdType {
    if s.sessioninfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.sessioninfo.RefId
    }
// Returns whether the element value for RefId is nil in the container SessionInfo.
  func (s *SessionInfo) RefId_IsNil() bool {
    return s.sessioninfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) RollMarked() *AUCodeSetsYesOrNoCategoryType {
    if s.sessioninfo.RollMarked == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.RollMarked = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.sessioninfo.RollMarked
    }
// Returns whether the element value for RollMarked is nil in the container SessionInfo.
  func (s *SessionInfo) RollMarked_IsNil() bool {
    return s.sessioninfo.RollMarked == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) RoomNumber() *String {
    if s.sessioninfo.RoomNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.RoomNumber = ((*String)(v))
      }
      }
      return s.sessioninfo.RoomNumber
    }
// Returns whether the element value for RoomNumber is nil in the container SessionInfo.
  func (s *SessionInfo) RoomNumber_IsNil() bool {
    return s.sessioninfo.RoomNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.sessioninfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.sessioninfo.SIF_ExtendedElements = v
      }
      }
      return s.sessioninfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container SessionInfo.
  func (s *SessionInfo) SIF_ExtendedElements_IsNil() bool {
    return s.sessioninfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) SIF_Metadata() *SIF_MetadataType {
    if s.sessioninfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.sessioninfo.SIF_Metadata = v
      }
      }
      return s.sessioninfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container SessionInfo.
  func (s *SessionInfo) SIF_Metadata_IsNil() bool {
    return s.sessioninfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) SchoolInfoRefId() *String {
    if s.sessioninfo.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.sessioninfo.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container SessionInfo.
  func (s *SessionInfo) SchoolInfoRefId_IsNil() bool {
    return s.sessioninfo.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) SchoolLocalId() *LocalIdType {
    if s.sessioninfo.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.sessioninfo.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container SessionInfo.
  func (s *SessionInfo) SchoolLocalId_IsNil() bool {
    return s.sessioninfo.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) SchoolYear() *SchoolYearType {
    if s.sessioninfo.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.sessioninfo.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container SessionInfo.
  func (s *SessionInfo) SchoolYear_IsNil() bool {
    return s.sessioninfo.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) SessionDate() *String {
    if s.sessioninfo.SessionDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.SessionDate = ((*String)(v))
      }
      }
      return s.sessioninfo.SessionDate
    }
// Returns whether the element value for SessionDate is nil in the container SessionInfo.
  func (s *SessionInfo) SessionDate_IsNil() bool {
    return s.sessioninfo.SessionDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) StaffPersonalLocalId() *LocalIdType {
    if s.sessioninfo.StaffPersonalLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.StaffPersonalLocalId = ((*LocalIdType)(v))
      }
      }
      return s.sessioninfo.StaffPersonalLocalId
    }
// Returns whether the element value for StaffPersonalLocalId is nil in the container SessionInfo.
  func (s *SessionInfo) StaffPersonalLocalId_IsNil() bool {
    return s.sessioninfo.StaffPersonalLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) StartTime() *String {
    if s.sessioninfo.StartTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.StartTime = ((*String)(v))
      }
      }
      return s.sessioninfo.StartTime
    }
// Returns whether the element value for StartTime is nil in the container SessionInfo.
  func (s *SessionInfo) StartTime_IsNil() bool {
    return s.sessioninfo.StartTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) TeachingGroupLocalId() *LocalIdType {
    if s.sessioninfo.TeachingGroupLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.TeachingGroupLocalId = ((*LocalIdType)(v))
      }
      }
      return s.sessioninfo.TeachingGroupLocalId
    }
// Returns whether the element value for TeachingGroupLocalId is nil in the container SessionInfo.
  func (s *SessionInfo) TeachingGroupLocalId_IsNil() bool {
    return s.sessioninfo.TeachingGroupLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) TimeTableCellRefId() *String {
    if s.sessioninfo.TimeTableCellRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.TimeTableCellRefId = ((*String)(v))
      }
      }
      return s.sessioninfo.TimeTableCellRefId
    }
// Returns whether the element value for TimeTableCellRefId is nil in the container SessionInfo.
  func (s *SessionInfo) TimeTableCellRefId_IsNil() bool {
    return s.sessioninfo.TimeTableCellRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SessionInfo) TimeTableSubjectLocalId() *LocalIdType {
    if s.sessioninfo.TimeTableSubjectLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sessioninfo.TimeTableSubjectLocalId = ((*LocalIdType)(v))
      }
      }
      return s.sessioninfo.TimeTableSubjectLocalId
    }
// Returns whether the element value for TimeTableSubjectLocalId is nil in the container SessionInfo.
  func (s *SessionInfo) TimeTableSubjectLocalId_IsNil() bool {
    return s.sessioninfo.TimeTableSubjectLocalId == nil
    }

// Set the value of a property to nil
func (n *SettingLocationType) Unset(key string) *SettingLocationType {
        switch key {
  case "SettingLocationName":
   n.settinglocationtype.SettingLocationName = nil
  case "SettingLocationObjectTypeName":
   n.settinglocationtype.SettingLocationObjectTypeName = nil
  case "SettingLocationRefId":
   n.settinglocationtype.SettingLocationRefId = nil
  case "SettingLocationType":
   n.settinglocationtype.SettingLocationType = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SettingLocationType")
        }
        return n
}

// Set a sequence of properties
func (n *SettingLocationType) SetProperties(props ...Prop) *SettingLocationType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SettingLocationType) SetProperty(key string, value interface{}) *SettingLocationType {
        if n == nil {
                n, _ = SettingLocationTypePointer(SettingLocationType{})
        }
        switch key {
    case "SettingLocationName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.settinglocationtype.SettingLocationName = ((*String)(v))
      }
    case "SettingLocationObjectTypeName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.settinglocationtype.SettingLocationObjectTypeName = ((*String)(v))
      }
    case "SettingLocationRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.settinglocationtype.SettingLocationRefId = ((*String)(v))
      }
    case "SettingLocationType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.settinglocationtype.SettingLocationType = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SettingLocationType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SettingLocationType) SettingLocationName() *String {
    if s.settinglocationtype.SettingLocationName == nil {
    if v, ok:= StringPointer(""); ok {
      s.settinglocationtype.SettingLocationName = ((*String)(v))
      }
      }
      return s.settinglocationtype.SettingLocationName
    }
// Returns whether the element value for SettingLocationName is nil in the container SettingLocationType.
  func (s *SettingLocationType) SettingLocationName_IsNil() bool {
    return s.settinglocationtype.SettingLocationName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SettingLocationType) SettingLocationObjectTypeName() *String {
    if s.settinglocationtype.SettingLocationObjectTypeName == nil {
    if v, ok:= StringPointer(""); ok {
      s.settinglocationtype.SettingLocationObjectTypeName = ((*String)(v))
      }
      }
      return s.settinglocationtype.SettingLocationObjectTypeName
    }
// Returns whether the element value for SettingLocationObjectTypeName is nil in the container SettingLocationType.
  func (s *SettingLocationType) SettingLocationObjectTypeName_IsNil() bool {
    return s.settinglocationtype.SettingLocationObjectTypeName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SettingLocationType) SettingLocationRefId() *String {
    if s.settinglocationtype.SettingLocationRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.settinglocationtype.SettingLocationRefId = ((*String)(v))
      }
      }
      return s.settinglocationtype.SettingLocationRefId
    }
// Returns whether the element value for SettingLocationRefId is nil in the container SettingLocationType.
  func (s *SettingLocationType) SettingLocationRefId_IsNil() bool {
    return s.settinglocationtype.SettingLocationRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SettingLocationType) SettingLocationType() *String {
    if s.settinglocationtype.SettingLocationType == nil {
    if v, ok:= StringPointer(""); ok {
      s.settinglocationtype.SettingLocationType = ((*String)(v))
      }
      }
      return s.settinglocationtype.SettingLocationType
    }
// Returns whether the element value for SettingLocationType is nil in the container SettingLocationType.
  func (s *SettingLocationType) SettingLocationType_IsNil() bool {
    return s.settinglocationtype.SettingLocationType == nil
    }

// Set the value of a property to nil
func (n *ShareWithType) Unset(key string) *ShareWithType {
        switch key {
  case "PermissionToOnShare":
   n.sharewithtype.PermissionToOnShare = nil
  case "ShareWithComments":
   n.sharewithtype.ShareWithComments = nil
  case "ShareWithLocalId":
   n.sharewithtype.ShareWithLocalId = nil
  case "ShareWithName":
   n.sharewithtype.ShareWithName = nil
  case "ShareWithObjectTypeName":
   n.sharewithtype.ShareWithObjectTypeName = nil
  case "ShareWithParty":
   n.sharewithtype.ShareWithParty = nil
  case "ShareWithPurpose":
   n.sharewithtype.ShareWithPurpose = nil
  case "ShareWithRefId":
   n.sharewithtype.ShareWithRefId = nil
  case "ShareWithRelationship":
   n.sharewithtype.ShareWithRelationship = nil
  case "ShareWithRole":
   n.sharewithtype.ShareWithRole = nil
  case "ShareWithURL":
   n.sharewithtype.ShareWithURL = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ShareWithType")
        }
        return n
}

// Set a sequence of properties
func (n *ShareWithType) SetProperties(props ...Prop) *ShareWithType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ShareWithType) SetProperty(key string, value interface{}) *ShareWithType {
        if n == nil {
                n, _ = ShareWithTypePointer(ShareWithType{})
        }
        switch key {
    case "PermissionToOnShare":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.PermissionToOnShare = ((*GenericYesNoType)(v))
      }
    case "ShareWithComments":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithComments = ((*String)(v))
      }
    case "ShareWithLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithLocalId = ((*LocalIdType)(v))
      }
    case "ShareWithName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithName = ((*String)(v))
      }
    case "ShareWithObjectTypeName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithObjectTypeName = ((*String)(v))
      }
    case "ShareWithParty":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithParty = ((*String)(v))
      }
    case "ShareWithPurpose":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithPurpose = ((*String)(v))
      }
    case "ShareWithRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithRefId = ((*String)(v))
      }
    case "ShareWithRelationship":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithRelationship = ((*String)(v))
      }
    case "ShareWithRole":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithRole = ((*String)(v))
      }
    case "ShareWithURL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sharewithtype.ShareWithURL = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ShareWithType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) PermissionToOnShare() *GenericYesNoType {
    if s.sharewithtype.PermissionToOnShare == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.PermissionToOnShare = ((*GenericYesNoType)(v))
      }
      }
      return s.sharewithtype.PermissionToOnShare
    }
// Returns whether the element value for PermissionToOnShare is nil in the container ShareWithType.
  func (s *ShareWithType) PermissionToOnShare_IsNil() bool {
    return s.sharewithtype.PermissionToOnShare == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithComments() *String {
    if s.sharewithtype.ShareWithComments == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithComments = ((*String)(v))
      }
      }
      return s.sharewithtype.ShareWithComments
    }
// Returns whether the element value for ShareWithComments is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithComments_IsNil() bool {
    return s.sharewithtype.ShareWithComments == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithLocalId() *LocalIdType {
    if s.sharewithtype.ShareWithLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithLocalId = ((*LocalIdType)(v))
      }
      }
      return s.sharewithtype.ShareWithLocalId
    }
// Returns whether the element value for ShareWithLocalId is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithLocalId_IsNil() bool {
    return s.sharewithtype.ShareWithLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithName() *String {
    if s.sharewithtype.ShareWithName == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithName = ((*String)(v))
      }
      }
      return s.sharewithtype.ShareWithName
    }
// Returns whether the element value for ShareWithName is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithName_IsNil() bool {
    return s.sharewithtype.ShareWithName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithObjectTypeName() *String {
    if s.sharewithtype.ShareWithObjectTypeName == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithObjectTypeName = ((*String)(v))
      }
      }
      return s.sharewithtype.ShareWithObjectTypeName
    }
// Returns whether the element value for ShareWithObjectTypeName is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithObjectTypeName_IsNil() bool {
    return s.sharewithtype.ShareWithObjectTypeName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithParty() *String {
    if s.sharewithtype.ShareWithParty == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithParty = ((*String)(v))
      }
      }
      return s.sharewithtype.ShareWithParty
    }
// Returns whether the element value for ShareWithParty is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithParty_IsNil() bool {
    return s.sharewithtype.ShareWithParty == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithPurpose() *String {
    if s.sharewithtype.ShareWithPurpose == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithPurpose = ((*String)(v))
      }
      }
      return s.sharewithtype.ShareWithPurpose
    }
// Returns whether the element value for ShareWithPurpose is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithPurpose_IsNil() bool {
    return s.sharewithtype.ShareWithPurpose == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithRefId() *String {
    if s.sharewithtype.ShareWithRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithRefId = ((*String)(v))
      }
      }
      return s.sharewithtype.ShareWithRefId
    }
// Returns whether the element value for ShareWithRefId is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithRefId_IsNil() bool {
    return s.sharewithtype.ShareWithRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithRelationship() *String {
    if s.sharewithtype.ShareWithRelationship == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithRelationship = ((*String)(v))
      }
      }
      return s.sharewithtype.ShareWithRelationship
    }
// Returns whether the element value for ShareWithRelationship is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithRelationship_IsNil() bool {
    return s.sharewithtype.ShareWithRelationship == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithRole() *String {
    if s.sharewithtype.ShareWithRole == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithRole = ((*String)(v))
      }
      }
      return s.sharewithtype.ShareWithRole
    }
// Returns whether the element value for ShareWithRole is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithRole_IsNil() bool {
    return s.sharewithtype.ShareWithRole == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ShareWithType) ShareWithURL() *String {
    if s.sharewithtype.ShareWithURL == nil {
    if v, ok:= StringPointer(""); ok {
      s.sharewithtype.ShareWithURL = ((*String)(v))
      }
      }
      return s.sharewithtype.ShareWithURL
    }
// Returns whether the element value for ShareWithURL is nil in the container ShareWithType.
  func (s *ShareWithType) ShareWithURL_IsNil() bool {
    return s.sharewithtype.ShareWithURL == nil
    }

// Set the value of a property to nil
func (n *SignatoryType) Unset(key string) *SignatoryType {
        switch key {
  case "Date":
   n.signatorytype.Date = nil
  case "Name":
   n.signatorytype.Name = nil
  case "Organisation":
   n.signatorytype.Organisation = nil
  case "Role":
   n.signatorytype.Role = nil
  case "Signature":
   n.signatorytype.Signature = nil
  case "SignatureImageType":
   n.signatorytype.SignatureImageType = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SignatoryType")
        }
        return n
}

// Set a sequence of properties
func (n *SignatoryType) SetProperties(props ...Prop) *SignatoryType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SignatoryType) SetProperty(key string, value interface{}) *SignatoryType {
        if n == nil {
                n, _ = SignatoryTypePointer(SignatoryType{})
        }
        switch key {
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.signatorytype.Date = ((*String)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.signatorytype.Name = ((*String)(v))
      }
    case "Organisation":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.signatorytype.Organisation = ((*String)(v))
      }
    case "Role":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.signatorytype.Role = ((*String)(v))
      }
    case "Signature":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.signatorytype.Signature = ((*URIOrBinaryType)(v))
      }
    case "SignatureImageType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsPictureSourceType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsPictureSourceType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.signatorytype.SignatureImageType = ((*AUCodeSetsPictureSourceType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SignatoryType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SignatoryType) Date() *String {
    if s.signatorytype.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.signatorytype.Date = ((*String)(v))
      }
      }
      return s.signatorytype.Date
    }
// Returns whether the element value for Date is nil in the container SignatoryType.
  func (s *SignatoryType) Date_IsNil() bool {
    return s.signatorytype.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SignatoryType) Name() *String {
    if s.signatorytype.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.signatorytype.Name = ((*String)(v))
      }
      }
      return s.signatorytype.Name
    }
// Returns whether the element value for Name is nil in the container SignatoryType.
  func (s *SignatoryType) Name_IsNil() bool {
    return s.signatorytype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SignatoryType) Organisation() *String {
    if s.signatorytype.Organisation == nil {
    if v, ok:= StringPointer(""); ok {
      s.signatorytype.Organisation = ((*String)(v))
      }
      }
      return s.signatorytype.Organisation
    }
// Returns whether the element value for Organisation is nil in the container SignatoryType.
  func (s *SignatoryType) Organisation_IsNil() bool {
    return s.signatorytype.Organisation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SignatoryType) Role() *String {
    if s.signatorytype.Role == nil {
    if v, ok:= StringPointer(""); ok {
      s.signatorytype.Role = ((*String)(v))
      }
      }
      return s.signatorytype.Role
    }
// Returns whether the element value for Role is nil in the container SignatoryType.
  func (s *SignatoryType) Role_IsNil() bool {
    return s.signatorytype.Role == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SignatoryType) Signature() *URIOrBinaryType {
    if s.signatorytype.Signature == nil {
    if v, ok:= StringPointer(""); ok {
      s.signatorytype.Signature = ((*URIOrBinaryType)(v))
      }
      }
      return s.signatorytype.Signature
    }
// Returns whether the element value for Signature is nil in the container SignatoryType.
  func (s *SignatoryType) Signature_IsNil() bool {
    return s.signatorytype.Signature == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SignatoryType) SignatureImageType() *AUCodeSetsPictureSourceType {
    if s.signatorytype.SignatureImageType == nil {
    if v, ok:= StringPointer(""); ok {
      s.signatorytype.SignatureImageType = ((*AUCodeSetsPictureSourceType)(v))
      }
      }
      return s.signatorytype.SignatureImageType
    }
// Returns whether the element value for SignatureImageType is nil in the container SignatoryType.
  func (s *SignatoryType) SignatureImageType_IsNil() bool {
    return s.signatorytype.SignatureImageType == nil
    }

// Set the value of a property to nil
func (n *SoftwareRequirementType) Unset(key string) *SoftwareRequirementType {
        switch key {
  case "OS":
   n.softwarerequirementtype.OS = nil
  case "SoftwareTitle":
   n.softwarerequirementtype.SoftwareTitle = nil
  case "Vendor":
   n.softwarerequirementtype.Vendor = nil
  case "Version":
   n.softwarerequirementtype.Version = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SoftwareRequirementType")
        }
        return n
}

// Set a sequence of properties
func (n *SoftwareRequirementType) SetProperties(props ...Prop) *SoftwareRequirementType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SoftwareRequirementType) SetProperty(key string, value interface{}) *SoftwareRequirementType {
        if n == nil {
                n, _ = SoftwareRequirementTypePointer(SoftwareRequirementType{})
        }
        switch key {
    case "OS":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.softwarerequirementtype.OS = ((*String)(v))
      }
    case "SoftwareTitle":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.softwarerequirementtype.SoftwareTitle = ((*String)(v))
      }
    case "Vendor":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.softwarerequirementtype.Vendor = ((*String)(v))
      }
    case "Version":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.softwarerequirementtype.Version = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SoftwareRequirementType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SoftwareRequirementType) OS() *String {
    if s.softwarerequirementtype.OS == nil {
    if v, ok:= StringPointer(""); ok {
      s.softwarerequirementtype.OS = ((*String)(v))
      }
      }
      return s.softwarerequirementtype.OS
    }
// Returns whether the element value for OS is nil in the container SoftwareRequirementType.
  func (s *SoftwareRequirementType) OS_IsNil() bool {
    return s.softwarerequirementtype.OS == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SoftwareRequirementType) SoftwareTitle() *String {
    if s.softwarerequirementtype.SoftwareTitle == nil {
    if v, ok:= StringPointer(""); ok {
      s.softwarerequirementtype.SoftwareTitle = ((*String)(v))
      }
      }
      return s.softwarerequirementtype.SoftwareTitle
    }
// Returns whether the element value for SoftwareTitle is nil in the container SoftwareRequirementType.
  func (s *SoftwareRequirementType) SoftwareTitle_IsNil() bool {
    return s.softwarerequirementtype.SoftwareTitle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SoftwareRequirementType) Vendor() *String {
    if s.softwarerequirementtype.Vendor == nil {
    if v, ok:= StringPointer(""); ok {
      s.softwarerequirementtype.Vendor = ((*String)(v))
      }
      }
      return s.softwarerequirementtype.Vendor
    }
// Returns whether the element value for Vendor is nil in the container SoftwareRequirementType.
  func (s *SoftwareRequirementType) Vendor_IsNil() bool {
    return s.softwarerequirementtype.Vendor == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SoftwareRequirementType) Version() *String {
    if s.softwarerequirementtype.Version == nil {
    if v, ok:= StringPointer(""); ok {
      s.softwarerequirementtype.Version = ((*String)(v))
      }
      }
      return s.softwarerequirementtype.Version
    }
// Returns whether the element value for Version is nil in the container SoftwareRequirementType.
  func (s *SoftwareRequirementType) Version_IsNil() bool {
    return s.softwarerequirementtype.Version == nil
    }

// Set the value of a property to nil
func (n *SoftwareVendorInfoContainerType) Unset(key string) *SoftwareVendorInfoContainerType {
        switch key {
  case "SoftwareProduct":
   n.softwarevendorinfocontainertype.SoftwareProduct = nil
  case "SoftwareVersion":
   n.softwarevendorinfocontainertype.SoftwareVersion = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SoftwareVendorInfoContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *SoftwareVendorInfoContainerType) SetProperties(props ...Prop) *SoftwareVendorInfoContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SoftwareVendorInfoContainerType) SetProperty(key string, value interface{}) *SoftwareVendorInfoContainerType {
        if n == nil {
                n, _ = SoftwareVendorInfoContainerTypePointer(SoftwareVendorInfoContainerType{})
        }
        switch key {
    case "SoftwareProduct":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.softwarevendorinfocontainertype.SoftwareProduct = ((*String)(v))
      }
    case "SoftwareVersion":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.softwarevendorinfocontainertype.SoftwareVersion = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SoftwareVendorInfoContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SoftwareVendorInfoContainerType) SoftwareProduct() *String {
    if s.softwarevendorinfocontainertype.SoftwareProduct == nil {
    if v, ok:= StringPointer(""); ok {
      s.softwarevendorinfocontainertype.SoftwareProduct = ((*String)(v))
      }
      }
      return s.softwarevendorinfocontainertype.SoftwareProduct
    }
// Returns whether the element value for SoftwareProduct is nil in the container SoftwareVendorInfoContainerType.
  func (s *SoftwareVendorInfoContainerType) SoftwareProduct_IsNil() bool {
    return s.softwarevendorinfocontainertype.SoftwareProduct == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SoftwareVendorInfoContainerType) SoftwareVersion() *String {
    if s.softwarevendorinfocontainertype.SoftwareVersion == nil {
    if v, ok:= StringPointer(""); ok {
      s.softwarevendorinfocontainertype.SoftwareVersion = ((*String)(v))
      }
      }
      return s.softwarevendorinfocontainertype.SoftwareVersion
    }
// Returns whether the element value for SoftwareVersion is nil in the container SoftwareVendorInfoContainerType.
  func (s *SoftwareVendorInfoContainerType) SoftwareVersion_IsNil() bool {
    return s.softwarevendorinfocontainertype.SoftwareVersion == nil
    }

// Set the value of a property to nil
func (n *SourceObjectsType_SourceObject) Unset(key string) *SourceObjectsType_SourceObject {
        switch key {
  case "SIF_RefObject":
   n.sourceobjectstype_sourceobject.SIF_RefObject = nil
  case "Value":
   n.sourceobjectstype_sourceobject.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SourceObjectsType_SourceObject")
        }
        return n
}

// Set a sequence of properties
func (n *SourceObjectsType_SourceObject) SetProperties(props ...Prop) *SourceObjectsType_SourceObject {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SourceObjectsType_SourceObject) SetProperty(key string, value interface{}) *SourceObjectsType_SourceObject {
        if n == nil {
                n, _ = SourceObjectsType_SourceObjectPointer(SourceObjectsType_SourceObject{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sourceobjectstype_sourceobject.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.sourceobjectstype_sourceobject.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SourceObjectsType_SourceObject")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SourceObjectsType_SourceObject) SIF_RefObject() *String {
    if s.sourceobjectstype_sourceobject.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.sourceobjectstype_sourceobject.SIF_RefObject = ((*String)(v))
      }
      }
      return s.sourceobjectstype_sourceobject.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container SourceObjectsType_SourceObject.
  func (s *SourceObjectsType_SourceObject) SIF_RefObject_IsNil() bool {
    return s.sourceobjectstype_sourceobject.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SourceObjectsType_SourceObject) Value() *String {
    if s.sourceobjectstype_sourceobject.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.sourceobjectstype_sourceobject.Value = ((*String)(v))
      }
      }
      return s.sourceobjectstype_sourceobject.Value
    }
// Returns whether the element value for Value is nil in the container SourceObjectsType_SourceObject.
  func (s *SourceObjectsType_SourceObject) Value_IsNil() bool {
    return s.sourceobjectstype_sourceobject.Value == nil
    }

// Set the value of a property to nil
func (n *SpanGapType) Unset(key string) *SpanGapType {
        switch key {
  case "EndDateTime":
   n.spangaptype.EndDateTime = nil
  case "StartDateTime":
   n.spangaptype.StartDateTime = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SpanGapType")
        }
        return n
}

// Set a sequence of properties
func (n *SpanGapType) SetProperties(props ...Prop) *SpanGapType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SpanGapType) SetProperty(key string, value interface{}) *SpanGapType {
        if n == nil {
                n, _ = SpanGapTypePointer(SpanGapType{})
        }
        switch key {
    case "EndDateTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.spangaptype.EndDateTime = ((*String)(v))
      }
    case "StartDateTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.spangaptype.StartDateTime = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SpanGapType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SpanGapType) EndDateTime() *String {
    if s.spangaptype.EndDateTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.spangaptype.EndDateTime = ((*String)(v))
      }
      }
      return s.spangaptype.EndDateTime
    }
// Returns whether the element value for EndDateTime is nil in the container SpanGapType.
  func (s *SpanGapType) EndDateTime_IsNil() bool {
    return s.spangaptype.EndDateTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SpanGapType) StartDateTime() *String {
    if s.spangaptype.StartDateTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.spangaptype.StartDateTime = ((*String)(v))
      }
      }
      return s.spangaptype.StartDateTime
    }
// Returns whether the element value for StartDateTime is nil in the container SpanGapType.
  func (s *SpanGapType) StartDateTime_IsNil() bool {
    return s.spangaptype.StartDateTime == nil
    }

// Set the value of a property to nil
func (n *StaffActivityExtensionType) Unset(key string) *StaffActivityExtensionType {
        switch key {
  case "Code":
   n.staffactivityextensiontype.Code = nil
  case "OtherCodeList":
   n.staffactivityextensiontype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffActivityExtensionType")
        }
        return n
}

// Set a sequence of properties
func (n *StaffActivityExtensionType) SetProperties(props ...Prop) *StaffActivityExtensionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StaffActivityExtensionType) SetProperty(key string, value interface{}) *StaffActivityExtensionType {
        if n == nil {
                n, _ = StaffActivityExtensionTypePointer(StaffActivityExtensionType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsStaffActivityType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsStaffActivityType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.staffactivityextensiontype.Code = ((*AUCodeSetsStaffActivityType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.staffactivityextensiontype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffActivityExtensionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffActivityExtensionType) Code() *AUCodeSetsStaffActivityType {
    if s.staffactivityextensiontype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffactivityextensiontype.Code = ((*AUCodeSetsStaffActivityType)(v))
      }
      }
      return s.staffactivityextensiontype.Code
    }
// Returns whether the element value for Code is nil in the container StaffActivityExtensionType.
  func (s *StaffActivityExtensionType) Code_IsNil() bool {
    return s.staffactivityextensiontype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffActivityExtensionType) OtherCodeList() *OtherCodeListType {
    if s.staffactivityextensiontype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.staffactivityextensiontype.OtherCodeList = v
      }
      }
      return s.staffactivityextensiontype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container StaffActivityExtensionType.
  func (s *StaffActivityExtensionType) OtherCodeList_IsNil() bool {
    return s.staffactivityextensiontype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *StaffAssignment) Unset(key string) *StaffAssignment {
        switch key {
  case "AvailableForTimetable":
   n.staffassignment.AvailableForTimetable = nil
  case "CalendarSummaryList":
   n.staffassignment.CalendarSummaryList = nil
  case "CasualReliefTeacher":
   n.staffassignment.CasualReliefTeacher = nil
  case "Description":
   n.staffassignment.Description = nil
  case "EmploymentStatus":
   n.staffassignment.EmploymentStatus = nil
  case "Homegroup":
   n.staffassignment.Homegroup = nil
  case "House":
   n.staffassignment.House = nil
  case "JobEndDate":
   n.staffassignment.JobEndDate = nil
  case "JobFTE":
   n.staffassignment.JobFTE = nil
  case "JobFunction":
   n.staffassignment.JobFunction = nil
  case "JobStartDate":
   n.staffassignment.JobStartDate = nil
  case "LocalCodeList":
   n.staffassignment.LocalCodeList = nil
  case "PreviousSchoolName":
   n.staffassignment.PreviousSchoolName = nil
  case "PrimaryAssignment":
   n.staffassignment.PrimaryAssignment = nil
  case "RefId":
   n.staffassignment.RefId = nil
  case "SIF_ExtendedElements":
   n.staffassignment.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.staffassignment.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.staffassignment.SchoolInfoRefId = nil
  case "SchoolYear":
   n.staffassignment.SchoolYear = nil
  case "StaffActivity":
   n.staffassignment.StaffActivity = nil
  case "StaffPersonalRefId":
   n.staffassignment.StaffPersonalRefId = nil
  case "StaffSubjectList":
   n.staffassignment.StaffSubjectList = nil
  case "YearLevels":
   n.staffassignment.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffAssignment")
        }
        return n
}

// Set a sequence of properties
func (n *StaffAssignment) SetProperties(props ...Prop) *StaffAssignment {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StaffAssignment) SetProperty(key string, value interface{}) *StaffAssignment {
        if n == nil {
                n, _ = StaffAssignmentPointer(StaffAssignment{})
        }
        switch key {
    case "AvailableForTimetable":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.staffassignment.AvailableForTimetable = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "CalendarSummaryList":
    if v, ok:= CalendarSummaryListTypePointer(value); ok {
      n.staffassignment.CalendarSummaryList = v
      }
    case "CasualReliefTeacher":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.staffassignment.CasualReliefTeacher = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.Description = ((*String)(v))
      }
    case "EmploymentStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsStaffStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsStaffStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.staffassignment.EmploymentStatus = ((*AUCodeSetsStaffStatusType)(v))
      }
    case "Homegroup":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.Homegroup = ((*String)(v))
      }
    case "House":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.House = ((*String)(v))
      }
    case "JobEndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.JobEndDate = ((*String)(v))
      }
    case "JobFTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.JobFTE = ((*FTEType)(v))
      }
    case "JobFunction":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.JobFunction = ((*String)(v))
      }
    case "JobStartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.JobStartDate = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.staffassignment.LocalCodeList = v
      }
    case "PreviousSchoolName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.PreviousSchoolName = ((*String)(v))
      }
    case "PrimaryAssignment":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.staffassignment.PrimaryAssignment = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.staffassignment.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.staffassignment.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StaffActivity":
    if v, ok:= StaffActivityExtensionTypePointer(value); ok {
      n.staffassignment.StaffActivity = v
      }
    case "StaffPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignment.StaffPersonalRefId = ((*String)(v))
      }
    case "StaffSubjectList":
    if v, ok:= StaffSubjectListTypePointer(value); ok {
      n.staffassignment.StaffSubjectList = v
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.staffassignment.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffAssignment")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) AvailableForTimetable() *AUCodeSetsYesOrNoCategoryType {
    if s.staffassignment.AvailableForTimetable == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.AvailableForTimetable = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.staffassignment.AvailableForTimetable
    }
// Returns whether the element value for AvailableForTimetable is nil in the container StaffAssignment.
  func (s *StaffAssignment) AvailableForTimetable_IsNil() bool {
    return s.staffassignment.AvailableForTimetable == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) CalendarSummaryList() *CalendarSummaryListType {
    if s.staffassignment.CalendarSummaryList == nil {
     if v, ok:= CalendarSummaryListTypePointer(CalendarSummaryListType{}); ok {
      s.staffassignment.CalendarSummaryList = v
      }
      }
      return s.staffassignment.CalendarSummaryList
    }
// Returns whether the element value for CalendarSummaryList is nil in the container StaffAssignment.
  func (s *StaffAssignment) CalendarSummaryList_IsNil() bool {
    return s.staffassignment.CalendarSummaryList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) CasualReliefTeacher() *AUCodeSetsYesOrNoCategoryType {
    if s.staffassignment.CasualReliefTeacher == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.CasualReliefTeacher = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.staffassignment.CasualReliefTeacher
    }
// Returns whether the element value for CasualReliefTeacher is nil in the container StaffAssignment.
  func (s *StaffAssignment) CasualReliefTeacher_IsNil() bool {
    return s.staffassignment.CasualReliefTeacher == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) Description() *String {
    if s.staffassignment.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.Description = ((*String)(v))
      }
      }
      return s.staffassignment.Description
    }
// Returns whether the element value for Description is nil in the container StaffAssignment.
  func (s *StaffAssignment) Description_IsNil() bool {
    return s.staffassignment.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) EmploymentStatus() *AUCodeSetsStaffStatusType {
    if s.staffassignment.EmploymentStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.EmploymentStatus = ((*AUCodeSetsStaffStatusType)(v))
      }
      }
      return s.staffassignment.EmploymentStatus
    }
// Returns whether the element value for EmploymentStatus is nil in the container StaffAssignment.
  func (s *StaffAssignment) EmploymentStatus_IsNil() bool {
    return s.staffassignment.EmploymentStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) Homegroup() *String {
    if s.staffassignment.Homegroup == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.Homegroup = ((*String)(v))
      }
      }
      return s.staffassignment.Homegroup
    }
// Returns whether the element value for Homegroup is nil in the container StaffAssignment.
  func (s *StaffAssignment) Homegroup_IsNil() bool {
    return s.staffassignment.Homegroup == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) House() *String {
    if s.staffassignment.House == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.House = ((*String)(v))
      }
      }
      return s.staffassignment.House
    }
// Returns whether the element value for House is nil in the container StaffAssignment.
  func (s *StaffAssignment) House_IsNil() bool {
    return s.staffassignment.House == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) JobEndDate() *String {
    if s.staffassignment.JobEndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.JobEndDate = ((*String)(v))
      }
      }
      return s.staffassignment.JobEndDate
    }
// Returns whether the element value for JobEndDate is nil in the container StaffAssignment.
  func (s *StaffAssignment) JobEndDate_IsNil() bool {
    return s.staffassignment.JobEndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) JobFTE() *FTEType {
    if s.staffassignment.JobFTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.JobFTE = ((*FTEType)(v))
      }
      }
      return s.staffassignment.JobFTE
    }
// Returns whether the element value for JobFTE is nil in the container StaffAssignment.
  func (s *StaffAssignment) JobFTE_IsNil() bool {
    return s.staffassignment.JobFTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) JobFunction() *String {
    if s.staffassignment.JobFunction == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.JobFunction = ((*String)(v))
      }
      }
      return s.staffassignment.JobFunction
    }
// Returns whether the element value for JobFunction is nil in the container StaffAssignment.
  func (s *StaffAssignment) JobFunction_IsNil() bool {
    return s.staffassignment.JobFunction == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) JobStartDate() *String {
    if s.staffassignment.JobStartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.JobStartDate = ((*String)(v))
      }
      }
      return s.staffassignment.JobStartDate
    }
// Returns whether the element value for JobStartDate is nil in the container StaffAssignment.
  func (s *StaffAssignment) JobStartDate_IsNil() bool {
    return s.staffassignment.JobStartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) LocalCodeList() *LocalCodeListType {
    if s.staffassignment.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.staffassignment.LocalCodeList = v
      }
      }
      return s.staffassignment.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StaffAssignment.
  func (s *StaffAssignment) LocalCodeList_IsNil() bool {
    return s.staffassignment.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) PreviousSchoolName() *String {
    if s.staffassignment.PreviousSchoolName == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.PreviousSchoolName = ((*String)(v))
      }
      }
      return s.staffassignment.PreviousSchoolName
    }
// Returns whether the element value for PreviousSchoolName is nil in the container StaffAssignment.
  func (s *StaffAssignment) PreviousSchoolName_IsNil() bool {
    return s.staffassignment.PreviousSchoolName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) PrimaryAssignment() *AUCodeSetsYesOrNoCategoryType {
    if s.staffassignment.PrimaryAssignment == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.PrimaryAssignment = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.staffassignment.PrimaryAssignment
    }
// Returns whether the element value for PrimaryAssignment is nil in the container StaffAssignment.
  func (s *StaffAssignment) PrimaryAssignment_IsNil() bool {
    return s.staffassignment.PrimaryAssignment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) RefId() *RefIdType {
    if s.staffassignment.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.RefId = ((*RefIdType)(v))
      }
      }
      return s.staffassignment.RefId
    }
// Returns whether the element value for RefId is nil in the container StaffAssignment.
  func (s *StaffAssignment) RefId_IsNil() bool {
    return s.staffassignment.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.staffassignment.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.staffassignment.SIF_ExtendedElements = v
      }
      }
      return s.staffassignment.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StaffAssignment.
  func (s *StaffAssignment) SIF_ExtendedElements_IsNil() bool {
    return s.staffassignment.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) SIF_Metadata() *SIF_MetadataType {
    if s.staffassignment.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.staffassignment.SIF_Metadata = v
      }
      }
      return s.staffassignment.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StaffAssignment.
  func (s *StaffAssignment) SIF_Metadata_IsNil() bool {
    return s.staffassignment.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) SchoolInfoRefId() *String {
    if s.staffassignment.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.staffassignment.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container StaffAssignment.
  func (s *StaffAssignment) SchoolInfoRefId_IsNil() bool {
    return s.staffassignment.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) SchoolYear() *SchoolYearType {
    if s.staffassignment.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.staffassignment.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StaffAssignment.
  func (s *StaffAssignment) SchoolYear_IsNil() bool {
    return s.staffassignment.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) StaffActivity() *StaffActivityExtensionType {
    if s.staffassignment.StaffActivity == nil {
     if v, ok:= StaffActivityExtensionTypePointer(StaffActivityExtensionType{}); ok {
      s.staffassignment.StaffActivity = v
      }
      }
      return s.staffassignment.StaffActivity
    }
// Returns whether the element value for StaffActivity is nil in the container StaffAssignment.
  func (s *StaffAssignment) StaffActivity_IsNil() bool {
    return s.staffassignment.StaffActivity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) StaffPersonalRefId() *String {
    if s.staffassignment.StaffPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignment.StaffPersonalRefId = ((*String)(v))
      }
      }
      return s.staffassignment.StaffPersonalRefId
    }
// Returns whether the element value for StaffPersonalRefId is nil in the container StaffAssignment.
  func (s *StaffAssignment) StaffPersonalRefId_IsNil() bool {
    return s.staffassignment.StaffPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) StaffSubjectList() *StaffSubjectListType {
    if s.staffassignment.StaffSubjectList == nil {
     if v, ok:= StaffSubjectListTypePointer(StaffSubjectListType{}); ok {
      s.staffassignment.StaffSubjectList = v
      }
      }
      return s.staffassignment.StaffSubjectList
    }
// Returns whether the element value for StaffSubjectList is nil in the container StaffAssignment.
  func (s *StaffAssignment) StaffSubjectList_IsNil() bool {
    return s.staffassignment.StaffSubjectList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignment) YearLevels() *YearLevelsType {
    if s.staffassignment.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.staffassignment.YearLevels = v
      }
      }
      return s.staffassignment.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container StaffAssignment.
  func (s *StaffAssignment) YearLevels_IsNil() bool {
    return s.staffassignment.YearLevels == nil
    }

// Set the value of a property to nil
func (n *StaffAssignmentMostRecentContainerType) Unset(key string) *StaffAssignmentMostRecentContainerType {
        switch key {
  case "PrimaryFTE":
   n.staffassignmentmostrecentcontainertype.PrimaryFTE = nil
  case "SecondaryFTE":
   n.staffassignmentmostrecentcontainertype.SecondaryFTE = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffAssignmentMostRecentContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *StaffAssignmentMostRecentContainerType) SetProperties(props ...Prop) *StaffAssignmentMostRecentContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StaffAssignmentMostRecentContainerType) SetProperty(key string, value interface{}) *StaffAssignmentMostRecentContainerType {
        if n == nil {
                n, _ = StaffAssignmentMostRecentContainerTypePointer(StaffAssignmentMostRecentContainerType{})
        }
        switch key {
    case "PrimaryFTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignmentmostrecentcontainertype.PrimaryFTE = ((*FTEType)(v))
      }
    case "SecondaryFTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffassignmentmostrecentcontainertype.SecondaryFTE = ((*FTEType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffAssignmentMostRecentContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignmentMostRecentContainerType) PrimaryFTE() *FTEType {
    if s.staffassignmentmostrecentcontainertype.PrimaryFTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignmentmostrecentcontainertype.PrimaryFTE = ((*FTEType)(v))
      }
      }
      return s.staffassignmentmostrecentcontainertype.PrimaryFTE
    }
// Returns whether the element value for PrimaryFTE is nil in the container StaffAssignmentMostRecentContainerType.
  func (s *StaffAssignmentMostRecentContainerType) PrimaryFTE_IsNil() bool {
    return s.staffassignmentmostrecentcontainertype.PrimaryFTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffAssignmentMostRecentContainerType) SecondaryFTE() *FTEType {
    if s.staffassignmentmostrecentcontainertype.SecondaryFTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffassignmentmostrecentcontainertype.SecondaryFTE = ((*FTEType)(v))
      }
      }
      return s.staffassignmentmostrecentcontainertype.SecondaryFTE
    }
// Returns whether the element value for SecondaryFTE is nil in the container StaffAssignmentMostRecentContainerType.
  func (s *StaffAssignmentMostRecentContainerType) SecondaryFTE_IsNil() bool {
    return s.staffassignmentmostrecentcontainertype.SecondaryFTE == nil
    }

// Set the value of a property to nil
func (n *StaffMostRecentContainerType) Unset(key string) *StaffMostRecentContainerType {
        switch key {
  case "HomeGroup":
   n.staffmostrecentcontainertype.HomeGroup = nil
  case "LocalCampusId":
   n.staffmostrecentcontainertype.LocalCampusId = nil
  case "NAPLANClassList":
   n.staffmostrecentcontainertype.NAPLANClassList = nil
  case "SchoolACARAId":
   n.staffmostrecentcontainertype.SchoolACARAId = nil
  case "SchoolLocalId":
   n.staffmostrecentcontainertype.SchoolLocalId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffMostRecentContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *StaffMostRecentContainerType) SetProperties(props ...Prop) *StaffMostRecentContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StaffMostRecentContainerType) SetProperty(key string, value interface{}) *StaffMostRecentContainerType {
        if n == nil {
                n, _ = StaffMostRecentContainerTypePointer(StaffMostRecentContainerType{})
        }
        switch key {
    case "HomeGroup":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffmostrecentcontainertype.HomeGroup = ((*String)(v))
      }
    case "LocalCampusId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffmostrecentcontainertype.LocalCampusId = ((*LocalIdType)(v))
      }
    case "NAPLANClassList":
    if v, ok:= NAPLANClassListTypePointer(value); ok {
      n.staffmostrecentcontainertype.NAPLANClassList = v
      }
    case "SchoolACARAId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffmostrecentcontainertype.SchoolACARAId = ((*LocalIdType)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffmostrecentcontainertype.SchoolLocalId = ((*LocalIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffMostRecentContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffMostRecentContainerType) HomeGroup() *String {
    if s.staffmostrecentcontainertype.HomeGroup == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffmostrecentcontainertype.HomeGroup = ((*String)(v))
      }
      }
      return s.staffmostrecentcontainertype.HomeGroup
    }
// Returns whether the element value for HomeGroup is nil in the container StaffMostRecentContainerType.
  func (s *StaffMostRecentContainerType) HomeGroup_IsNil() bool {
    return s.staffmostrecentcontainertype.HomeGroup == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffMostRecentContainerType) LocalCampusId() *LocalIdType {
    if s.staffmostrecentcontainertype.LocalCampusId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffmostrecentcontainertype.LocalCampusId = ((*LocalIdType)(v))
      }
      }
      return s.staffmostrecentcontainertype.LocalCampusId
    }
// Returns whether the element value for LocalCampusId is nil in the container StaffMostRecentContainerType.
  func (s *StaffMostRecentContainerType) LocalCampusId_IsNil() bool {
    return s.staffmostrecentcontainertype.LocalCampusId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffMostRecentContainerType) NAPLANClassList() *NAPLANClassListType {
    if s.staffmostrecentcontainertype.NAPLANClassList == nil {
     if v, ok:= NAPLANClassListTypePointer(NAPLANClassListType{}); ok {
      s.staffmostrecentcontainertype.NAPLANClassList = v
      }
      }
      return s.staffmostrecentcontainertype.NAPLANClassList
    }
// Returns whether the element value for NAPLANClassList is nil in the container StaffMostRecentContainerType.
  func (s *StaffMostRecentContainerType) NAPLANClassList_IsNil() bool {
    return s.staffmostrecentcontainertype.NAPLANClassList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffMostRecentContainerType) SchoolACARAId() *LocalIdType {
    if s.staffmostrecentcontainertype.SchoolACARAId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffmostrecentcontainertype.SchoolACARAId = ((*LocalIdType)(v))
      }
      }
      return s.staffmostrecentcontainertype.SchoolACARAId
    }
// Returns whether the element value for SchoolACARAId is nil in the container StaffMostRecentContainerType.
  func (s *StaffMostRecentContainerType) SchoolACARAId_IsNil() bool {
    return s.staffmostrecentcontainertype.SchoolACARAId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffMostRecentContainerType) SchoolLocalId() *LocalIdType {
    if s.staffmostrecentcontainertype.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffmostrecentcontainertype.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.staffmostrecentcontainertype.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container StaffMostRecentContainerType.
  func (s *StaffMostRecentContainerType) SchoolLocalId_IsNil() bool {
    return s.staffmostrecentcontainertype.SchoolLocalId == nil
    }

// Set the value of a property to nil
func (n *StaffPersonal) Unset(key string) *StaffPersonal {
        switch key {
  case "ElectronicIdList":
   n.staffpersonal.ElectronicIdList = nil
  case "EmploymentStatus":
   n.staffpersonal.EmploymentStatus = nil
  case "LocalCodeList":
   n.staffpersonal.LocalCodeList = nil
  case "LocalId":
   n.staffpersonal.LocalId = nil
  case "MostRecent":
   n.staffpersonal.MostRecent = nil
  case "OtherIdList":
   n.staffpersonal.OtherIdList = nil
  case "PersonInfo":
   n.staffpersonal.PersonInfo = nil
  case "RefId":
   n.staffpersonal.RefId = nil
  case "SIF_ExtendedElements":
   n.staffpersonal.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.staffpersonal.SIF_Metadata = nil
  case "StateProvinceId":
   n.staffpersonal.StateProvinceId = nil
  case "Title":
   n.staffpersonal.Title = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffPersonal")
        }
        return n
}

// Set a sequence of properties
func (n *StaffPersonal) SetProperties(props ...Prop) *StaffPersonal {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StaffPersonal) SetProperty(key string, value interface{}) *StaffPersonal {
        if n == nil {
                n, _ = StaffPersonalPointer(StaffPersonal{})
        }
        switch key {
    case "ElectronicIdList":
    if v, ok:= ElectronicIdListTypePointer(value); ok {
      n.staffpersonal.ElectronicIdList = v
      }
    case "EmploymentStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsStaffStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsStaffStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.staffpersonal.EmploymentStatus = ((*AUCodeSetsStaffStatusType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.staffpersonal.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffpersonal.LocalId = ((*LocalIdType)(v))
      }
    case "MostRecent":
    if v, ok:= StaffMostRecentContainerTypePointer(value); ok {
      n.staffpersonal.MostRecent = v
      }
    case "OtherIdList":
    if v, ok:= OtherIdListTypePointer(value); ok {
      n.staffpersonal.OtherIdList = v
      }
    case "PersonInfo":
    if v, ok:= PersonInfoTypePointer(value); ok {
      n.staffpersonal.PersonInfo = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffpersonal.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.staffpersonal.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.staffpersonal.SIF_Metadata = v
      }
    case "StateProvinceId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffpersonal.StateProvinceId = ((*StateProvinceIdType)(v))
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffpersonal.Title = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffPersonal")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) ElectronicIdList() *ElectronicIdListType {
    if s.staffpersonal.ElectronicIdList == nil {
     if v, ok:= ElectronicIdListTypePointer(ElectronicIdListType{}); ok {
      s.staffpersonal.ElectronicIdList = v
      }
      }
      return s.staffpersonal.ElectronicIdList
    }
// Returns whether the element value for ElectronicIdList is nil in the container StaffPersonal.
  func (s *StaffPersonal) ElectronicIdList_IsNil() bool {
    return s.staffpersonal.ElectronicIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) EmploymentStatus() *AUCodeSetsStaffStatusType {
    if s.staffpersonal.EmploymentStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffpersonal.EmploymentStatus = ((*AUCodeSetsStaffStatusType)(v))
      }
      }
      return s.staffpersonal.EmploymentStatus
    }
// Returns whether the element value for EmploymentStatus is nil in the container StaffPersonal.
  func (s *StaffPersonal) EmploymentStatus_IsNil() bool {
    return s.staffpersonal.EmploymentStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) LocalCodeList() *LocalCodeListType {
    if s.staffpersonal.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.staffpersonal.LocalCodeList = v
      }
      }
      return s.staffpersonal.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StaffPersonal.
  func (s *StaffPersonal) LocalCodeList_IsNil() bool {
    return s.staffpersonal.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) LocalId() *LocalIdType {
    if s.staffpersonal.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffpersonal.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.staffpersonal.LocalId
    }
// Returns whether the element value for LocalId is nil in the container StaffPersonal.
  func (s *StaffPersonal) LocalId_IsNil() bool {
    return s.staffpersonal.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) MostRecent() *StaffMostRecentContainerType {
    if s.staffpersonal.MostRecent == nil {
     if v, ok:= StaffMostRecentContainerTypePointer(StaffMostRecentContainerType{}); ok {
      s.staffpersonal.MostRecent = v
      }
      }
      return s.staffpersonal.MostRecent
    }
// Returns whether the element value for MostRecent is nil in the container StaffPersonal.
  func (s *StaffPersonal) MostRecent_IsNil() bool {
    return s.staffpersonal.MostRecent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) OtherIdList() *OtherIdListType {
    if s.staffpersonal.OtherIdList == nil {
     if v, ok:= OtherIdListTypePointer(OtherIdListType{}); ok {
      s.staffpersonal.OtherIdList = v
      }
      }
      return s.staffpersonal.OtherIdList
    }
// Returns whether the element value for OtherIdList is nil in the container StaffPersonal.
  func (s *StaffPersonal) OtherIdList_IsNil() bool {
    return s.staffpersonal.OtherIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) PersonInfo() *PersonInfoType {
    if s.staffpersonal.PersonInfo == nil {
     if v, ok:= PersonInfoTypePointer(PersonInfoType{}); ok {
      s.staffpersonal.PersonInfo = v
      }
      }
      return s.staffpersonal.PersonInfo
    }
// Returns whether the element value for PersonInfo is nil in the container StaffPersonal.
  func (s *StaffPersonal) PersonInfo_IsNil() bool {
    return s.staffpersonal.PersonInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) RefId() *RefIdType {
    if s.staffpersonal.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffpersonal.RefId = ((*RefIdType)(v))
      }
      }
      return s.staffpersonal.RefId
    }
// Returns whether the element value for RefId is nil in the container StaffPersonal.
  func (s *StaffPersonal) RefId_IsNil() bool {
    return s.staffpersonal.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.staffpersonal.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.staffpersonal.SIF_ExtendedElements = v
      }
      }
      return s.staffpersonal.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StaffPersonal.
  func (s *StaffPersonal) SIF_ExtendedElements_IsNil() bool {
    return s.staffpersonal.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) SIF_Metadata() *SIF_MetadataType {
    if s.staffpersonal.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.staffpersonal.SIF_Metadata = v
      }
      }
      return s.staffpersonal.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StaffPersonal.
  func (s *StaffPersonal) SIF_Metadata_IsNil() bool {
    return s.staffpersonal.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) StateProvinceId() *StateProvinceIdType {
    if s.staffpersonal.StateProvinceId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffpersonal.StateProvinceId = ((*StateProvinceIdType)(v))
      }
      }
      return s.staffpersonal.StateProvinceId
    }
// Returns whether the element value for StateProvinceId is nil in the container StaffPersonal.
  func (s *StaffPersonal) StateProvinceId_IsNil() bool {
    return s.staffpersonal.StateProvinceId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffPersonal) Title() *String {
    if s.staffpersonal.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffpersonal.Title = ((*String)(v))
      }
      }
      return s.staffpersonal.Title
    }
// Returns whether the element value for Title is nil in the container StaffPersonal.
  func (s *StaffPersonal) Title_IsNil() bool {
    return s.staffpersonal.Title == nil
    }

// Set the value of a property to nil
func (n *StaffRefIdType) Unset(key string) *StaffRefIdType {
        switch key {
  case "SIF_RefObject":
   n.staffrefidtype.SIF_RefObject = nil
  case "Value":
   n.staffrefidtype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffRefIdType")
        }
        return n
}

// Set a sequence of properties
func (n *StaffRefIdType) SetProperties(props ...Prop) *StaffRefIdType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StaffRefIdType) SetProperty(key string, value interface{}) *StaffRefIdType {
        if n == nil {
                n, _ = StaffRefIdTypePointer(StaffRefIdType{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffrefidtype.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffrefidtype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffRefIdType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffRefIdType) SIF_RefObject() *String {
    if s.staffrefidtype.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffrefidtype.SIF_RefObject = ((*String)(v))
      }
      }
      return s.staffrefidtype.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container StaffRefIdType.
  func (s *StaffRefIdType) SIF_RefObject_IsNil() bool {
    return s.staffrefidtype.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffRefIdType) Value() *String {
    if s.staffrefidtype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffrefidtype.Value = ((*String)(v))
      }
      }
      return s.staffrefidtype.Value
    }
// Returns whether the element value for Value is nil in the container StaffRefIdType.
  func (s *StaffRefIdType) Value_IsNil() bool {
    return s.staffrefidtype.Value == nil
    }

// Set the value of a property to nil
func (n *StaffSubjectType) Unset(key string) *StaffSubjectType {
        switch key {
  case "PreferenceNumber":
   n.staffsubjecttype.PreferenceNumber = nil
  case "SubjectLocalId":
   n.staffsubjecttype.SubjectLocalId = nil
  case "TimeTableSubjectRefId":
   n.staffsubjecttype.TimeTableSubjectRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffSubjectType")
        }
        return n
}

// Set a sequence of properties
func (n *StaffSubjectType) SetProperties(props ...Prop) *StaffSubjectType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StaffSubjectType) SetProperty(key string, value interface{}) *StaffSubjectType {
        if n == nil {
                n, _ = StaffSubjectTypePointer(StaffSubjectType{})
        }
        switch key {
    case "PreferenceNumber":
    
    if v, ok:= IntPointer(value); ok {
      n.staffsubjecttype.PreferenceNumber = ((*Int)(v))
      }
    case "SubjectLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffsubjecttype.SubjectLocalId = ((*LocalIdType)(v))
      }
    case "TimeTableSubjectRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.staffsubjecttype.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StaffSubjectType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffSubjectType) PreferenceNumber() *Int {
    if s.staffsubjecttype.PreferenceNumber == nil {
    if v, ok:= IntPointer(0); ok {
      s.staffsubjecttype.PreferenceNumber = ((*Int)(v))
      }
      }
      return s.staffsubjecttype.PreferenceNumber
    }
// Returns whether the element value for PreferenceNumber is nil in the container StaffSubjectType.
  func (s *StaffSubjectType) PreferenceNumber_IsNil() bool {
    return s.staffsubjecttype.PreferenceNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffSubjectType) SubjectLocalId() *LocalIdType {
    if s.staffsubjecttype.SubjectLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffsubjecttype.SubjectLocalId = ((*LocalIdType)(v))
      }
      }
      return s.staffsubjecttype.SubjectLocalId
    }
// Returns whether the element value for SubjectLocalId is nil in the container StaffSubjectType.
  func (s *StaffSubjectType) SubjectLocalId_IsNil() bool {
    return s.staffsubjecttype.SubjectLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StaffSubjectType) TimeTableSubjectRefId() *RefIdType {
    if s.staffsubjecttype.TimeTableSubjectRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.staffsubjecttype.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
      }
      return s.staffsubjecttype.TimeTableSubjectRefId
    }
// Returns whether the element value for TimeTableSubjectRefId is nil in the container StaffSubjectType.
  func (s *StaffSubjectType) TimeTableSubjectRefId_IsNil() bool {
    return s.staffsubjecttype.TimeTableSubjectRefId == nil
    }

// Set the value of a property to nil
func (n *StandardHierarchyLevelType) Unset(key string) *StandardHierarchyLevelType {
        switch key {
  case "Description":
   n.standardhierarchyleveltype.Description = nil
  case "Number":
   n.standardhierarchyleveltype.Number = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StandardHierarchyLevelType")
        }
        return n
}

// Set a sequence of properties
func (n *StandardHierarchyLevelType) SetProperties(props ...Prop) *StandardHierarchyLevelType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StandardHierarchyLevelType) SetProperty(key string, value interface{}) *StandardHierarchyLevelType {
        if n == nil {
                n, _ = StandardHierarchyLevelTypePointer(StandardHierarchyLevelType{})
        }
        switch key {
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.standardhierarchyleveltype.Description = ((*String)(v))
      }
    case "Number":
    
    if v, ok:= IntPointer(value); ok {
      n.standardhierarchyleveltype.Number = ((*Int)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StandardHierarchyLevelType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardHierarchyLevelType) Description() *String {
    if s.standardhierarchyleveltype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.standardhierarchyleveltype.Description = ((*String)(v))
      }
      }
      return s.standardhierarchyleveltype.Description
    }
// Returns whether the element value for Description is nil in the container StandardHierarchyLevelType.
  func (s *StandardHierarchyLevelType) Description_IsNil() bool {
    return s.standardhierarchyleveltype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardHierarchyLevelType) Number() *Int {
    if s.standardhierarchyleveltype.Number == nil {
    if v, ok:= IntPointer(0); ok {
      s.standardhierarchyleveltype.Number = ((*Int)(v))
      }
      }
      return s.standardhierarchyleveltype.Number
    }
// Returns whether the element value for Number is nil in the container StandardHierarchyLevelType.
  func (s *StandardHierarchyLevelType) Number_IsNil() bool {
    return s.standardhierarchyleveltype.Number == nil
    }

// Set the value of a property to nil
func (n *StandardIdentifierType) Unset(key string) *StandardIdentifierType {
        switch key {
  case "ACStrandSubjectArea":
   n.standardidentifiertype.ACStrandSubjectArea = nil
  case "AlternateIdentificationCodes":
   n.standardidentifiertype.AlternateIdentificationCodes = nil
  case "Benchmark":
   n.standardidentifiertype.Benchmark = nil
  case "IndicatorNumber":
   n.standardidentifiertype.IndicatorNumber = nil
  case "Organization":
   n.standardidentifiertype.Organization = nil
  case "StandardNumber":
   n.standardidentifiertype.StandardNumber = nil
  case "YearCreated":
   n.standardidentifiertype.YearCreated = nil
  case "YearLevel":
   n.standardidentifiertype.YearLevel = nil
  case "YearLevels":
   n.standardidentifiertype.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StandardIdentifierType")
        }
        return n
}

// Set a sequence of properties
func (n *StandardIdentifierType) SetProperties(props ...Prop) *StandardIdentifierType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StandardIdentifierType) SetProperty(key string, value interface{}) *StandardIdentifierType {
        if n == nil {
                n, _ = StandardIdentifierTypePointer(StandardIdentifierType{})
        }
        switch key {
    case "ACStrandSubjectArea":
    if v, ok:= ACStrandSubjectAreaTypePointer(value); ok {
      n.standardidentifiertype.ACStrandSubjectArea = v
      }
    case "AlternateIdentificationCodes":
    if v, ok:= AlternateIdentificationCodeListTypePointer(value); ok {
      n.standardidentifiertype.AlternateIdentificationCodes = v
      }
    case "Benchmark":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.standardidentifiertype.Benchmark = ((*String)(v))
      }
    case "IndicatorNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.standardidentifiertype.IndicatorNumber = ((*String)(v))
      }
    case "Organization":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.standardidentifiertype.Organization = ((*String)(v))
      }
    case "StandardNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.standardidentifiertype.StandardNumber = ((*String)(v))
      }
    case "YearCreated":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.standardidentifiertype.YearCreated = ((*String)(v))
      }
    case "YearLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.standardidentifiertype.YearLevel = v
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.standardidentifiertype.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StandardIdentifierType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardIdentifierType) ACStrandSubjectArea() *ACStrandSubjectAreaType {
    if s.standardidentifiertype.ACStrandSubjectArea == nil {
     if v, ok:= ACStrandSubjectAreaTypePointer(ACStrandSubjectAreaType{}); ok {
      s.standardidentifiertype.ACStrandSubjectArea = v
      }
      }
      return s.standardidentifiertype.ACStrandSubjectArea
    }
// Returns whether the element value for ACStrandSubjectArea is nil in the container StandardIdentifierType.
  func (s *StandardIdentifierType) ACStrandSubjectArea_IsNil() bool {
    return s.standardidentifiertype.ACStrandSubjectArea == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardIdentifierType) AlternateIdentificationCodes() *AlternateIdentificationCodeListType {
    if s.standardidentifiertype.AlternateIdentificationCodes == nil {
     if v, ok:= AlternateIdentificationCodeListTypePointer(AlternateIdentificationCodeListType{}); ok {
      s.standardidentifiertype.AlternateIdentificationCodes = v
      }
      }
      return s.standardidentifiertype.AlternateIdentificationCodes
    }
// Returns whether the element value for AlternateIdentificationCodes is nil in the container StandardIdentifierType.
  func (s *StandardIdentifierType) AlternateIdentificationCodes_IsNil() bool {
    return s.standardidentifiertype.AlternateIdentificationCodes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardIdentifierType) Benchmark() *String {
    if s.standardidentifiertype.Benchmark == nil {
    if v, ok:= StringPointer(""); ok {
      s.standardidentifiertype.Benchmark = ((*String)(v))
      }
      }
      return s.standardidentifiertype.Benchmark
    }
// Returns whether the element value for Benchmark is nil in the container StandardIdentifierType.
  func (s *StandardIdentifierType) Benchmark_IsNil() bool {
    return s.standardidentifiertype.Benchmark == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardIdentifierType) IndicatorNumber() *String {
    if s.standardidentifiertype.IndicatorNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.standardidentifiertype.IndicatorNumber = ((*String)(v))
      }
      }
      return s.standardidentifiertype.IndicatorNumber
    }
// Returns whether the element value for IndicatorNumber is nil in the container StandardIdentifierType.
  func (s *StandardIdentifierType) IndicatorNumber_IsNil() bool {
    return s.standardidentifiertype.IndicatorNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardIdentifierType) Organization() *String {
    if s.standardidentifiertype.Organization == nil {
    if v, ok:= StringPointer(""); ok {
      s.standardidentifiertype.Organization = ((*String)(v))
      }
      }
      return s.standardidentifiertype.Organization
    }
// Returns whether the element value for Organization is nil in the container StandardIdentifierType.
  func (s *StandardIdentifierType) Organization_IsNil() bool {
    return s.standardidentifiertype.Organization == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardIdentifierType) StandardNumber() *String {
    if s.standardidentifiertype.StandardNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.standardidentifiertype.StandardNumber = ((*String)(v))
      }
      }
      return s.standardidentifiertype.StandardNumber
    }
// Returns whether the element value for StandardNumber is nil in the container StandardIdentifierType.
  func (s *StandardIdentifierType) StandardNumber_IsNil() bool {
    return s.standardidentifiertype.StandardNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardIdentifierType) YearCreated() *String {
    if s.standardidentifiertype.YearCreated == nil {
    if v, ok:= StringPointer(""); ok {
      s.standardidentifiertype.YearCreated = ((*String)(v))
      }
      }
      return s.standardidentifiertype.YearCreated
    }
// Returns whether the element value for YearCreated is nil in the container StandardIdentifierType.
  func (s *StandardIdentifierType) YearCreated_IsNil() bool {
    return s.standardidentifiertype.YearCreated == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardIdentifierType) YearLevel() *YearLevelType {
    if s.standardidentifiertype.YearLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.standardidentifiertype.YearLevel = v
      }
      }
      return s.standardidentifiertype.YearLevel
    }
// Returns whether the element value for YearLevel is nil in the container StandardIdentifierType.
  func (s *StandardIdentifierType) YearLevel_IsNil() bool {
    return s.standardidentifiertype.YearLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardIdentifierType) YearLevels() *YearLevelsType {
    if s.standardidentifiertype.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.standardidentifiertype.YearLevels = v
      }
      }
      return s.standardidentifiertype.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container StandardIdentifierType.
  func (s *StandardIdentifierType) YearLevels_IsNil() bool {
    return s.standardidentifiertype.YearLevels == nil
    }

// Set the value of a property to nil
func (n *StandardsSettingBodyType) Unset(key string) *StandardsSettingBodyType {
        switch key {
  case "Country":
   n.standardssettingbodytype.Country = nil
  case "SettingBodyName":
   n.standardssettingbodytype.SettingBodyName = nil
  case "StateProvince":
   n.standardssettingbodytype.StateProvince = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StandardsSettingBodyType")
        }
        return n
}

// Set a sequence of properties
func (n *StandardsSettingBodyType) SetProperties(props ...Prop) *StandardsSettingBodyType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StandardsSettingBodyType) SetProperty(key string, value interface{}) *StandardsSettingBodyType {
        if n == nil {
                n, _ = StandardsSettingBodyTypePointer(StandardsSettingBodyType{})
        }
        switch key {
    case "Country":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.standardssettingbodytype.Country = ((*CountryType)(v))
      }
    case "SettingBodyName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.standardssettingbodytype.SettingBodyName = ((*String)(v))
      }
    case "StateProvince":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.standardssettingbodytype.StateProvince = ((*StateProvinceType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StandardsSettingBodyType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardsSettingBodyType) Country() *CountryType {
    if s.standardssettingbodytype.Country == nil {
    if v, ok:= StringPointer(""); ok {
      s.standardssettingbodytype.Country = ((*CountryType)(v))
      }
      }
      return s.standardssettingbodytype.Country
    }
// Returns whether the element value for Country is nil in the container StandardsSettingBodyType.
  func (s *StandardsSettingBodyType) Country_IsNil() bool {
    return s.standardssettingbodytype.Country == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardsSettingBodyType) SettingBodyName() *String {
    if s.standardssettingbodytype.SettingBodyName == nil {
    if v, ok:= StringPointer(""); ok {
      s.standardssettingbodytype.SettingBodyName = ((*String)(v))
      }
      }
      return s.standardssettingbodytype.SettingBodyName
    }
// Returns whether the element value for SettingBodyName is nil in the container StandardsSettingBodyType.
  func (s *StandardsSettingBodyType) SettingBodyName_IsNil() bool {
    return s.standardssettingbodytype.SettingBodyName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StandardsSettingBodyType) StateProvince() *StateProvinceType {
    if s.standardssettingbodytype.StateProvince == nil {
    if v, ok:= StringPointer(""); ok {
      s.standardssettingbodytype.StateProvince = ((*StateProvinceType)(v))
      }
      }
      return s.standardssettingbodytype.StateProvince
    }
// Returns whether the element value for StateProvince is nil in the container StandardsSettingBodyType.
  func (s *StandardsSettingBodyType) StateProvince_IsNil() bool {
    return s.standardssettingbodytype.StateProvince == nil
    }

// Set the value of a property to nil
func (n *StatisticalAreaType) Unset(key string) *StatisticalAreaType {
        switch key {
  case "SpatialUnitType":
   n.statisticalareatype.SpatialUnitType = nil
  case "Value":
   n.statisticalareatype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StatisticalAreaType")
        }
        return n
}

// Set a sequence of properties
func (n *StatisticalAreaType) SetProperties(props ...Prop) *StatisticalAreaType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StatisticalAreaType) SetProperty(key string, value interface{}) *StatisticalAreaType {
        if n == nil {
                n, _ = StatisticalAreaTypePointer(StatisticalAreaType{})
        }
        switch key {
    case "SpatialUnitType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.statisticalareatype.SpatialUnitType = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.statisticalareatype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StatisticalAreaType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatisticalAreaType) SpatialUnitType() *String {
    if s.statisticalareatype.SpatialUnitType == nil {
    if v, ok:= StringPointer(""); ok {
      s.statisticalareatype.SpatialUnitType = ((*String)(v))
      }
      }
      return s.statisticalareatype.SpatialUnitType
    }
// Returns whether the element value for SpatialUnitType is nil in the container StatisticalAreaType.
  func (s *StatisticalAreaType) SpatialUnitType_IsNil() bool {
    return s.statisticalareatype.SpatialUnitType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatisticalAreaType) Value() *String {
    if s.statisticalareatype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.statisticalareatype.Value = ((*String)(v))
      }
      }
      return s.statisticalareatype.Value
    }
// Returns whether the element value for Value is nil in the container StatisticalAreaType.
  func (s *StatisticalAreaType) Value_IsNil() bool {
    return s.statisticalareatype.Value == nil
    }

// Set the value of a property to nil
func (n *StatsCohortType) Unset(key string) *StatsCohortType {
        switch key {
  case "AttendanceDays":
   n.statscohorttype.AttendanceDays = nil
  case "AttendanceGTE90Percent":
   n.statscohorttype.AttendanceGTE90Percent = nil
  case "AttendanceLess90Percent":
   n.statscohorttype.AttendanceLess90Percent = nil
  case "CohortGender":
   n.statscohorttype.CohortGender = nil
  case "DaysInReferencePeriod":
   n.statscohorttype.DaysInReferencePeriod = nil
  case "PossibleSchoolDays":
   n.statscohorttype.PossibleSchoolDays = nil
  case "PossibleSchoolDaysGT90PercentAttendance":
   n.statscohorttype.PossibleSchoolDaysGT90PercentAttendance = nil
  case "StatsCohortId":
   n.statscohorttype.StatsCohortId = nil
  case "StatsIndigenousStudentType":
   n.statscohorttype.StatsIndigenousStudentType = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StatsCohortType")
        }
        return n
}

// Set a sequence of properties
func (n *StatsCohortType) SetProperties(props ...Prop) *StatsCohortType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StatsCohortType) SetProperty(key string, value interface{}) *StatsCohortType {
        if n == nil {
                n, _ = StatsCohortTypePointer(StatsCohortType{})
        }
        switch key {
    case "AttendanceDays":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.statscohorttype.AttendanceDays = ((*String)(v))
      }
    case "AttendanceGTE90Percent":
    
    if v, ok:= IntPointer(value); ok {
      n.statscohorttype.AttendanceGTE90Percent = ((*Int)(v))
      }
    case "AttendanceLess90Percent":
    
    if v, ok:= IntPointer(value); ok {
      n.statscohorttype.AttendanceLess90Percent = ((*Int)(v))
      }
    case "CohortGender":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.statscohorttype.CohortGender = ((*String)(v))
      }
    case "DaysInReferencePeriod":
    
    if v, ok:= IntPointer(value); ok {
      n.statscohorttype.DaysInReferencePeriod = ((*Int)(v))
      }
    case "PossibleSchoolDays":
    
    if v, ok:= IntPointer(value); ok {
      n.statscohorttype.PossibleSchoolDays = ((*Int)(v))
      }
    case "PossibleSchoolDaysGT90PercentAttendance":
    
    if v, ok:= IntPointer(value); ok {
      n.statscohorttype.PossibleSchoolDaysGT90PercentAttendance = ((*Int)(v))
      }
    case "StatsCohortId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.statscohorttype.StatsCohortId = ((*LocalIdType)(v))
      }
    case "StatsIndigenousStudentType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.statscohorttype.StatsIndigenousStudentType = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StatsCohortType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortType) AttendanceDays() *String {
    if s.statscohorttype.AttendanceDays == nil {
    if v, ok:= StringPointer(""); ok {
      s.statscohorttype.AttendanceDays = ((*String)(v))
      }
      }
      return s.statscohorttype.AttendanceDays
    }
// Returns whether the element value for AttendanceDays is nil in the container StatsCohortType.
  func (s *StatsCohortType) AttendanceDays_IsNil() bool {
    return s.statscohorttype.AttendanceDays == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortType) AttendanceGTE90Percent() *Int {
    if s.statscohorttype.AttendanceGTE90Percent == nil {
    if v, ok:= IntPointer(0); ok {
      s.statscohorttype.AttendanceGTE90Percent = ((*Int)(v))
      }
      }
      return s.statscohorttype.AttendanceGTE90Percent
    }
// Returns whether the element value for AttendanceGTE90Percent is nil in the container StatsCohortType.
  func (s *StatsCohortType) AttendanceGTE90Percent_IsNil() bool {
    return s.statscohorttype.AttendanceGTE90Percent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortType) AttendanceLess90Percent() *Int {
    if s.statscohorttype.AttendanceLess90Percent == nil {
    if v, ok:= IntPointer(0); ok {
      s.statscohorttype.AttendanceLess90Percent = ((*Int)(v))
      }
      }
      return s.statscohorttype.AttendanceLess90Percent
    }
// Returns whether the element value for AttendanceLess90Percent is nil in the container StatsCohortType.
  func (s *StatsCohortType) AttendanceLess90Percent_IsNil() bool {
    return s.statscohorttype.AttendanceLess90Percent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortType) CohortGender() *String {
    if s.statscohorttype.CohortGender == nil {
    if v, ok:= StringPointer(""); ok {
      s.statscohorttype.CohortGender = ((*String)(v))
      }
      }
      return s.statscohorttype.CohortGender
    }
// Returns whether the element value for CohortGender is nil in the container StatsCohortType.
  func (s *StatsCohortType) CohortGender_IsNil() bool {
    return s.statscohorttype.CohortGender == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortType) DaysInReferencePeriod() *Int {
    if s.statscohorttype.DaysInReferencePeriod == nil {
    if v, ok:= IntPointer(0); ok {
      s.statscohorttype.DaysInReferencePeriod = ((*Int)(v))
      }
      }
      return s.statscohorttype.DaysInReferencePeriod
    }
// Returns whether the element value for DaysInReferencePeriod is nil in the container StatsCohortType.
  func (s *StatsCohortType) DaysInReferencePeriod_IsNil() bool {
    return s.statscohorttype.DaysInReferencePeriod == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortType) PossibleSchoolDays() *Int {
    if s.statscohorttype.PossibleSchoolDays == nil {
    if v, ok:= IntPointer(0); ok {
      s.statscohorttype.PossibleSchoolDays = ((*Int)(v))
      }
      }
      return s.statscohorttype.PossibleSchoolDays
    }
// Returns whether the element value for PossibleSchoolDays is nil in the container StatsCohortType.
  func (s *StatsCohortType) PossibleSchoolDays_IsNil() bool {
    return s.statscohorttype.PossibleSchoolDays == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortType) PossibleSchoolDaysGT90PercentAttendance() *Int {
    if s.statscohorttype.PossibleSchoolDaysGT90PercentAttendance == nil {
    if v, ok:= IntPointer(0); ok {
      s.statscohorttype.PossibleSchoolDaysGT90PercentAttendance = ((*Int)(v))
      }
      }
      return s.statscohorttype.PossibleSchoolDaysGT90PercentAttendance
    }
// Returns whether the element value for PossibleSchoolDaysGT90PercentAttendance is nil in the container StatsCohortType.
  func (s *StatsCohortType) PossibleSchoolDaysGT90PercentAttendance_IsNil() bool {
    return s.statscohorttype.PossibleSchoolDaysGT90PercentAttendance == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortType) StatsCohortId() *LocalIdType {
    if s.statscohorttype.StatsCohortId == nil {
    if v, ok:= StringPointer(""); ok {
      s.statscohorttype.StatsCohortId = ((*LocalIdType)(v))
      }
      }
      return s.statscohorttype.StatsCohortId
    }
// Returns whether the element value for StatsCohortId is nil in the container StatsCohortType.
  func (s *StatsCohortType) StatsCohortId_IsNil() bool {
    return s.statscohorttype.StatsCohortId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortType) StatsIndigenousStudentType() *String {
    if s.statscohorttype.StatsIndigenousStudentType == nil {
    if v, ok:= StringPointer(""); ok {
      s.statscohorttype.StatsIndigenousStudentType = ((*String)(v))
      }
      }
      return s.statscohorttype.StatsIndigenousStudentType
    }
// Returns whether the element value for StatsIndigenousStudentType is nil in the container StatsCohortType.
  func (s *StatsCohortType) StatsIndigenousStudentType_IsNil() bool {
    return s.statscohorttype.StatsIndigenousStudentType == nil
    }

// Set the value of a property to nil
func (n *StatsCohortYearLevelType) Unset(key string) *StatsCohortYearLevelType {
        switch key {
  case "CohortYearLevel":
   n.statscohortyearleveltype.CohortYearLevel = nil
  case "StatsCohortList":
   n.statscohortyearleveltype.StatsCohortList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StatsCohortYearLevelType")
        }
        return n
}

// Set a sequence of properties
func (n *StatsCohortYearLevelType) SetProperties(props ...Prop) *StatsCohortYearLevelType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StatsCohortYearLevelType) SetProperty(key string, value interface{}) *StatsCohortYearLevelType {
        if n == nil {
                n, _ = StatsCohortYearLevelTypePointer(StatsCohortYearLevelType{})
        }
        switch key {
    case "CohortYearLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.statscohortyearleveltype.CohortYearLevel = v
      }
    case "StatsCohortList":
    if v, ok:= StatsCohortListTypePointer(value); ok {
      n.statscohortyearleveltype.StatsCohortList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StatsCohortYearLevelType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortYearLevelType) CohortYearLevel() *YearLevelType {
    if s.statscohortyearleveltype.CohortYearLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.statscohortyearleveltype.CohortYearLevel = v
      }
      }
      return s.statscohortyearleveltype.CohortYearLevel
    }
// Returns whether the element value for CohortYearLevel is nil in the container StatsCohortYearLevelType.
  func (s *StatsCohortYearLevelType) CohortYearLevel_IsNil() bool {
    return s.statscohortyearleveltype.CohortYearLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StatsCohortYearLevelType) StatsCohortList() *StatsCohortListType {
    if s.statscohortyearleveltype.StatsCohortList == nil {
     if v, ok:= StatsCohortListTypePointer(StatsCohortListType{}); ok {
      s.statscohortyearleveltype.StatsCohortList = v
      }
      }
      return s.statscohortyearleveltype.StatsCohortList
    }
// Returns whether the element value for StatsCohortList is nil in the container StatsCohortYearLevelType.
  func (s *StatsCohortYearLevelType) StatsCohortList_IsNil() bool {
    return s.statscohortyearleveltype.StatsCohortList == nil
    }

// Set the value of a property to nil
func (n *StimulusType) Unset(key string) *StimulusType {
        switch key {
  case "Content":
   n.stimulustype.Content = nil
  case "StimulusLocalId":
   n.stimulustype.StimulusLocalId = nil
  case "TextDescriptor":
   n.stimulustype.TextDescriptor = nil
  case "TextGenre":
   n.stimulustype.TextGenre = nil
  case "TextType":
   n.stimulustype.TextType = nil
  case "WordCount":
   n.stimulustype.WordCount = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StimulusType")
        }
        return n
}

// Set a sequence of properties
func (n *StimulusType) SetProperties(props ...Prop) *StimulusType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StimulusType) SetProperty(key string, value interface{}) *StimulusType {
        if n == nil {
                n, _ = StimulusTypePointer(StimulusType{})
        }
        switch key {
    case "Content":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stimulustype.Content = ((*String)(v))
      }
    case "StimulusLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stimulustype.StimulusLocalId = ((*LocalIdType)(v))
      }
    case "TextDescriptor":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stimulustype.TextDescriptor = ((*String)(v))
      }
    case "TextGenre":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stimulustype.TextGenre = ((*String)(v))
      }
    case "TextType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.stimulustype.TextType = ((*String)(v))
      }
    case "WordCount":
    
    if v, ok:= IntPointer(value); ok {
      n.stimulustype.WordCount = ((*Int)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StimulusType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StimulusType) Content() *String {
    if s.stimulustype.Content == nil {
    if v, ok:= StringPointer(""); ok {
      s.stimulustype.Content = ((*String)(v))
      }
      }
      return s.stimulustype.Content
    }
// Returns whether the element value for Content is nil in the container StimulusType.
  func (s *StimulusType) Content_IsNil() bool {
    return s.stimulustype.Content == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StimulusType) StimulusLocalId() *LocalIdType {
    if s.stimulustype.StimulusLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.stimulustype.StimulusLocalId = ((*LocalIdType)(v))
      }
      }
      return s.stimulustype.StimulusLocalId
    }
// Returns whether the element value for StimulusLocalId is nil in the container StimulusType.
  func (s *StimulusType) StimulusLocalId_IsNil() bool {
    return s.stimulustype.StimulusLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StimulusType) TextDescriptor() *String {
    if s.stimulustype.TextDescriptor == nil {
    if v, ok:= StringPointer(""); ok {
      s.stimulustype.TextDescriptor = ((*String)(v))
      }
      }
      return s.stimulustype.TextDescriptor
    }
// Returns whether the element value for TextDescriptor is nil in the container StimulusType.
  func (s *StimulusType) TextDescriptor_IsNil() bool {
    return s.stimulustype.TextDescriptor == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StimulusType) TextGenre() *String {
    if s.stimulustype.TextGenre == nil {
    if v, ok:= StringPointer(""); ok {
      s.stimulustype.TextGenre = ((*String)(v))
      }
      }
      return s.stimulustype.TextGenre
    }
// Returns whether the element value for TextGenre is nil in the container StimulusType.
  func (s *StimulusType) TextGenre_IsNil() bool {
    return s.stimulustype.TextGenre == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StimulusType) TextType() *String {
    if s.stimulustype.TextType == nil {
    if v, ok:= StringPointer(""); ok {
      s.stimulustype.TextType = ((*String)(v))
      }
      }
      return s.stimulustype.TextType
    }
// Returns whether the element value for TextType is nil in the container StimulusType.
  func (s *StimulusType) TextType_IsNil() bool {
    return s.stimulustype.TextType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StimulusType) WordCount() *Int {
    if s.stimulustype.WordCount == nil {
    if v, ok:= IntPointer(0); ok {
      s.stimulustype.WordCount = ((*Int)(v))
      }
      }
      return s.stimulustype.WordCount
    }
// Returns whether the element value for WordCount is nil in the container StimulusType.
  func (s *StimulusType) WordCount_IsNil() bool {
    return s.stimulustype.WordCount == nil
    }

// Set the value of a property to nil
func (n *StudentActivityInfo) Unset(key string) *StudentActivityInfo {
        switch key {
  case "CurricularStatus":
   n.studentactivityinfo.CurricularStatus = nil
  case "Description":
   n.studentactivityinfo.Description = nil
  case "LocalCodeList":
   n.studentactivityinfo.LocalCodeList = nil
  case "Location":
   n.studentactivityinfo.Location = nil
  case "RefId":
   n.studentactivityinfo.RefId = nil
  case "SIF_ExtendedElements":
   n.studentactivityinfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentactivityinfo.SIF_Metadata = nil
  case "StudentActivityLevel":
   n.studentactivityinfo.StudentActivityLevel = nil
  case "StudentActivityType":
   n.studentactivityinfo.StudentActivityType = nil
  case "Title":
   n.studentactivityinfo.Title = nil
  case "YearLevels":
   n.studentactivityinfo.YearLevels = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentActivityInfo")
        }
        return n
}

// Set a sequence of properties
func (n *StudentActivityInfo) SetProperties(props ...Prop) *StudentActivityInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentActivityInfo) SetProperty(key string, value interface{}) *StudentActivityInfo {
        if n == nil {
                n, _ = StudentActivityInfoPointer(StudentActivityInfo{})
        }
        switch key {
    case "CurricularStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsActivityTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsActivityTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentactivityinfo.CurricularStatus = ((*AUCodeSetsActivityTypeType)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityinfo.Description = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentactivityinfo.LocalCodeList = v
      }
    case "Location":
    if v, ok:= LocationTypePointer(value); ok {
      n.studentactivityinfo.Location = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityinfo.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentactivityinfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentactivityinfo.SIF_Metadata = v
      }
    case "StudentActivityLevel":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityinfo.StudentActivityLevel = ((*String)(v))
      }
    case "StudentActivityType":
    if v, ok:= StudentActivityTypePointer(value); ok {
      n.studentactivityinfo.StudentActivityType = v
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityinfo.Title = ((*String)(v))
      }
    case "YearLevels":
    if v, ok:= YearLevelsTypePointer(value); ok {
      n.studentactivityinfo.YearLevels = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentActivityInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) CurricularStatus() *AUCodeSetsActivityTypeType {
    if s.studentactivityinfo.CurricularStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityinfo.CurricularStatus = ((*AUCodeSetsActivityTypeType)(v))
      }
      }
      return s.studentactivityinfo.CurricularStatus
    }
// Returns whether the element value for CurricularStatus is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) CurricularStatus_IsNil() bool {
    return s.studentactivityinfo.CurricularStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) Description() *String {
    if s.studentactivityinfo.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityinfo.Description = ((*String)(v))
      }
      }
      return s.studentactivityinfo.Description
    }
// Returns whether the element value for Description is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) Description_IsNil() bool {
    return s.studentactivityinfo.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) LocalCodeList() *LocalCodeListType {
    if s.studentactivityinfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentactivityinfo.LocalCodeList = v
      }
      }
      return s.studentactivityinfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) LocalCodeList_IsNil() bool {
    return s.studentactivityinfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) Location() *LocationType {
    if s.studentactivityinfo.Location == nil {
     if v, ok:= LocationTypePointer(LocationType{}); ok {
      s.studentactivityinfo.Location = v
      }
      }
      return s.studentactivityinfo.Location
    }
// Returns whether the element value for Location is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) Location_IsNil() bool {
    return s.studentactivityinfo.Location == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) RefId() *RefIdType {
    if s.studentactivityinfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityinfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentactivityinfo.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) RefId_IsNil() bool {
    return s.studentactivityinfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentactivityinfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentactivityinfo.SIF_ExtendedElements = v
      }
      }
      return s.studentactivityinfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) SIF_ExtendedElements_IsNil() bool {
    return s.studentactivityinfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) SIF_Metadata() *SIF_MetadataType {
    if s.studentactivityinfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentactivityinfo.SIF_Metadata = v
      }
      }
      return s.studentactivityinfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) SIF_Metadata_IsNil() bool {
    return s.studentactivityinfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) StudentActivityLevel() *String {
    if s.studentactivityinfo.StudentActivityLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityinfo.StudentActivityLevel = ((*String)(v))
      }
      }
      return s.studentactivityinfo.StudentActivityLevel
    }
// Returns whether the element value for StudentActivityLevel is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) StudentActivityLevel_IsNil() bool {
    return s.studentactivityinfo.StudentActivityLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) StudentActivityType() *StudentActivityType {
    if s.studentactivityinfo.StudentActivityType == nil {
     if v, ok:= StudentActivityTypePointer(StudentActivityType{}); ok {
      s.studentactivityinfo.StudentActivityType = v
      }
      }
      return s.studentactivityinfo.StudentActivityType
    }
// Returns whether the element value for StudentActivityType is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) StudentActivityType_IsNil() bool {
    return s.studentactivityinfo.StudentActivityType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) Title() *String {
    if s.studentactivityinfo.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityinfo.Title = ((*String)(v))
      }
      }
      return s.studentactivityinfo.Title
    }
// Returns whether the element value for Title is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) Title_IsNil() bool {
    return s.studentactivityinfo.Title == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityInfo) YearLevels() *YearLevelsType {
    if s.studentactivityinfo.YearLevels == nil {
     if v, ok:= YearLevelsTypePointer(YearLevelsType{}); ok {
      s.studentactivityinfo.YearLevels = v
      }
      }
      return s.studentactivityinfo.YearLevels
    }
// Returns whether the element value for YearLevels is nil in the container StudentActivityInfo.
  func (s *StudentActivityInfo) YearLevels_IsNil() bool {
    return s.studentactivityinfo.YearLevels == nil
    }

// Set the value of a property to nil
func (n *StudentActivityParticipation) Unset(key string) *StudentActivityParticipation {
        switch key {
  case "EndDate":
   n.studentactivityparticipation.EndDate = nil
  case "LocalCodeList":
   n.studentactivityparticipation.LocalCodeList = nil
  case "ParticipationComment":
   n.studentactivityparticipation.ParticipationComment = nil
  case "RecognitionList":
   n.studentactivityparticipation.RecognitionList = nil
  case "RefId":
   n.studentactivityparticipation.RefId = nil
  case "Role":
   n.studentactivityparticipation.Role = nil
  case "SIF_ExtendedElements":
   n.studentactivityparticipation.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentactivityparticipation.SIF_Metadata = nil
  case "SchoolYear":
   n.studentactivityparticipation.SchoolYear = nil
  case "StartDate":
   n.studentactivityparticipation.StartDate = nil
  case "StudentActivityInfoRefId":
   n.studentactivityparticipation.StudentActivityInfoRefId = nil
  case "StudentPersonalRefId":
   n.studentactivityparticipation.StudentPersonalRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentActivityParticipation")
        }
        return n
}

// Set a sequence of properties
func (n *StudentActivityParticipation) SetProperties(props ...Prop) *StudentActivityParticipation {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentActivityParticipation) SetProperty(key string, value interface{}) *StudentActivityParticipation {
        if n == nil {
                n, _ = StudentActivityParticipationPointer(StudentActivityParticipation{})
        }
        switch key {
    case "EndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityparticipation.EndDate = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentactivityparticipation.LocalCodeList = v
      }
    case "ParticipationComment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityparticipation.ParticipationComment = ((*String)(v))
      }
    case "RecognitionList":
    if v, ok:= RecognitionListTypePointer(value); ok {
      n.studentactivityparticipation.RecognitionList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityparticipation.RefId = ((*RefIdType)(v))
      }
    case "Role":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityparticipation.Role = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentactivityparticipation.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentactivityparticipation.SIF_Metadata = v
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityparticipation.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityparticipation.StartDate = ((*String)(v))
      }
    case "StudentActivityInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityparticipation.StudentActivityInfoRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentactivityparticipation.StudentPersonalRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentActivityParticipation")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) EndDate() *String {
    if s.studentactivityparticipation.EndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityparticipation.EndDate = ((*String)(v))
      }
      }
      return s.studentactivityparticipation.EndDate
    }
// Returns whether the element value for EndDate is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) EndDate_IsNil() bool {
    return s.studentactivityparticipation.EndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) LocalCodeList() *LocalCodeListType {
    if s.studentactivityparticipation.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentactivityparticipation.LocalCodeList = v
      }
      }
      return s.studentactivityparticipation.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) LocalCodeList_IsNil() bool {
    return s.studentactivityparticipation.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) ParticipationComment() *String {
    if s.studentactivityparticipation.ParticipationComment == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityparticipation.ParticipationComment = ((*String)(v))
      }
      }
      return s.studentactivityparticipation.ParticipationComment
    }
// Returns whether the element value for ParticipationComment is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) ParticipationComment_IsNil() bool {
    return s.studentactivityparticipation.ParticipationComment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) RecognitionList() *RecognitionListType {
    if s.studentactivityparticipation.RecognitionList == nil {
     if v, ok:= RecognitionListTypePointer(RecognitionListType{}); ok {
      s.studentactivityparticipation.RecognitionList = v
      }
      }
      return s.studentactivityparticipation.RecognitionList
    }
// Returns whether the element value for RecognitionList is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) RecognitionList_IsNil() bool {
    return s.studentactivityparticipation.RecognitionList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) RefId() *RefIdType {
    if s.studentactivityparticipation.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityparticipation.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentactivityparticipation.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) RefId_IsNil() bool {
    return s.studentactivityparticipation.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) Role() *String {
    if s.studentactivityparticipation.Role == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityparticipation.Role = ((*String)(v))
      }
      }
      return s.studentactivityparticipation.Role
    }
// Returns whether the element value for Role is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) Role_IsNil() bool {
    return s.studentactivityparticipation.Role == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentactivityparticipation.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentactivityparticipation.SIF_ExtendedElements = v
      }
      }
      return s.studentactivityparticipation.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) SIF_ExtendedElements_IsNil() bool {
    return s.studentactivityparticipation.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) SIF_Metadata() *SIF_MetadataType {
    if s.studentactivityparticipation.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentactivityparticipation.SIF_Metadata = v
      }
      }
      return s.studentactivityparticipation.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) SIF_Metadata_IsNil() bool {
    return s.studentactivityparticipation.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) SchoolYear() *SchoolYearType {
    if s.studentactivityparticipation.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityparticipation.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentactivityparticipation.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) SchoolYear_IsNil() bool {
    return s.studentactivityparticipation.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) StartDate() *String {
    if s.studentactivityparticipation.StartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityparticipation.StartDate = ((*String)(v))
      }
      }
      return s.studentactivityparticipation.StartDate
    }
// Returns whether the element value for StartDate is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) StartDate_IsNil() bool {
    return s.studentactivityparticipation.StartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) StudentActivityInfoRefId() *String {
    if s.studentactivityparticipation.StudentActivityInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityparticipation.StudentActivityInfoRefId = ((*String)(v))
      }
      }
      return s.studentactivityparticipation.StudentActivityInfoRefId
    }
// Returns whether the element value for StudentActivityInfoRefId is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) StudentActivityInfoRefId_IsNil() bool {
    return s.studentactivityparticipation.StudentActivityInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityParticipation) StudentPersonalRefId() *String {
    if s.studentactivityparticipation.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivityparticipation.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentactivityparticipation.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentActivityParticipation.
  func (s *StudentActivityParticipation) StudentPersonalRefId_IsNil() bool {
    return s.studentactivityparticipation.StudentPersonalRefId == nil
    }

// Set the value of a property to nil
func (n *StudentActivityType) Unset(key string) *StudentActivityType {
        switch key {
  case "Code":
   n.studentactivitytype.Code = nil
  case "OtherCodeList":
   n.studentactivitytype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentActivityType")
        }
        return n
}

// Set a sequence of properties
func (n *StudentActivityType) SetProperties(props ...Prop) *StudentActivityType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentActivityType) SetProperty(key string, value interface{}) *StudentActivityType {
        if n == nil {
                n, _ = StudentActivityTypePointer(StudentActivityType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsActivityInvolvementCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsActivityInvolvementCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentactivitytype.Code = ((*AUCodeSetsActivityInvolvementCodeType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.studentactivitytype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentActivityType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityType) Code() *AUCodeSetsActivityInvolvementCodeType {
    if s.studentactivitytype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentactivitytype.Code = ((*AUCodeSetsActivityInvolvementCodeType)(v))
      }
      }
      return s.studentactivitytype.Code
    }
// Returns whether the element value for Code is nil in the container StudentActivityType.
  func (s *StudentActivityType) Code_IsNil() bool {
    return s.studentactivitytype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentActivityType) OtherCodeList() *OtherCodeListType {
    if s.studentactivitytype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.studentactivitytype.OtherCodeList = v
      }
      }
      return s.studentactivitytype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container StudentActivityType.
  func (s *StudentActivityType) OtherCodeList_IsNil() bool {
    return s.studentactivitytype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *StudentAttendanceCollection) Unset(key string) *StudentAttendanceCollection {
        switch key {
  case "LocalCodeList":
   n.studentattendancecollection.LocalCodeList = nil
  case "RefId":
   n.studentattendancecollection.RefId = nil
  case "RoundCode":
   n.studentattendancecollection.RoundCode = nil
  case "SIF_ExtendedElements":
   n.studentattendancecollection.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentattendancecollection.SIF_Metadata = nil
  case "SoftwareVendorInfo":
   n.studentattendancecollection.SoftwareVendorInfo = nil
  case "StudentAttendanceCollectionReportingList":
   n.studentattendancecollection.StudentAttendanceCollectionReportingList = nil
  case "StudentAttendanceCollectionYear":
   n.studentattendancecollection.StudentAttendanceCollectionYear = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentAttendanceCollection")
        }
        return n
}

// Set a sequence of properties
func (n *StudentAttendanceCollection) SetProperties(props ...Prop) *StudentAttendanceCollection {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentAttendanceCollection) SetProperty(key string, value interface{}) *StudentAttendanceCollection {
        if n == nil {
                n, _ = StudentAttendanceCollectionPointer(StudentAttendanceCollection{})
        }
        switch key {
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentattendancecollection.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancecollection.RefId = ((*RefIdType)(v))
      }
    case "RoundCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancecollection.RoundCode = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentattendancecollection.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentattendancecollection.SIF_Metadata = v
      }
    case "SoftwareVendorInfo":
    if v, ok:= SoftwareVendorInfoContainerTypePointer(value); ok {
      n.studentattendancecollection.SoftwareVendorInfo = v
      }
    case "StudentAttendanceCollectionReportingList":
    if v, ok:= StudentAttendanceCollectionReportingListTypePointer(value); ok {
      n.studentattendancecollection.StudentAttendanceCollectionReportingList = v
      }
    case "StudentAttendanceCollectionYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancecollection.StudentAttendanceCollectionYear = ((*SchoolYearType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentAttendanceCollection")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollection) LocalCodeList() *LocalCodeListType {
    if s.studentattendancecollection.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentattendancecollection.LocalCodeList = v
      }
      }
      return s.studentattendancecollection.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentAttendanceCollection.
  func (s *StudentAttendanceCollection) LocalCodeList_IsNil() bool {
    return s.studentattendancecollection.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollection) RefId() *RefIdType {
    if s.studentattendancecollection.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancecollection.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentattendancecollection.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentAttendanceCollection.
  func (s *StudentAttendanceCollection) RefId_IsNil() bool {
    return s.studentattendancecollection.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollection) RoundCode() *String {
    if s.studentattendancecollection.RoundCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancecollection.RoundCode = ((*String)(v))
      }
      }
      return s.studentattendancecollection.RoundCode
    }
// Returns whether the element value for RoundCode is nil in the container StudentAttendanceCollection.
  func (s *StudentAttendanceCollection) RoundCode_IsNil() bool {
    return s.studentattendancecollection.RoundCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollection) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentattendancecollection.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentattendancecollection.SIF_ExtendedElements = v
      }
      }
      return s.studentattendancecollection.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentAttendanceCollection.
  func (s *StudentAttendanceCollection) SIF_ExtendedElements_IsNil() bool {
    return s.studentattendancecollection.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollection) SIF_Metadata() *SIF_MetadataType {
    if s.studentattendancecollection.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentattendancecollection.SIF_Metadata = v
      }
      }
      return s.studentattendancecollection.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentAttendanceCollection.
  func (s *StudentAttendanceCollection) SIF_Metadata_IsNil() bool {
    return s.studentattendancecollection.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollection) SoftwareVendorInfo() *SoftwareVendorInfoContainerType {
    if s.studentattendancecollection.SoftwareVendorInfo == nil {
     if v, ok:= SoftwareVendorInfoContainerTypePointer(SoftwareVendorInfoContainerType{}); ok {
      s.studentattendancecollection.SoftwareVendorInfo = v
      }
      }
      return s.studentattendancecollection.SoftwareVendorInfo
    }
// Returns whether the element value for SoftwareVendorInfo is nil in the container StudentAttendanceCollection.
  func (s *StudentAttendanceCollection) SoftwareVendorInfo_IsNil() bool {
    return s.studentattendancecollection.SoftwareVendorInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollection) StudentAttendanceCollectionReportingList() *StudentAttendanceCollectionReportingListType {
    if s.studentattendancecollection.StudentAttendanceCollectionReportingList == nil {
     if v, ok:= StudentAttendanceCollectionReportingListTypePointer(StudentAttendanceCollectionReportingListType{}); ok {
      s.studentattendancecollection.StudentAttendanceCollectionReportingList = v
      }
      }
      return s.studentattendancecollection.StudentAttendanceCollectionReportingList
    }
// Returns whether the element value for StudentAttendanceCollectionReportingList is nil in the container StudentAttendanceCollection.
  func (s *StudentAttendanceCollection) StudentAttendanceCollectionReportingList_IsNil() bool {
    return s.studentattendancecollection.StudentAttendanceCollectionReportingList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollection) StudentAttendanceCollectionYear() *SchoolYearType {
    if s.studentattendancecollection.StudentAttendanceCollectionYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancecollection.StudentAttendanceCollectionYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentattendancecollection.StudentAttendanceCollectionYear
    }
// Returns whether the element value for StudentAttendanceCollectionYear is nil in the container StudentAttendanceCollection.
  func (s *StudentAttendanceCollection) StudentAttendanceCollectionYear_IsNil() bool {
    return s.studentattendancecollection.StudentAttendanceCollectionYear == nil
    }

// Set the value of a property to nil
func (n *StudentAttendanceCollectionReportingType) Unset(key string) *StudentAttendanceCollectionReportingType {
        switch key {
  case "CommonwealthId":
   n.studentattendancecollectionreportingtype.CommonwealthId = nil
  case "EntityContact":
   n.studentattendancecollectionreportingtype.EntityContact = nil
  case "EntityName":
   n.studentattendancecollectionreportingtype.EntityName = nil
  case "StatsCohortYearLevelList":
   n.studentattendancecollectionreportingtype.StatsCohortYearLevelList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentAttendanceCollectionReportingType")
        }
        return n
}

// Set a sequence of properties
func (n *StudentAttendanceCollectionReportingType) SetProperties(props ...Prop) *StudentAttendanceCollectionReportingType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentAttendanceCollectionReportingType) SetProperty(key string, value interface{}) *StudentAttendanceCollectionReportingType {
        if n == nil {
                n, _ = StudentAttendanceCollectionReportingTypePointer(StudentAttendanceCollectionReportingType{})
        }
        switch key {
    case "CommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancecollectionreportingtype.CommonwealthId = ((*String)(v))
      }
    case "EntityContact":
    if v, ok:= EntityContactInfoTypePointer(value); ok {
      n.studentattendancecollectionreportingtype.EntityContact = v
      }
    case "EntityName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancecollectionreportingtype.EntityName = ((*String)(v))
      }
    case "StatsCohortYearLevelList":
    if v, ok:= StatsCohortYearLevelListTypePointer(value); ok {
      n.studentattendancecollectionreportingtype.StatsCohortYearLevelList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentAttendanceCollectionReportingType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollectionReportingType) CommonwealthId() *String {
    if s.studentattendancecollectionreportingtype.CommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancecollectionreportingtype.CommonwealthId = ((*String)(v))
      }
      }
      return s.studentattendancecollectionreportingtype.CommonwealthId
    }
// Returns whether the element value for CommonwealthId is nil in the container StudentAttendanceCollectionReportingType.
  func (s *StudentAttendanceCollectionReportingType) CommonwealthId_IsNil() bool {
    return s.studentattendancecollectionreportingtype.CommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollectionReportingType) EntityContact() *EntityContactInfoType {
    if s.studentattendancecollectionreportingtype.EntityContact == nil {
     if v, ok:= EntityContactInfoTypePointer(EntityContactInfoType{}); ok {
      s.studentattendancecollectionreportingtype.EntityContact = v
      }
      }
      return s.studentattendancecollectionreportingtype.EntityContact
    }
// Returns whether the element value for EntityContact is nil in the container StudentAttendanceCollectionReportingType.
  func (s *StudentAttendanceCollectionReportingType) EntityContact_IsNil() bool {
    return s.studentattendancecollectionreportingtype.EntityContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollectionReportingType) EntityName() *String {
    if s.studentattendancecollectionreportingtype.EntityName == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancecollectionreportingtype.EntityName = ((*String)(v))
      }
      }
      return s.studentattendancecollectionreportingtype.EntityName
    }
// Returns whether the element value for EntityName is nil in the container StudentAttendanceCollectionReportingType.
  func (s *StudentAttendanceCollectionReportingType) EntityName_IsNil() bool {
    return s.studentattendancecollectionreportingtype.EntityName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceCollectionReportingType) StatsCohortYearLevelList() *StatsCohortYearLevelListType {
    if s.studentattendancecollectionreportingtype.StatsCohortYearLevelList == nil {
     if v, ok:= StatsCohortYearLevelListTypePointer(StatsCohortYearLevelListType{}); ok {
      s.studentattendancecollectionreportingtype.StatsCohortYearLevelList = v
      }
      }
      return s.studentattendancecollectionreportingtype.StatsCohortYearLevelList
    }
// Returns whether the element value for StatsCohortYearLevelList is nil in the container StudentAttendanceCollectionReportingType.
  func (s *StudentAttendanceCollectionReportingType) StatsCohortYearLevelList_IsNil() bool {
    return s.studentattendancecollectionreportingtype.StatsCohortYearLevelList == nil
    }

// Set the value of a property to nil
func (n *StudentAttendanceSummary) Unset(key string) *StudentAttendanceSummary {
        switch key {
  case "DaysAttended":
   n.studentattendancesummary.DaysAttended = nil
  case "DaysInMembership":
   n.studentattendancesummary.DaysInMembership = nil
  case "DaysTardy":
   n.studentattendancesummary.DaysTardy = nil
  case "EndDate":
   n.studentattendancesummary.EndDate = nil
  case "EndDay":
   n.studentattendancesummary.EndDay = nil
  case "ExcusedAbsences":
   n.studentattendancesummary.ExcusedAbsences = nil
  case "FTE":
   n.studentattendancesummary.FTE = nil
  case "LocalCodeList":
   n.studentattendancesummary.LocalCodeList = nil
  case "SIF_ExtendedElements":
   n.studentattendancesummary.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentattendancesummary.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.studentattendancesummary.SchoolInfoRefId = nil
  case "SchoolYear":
   n.studentattendancesummary.SchoolYear = nil
  case "StartDate":
   n.studentattendancesummary.StartDate = nil
  case "StartDay":
   n.studentattendancesummary.StartDay = nil
  case "StudentAttendanceSummaryRefId":
   n.studentattendancesummary.StudentAttendanceSummaryRefId = nil
  case "StudentPersonalRefId":
   n.studentattendancesummary.StudentPersonalRefId = nil
  case "UnexcusedAbsences":
   n.studentattendancesummary.UnexcusedAbsences = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentAttendanceSummary")
        }
        return n
}

// Set a sequence of properties
func (n *StudentAttendanceSummary) SetProperties(props ...Prop) *StudentAttendanceSummary {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentAttendanceSummary) SetProperty(key string, value interface{}) *StudentAttendanceSummary {
        if n == nil {
                n, _ = StudentAttendanceSummaryPointer(StudentAttendanceSummary{})
        }
        switch key {
    case "DaysAttended":
    
    if v, ok:= FloatPointer(value); ok {
      n.studentattendancesummary.DaysAttended = ((*Float)(v))
      }
    case "DaysInMembership":
    
    if v, ok:= FloatPointer(value); ok {
      n.studentattendancesummary.DaysInMembership = ((*Float)(v))
      }
    case "DaysTardy":
    
    if v, ok:= FloatPointer(value); ok {
      n.studentattendancesummary.DaysTardy = ((*Float)(v))
      }
    case "EndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancesummary.EndDate = ((*String)(v))
      }
    case "EndDay":
    
    if v, ok:= IntPointer(value); ok {
      n.studentattendancesummary.EndDay = ((*Int)(v))
      }
    case "ExcusedAbsences":
    
    if v, ok:= FloatPointer(value); ok {
      n.studentattendancesummary.ExcusedAbsences = ((*Float)(v))
      }
    case "FTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancesummary.FTE = ((*FTEType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentattendancesummary.LocalCodeList = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentattendancesummary.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentattendancesummary.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancesummary.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancesummary.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancesummary.StartDate = ((*String)(v))
      }
    case "StartDay":
    
    if v, ok:= IntPointer(value); ok {
      n.studentattendancesummary.StartDay = ((*Int)(v))
      }
    case "StudentAttendanceSummaryRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancesummary.StudentAttendanceSummaryRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancesummary.StudentPersonalRefId = ((*String)(v))
      }
    case "UnexcusedAbsences":
    
    if v, ok:= FloatPointer(value); ok {
      n.studentattendancesummary.UnexcusedAbsences = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentAttendanceSummary")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) DaysAttended() *Float {
    if s.studentattendancesummary.DaysAttended == nil {
    if v, ok:= FloatPointer(0); ok {
      s.studentattendancesummary.DaysAttended = ((*Float)(v))
      }
      }
      return s.studentattendancesummary.DaysAttended
    }
// Returns whether the element value for DaysAttended is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) DaysAttended_IsNil() bool {
    return s.studentattendancesummary.DaysAttended == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) DaysInMembership() *Float {
    if s.studentattendancesummary.DaysInMembership == nil {
    if v, ok:= FloatPointer(0); ok {
      s.studentattendancesummary.DaysInMembership = ((*Float)(v))
      }
      }
      return s.studentattendancesummary.DaysInMembership
    }
// Returns whether the element value for DaysInMembership is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) DaysInMembership_IsNil() bool {
    return s.studentattendancesummary.DaysInMembership == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) DaysTardy() *Float {
    if s.studentattendancesummary.DaysTardy == nil {
    if v, ok:= FloatPointer(0); ok {
      s.studentattendancesummary.DaysTardy = ((*Float)(v))
      }
      }
      return s.studentattendancesummary.DaysTardy
    }
// Returns whether the element value for DaysTardy is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) DaysTardy_IsNil() bool {
    return s.studentattendancesummary.DaysTardy == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) EndDate() *String {
    if s.studentattendancesummary.EndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancesummary.EndDate = ((*String)(v))
      }
      }
      return s.studentattendancesummary.EndDate
    }
// Returns whether the element value for EndDate is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) EndDate_IsNil() bool {
    return s.studentattendancesummary.EndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) EndDay() *Int {
    if s.studentattendancesummary.EndDay == nil {
    if v, ok:= IntPointer(0); ok {
      s.studentattendancesummary.EndDay = ((*Int)(v))
      }
      }
      return s.studentattendancesummary.EndDay
    }
// Returns whether the element value for EndDay is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) EndDay_IsNil() bool {
    return s.studentattendancesummary.EndDay == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) ExcusedAbsences() *Float {
    if s.studentattendancesummary.ExcusedAbsences == nil {
    if v, ok:= FloatPointer(0); ok {
      s.studentattendancesummary.ExcusedAbsences = ((*Float)(v))
      }
      }
      return s.studentattendancesummary.ExcusedAbsences
    }
// Returns whether the element value for ExcusedAbsences is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) ExcusedAbsences_IsNil() bool {
    return s.studentattendancesummary.ExcusedAbsences == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) FTE() *FTEType {
    if s.studentattendancesummary.FTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancesummary.FTE = ((*FTEType)(v))
      }
      }
      return s.studentattendancesummary.FTE
    }
// Returns whether the element value for FTE is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) FTE_IsNil() bool {
    return s.studentattendancesummary.FTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) LocalCodeList() *LocalCodeListType {
    if s.studentattendancesummary.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentattendancesummary.LocalCodeList = v
      }
      }
      return s.studentattendancesummary.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) LocalCodeList_IsNil() bool {
    return s.studentattendancesummary.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentattendancesummary.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentattendancesummary.SIF_ExtendedElements = v
      }
      }
      return s.studentattendancesummary.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) SIF_ExtendedElements_IsNil() bool {
    return s.studentattendancesummary.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) SIF_Metadata() *SIF_MetadataType {
    if s.studentattendancesummary.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentattendancesummary.SIF_Metadata = v
      }
      }
      return s.studentattendancesummary.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) SIF_Metadata_IsNil() bool {
    return s.studentattendancesummary.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) SchoolInfoRefId() *String {
    if s.studentattendancesummary.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancesummary.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.studentattendancesummary.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) SchoolInfoRefId_IsNil() bool {
    return s.studentattendancesummary.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) SchoolYear() *SchoolYearType {
    if s.studentattendancesummary.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancesummary.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentattendancesummary.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) SchoolYear_IsNil() bool {
    return s.studentattendancesummary.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) StartDate() *String {
    if s.studentattendancesummary.StartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancesummary.StartDate = ((*String)(v))
      }
      }
      return s.studentattendancesummary.StartDate
    }
// Returns whether the element value for StartDate is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) StartDate_IsNil() bool {
    return s.studentattendancesummary.StartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) StartDay() *Int {
    if s.studentattendancesummary.StartDay == nil {
    if v, ok:= IntPointer(0); ok {
      s.studentattendancesummary.StartDay = ((*Int)(v))
      }
      }
      return s.studentattendancesummary.StartDay
    }
// Returns whether the element value for StartDay is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) StartDay_IsNil() bool {
    return s.studentattendancesummary.StartDay == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) StudentAttendanceSummaryRefId() *String {
    if s.studentattendancesummary.StudentAttendanceSummaryRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancesummary.StudentAttendanceSummaryRefId = ((*String)(v))
      }
      }
      return s.studentattendancesummary.StudentAttendanceSummaryRefId
    }
// Returns whether the element value for StudentAttendanceSummaryRefId is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) StudentAttendanceSummaryRefId_IsNil() bool {
    return s.studentattendancesummary.StudentAttendanceSummaryRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) StudentPersonalRefId() *String {
    if s.studentattendancesummary.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancesummary.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentattendancesummary.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) StudentPersonalRefId_IsNil() bool {
    return s.studentattendancesummary.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceSummary) UnexcusedAbsences() *Float {
    if s.studentattendancesummary.UnexcusedAbsences == nil {
    if v, ok:= FloatPointer(0); ok {
      s.studentattendancesummary.UnexcusedAbsences = ((*Float)(v))
      }
      }
      return s.studentattendancesummary.UnexcusedAbsences
    }
// Returns whether the element value for UnexcusedAbsences is nil in the container StudentAttendanceSummary.
  func (s *StudentAttendanceSummary) UnexcusedAbsences_IsNil() bool {
    return s.studentattendancesummary.UnexcusedAbsences == nil
    }

// Set the value of a property to nil
func (n *StudentAttendanceTimeList) Unset(key string) *StudentAttendanceTimeList {
        switch key {
  case "AttendanceTimes":
   n.studentattendancetimelist.AttendanceTimes = nil
  case "Date":
   n.studentattendancetimelist.Date = nil
  case "LocalCodeList":
   n.studentattendancetimelist.LocalCodeList = nil
  case "PeriodAttendances":
   n.studentattendancetimelist.PeriodAttendances = nil
  case "RefId":
   n.studentattendancetimelist.RefId = nil
  case "SIF_ExtendedElements":
   n.studentattendancetimelist.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentattendancetimelist.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.studentattendancetimelist.SchoolInfoRefId = nil
  case "SchoolYear":
   n.studentattendancetimelist.SchoolYear = nil
  case "StudentPersonalRefId":
   n.studentattendancetimelist.StudentPersonalRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentAttendanceTimeList")
        }
        return n
}

// Set a sequence of properties
func (n *StudentAttendanceTimeList) SetProperties(props ...Prop) *StudentAttendanceTimeList {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentAttendanceTimeList) SetProperty(key string, value interface{}) *StudentAttendanceTimeList {
        if n == nil {
                n, _ = StudentAttendanceTimeListPointer(StudentAttendanceTimeList{})
        }
        switch key {
    case "AttendanceTimes":
    if v, ok:= AttendanceTimesTypePointer(value); ok {
      n.studentattendancetimelist.AttendanceTimes = v
      }
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancetimelist.Date = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentattendancetimelist.LocalCodeList = v
      }
    case "PeriodAttendances":
    if v, ok:= PeriodAttendancesTypePointer(value); ok {
      n.studentattendancetimelist.PeriodAttendances = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancetimelist.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentattendancetimelist.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentattendancetimelist.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancetimelist.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancetimelist.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentattendancetimelist.StudentPersonalRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentAttendanceTimeList")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) AttendanceTimes() *AttendanceTimesType {
    if s.studentattendancetimelist.AttendanceTimes == nil {
     if v, ok:= AttendanceTimesTypePointer(AttendanceTimesType{}); ok {
      s.studentattendancetimelist.AttendanceTimes = v
      }
      }
      return s.studentattendancetimelist.AttendanceTimes
    }
// Returns whether the element value for AttendanceTimes is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) AttendanceTimes_IsNil() bool {
    return s.studentattendancetimelist.AttendanceTimes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) Date() *String {
    if s.studentattendancetimelist.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancetimelist.Date = ((*String)(v))
      }
      }
      return s.studentattendancetimelist.Date
    }
// Returns whether the element value for Date is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) Date_IsNil() bool {
    return s.studentattendancetimelist.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) LocalCodeList() *LocalCodeListType {
    if s.studentattendancetimelist.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentattendancetimelist.LocalCodeList = v
      }
      }
      return s.studentattendancetimelist.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) LocalCodeList_IsNil() bool {
    return s.studentattendancetimelist.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) PeriodAttendances() *PeriodAttendancesType {
    if s.studentattendancetimelist.PeriodAttendances == nil {
     if v, ok:= PeriodAttendancesTypePointer(PeriodAttendancesType{}); ok {
      s.studentattendancetimelist.PeriodAttendances = v
      }
      }
      return s.studentattendancetimelist.PeriodAttendances
    }
// Returns whether the element value for PeriodAttendances is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) PeriodAttendances_IsNil() bool {
    return s.studentattendancetimelist.PeriodAttendances == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) RefId() *RefIdType {
    if s.studentattendancetimelist.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancetimelist.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentattendancetimelist.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) RefId_IsNil() bool {
    return s.studentattendancetimelist.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentattendancetimelist.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentattendancetimelist.SIF_ExtendedElements = v
      }
      }
      return s.studentattendancetimelist.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) SIF_ExtendedElements_IsNil() bool {
    return s.studentattendancetimelist.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) SIF_Metadata() *SIF_MetadataType {
    if s.studentattendancetimelist.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentattendancetimelist.SIF_Metadata = v
      }
      }
      return s.studentattendancetimelist.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) SIF_Metadata_IsNil() bool {
    return s.studentattendancetimelist.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) SchoolInfoRefId() *String {
    if s.studentattendancetimelist.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancetimelist.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.studentattendancetimelist.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) SchoolInfoRefId_IsNil() bool {
    return s.studentattendancetimelist.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) SchoolYear() *SchoolYearType {
    if s.studentattendancetimelist.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancetimelist.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentattendancetimelist.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) SchoolYear_IsNil() bool {
    return s.studentattendancetimelist.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentAttendanceTimeList) StudentPersonalRefId() *String {
    if s.studentattendancetimelist.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentattendancetimelist.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentattendancetimelist.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentAttendanceTimeList.
  func (s *StudentAttendanceTimeList) StudentPersonalRefId_IsNil() bool {
    return s.studentattendancetimelist.StudentPersonalRefId == nil
    }

// Set the value of a property to nil
func (n *StudentContactFeePercentageType) Unset(key string) *StudentContactFeePercentageType {
        switch key {
  case "Curriculum":
   n.studentcontactfeepercentagetype.Curriculum = nil
  case "Other":
   n.studentcontactfeepercentagetype.Other = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentContactFeePercentageType")
        }
        return n
}

// Set a sequence of properties
func (n *StudentContactFeePercentageType) SetProperties(props ...Prop) *StudentContactFeePercentageType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentContactFeePercentageType) SetProperty(key string, value interface{}) *StudentContactFeePercentageType {
        if n == nil {
                n, _ = StudentContactFeePercentageTypePointer(StudentContactFeePercentageType{})
        }
        switch key {
    case "Curriculum":
    
    if v, ok:= FloatPointer(value); ok {
      n.studentcontactfeepercentagetype.Curriculum = ((*Float)(v))
      }
    case "Other":
    
    if v, ok:= FloatPointer(value); ok {
      n.studentcontactfeepercentagetype.Other = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentContactFeePercentageType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactFeePercentageType) Curriculum() *Float {
    if s.studentcontactfeepercentagetype.Curriculum == nil {
    if v, ok:= FloatPointer(0); ok {
      s.studentcontactfeepercentagetype.Curriculum = ((*Float)(v))
      }
      }
      return s.studentcontactfeepercentagetype.Curriculum
    }
// Returns whether the element value for Curriculum is nil in the container StudentContactFeePercentageType.
  func (s *StudentContactFeePercentageType) Curriculum_IsNil() bool {
    return s.studentcontactfeepercentagetype.Curriculum == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactFeePercentageType) Other() *Float {
    if s.studentcontactfeepercentagetype.Other == nil {
    if v, ok:= FloatPointer(0); ok {
      s.studentcontactfeepercentagetype.Other = ((*Float)(v))
      }
      }
      return s.studentcontactfeepercentagetype.Other
    }
// Returns whether the element value for Other is nil in the container StudentContactFeePercentageType.
  func (s *StudentContactFeePercentageType) Other_IsNil() bool {
    return s.studentcontactfeepercentagetype.Other == nil
    }

// Set the value of a property to nil
func (n *StudentContactPersonal) Unset(key string) *StudentContactPersonal {
        switch key {
  case "Employment":
   n.studentcontactpersonal.Employment = nil
  case "EmploymentType":
   n.studentcontactpersonal.EmploymentType = nil
  case "LocalCodeList":
   n.studentcontactpersonal.LocalCodeList = nil
  case "LocalId":
   n.studentcontactpersonal.LocalId = nil
  case "NonSchoolEducation":
   n.studentcontactpersonal.NonSchoolEducation = nil
  case "OtherIdList":
   n.studentcontactpersonal.OtherIdList = nil
  case "PersonInfo":
   n.studentcontactpersonal.PersonInfo = nil
  case "RefId":
   n.studentcontactpersonal.RefId = nil
  case "SIF_ExtendedElements":
   n.studentcontactpersonal.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentcontactpersonal.SIF_Metadata = nil
  case "SchoolEducationalLevel":
   n.studentcontactpersonal.SchoolEducationalLevel = nil
  case "WorkingWithChildrenCheck":
   n.studentcontactpersonal.WorkingWithChildrenCheck = nil
  case "Workplace":
   n.studentcontactpersonal.Workplace = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentContactPersonal")
        }
        return n
}

// Set a sequence of properties
func (n *StudentContactPersonal) SetProperties(props ...Prop) *StudentContactPersonal {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentContactPersonal) SetProperty(key string, value interface{}) *StudentContactPersonal {
        if n == nil {
                n, _ = StudentContactPersonalPointer(StudentContactPersonal{})
        }
        switch key {
    case "Employment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentcontactpersonal.Employment = ((*String)(v))
      }
    case "EmploymentType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEmploymentTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEmploymentTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentcontactpersonal.EmploymentType = ((*AUCodeSetsEmploymentTypeType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentcontactpersonal.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentcontactpersonal.LocalId = ((*LocalIdType)(v))
      }
    case "NonSchoolEducation":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNonSchoolEducationType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNonSchoolEducationType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentcontactpersonal.NonSchoolEducation = ((*AUCodeSetsNonSchoolEducationType)(v))
      }
    case "OtherIdList":
    if v, ok:= OtherIdListTypePointer(value); ok {
      n.studentcontactpersonal.OtherIdList = v
      }
    case "PersonInfo":
    if v, ok:= PersonInfoTypePointer(value); ok {
      n.studentcontactpersonal.PersonInfo = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentcontactpersonal.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentcontactpersonal.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentcontactpersonal.SIF_Metadata = v
      }
    case "SchoolEducationalLevel":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolEducationLevelTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolEducationLevelTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentcontactpersonal.SchoolEducationalLevel = ((*EducationalLevelType)(v))
      }
    case "WorkingWithChildrenCheck":
    if v, ok:= WorkingWithChildrenCheckTypePointer(value); ok {
      n.studentcontactpersonal.WorkingWithChildrenCheck = v
      }
    case "Workplace":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentcontactpersonal.Workplace = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentContactPersonal")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) Employment() *String {
    if s.studentcontactpersonal.Employment == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactpersonal.Employment = ((*String)(v))
      }
      }
      return s.studentcontactpersonal.Employment
    }
// Returns whether the element value for Employment is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) Employment_IsNil() bool {
    return s.studentcontactpersonal.Employment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) EmploymentType() *AUCodeSetsEmploymentTypeType {
    if s.studentcontactpersonal.EmploymentType == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactpersonal.EmploymentType = ((*AUCodeSetsEmploymentTypeType)(v))
      }
      }
      return s.studentcontactpersonal.EmploymentType
    }
// Returns whether the element value for EmploymentType is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) EmploymentType_IsNil() bool {
    return s.studentcontactpersonal.EmploymentType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) LocalCodeList() *LocalCodeListType {
    if s.studentcontactpersonal.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentcontactpersonal.LocalCodeList = v
      }
      }
      return s.studentcontactpersonal.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) LocalCodeList_IsNil() bool {
    return s.studentcontactpersonal.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) LocalId() *LocalIdType {
    if s.studentcontactpersonal.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactpersonal.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentcontactpersonal.LocalId
    }
// Returns whether the element value for LocalId is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) LocalId_IsNil() bool {
    return s.studentcontactpersonal.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) NonSchoolEducation() *AUCodeSetsNonSchoolEducationType {
    if s.studentcontactpersonal.NonSchoolEducation == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactpersonal.NonSchoolEducation = ((*AUCodeSetsNonSchoolEducationType)(v))
      }
      }
      return s.studentcontactpersonal.NonSchoolEducation
    }
// Returns whether the element value for NonSchoolEducation is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) NonSchoolEducation_IsNil() bool {
    return s.studentcontactpersonal.NonSchoolEducation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) OtherIdList() *OtherIdListType {
    if s.studentcontactpersonal.OtherIdList == nil {
     if v, ok:= OtherIdListTypePointer(OtherIdListType{}); ok {
      s.studentcontactpersonal.OtherIdList = v
      }
      }
      return s.studentcontactpersonal.OtherIdList
    }
// Returns whether the element value for OtherIdList is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) OtherIdList_IsNil() bool {
    return s.studentcontactpersonal.OtherIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) PersonInfo() *PersonInfoType {
    if s.studentcontactpersonal.PersonInfo == nil {
     if v, ok:= PersonInfoTypePointer(PersonInfoType{}); ok {
      s.studentcontactpersonal.PersonInfo = v
      }
      }
      return s.studentcontactpersonal.PersonInfo
    }
// Returns whether the element value for PersonInfo is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) PersonInfo_IsNil() bool {
    return s.studentcontactpersonal.PersonInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) RefId() *RefIdType {
    if s.studentcontactpersonal.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactpersonal.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentcontactpersonal.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) RefId_IsNil() bool {
    return s.studentcontactpersonal.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentcontactpersonal.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentcontactpersonal.SIF_ExtendedElements = v
      }
      }
      return s.studentcontactpersonal.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) SIF_ExtendedElements_IsNil() bool {
    return s.studentcontactpersonal.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) SIF_Metadata() *SIF_MetadataType {
    if s.studentcontactpersonal.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentcontactpersonal.SIF_Metadata = v
      }
      }
      return s.studentcontactpersonal.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) SIF_Metadata_IsNil() bool {
    return s.studentcontactpersonal.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) SchoolEducationalLevel() *EducationalLevelType {
    if s.studentcontactpersonal.SchoolEducationalLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactpersonal.SchoolEducationalLevel = ((*EducationalLevelType)(v))
      }
      }
      return s.studentcontactpersonal.SchoolEducationalLevel
    }
// Returns whether the element value for SchoolEducationalLevel is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) SchoolEducationalLevel_IsNil() bool {
    return s.studentcontactpersonal.SchoolEducationalLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) WorkingWithChildrenCheck() *WorkingWithChildrenCheckType {
    if s.studentcontactpersonal.WorkingWithChildrenCheck == nil {
     if v, ok:= WorkingWithChildrenCheckTypePointer(WorkingWithChildrenCheckType{}); ok {
      s.studentcontactpersonal.WorkingWithChildrenCheck = v
      }
      }
      return s.studentcontactpersonal.WorkingWithChildrenCheck
    }
// Returns whether the element value for WorkingWithChildrenCheck is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) WorkingWithChildrenCheck_IsNil() bool {
    return s.studentcontactpersonal.WorkingWithChildrenCheck == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactPersonal) Workplace() *String {
    if s.studentcontactpersonal.Workplace == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactpersonal.Workplace = ((*String)(v))
      }
      }
      return s.studentcontactpersonal.Workplace
    }
// Returns whether the element value for Workplace is nil in the container StudentContactPersonal.
  func (s *StudentContactPersonal) Workplace_IsNil() bool {
    return s.studentcontactpersonal.Workplace == nil
    }

// Set the value of a property to nil
func (n *StudentContactRelationship) Unset(key string) *StudentContactRelationship {
        switch key {
  case "ContactFlags":
   n.studentcontactrelationship.ContactFlags = nil
  case "ContactMethod":
   n.studentcontactrelationship.ContactMethod = nil
  case "ContactSequence":
   n.studentcontactrelationship.ContactSequence = nil
  case "ContactSequenceSource":
   n.studentcontactrelationship.ContactSequenceSource = nil
  case "FeePercentage":
   n.studentcontactrelationship.FeePercentage = nil
  case "HouseholdList":
   n.studentcontactrelationship.HouseholdList = nil
  case "LocalCodeList":
   n.studentcontactrelationship.LocalCodeList = nil
  case "MainlySpeaksEnglishAtHome":
   n.studentcontactrelationship.MainlySpeaksEnglishAtHome = nil
  case "ParentRelationshipStatus":
   n.studentcontactrelationship.ParentRelationshipStatus = nil
  case "Relationship":
   n.studentcontactrelationship.Relationship = nil
  case "SIF_ExtendedElements":
   n.studentcontactrelationship.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentcontactrelationship.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.studentcontactrelationship.SchoolInfoRefId = nil
  case "StudentContactPersonalRefId":
   n.studentcontactrelationship.StudentContactPersonalRefId = nil
  case "StudentContactRelationshipRefId":
   n.studentcontactrelationship.StudentContactRelationshipRefId = nil
  case "StudentPersonalRefId":
   n.studentcontactrelationship.StudentPersonalRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentContactRelationship")
        }
        return n
}

// Set a sequence of properties
func (n *StudentContactRelationship) SetProperties(props ...Prop) *StudentContactRelationship {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentContactRelationship) SetProperty(key string, value interface{}) *StudentContactRelationship {
        if n == nil {
                n, _ = StudentContactRelationshipPointer(StudentContactRelationship{})
        }
        switch key {
    case "ContactFlags":
    if v, ok:= ContactFlagsTypePointer(value); ok {
      n.studentcontactrelationship.ContactFlags = v
      }
    case "ContactMethod":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsContactMethodType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsContactMethodType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentcontactrelationship.ContactMethod = ((*AUCodeSetsContactMethodType)(v))
      }
    case "ContactSequence":
    
    if v, ok:= IntPointer(value); ok {
      n.studentcontactrelationship.ContactSequence = ((*Int)(v))
      }
    case "ContactSequenceSource":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSourceCodeTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSourceCodeTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentcontactrelationship.ContactSequenceSource = ((*AUCodeSetsSourceCodeTypeType)(v))
      }
    case "FeePercentage":
    if v, ok:= StudentContactFeePercentageTypePointer(value); ok {
      n.studentcontactrelationship.FeePercentage = v
      }
    case "HouseholdList":
    if v, ok:= HouseholdListTypePointer(value); ok {
      n.studentcontactrelationship.HouseholdList = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentcontactrelationship.LocalCodeList = v
      }
    case "MainlySpeaksEnglishAtHome":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentcontactrelationship.MainlySpeaksEnglishAtHome = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "ParentRelationshipStatus":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentcontactrelationship.ParentRelationshipStatus = ((*String)(v))
      }
    case "Relationship":
    if v, ok:= RelationshipTypePointer(value); ok {
      n.studentcontactrelationship.Relationship = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentcontactrelationship.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentcontactrelationship.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentcontactrelationship.SchoolInfoRefId = ((*String)(v))
      }
    case "StudentContactPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentcontactrelationship.StudentContactPersonalRefId = ((*RefIdType)(v))
      }
    case "StudentContactRelationshipRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentcontactrelationship.StudentContactRelationshipRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentcontactrelationship.StudentPersonalRefId = ((*RefIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentContactRelationship")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) ContactFlags() *ContactFlagsType {
    if s.studentcontactrelationship.ContactFlags == nil {
     if v, ok:= ContactFlagsTypePointer(ContactFlagsType{}); ok {
      s.studentcontactrelationship.ContactFlags = v
      }
      }
      return s.studentcontactrelationship.ContactFlags
    }
// Returns whether the element value for ContactFlags is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) ContactFlags_IsNil() bool {
    return s.studentcontactrelationship.ContactFlags == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) ContactMethod() *AUCodeSetsContactMethodType {
    if s.studentcontactrelationship.ContactMethod == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactrelationship.ContactMethod = ((*AUCodeSetsContactMethodType)(v))
      }
      }
      return s.studentcontactrelationship.ContactMethod
    }
// Returns whether the element value for ContactMethod is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) ContactMethod_IsNil() bool {
    return s.studentcontactrelationship.ContactMethod == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) ContactSequence() *Int {
    if s.studentcontactrelationship.ContactSequence == nil {
    if v, ok:= IntPointer(0); ok {
      s.studentcontactrelationship.ContactSequence = ((*Int)(v))
      }
      }
      return s.studentcontactrelationship.ContactSequence
    }
// Returns whether the element value for ContactSequence is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) ContactSequence_IsNil() bool {
    return s.studentcontactrelationship.ContactSequence == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) ContactSequenceSource() *AUCodeSetsSourceCodeTypeType {
    if s.studentcontactrelationship.ContactSequenceSource == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactrelationship.ContactSequenceSource = ((*AUCodeSetsSourceCodeTypeType)(v))
      }
      }
      return s.studentcontactrelationship.ContactSequenceSource
    }
// Returns whether the element value for ContactSequenceSource is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) ContactSequenceSource_IsNil() bool {
    return s.studentcontactrelationship.ContactSequenceSource == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) FeePercentage() *StudentContactFeePercentageType {
    if s.studentcontactrelationship.FeePercentage == nil {
     if v, ok:= StudentContactFeePercentageTypePointer(StudentContactFeePercentageType{}); ok {
      s.studentcontactrelationship.FeePercentage = v
      }
      }
      return s.studentcontactrelationship.FeePercentage
    }
// Returns whether the element value for FeePercentage is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) FeePercentage_IsNil() bool {
    return s.studentcontactrelationship.FeePercentage == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) HouseholdList() *HouseholdListType {
    if s.studentcontactrelationship.HouseholdList == nil {
     if v, ok:= HouseholdListTypePointer(HouseholdListType{}); ok {
      s.studentcontactrelationship.HouseholdList = v
      }
      }
      return s.studentcontactrelationship.HouseholdList
    }
// Returns whether the element value for HouseholdList is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) HouseholdList_IsNil() bool {
    return s.studentcontactrelationship.HouseholdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) LocalCodeList() *LocalCodeListType {
    if s.studentcontactrelationship.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentcontactrelationship.LocalCodeList = v
      }
      }
      return s.studentcontactrelationship.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) LocalCodeList_IsNil() bool {
    return s.studentcontactrelationship.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) MainlySpeaksEnglishAtHome() *AUCodeSetsYesOrNoCategoryType {
    if s.studentcontactrelationship.MainlySpeaksEnglishAtHome == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactrelationship.MainlySpeaksEnglishAtHome = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentcontactrelationship.MainlySpeaksEnglishAtHome
    }
// Returns whether the element value for MainlySpeaksEnglishAtHome is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) MainlySpeaksEnglishAtHome_IsNil() bool {
    return s.studentcontactrelationship.MainlySpeaksEnglishAtHome == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) ParentRelationshipStatus() *String {
    if s.studentcontactrelationship.ParentRelationshipStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactrelationship.ParentRelationshipStatus = ((*String)(v))
      }
      }
      return s.studentcontactrelationship.ParentRelationshipStatus
    }
// Returns whether the element value for ParentRelationshipStatus is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) ParentRelationshipStatus_IsNil() bool {
    return s.studentcontactrelationship.ParentRelationshipStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) Relationship() *RelationshipType {
    if s.studentcontactrelationship.Relationship == nil {
     if v, ok:= RelationshipTypePointer(RelationshipType{}); ok {
      s.studentcontactrelationship.Relationship = v
      }
      }
      return s.studentcontactrelationship.Relationship
    }
// Returns whether the element value for Relationship is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) Relationship_IsNil() bool {
    return s.studentcontactrelationship.Relationship == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentcontactrelationship.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentcontactrelationship.SIF_ExtendedElements = v
      }
      }
      return s.studentcontactrelationship.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) SIF_ExtendedElements_IsNil() bool {
    return s.studentcontactrelationship.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) SIF_Metadata() *SIF_MetadataType {
    if s.studentcontactrelationship.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentcontactrelationship.SIF_Metadata = v
      }
      }
      return s.studentcontactrelationship.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) SIF_Metadata_IsNil() bool {
    return s.studentcontactrelationship.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) SchoolInfoRefId() *String {
    if s.studentcontactrelationship.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactrelationship.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.studentcontactrelationship.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) SchoolInfoRefId_IsNil() bool {
    return s.studentcontactrelationship.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) StudentContactPersonalRefId() *RefIdType {
    if s.studentcontactrelationship.StudentContactPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactrelationship.StudentContactPersonalRefId = ((*RefIdType)(v))
      }
      }
      return s.studentcontactrelationship.StudentContactPersonalRefId
    }
// Returns whether the element value for StudentContactPersonalRefId is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) StudentContactPersonalRefId_IsNil() bool {
    return s.studentcontactrelationship.StudentContactPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) StudentContactRelationshipRefId() *String {
    if s.studentcontactrelationship.StudentContactRelationshipRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactrelationship.StudentContactRelationshipRefId = ((*String)(v))
      }
      }
      return s.studentcontactrelationship.StudentContactRelationshipRefId
    }
// Returns whether the element value for StudentContactRelationshipRefId is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) StudentContactRelationshipRefId_IsNil() bool {
    return s.studentcontactrelationship.StudentContactRelationshipRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentContactRelationship) StudentPersonalRefId() *RefIdType {
    if s.studentcontactrelationship.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentcontactrelationship.StudentPersonalRefId = ((*RefIdType)(v))
      }
      }
      return s.studentcontactrelationship.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentContactRelationship.
  func (s *StudentContactRelationship) StudentPersonalRefId_IsNil() bool {
    return s.studentcontactrelationship.StudentPersonalRefId == nil
    }

// Set the value of a property to nil
func (n *StudentDailyAttendance) Unset(key string) *StudentDailyAttendance {
        switch key {
  case "AbsenceValue":
   n.studentdailyattendance.AbsenceValue = nil
  case "AttendanceCode":
   n.studentdailyattendance.AttendanceCode = nil
  case "AttendanceNote":
   n.studentdailyattendance.AttendanceNote = nil
  case "AttendanceStatus":
   n.studentdailyattendance.AttendanceStatus = nil
  case "Date":
   n.studentdailyattendance.Date = nil
  case "DayValue":
   n.studentdailyattendance.DayValue = nil
  case "LocalCodeList":
   n.studentdailyattendance.LocalCodeList = nil
  case "RefId":
   n.studentdailyattendance.RefId = nil
  case "SIF_ExtendedElements":
   n.studentdailyattendance.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentdailyattendance.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.studentdailyattendance.SchoolInfoRefId = nil
  case "SchoolYear":
   n.studentdailyattendance.SchoolYear = nil
  case "StudentPersonalRefId":
   n.studentdailyattendance.StudentPersonalRefId = nil
  case "TimeIn":
   n.studentdailyattendance.TimeIn = nil
  case "TimeOut":
   n.studentdailyattendance.TimeOut = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentDailyAttendance")
        }
        return n
}

// Set a sequence of properties
func (n *StudentDailyAttendance) SetProperties(props ...Prop) *StudentDailyAttendance {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentDailyAttendance) SetProperty(key string, value interface{}) *StudentDailyAttendance {
        if n == nil {
                n, _ = StudentDailyAttendancePointer(StudentDailyAttendance{})
        }
        switch key {
    case "AbsenceValue":
    
    if v, ok:= FloatPointer(value); ok {
      n.studentdailyattendance.AbsenceValue = ((*Float)(v))
      }
    case "AttendanceCode":
    if v, ok:= AttendanceCodeTypePointer(value); ok {
      n.studentdailyattendance.AttendanceCode = v
      }
    case "AttendanceNote":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.AttendanceNote = ((*String)(v))
      }
    case "AttendanceStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAttendanceStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAttendanceStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.AttendanceStatus = ((*AUCodeSetsAttendanceStatusType)(v))
      }
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.Date = ((*String)(v))
      }
    case "DayValue":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsDayValueCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsDayValueCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.DayValue = ((*AUCodeSetsDayValueCodeType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentdailyattendance.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentdailyattendance.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentdailyattendance.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.StudentPersonalRefId = ((*String)(v))
      }
    case "TimeIn":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.TimeIn = ((*String)(v))
      }
    case "TimeOut":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdailyattendance.TimeOut = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentDailyAttendance")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) AbsenceValue() *Float {
    if s.studentdailyattendance.AbsenceValue == nil {
    if v, ok:= FloatPointer(0); ok {
      s.studentdailyattendance.AbsenceValue = ((*Float)(v))
      }
      }
      return s.studentdailyattendance.AbsenceValue
    }
// Returns whether the element value for AbsenceValue is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) AbsenceValue_IsNil() bool {
    return s.studentdailyattendance.AbsenceValue == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) AttendanceCode() *AttendanceCodeType {
    if s.studentdailyattendance.AttendanceCode == nil {
     if v, ok:= AttendanceCodeTypePointer(AttendanceCodeType{}); ok {
      s.studentdailyattendance.AttendanceCode = v
      }
      }
      return s.studentdailyattendance.AttendanceCode
    }
// Returns whether the element value for AttendanceCode is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) AttendanceCode_IsNil() bool {
    return s.studentdailyattendance.AttendanceCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) AttendanceNote() *String {
    if s.studentdailyattendance.AttendanceNote == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.AttendanceNote = ((*String)(v))
      }
      }
      return s.studentdailyattendance.AttendanceNote
    }
// Returns whether the element value for AttendanceNote is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) AttendanceNote_IsNil() bool {
    return s.studentdailyattendance.AttendanceNote == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) AttendanceStatus() *AUCodeSetsAttendanceStatusType {
    if s.studentdailyattendance.AttendanceStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.AttendanceStatus = ((*AUCodeSetsAttendanceStatusType)(v))
      }
      }
      return s.studentdailyattendance.AttendanceStatus
    }
// Returns whether the element value for AttendanceStatus is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) AttendanceStatus_IsNil() bool {
    return s.studentdailyattendance.AttendanceStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) Date() *String {
    if s.studentdailyattendance.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.Date = ((*String)(v))
      }
      }
      return s.studentdailyattendance.Date
    }
// Returns whether the element value for Date is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) Date_IsNil() bool {
    return s.studentdailyattendance.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) DayValue() *AUCodeSetsDayValueCodeType {
    if s.studentdailyattendance.DayValue == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.DayValue = ((*AUCodeSetsDayValueCodeType)(v))
      }
      }
      return s.studentdailyattendance.DayValue
    }
// Returns whether the element value for DayValue is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) DayValue_IsNil() bool {
    return s.studentdailyattendance.DayValue == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) LocalCodeList() *LocalCodeListType {
    if s.studentdailyattendance.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentdailyattendance.LocalCodeList = v
      }
      }
      return s.studentdailyattendance.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) LocalCodeList_IsNil() bool {
    return s.studentdailyattendance.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) RefId() *RefIdType {
    if s.studentdailyattendance.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentdailyattendance.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) RefId_IsNil() bool {
    return s.studentdailyattendance.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentdailyattendance.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentdailyattendance.SIF_ExtendedElements = v
      }
      }
      return s.studentdailyattendance.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) SIF_ExtendedElements_IsNil() bool {
    return s.studentdailyattendance.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) SIF_Metadata() *SIF_MetadataType {
    if s.studentdailyattendance.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentdailyattendance.SIF_Metadata = v
      }
      }
      return s.studentdailyattendance.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) SIF_Metadata_IsNil() bool {
    return s.studentdailyattendance.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) SchoolInfoRefId() *String {
    if s.studentdailyattendance.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.studentdailyattendance.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) SchoolInfoRefId_IsNil() bool {
    return s.studentdailyattendance.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) SchoolYear() *SchoolYearType {
    if s.studentdailyattendance.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentdailyattendance.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) SchoolYear_IsNil() bool {
    return s.studentdailyattendance.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) StudentPersonalRefId() *String {
    if s.studentdailyattendance.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentdailyattendance.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) StudentPersonalRefId_IsNil() bool {
    return s.studentdailyattendance.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) TimeIn() *String {
    if s.studentdailyattendance.TimeIn == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.TimeIn = ((*String)(v))
      }
      }
      return s.studentdailyattendance.TimeIn
    }
// Returns whether the element value for TimeIn is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) TimeIn_IsNil() bool {
    return s.studentdailyattendance.TimeIn == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDailyAttendance) TimeOut() *String {
    if s.studentdailyattendance.TimeOut == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdailyattendance.TimeOut = ((*String)(v))
      }
      }
      return s.studentdailyattendance.TimeOut
    }
// Returns whether the element value for TimeOut is nil in the container StudentDailyAttendance.
  func (s *StudentDailyAttendance) TimeOut_IsNil() bool {
    return s.studentdailyattendance.TimeOut == nil
    }

// Set the value of a property to nil
func (n *StudentDataTransferNote) Unset(key string) *StudentDataTransferNote {
        switch key {
  case "AdditionalNotes":
   n.studentdatatransfernote.AdditionalNotes = nil
  case "ArrivalSchool":
   n.studentdatatransfernote.ArrivalSchool = nil
  case "Attendance":
   n.studentdatatransfernote.Attendance = nil
  case "AustralianCitizenship":
   n.studentdatatransfernote.AustralianCitizenship = nil
  case "BirthDate":
   n.studentdatatransfernote.BirthDate = nil
  case "ChildSubjectToOrders":
   n.studentdatatransfernote.ChildSubjectToOrders = nil
  case "Consent":
   n.studentdatatransfernote.Consent = nil
  case "CountryOfBirth":
   n.studentdatatransfernote.CountryOfBirth = nil
  case "DepartureSchool":
   n.studentdatatransfernote.DepartureSchool = nil
  case "DisciplinaryAbsences":
   n.studentdatatransfernote.DisciplinaryAbsences = nil
  case "EducationalAssessmentList":
   n.studentdatatransfernote.EducationalAssessmentList = nil
  case "FollowupRequest":
   n.studentdatatransfernote.FollowupRequest = nil
  case "Gender":
   n.studentdatatransfernote.Gender = nil
  case "Healthcare":
   n.studentdatatransfernote.Healthcare = nil
  case "IndigenousStatus":
   n.studentdatatransfernote.IndigenousStatus = nil
  case "IndividualBehaviourManagementPlan":
   n.studentdatatransfernote.IndividualBehaviourManagementPlan = nil
  case "InterestTalents":
   n.studentdatatransfernote.InterestTalents = nil
  case "LBOTE":
   n.studentdatatransfernote.LBOTE = nil
  case "LatestReportAvailable":
   n.studentdatatransfernote.LatestReportAvailable = nil
  case "LocalCodeList":
   n.studentdatatransfernote.LocalCodeList = nil
  case "NAPLANScoreList":
   n.studentdatatransfernote.NAPLANScoreList = nil
  case "NCCDList":
   n.studentdatatransfernote.NCCDList = nil
  case "Name":
   n.studentdatatransfernote.Name = nil
  case "NationalUniqueStudentIdentifier":
   n.studentdatatransfernote.NationalUniqueStudentIdentifier = nil
  case "OtherNames":
   n.studentdatatransfernote.OtherNames = nil
  case "PlaceOfBirth":
   n.studentdatatransfernote.PlaceOfBirth = nil
  case "PreviousSchoolList":
   n.studentdatatransfernote.PreviousSchoolList = nil
  case "RefId":
   n.studentdatatransfernote.RefId = nil
  case "RequestID":
   n.studentdatatransfernote.RequestID = nil
  case "SIF_ExtendedElements":
   n.studentdatatransfernote.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentdatatransfernote.SIF_Metadata = nil
  case "STDNAttachmentList":
   n.studentdatatransfernote.STDNAttachmentList = nil
  case "StateOfBirth":
   n.studentdatatransfernote.StateOfBirth = nil
  case "StudentGradeList":
   n.studentdatatransfernote.StudentGradeList = nil
  case "SupportNeeds":
   n.studentdatatransfernote.SupportNeeds = nil
  case "VisaStatus":
   n.studentdatatransfernote.VisaStatus = nil
  case "YearLevel":
   n.studentdatatransfernote.YearLevel = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentDataTransferNote")
        }
        return n
}

// Set a sequence of properties
func (n *StudentDataTransferNote) SetProperties(props ...Prop) *StudentDataTransferNote {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentDataTransferNote) SetProperty(key string, value interface{}) *StudentDataTransferNote {
        if n == nil {
                n, _ = StudentDataTransferNotePointer(StudentDataTransferNote{})
        }
        switch key {
    case "AdditionalNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.AdditionalNotes = ((*String)(v))
      }
    case "ArrivalSchool":
    if v, ok:= ArrivalSchoolTypePointer(value); ok {
      n.studentdatatransfernote.ArrivalSchool = v
      }
    case "Attendance":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.Attendance = ((*Bool)(v))
      }
    case "AustralianCitizenship":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.AustralianCitizenship = ((*Bool)(v))
      }
    case "BirthDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.BirthDate = ((*BirthDateType)(v))
      }
    case "ChildSubjectToOrders":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.ChildSubjectToOrders = ((*Bool)(v))
      }
    case "Consent":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.Consent = ((*Bool)(v))
      }
    case "CountryOfBirth":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsStandardAustralianClassificationOfCountriesSACCType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.CountryOfBirth = ((*CountryType)(v))
      }
    case "DepartureSchool":
    if v, ok:= DepartureSchoolTypePointer(value); ok {
      n.studentdatatransfernote.DepartureSchool = v
      }
    case "DisciplinaryAbsences":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.DisciplinaryAbsences = ((*Bool)(v))
      }
    case "EducationalAssessmentList":
    if v, ok:= EducationalAssessmentListTypePointer(value); ok {
      n.studentdatatransfernote.EducationalAssessmentList = v
      }
    case "FollowupRequest":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.FollowupRequest = ((*Bool)(v))
      }
    case "Gender":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSexCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSexCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.Gender = ((*AUCodeSetsSexCodeType)(v))
      }
    case "Healthcare":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.Healthcare = ((*Bool)(v))
      }
    case "IndigenousStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsIndigenousStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsIndigenousStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.IndigenousStatus = ((*AUCodeSetsIndigenousStatusType)(v))
      }
    case "IndividualBehaviourManagementPlan":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.IndividualBehaviourManagementPlan = ((*Bool)(v))
      }
    case "InterestTalents":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.InterestTalents = ((*String)(v))
      }
    case "LBOTE":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.LBOTE = ((*Bool)(v))
      }
    case "LatestReportAvailable":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentdatatransfernote.LatestReportAvailable = ((*Bool)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentdatatransfernote.LocalCodeList = v
      }
    case "NAPLANScoreList":
    if v, ok:= NAPLANScoreWithYearsListTypePointer(value); ok {
      n.studentdatatransfernote.NAPLANScoreList = v
      }
    case "NCCDList":
    if v, ok:= NCCDListTypePointer(value); ok {
      n.studentdatatransfernote.NCCDList = v
      }
    case "Name":
    if v, ok:= NameOfRecordTypePointer(value); ok {
      n.studentdatatransfernote.Name = v
      }
    case "NationalUniqueStudentIdentifier":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.NationalUniqueStudentIdentifier = ((*String)(v))
      }
    case "OtherNames":
    if v, ok:= OtherNamesTypePointer(value); ok {
      n.studentdatatransfernote.OtherNames = v
      }
    case "PlaceOfBirth":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.PlaceOfBirth = ((*String)(v))
      }
    case "PreviousSchoolList":
    if v, ok:= PreviousSchoolListTypePointer(value); ok {
      n.studentdatatransfernote.PreviousSchoolList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.RefId = ((*RefIdType)(v))
      }
    case "RequestID":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.RequestID = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentdatatransfernote.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentdatatransfernote.SIF_Metadata = v
      }
    case "STDNAttachmentList":
    if v, ok:= STDNAttachmentListTypePointer(value); ok {
      n.studentdatatransfernote.STDNAttachmentList = v
      }
    case "StateOfBirth":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentdatatransfernote.StateOfBirth = ((*StateProvinceType)(v))
      }
    case "StudentGradeList":
    if v, ok:= STDNGradeListTypePointer(value); ok {
      n.studentdatatransfernote.StudentGradeList = v
      }
    case "SupportNeeds":
    if v, ok:= STDNSupportNeedsTypePointer(value); ok {
      n.studentdatatransfernote.SupportNeeds = v
      }
    case "VisaStatus":
    if v, ok:= VisaSubClassTypePointer(value); ok {
      n.studentdatatransfernote.VisaStatus = v
      }
    case "YearLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.studentdatatransfernote.YearLevel = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentDataTransferNote")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) AdditionalNotes() *String {
    if s.studentdatatransfernote.AdditionalNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.AdditionalNotes = ((*String)(v))
      }
      }
      return s.studentdatatransfernote.AdditionalNotes
    }
// Returns whether the element value for AdditionalNotes is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) AdditionalNotes_IsNil() bool {
    return s.studentdatatransfernote.AdditionalNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) ArrivalSchool() *ArrivalSchoolType {
    if s.studentdatatransfernote.ArrivalSchool == nil {
     if v, ok:= ArrivalSchoolTypePointer(ArrivalSchoolType{}); ok {
      s.studentdatatransfernote.ArrivalSchool = v
      }
      }
      return s.studentdatatransfernote.ArrivalSchool
    }
// Returns whether the element value for ArrivalSchool is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) ArrivalSchool_IsNil() bool {
    return s.studentdatatransfernote.ArrivalSchool == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) Attendance() *Bool {
    if s.studentdatatransfernote.Attendance == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.Attendance = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.Attendance
    }
// Returns whether the element value for Attendance is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) Attendance_IsNil() bool {
    return s.studentdatatransfernote.Attendance == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) AustralianCitizenship() *Bool {
    if s.studentdatatransfernote.AustralianCitizenship == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.AustralianCitizenship = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.AustralianCitizenship
    }
// Returns whether the element value for AustralianCitizenship is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) AustralianCitizenship_IsNil() bool {
    return s.studentdatatransfernote.AustralianCitizenship == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) BirthDate() *BirthDateType {
    if s.studentdatatransfernote.BirthDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.BirthDate = ((*BirthDateType)(v))
      }
      }
      return s.studentdatatransfernote.BirthDate
    }
// Returns whether the element value for BirthDate is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) BirthDate_IsNil() bool {
    return s.studentdatatransfernote.BirthDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) ChildSubjectToOrders() *Bool {
    if s.studentdatatransfernote.ChildSubjectToOrders == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.ChildSubjectToOrders = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.ChildSubjectToOrders
    }
// Returns whether the element value for ChildSubjectToOrders is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) ChildSubjectToOrders_IsNil() bool {
    return s.studentdatatransfernote.ChildSubjectToOrders == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) Consent() *Bool {
    if s.studentdatatransfernote.Consent == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.Consent = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.Consent
    }
// Returns whether the element value for Consent is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) Consent_IsNil() bool {
    return s.studentdatatransfernote.Consent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) CountryOfBirth() *CountryType {
    if s.studentdatatransfernote.CountryOfBirth == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.CountryOfBirth = ((*CountryType)(v))
      }
      }
      return s.studentdatatransfernote.CountryOfBirth
    }
// Returns whether the element value for CountryOfBirth is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) CountryOfBirth_IsNil() bool {
    return s.studentdatatransfernote.CountryOfBirth == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) DepartureSchool() *DepartureSchoolType {
    if s.studentdatatransfernote.DepartureSchool == nil {
     if v, ok:= DepartureSchoolTypePointer(DepartureSchoolType{}); ok {
      s.studentdatatransfernote.DepartureSchool = v
      }
      }
      return s.studentdatatransfernote.DepartureSchool
    }
// Returns whether the element value for DepartureSchool is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) DepartureSchool_IsNil() bool {
    return s.studentdatatransfernote.DepartureSchool == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) DisciplinaryAbsences() *Bool {
    if s.studentdatatransfernote.DisciplinaryAbsences == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.DisciplinaryAbsences = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.DisciplinaryAbsences
    }
// Returns whether the element value for DisciplinaryAbsences is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) DisciplinaryAbsences_IsNil() bool {
    return s.studentdatatransfernote.DisciplinaryAbsences == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) EducationalAssessmentList() *EducationalAssessmentListType {
    if s.studentdatatransfernote.EducationalAssessmentList == nil {
     if v, ok:= EducationalAssessmentListTypePointer(EducationalAssessmentListType{}); ok {
      s.studentdatatransfernote.EducationalAssessmentList = v
      }
      }
      return s.studentdatatransfernote.EducationalAssessmentList
    }
// Returns whether the element value for EducationalAssessmentList is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) EducationalAssessmentList_IsNil() bool {
    return s.studentdatatransfernote.EducationalAssessmentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) FollowupRequest() *Bool {
    if s.studentdatatransfernote.FollowupRequest == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.FollowupRequest = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.FollowupRequest
    }
// Returns whether the element value for FollowupRequest is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) FollowupRequest_IsNil() bool {
    return s.studentdatatransfernote.FollowupRequest == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) Gender() *AUCodeSetsSexCodeType {
    if s.studentdatatransfernote.Gender == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.Gender = ((*AUCodeSetsSexCodeType)(v))
      }
      }
      return s.studentdatatransfernote.Gender
    }
// Returns whether the element value for Gender is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) Gender_IsNil() bool {
    return s.studentdatatransfernote.Gender == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) Healthcare() *Bool {
    if s.studentdatatransfernote.Healthcare == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.Healthcare = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.Healthcare
    }
// Returns whether the element value for Healthcare is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) Healthcare_IsNil() bool {
    return s.studentdatatransfernote.Healthcare == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) IndigenousStatus() *AUCodeSetsIndigenousStatusType {
    if s.studentdatatransfernote.IndigenousStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.IndigenousStatus = ((*AUCodeSetsIndigenousStatusType)(v))
      }
      }
      return s.studentdatatransfernote.IndigenousStatus
    }
// Returns whether the element value for IndigenousStatus is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) IndigenousStatus_IsNil() bool {
    return s.studentdatatransfernote.IndigenousStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) IndividualBehaviourManagementPlan() *Bool {
    if s.studentdatatransfernote.IndividualBehaviourManagementPlan == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.IndividualBehaviourManagementPlan = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.IndividualBehaviourManagementPlan
    }
// Returns whether the element value for IndividualBehaviourManagementPlan is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) IndividualBehaviourManagementPlan_IsNil() bool {
    return s.studentdatatransfernote.IndividualBehaviourManagementPlan == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) InterestTalents() *String {
    if s.studentdatatransfernote.InterestTalents == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.InterestTalents = ((*String)(v))
      }
      }
      return s.studentdatatransfernote.InterestTalents
    }
// Returns whether the element value for InterestTalents is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) InterestTalents_IsNil() bool {
    return s.studentdatatransfernote.InterestTalents == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) LBOTE() *Bool {
    if s.studentdatatransfernote.LBOTE == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.LBOTE = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.LBOTE
    }
// Returns whether the element value for LBOTE is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) LBOTE_IsNil() bool {
    return s.studentdatatransfernote.LBOTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) LatestReportAvailable() *Bool {
    if s.studentdatatransfernote.LatestReportAvailable == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentdatatransfernote.LatestReportAvailable = ((*Bool)(v))
      }
      }
      return s.studentdatatransfernote.LatestReportAvailable
    }
// Returns whether the element value for LatestReportAvailable is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) LatestReportAvailable_IsNil() bool {
    return s.studentdatatransfernote.LatestReportAvailable == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) LocalCodeList() *LocalCodeListType {
    if s.studentdatatransfernote.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentdatatransfernote.LocalCodeList = v
      }
      }
      return s.studentdatatransfernote.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) LocalCodeList_IsNil() bool {
    return s.studentdatatransfernote.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) NAPLANScoreList() *NAPLANScoreWithYearsListType {
    if s.studentdatatransfernote.NAPLANScoreList == nil {
     if v, ok:= NAPLANScoreWithYearsListTypePointer(NAPLANScoreWithYearsListType{}); ok {
      s.studentdatatransfernote.NAPLANScoreList = v
      }
      }
      return s.studentdatatransfernote.NAPLANScoreList
    }
// Returns whether the element value for NAPLANScoreList is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) NAPLANScoreList_IsNil() bool {
    return s.studentdatatransfernote.NAPLANScoreList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) NCCDList() *NCCDListType {
    if s.studentdatatransfernote.NCCDList == nil {
     if v, ok:= NCCDListTypePointer(NCCDListType{}); ok {
      s.studentdatatransfernote.NCCDList = v
      }
      }
      return s.studentdatatransfernote.NCCDList
    }
// Returns whether the element value for NCCDList is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) NCCDList_IsNil() bool {
    return s.studentdatatransfernote.NCCDList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) Name() *NameOfRecordType {
    if s.studentdatatransfernote.Name == nil {
     if v, ok:= NameOfRecordTypePointer(NameOfRecordType{}); ok {
      s.studentdatatransfernote.Name = v
      }
      }
      return s.studentdatatransfernote.Name
    }
// Returns whether the element value for Name is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) Name_IsNil() bool {
    return s.studentdatatransfernote.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) NationalUniqueStudentIdentifier() *String {
    if s.studentdatatransfernote.NationalUniqueStudentIdentifier == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.NationalUniqueStudentIdentifier = ((*String)(v))
      }
      }
      return s.studentdatatransfernote.NationalUniqueStudentIdentifier
    }
// Returns whether the element value for NationalUniqueStudentIdentifier is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) NationalUniqueStudentIdentifier_IsNil() bool {
    return s.studentdatatransfernote.NationalUniqueStudentIdentifier == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) OtherNames() *OtherNamesType {
    if s.studentdatatransfernote.OtherNames == nil {
     if v, ok:= OtherNamesTypePointer(OtherNamesType{}); ok {
      s.studentdatatransfernote.OtherNames = v
      }
      }
      return s.studentdatatransfernote.OtherNames
    }
// Returns whether the element value for OtherNames is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) OtherNames_IsNil() bool {
    return s.studentdatatransfernote.OtherNames == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) PlaceOfBirth() *String {
    if s.studentdatatransfernote.PlaceOfBirth == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.PlaceOfBirth = ((*String)(v))
      }
      }
      return s.studentdatatransfernote.PlaceOfBirth
    }
// Returns whether the element value for PlaceOfBirth is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) PlaceOfBirth_IsNil() bool {
    return s.studentdatatransfernote.PlaceOfBirth == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) PreviousSchoolList() *PreviousSchoolListType {
    if s.studentdatatransfernote.PreviousSchoolList == nil {
     if v, ok:= PreviousSchoolListTypePointer(PreviousSchoolListType{}); ok {
      s.studentdatatransfernote.PreviousSchoolList = v
      }
      }
      return s.studentdatatransfernote.PreviousSchoolList
    }
// Returns whether the element value for PreviousSchoolList is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) PreviousSchoolList_IsNil() bool {
    return s.studentdatatransfernote.PreviousSchoolList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) RefId() *RefIdType {
    if s.studentdatatransfernote.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentdatatransfernote.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) RefId_IsNil() bool {
    return s.studentdatatransfernote.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) RequestID() *String {
    if s.studentdatatransfernote.RequestID == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.RequestID = ((*String)(v))
      }
      }
      return s.studentdatatransfernote.RequestID
    }
// Returns whether the element value for RequestID is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) RequestID_IsNil() bool {
    return s.studentdatatransfernote.RequestID == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentdatatransfernote.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentdatatransfernote.SIF_ExtendedElements = v
      }
      }
      return s.studentdatatransfernote.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) SIF_ExtendedElements_IsNil() bool {
    return s.studentdatatransfernote.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) SIF_Metadata() *SIF_MetadataType {
    if s.studentdatatransfernote.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentdatatransfernote.SIF_Metadata = v
      }
      }
      return s.studentdatatransfernote.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) SIF_Metadata_IsNil() bool {
    return s.studentdatatransfernote.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) STDNAttachmentList() *STDNAttachmentListType {
    if s.studentdatatransfernote.STDNAttachmentList == nil {
     if v, ok:= STDNAttachmentListTypePointer(STDNAttachmentListType{}); ok {
      s.studentdatatransfernote.STDNAttachmentList = v
      }
      }
      return s.studentdatatransfernote.STDNAttachmentList
    }
// Returns whether the element value for STDNAttachmentList is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) STDNAttachmentList_IsNil() bool {
    return s.studentdatatransfernote.STDNAttachmentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) StateOfBirth() *StateProvinceType {
    if s.studentdatatransfernote.StateOfBirth == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentdatatransfernote.StateOfBirth = ((*StateProvinceType)(v))
      }
      }
      return s.studentdatatransfernote.StateOfBirth
    }
// Returns whether the element value for StateOfBirth is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) StateOfBirth_IsNil() bool {
    return s.studentdatatransfernote.StateOfBirth == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) StudentGradeList() *STDNGradeListType {
    if s.studentdatatransfernote.StudentGradeList == nil {
     if v, ok:= STDNGradeListTypePointer(STDNGradeListType{}); ok {
      s.studentdatatransfernote.StudentGradeList = v
      }
      }
      return s.studentdatatransfernote.StudentGradeList
    }
// Returns whether the element value for StudentGradeList is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) StudentGradeList_IsNil() bool {
    return s.studentdatatransfernote.StudentGradeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) SupportNeeds() *STDNSupportNeedsType {
    if s.studentdatatransfernote.SupportNeeds == nil {
     if v, ok:= STDNSupportNeedsTypePointer(STDNSupportNeedsType{}); ok {
      s.studentdatatransfernote.SupportNeeds = v
      }
      }
      return s.studentdatatransfernote.SupportNeeds
    }
// Returns whether the element value for SupportNeeds is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) SupportNeeds_IsNil() bool {
    return s.studentdatatransfernote.SupportNeeds == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) VisaStatus() *VisaSubClassType {
    if s.studentdatatransfernote.VisaStatus == nil {
     if v, ok:= VisaSubClassTypePointer(VisaSubClassType{}); ok {
      s.studentdatatransfernote.VisaStatus = v
      }
      }
      return s.studentdatatransfernote.VisaStatus
    }
// Returns whether the element value for VisaStatus is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) VisaStatus_IsNil() bool {
    return s.studentdatatransfernote.VisaStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentDataTransferNote) YearLevel() *YearLevelType {
    if s.studentdatatransfernote.YearLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.studentdatatransfernote.YearLevel = v
      }
      }
      return s.studentdatatransfernote.YearLevel
    }
// Returns whether the element value for YearLevel is nil in the container StudentDataTransferNote.
  func (s *StudentDataTransferNote) YearLevel_IsNil() bool {
    return s.studentdatatransfernote.YearLevel == nil
    }

// Set the value of a property to nil
func (n *StudentEntryContainerType) Unset(key string) *StudentEntryContainerType {
        switch key {
  case "Code":
   n.studententrycontainertype.Code = nil
  case "OtherCodeList":
   n.studententrycontainertype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentEntryContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *StudentEntryContainerType) SetProperties(props ...Prop) *StudentEntryContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentEntryContainerType) SetProperty(key string, value interface{}) *StudentEntryContainerType {
        if n == nil {
                n, _ = StudentEntryContainerTypePointer(StudentEntryContainerType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEntryTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEntryTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studententrycontainertype.Code = ((*AUCodeSetsEntryTypeType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.studententrycontainertype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentEntryContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentEntryContainerType) Code() *AUCodeSetsEntryTypeType {
    if s.studententrycontainertype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.studententrycontainertype.Code = ((*AUCodeSetsEntryTypeType)(v))
      }
      }
      return s.studententrycontainertype.Code
    }
// Returns whether the element value for Code is nil in the container StudentEntryContainerType.
  func (s *StudentEntryContainerType) Code_IsNil() bool {
    return s.studententrycontainertype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentEntryContainerType) OtherCodeList() *OtherCodeListType {
    if s.studententrycontainertype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.studententrycontainertype.OtherCodeList = v
      }
      }
      return s.studententrycontainertype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container StudentEntryContainerType.
  func (s *StudentEntryContainerType) OtherCodeList_IsNil() bool {
    return s.studententrycontainertype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *StudentExitContainerType) Unset(key string) *StudentExitContainerType {
        switch key {
  case "Code":
   n.studentexitcontainertype.Code = nil
  case "OtherCodeList":
   n.studentexitcontainertype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentExitContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *StudentExitContainerType) SetProperties(props ...Prop) *StudentExitContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentExitContainerType) SetProperty(key string, value interface{}) *StudentExitContainerType {
        if n == nil {
                n, _ = StudentExitContainerTypePointer(StudentExitContainerType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsExitWithdrawalTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsExitWithdrawalTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentexitcontainertype.Code = ((*AUCodeSetsExitWithdrawalTypeType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.studentexitcontainertype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentExitContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentExitContainerType) Code() *AUCodeSetsExitWithdrawalTypeType {
    if s.studentexitcontainertype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentexitcontainertype.Code = ((*AUCodeSetsExitWithdrawalTypeType)(v))
      }
      }
      return s.studentexitcontainertype.Code
    }
// Returns whether the element value for Code is nil in the container StudentExitContainerType.
  func (s *StudentExitContainerType) Code_IsNil() bool {
    return s.studentexitcontainertype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentExitContainerType) OtherCodeList() *OtherCodeListType {
    if s.studentexitcontainertype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.studentexitcontainertype.OtherCodeList = v
      }
      }
      return s.studentexitcontainertype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container StudentExitContainerType.
  func (s *StudentExitContainerType) OtherCodeList_IsNil() bool {
    return s.studentexitcontainertype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *StudentExitStatusContainerType) Unset(key string) *StudentExitStatusContainerType {
        switch key {
  case "Code":
   n.studentexitstatuscontainertype.Code = nil
  case "OtherCodeList":
   n.studentexitstatuscontainertype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentExitStatusContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *StudentExitStatusContainerType) SetProperties(props ...Prop) *StudentExitStatusContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentExitStatusContainerType) SetProperty(key string, value interface{}) *StudentExitStatusContainerType {
        if n == nil {
                n, _ = StudentExitStatusContainerTypePointer(StudentExitStatusContainerType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsExitWithdrawalStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsExitWithdrawalStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentexitstatuscontainertype.Code = ((*AUCodeSetsExitWithdrawalStatusType)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.studentexitstatuscontainertype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentExitStatusContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentExitStatusContainerType) Code() *AUCodeSetsExitWithdrawalStatusType {
    if s.studentexitstatuscontainertype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentexitstatuscontainertype.Code = ((*AUCodeSetsExitWithdrawalStatusType)(v))
      }
      }
      return s.studentexitstatuscontainertype.Code
    }
// Returns whether the element value for Code is nil in the container StudentExitStatusContainerType.
  func (s *StudentExitStatusContainerType) Code_IsNil() bool {
    return s.studentexitstatuscontainertype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentExitStatusContainerType) OtherCodeList() *OtherCodeListType {
    if s.studentexitstatuscontainertype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.studentexitstatuscontainertype.OtherCodeList = v
      }
      }
      return s.studentexitstatuscontainertype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container StudentExitStatusContainerType.
  func (s *StudentExitStatusContainerType) OtherCodeList_IsNil() bool {
    return s.studentexitstatuscontainertype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *StudentGrade) Unset(key string) *StudentGrade {
        switch key {
  case "Description":
   n.studentgrade.Description = nil
  case "Grade":
   n.studentgrade.Grade = nil
  case "GradingScoreList":
   n.studentgrade.GradingScoreList = nil
  case "Homegroup":
   n.studentgrade.Homegroup = nil
  case "LearningArea":
   n.studentgrade.LearningArea = nil
  case "LearningStandardList":
   n.studentgrade.LearningStandardList = nil
  case "LocalCodeList":
   n.studentgrade.LocalCodeList = nil
  case "Markers":
   n.studentgrade.Markers = nil
  case "RefId":
   n.studentgrade.RefId = nil
  case "SIF_ExtendedElements":
   n.studentgrade.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentgrade.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.studentgrade.SchoolInfoRefId = nil
  case "SchoolYear":
   n.studentgrade.SchoolYear = nil
  case "StaffPersonalRefId":
   n.studentgrade.StaffPersonalRefId = nil
  case "StudentPersonalRefId":
   n.studentgrade.StudentPersonalRefId = nil
  case "TeacherJudgement":
   n.studentgrade.TeacherJudgement = nil
  case "TeachingGroupRefId":
   n.studentgrade.TeachingGroupRefId = nil
  case "TeachingGroupShortName":
   n.studentgrade.TeachingGroupShortName = nil
  case "TermInfoRefId":
   n.studentgrade.TermInfoRefId = nil
  case "TermSpan":
   n.studentgrade.TermSpan = nil
  case "YearLevel":
   n.studentgrade.YearLevel = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentGrade")
        }
        return n
}

// Set a sequence of properties
func (n *StudentGrade) SetProperties(props ...Prop) *StudentGrade {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentGrade) SetProperty(key string, value interface{}) *StudentGrade {
        if n == nil {
                n, _ = StudentGradePointer(StudentGrade{})
        }
        switch key {
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.Description = ((*String)(v))
      }
    case "Grade":
    if v, ok:= GradeTypePointer(value); ok {
      n.studentgrade.Grade = v
      }
    case "GradingScoreList":
    if v, ok:= GradingScoreListTypePointer(value); ok {
      n.studentgrade.GradingScoreList = v
      }
    case "Homegroup":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.Homegroup = ((*String)(v))
      }
    case "LearningArea":
    if v, ok:= ACStrandSubjectAreaTypePointer(value); ok {
      n.studentgrade.LearningArea = v
      }
    case "LearningStandardList":
    if v, ok:= LearningStandardListTypePointer(value); ok {
      n.studentgrade.LearningStandardList = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentgrade.LocalCodeList = v
      }
    case "Markers":
    if v, ok:= StudentGradeMarkersListTypePointer(value); ok {
      n.studentgrade.Markers = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentgrade.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentgrade.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StaffPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.StaffPersonalRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.StudentPersonalRefId = ((*String)(v))
      }
    case "TeacherJudgement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.TeacherJudgement = ((*String)(v))
      }
    case "TeachingGroupRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.TeachingGroupRefId = ((*String)(v))
      }
    case "TeachingGroupShortName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.TeachingGroupShortName = ((*String)(v))
      }
    case "TermInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrade.TermInfoRefId = ((*String)(v))
      }
    case "TermSpan":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSessionTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSessionTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentgrade.TermSpan = ((*AUCodeSetsSessionTypeType)(v))
      }
    case "YearLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.studentgrade.YearLevel = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentGrade")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) Description() *String {
    if s.studentgrade.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.Description = ((*String)(v))
      }
      }
      return s.studentgrade.Description
    }
// Returns whether the element value for Description is nil in the container StudentGrade.
  func (s *StudentGrade) Description_IsNil() bool {
    return s.studentgrade.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) Grade() *GradeType {
    if s.studentgrade.Grade == nil {
     if v, ok:= GradeTypePointer(GradeType{}); ok {
      s.studentgrade.Grade = v
      }
      }
      return s.studentgrade.Grade
    }
// Returns whether the element value for Grade is nil in the container StudentGrade.
  func (s *StudentGrade) Grade_IsNil() bool {
    return s.studentgrade.Grade == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) GradingScoreList() *GradingScoreListType {
    if s.studentgrade.GradingScoreList == nil {
     if v, ok:= GradingScoreListTypePointer(GradingScoreListType{}); ok {
      s.studentgrade.GradingScoreList = v
      }
      }
      return s.studentgrade.GradingScoreList
    }
// Returns whether the element value for GradingScoreList is nil in the container StudentGrade.
  func (s *StudentGrade) GradingScoreList_IsNil() bool {
    return s.studentgrade.GradingScoreList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) Homegroup() *String {
    if s.studentgrade.Homegroup == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.Homegroup = ((*String)(v))
      }
      }
      return s.studentgrade.Homegroup
    }
// Returns whether the element value for Homegroup is nil in the container StudentGrade.
  func (s *StudentGrade) Homegroup_IsNil() bool {
    return s.studentgrade.Homegroup == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) LearningArea() *ACStrandSubjectAreaType {
    if s.studentgrade.LearningArea == nil {
     if v, ok:= ACStrandSubjectAreaTypePointer(ACStrandSubjectAreaType{}); ok {
      s.studentgrade.LearningArea = v
      }
      }
      return s.studentgrade.LearningArea
    }
// Returns whether the element value for LearningArea is nil in the container StudentGrade.
  func (s *StudentGrade) LearningArea_IsNil() bool {
    return s.studentgrade.LearningArea == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) LearningStandardList() *LearningStandardListType {
    if s.studentgrade.LearningStandardList == nil {
     if v, ok:= LearningStandardListTypePointer(LearningStandardListType{}); ok {
      s.studentgrade.LearningStandardList = v
      }
      }
      return s.studentgrade.LearningStandardList
    }
// Returns whether the element value for LearningStandardList is nil in the container StudentGrade.
  func (s *StudentGrade) LearningStandardList_IsNil() bool {
    return s.studentgrade.LearningStandardList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) LocalCodeList() *LocalCodeListType {
    if s.studentgrade.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentgrade.LocalCodeList = v
      }
      }
      return s.studentgrade.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentGrade.
  func (s *StudentGrade) LocalCodeList_IsNil() bool {
    return s.studentgrade.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) Markers() *StudentGradeMarkersListType {
    if s.studentgrade.Markers == nil {
     if v, ok:= StudentGradeMarkersListTypePointer(StudentGradeMarkersListType{}); ok {
      s.studentgrade.Markers = v
      }
      }
      return s.studentgrade.Markers
    }
// Returns whether the element value for Markers is nil in the container StudentGrade.
  func (s *StudentGrade) Markers_IsNil() bool {
    return s.studentgrade.Markers == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) RefId() *RefIdType {
    if s.studentgrade.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentgrade.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentGrade.
  func (s *StudentGrade) RefId_IsNil() bool {
    return s.studentgrade.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentgrade.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentgrade.SIF_ExtendedElements = v
      }
      }
      return s.studentgrade.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentGrade.
  func (s *StudentGrade) SIF_ExtendedElements_IsNil() bool {
    return s.studentgrade.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) SIF_Metadata() *SIF_MetadataType {
    if s.studentgrade.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentgrade.SIF_Metadata = v
      }
      }
      return s.studentgrade.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentGrade.
  func (s *StudentGrade) SIF_Metadata_IsNil() bool {
    return s.studentgrade.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) SchoolInfoRefId() *String {
    if s.studentgrade.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.studentgrade.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container StudentGrade.
  func (s *StudentGrade) SchoolInfoRefId_IsNil() bool {
    return s.studentgrade.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) SchoolYear() *SchoolYearType {
    if s.studentgrade.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentgrade.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StudentGrade.
  func (s *StudentGrade) SchoolYear_IsNil() bool {
    return s.studentgrade.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) StaffPersonalRefId() *String {
    if s.studentgrade.StaffPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.StaffPersonalRefId = ((*String)(v))
      }
      }
      return s.studentgrade.StaffPersonalRefId
    }
// Returns whether the element value for StaffPersonalRefId is nil in the container StudentGrade.
  func (s *StudentGrade) StaffPersonalRefId_IsNil() bool {
    return s.studentgrade.StaffPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) StudentPersonalRefId() *String {
    if s.studentgrade.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentgrade.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentGrade.
  func (s *StudentGrade) StudentPersonalRefId_IsNil() bool {
    return s.studentgrade.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) TeacherJudgement() *String {
    if s.studentgrade.TeacherJudgement == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.TeacherJudgement = ((*String)(v))
      }
      }
      return s.studentgrade.TeacherJudgement
    }
// Returns whether the element value for TeacherJudgement is nil in the container StudentGrade.
  func (s *StudentGrade) TeacherJudgement_IsNil() bool {
    return s.studentgrade.TeacherJudgement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) TeachingGroupRefId() *String {
    if s.studentgrade.TeachingGroupRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.TeachingGroupRefId = ((*String)(v))
      }
      }
      return s.studentgrade.TeachingGroupRefId
    }
// Returns whether the element value for TeachingGroupRefId is nil in the container StudentGrade.
  func (s *StudentGrade) TeachingGroupRefId_IsNil() bool {
    return s.studentgrade.TeachingGroupRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) TeachingGroupShortName() *String {
    if s.studentgrade.TeachingGroupShortName == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.TeachingGroupShortName = ((*String)(v))
      }
      }
      return s.studentgrade.TeachingGroupShortName
    }
// Returns whether the element value for TeachingGroupShortName is nil in the container StudentGrade.
  func (s *StudentGrade) TeachingGroupShortName_IsNil() bool {
    return s.studentgrade.TeachingGroupShortName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) TermInfoRefId() *String {
    if s.studentgrade.TermInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.TermInfoRefId = ((*String)(v))
      }
      }
      return s.studentgrade.TermInfoRefId
    }
// Returns whether the element value for TermInfoRefId is nil in the container StudentGrade.
  func (s *StudentGrade) TermInfoRefId_IsNil() bool {
    return s.studentgrade.TermInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) TermSpan() *AUCodeSetsSessionTypeType {
    if s.studentgrade.TermSpan == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrade.TermSpan = ((*AUCodeSetsSessionTypeType)(v))
      }
      }
      return s.studentgrade.TermSpan
    }
// Returns whether the element value for TermSpan is nil in the container StudentGrade.
  func (s *StudentGrade) TermSpan_IsNil() bool {
    return s.studentgrade.TermSpan == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGrade) YearLevel() *YearLevelType {
    if s.studentgrade.YearLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.studentgrade.YearLevel = v
      }
      }
      return s.studentgrade.YearLevel
    }
// Returns whether the element value for YearLevel is nil in the container StudentGrade.
  func (s *StudentGrade) YearLevel_IsNil() bool {
    return s.studentgrade.YearLevel == nil
    }

// Set the value of a property to nil
func (n *StudentGroupType) Unset(key string) *StudentGroupType {
        switch key {
  case "GroupCategory":
   n.studentgrouptype.GroupCategory = nil
  case "GroupDescription":
   n.studentgrouptype.GroupDescription = nil
  case "GroupLocalId":
   n.studentgrouptype.GroupLocalId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentGroupType")
        }
        return n
}

// Set a sequence of properties
func (n *StudentGroupType) SetProperties(props ...Prop) *StudentGroupType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentGroupType) SetProperty(key string, value interface{}) *StudentGroupType {
        if n == nil {
                n, _ = StudentGroupTypePointer(StudentGroupType{})
        }
        switch key {
    case "GroupCategory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsGroupCategoryCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsGroupCategoryCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentgrouptype.GroupCategory = ((*AUCodeSetsGroupCategoryCodeType)(v))
      }
    case "GroupDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrouptype.GroupDescription = ((*String)(v))
      }
    case "GroupLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentgrouptype.GroupLocalId = ((*LocalIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentGroupType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGroupType) GroupCategory() *AUCodeSetsGroupCategoryCodeType {
    if s.studentgrouptype.GroupCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrouptype.GroupCategory = ((*AUCodeSetsGroupCategoryCodeType)(v))
      }
      }
      return s.studentgrouptype.GroupCategory
    }
// Returns whether the element value for GroupCategory is nil in the container StudentGroupType.
  func (s *StudentGroupType) GroupCategory_IsNil() bool {
    return s.studentgrouptype.GroupCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGroupType) GroupDescription() *String {
    if s.studentgrouptype.GroupDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrouptype.GroupDescription = ((*String)(v))
      }
      }
      return s.studentgrouptype.GroupDescription
    }
// Returns whether the element value for GroupDescription is nil in the container StudentGroupType.
  func (s *StudentGroupType) GroupDescription_IsNil() bool {
    return s.studentgrouptype.GroupDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentGroupType) GroupLocalId() *LocalIdType {
    if s.studentgrouptype.GroupLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentgrouptype.GroupLocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentgrouptype.GroupLocalId
    }
// Returns whether the element value for GroupLocalId is nil in the container StudentGroupType.
  func (s *StudentGroupType) GroupLocalId_IsNil() bool {
    return s.studentgrouptype.GroupLocalId == nil
    }

// Set the value of a property to nil
func (n *StudentMostRecentContainerType) Unset(key string) *StudentMostRecentContainerType {
        switch key {
  case "BoardingStatus":
   n.studentmostrecentcontainertype.BoardingStatus = nil
  case "CensusAge":
   n.studentmostrecentcontainertype.CensusAge = nil
  case "ClassCode":
   n.studentmostrecentcontainertype.ClassCode = nil
  case "DisabilityCategory":
   n.studentmostrecentcontainertype.DisabilityCategory = nil
  case "DisabilityLevelOfAdjustment":
   n.studentmostrecentcontainertype.DisabilityLevelOfAdjustment = nil
  case "DistanceEducationStudent":
   n.studentmostrecentcontainertype.DistanceEducationStudent = nil
  case "FFPOS":
   n.studentmostrecentcontainertype.FFPOS = nil
  case "FTE":
   n.studentmostrecentcontainertype.FTE = nil
  case "Homegroup":
   n.studentmostrecentcontainertype.Homegroup = nil
  case "HomeroomLocalId":
   n.studentmostrecentcontainertype.HomeroomLocalId = nil
  case "LocalCampusId":
   n.studentmostrecentcontainertype.LocalCampusId = nil
  case "MembershipType":
   n.studentmostrecentcontainertype.MembershipType = nil
  case "OtherEnrollmentSchoolACARAId":
   n.studentmostrecentcontainertype.OtherEnrollmentSchoolACARAId = nil
  case "OtherSchoolName":
   n.studentmostrecentcontainertype.OtherSchoolName = nil
  case "Parent1EmploymentType":
   n.studentmostrecentcontainertype.Parent1EmploymentType = nil
  case "Parent1Language":
   n.studentmostrecentcontainertype.Parent1Language = nil
  case "Parent1NonSchoolEducation":
   n.studentmostrecentcontainertype.Parent1NonSchoolEducation = nil
  case "Parent1SchoolEducationLevel":
   n.studentmostrecentcontainertype.Parent1SchoolEducationLevel = nil
  case "Parent2EmploymentType":
   n.studentmostrecentcontainertype.Parent2EmploymentType = nil
  case "Parent2Language":
   n.studentmostrecentcontainertype.Parent2Language = nil
  case "Parent2NonSchoolEducation":
   n.studentmostrecentcontainertype.Parent2NonSchoolEducation = nil
  case "Parent2SchoolEducationLevel":
   n.studentmostrecentcontainertype.Parent2SchoolEducationLevel = nil
  case "ReportingSchoolId":
   n.studentmostrecentcontainertype.ReportingSchoolId = nil
  case "SchoolACARAId":
   n.studentmostrecentcontainertype.SchoolACARAId = nil
  case "SchoolLocalId":
   n.studentmostrecentcontainertype.SchoolLocalId = nil
  case "TestLevel":
   n.studentmostrecentcontainertype.TestLevel = nil
  case "YearLevel":
   n.studentmostrecentcontainertype.YearLevel = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentMostRecentContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *StudentMostRecentContainerType) SetProperties(props ...Prop) *StudentMostRecentContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentMostRecentContainerType) SetProperty(key string, value interface{}) *StudentMostRecentContainerType {
        if n == nil {
                n, _ = StudentMostRecentContainerTypePointer(StudentMostRecentContainerType{})
        }
        switch key {
    case "BoardingStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsBoardingType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsBoardingType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.BoardingStatus = ((*AUCodeSetsBoardingType)(v))
      }
    case "CensusAge":
    
    if v, ok:= IntPointer(value); ok {
      n.studentmostrecentcontainertype.CensusAge = ((*Int)(v))
      }
    case "ClassCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.ClassCode = ((*String)(v))
      }
    case "DisabilityCategory":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.DisabilityCategory = ((*String)(v))
      }
    case "DisabilityLevelOfAdjustment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.DisabilityLevelOfAdjustment = ((*String)(v))
      }
    case "DistanceEducationStudent":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.DistanceEducationStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "FFPOS":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsFFPOSStatusCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsFFPOSStatusCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.FFPOS = ((*AUCodeSetsFFPOSStatusCodeType)(v))
      }
    case "FTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.FTE = ((*FTEType)(v))
      }
    case "Homegroup":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.Homegroup = ((*String)(v))
      }
    case "HomeroomLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.HomeroomLocalId = ((*LocalIdType)(v))
      }
    case "LocalCampusId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.LocalCampusId = ((*LocalIdType)(v))
      }
    case "MembershipType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolEnrollmentTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolEnrollmentTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.MembershipType = ((*AUCodeSetsSchoolEnrollmentTypeType)(v))
      }
    case "OtherEnrollmentSchoolACARAId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.OtherEnrollmentSchoolACARAId = ((*LocalIdType)(v))
      }
    case "OtherSchoolName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.OtherSchoolName = ((*String)(v))
      }
    case "Parent1EmploymentType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEmploymentTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEmploymentTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.Parent1EmploymentType = ((*AUCodeSetsEmploymentTypeType)(v))
      }
    case "Parent1Language":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.Parent1Language = ((*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType)(v))
      }
    case "Parent1NonSchoolEducation":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNonSchoolEducationType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNonSchoolEducationType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.Parent1NonSchoolEducation = ((*AUCodeSetsNonSchoolEducationType)(v))
      }
    case "Parent1SchoolEducationLevel":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolEducationLevelTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolEducationLevelTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.Parent1SchoolEducationLevel = ((*AUCodeSetsSchoolEducationLevelTypeType)(v))
      }
    case "Parent2EmploymentType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEmploymentTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEmploymentTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.Parent2EmploymentType = ((*AUCodeSetsEmploymentTypeType)(v))
      }
    case "Parent2Language":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.Parent2Language = ((*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType)(v))
      }
    case "Parent2NonSchoolEducation":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNonSchoolEducationType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNonSchoolEducationType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.Parent2NonSchoolEducation = ((*AUCodeSetsNonSchoolEducationType)(v))
      }
    case "Parent2SchoolEducationLevel":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolEducationLevelTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolEducationLevelTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.Parent2SchoolEducationLevel = ((*AUCodeSetsSchoolEducationLevelTypeType)(v))
      }
    case "ReportingSchoolId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.ReportingSchoolId = ((*LocalIdType)(v))
      }
    case "SchoolACARAId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.SchoolACARAId = ((*LocalIdType)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentmostrecentcontainertype.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "TestLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.studentmostrecentcontainertype.TestLevel = v
      }
    case "YearLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.studentmostrecentcontainertype.YearLevel = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentMostRecentContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) BoardingStatus() *AUCodeSetsBoardingType {
    if s.studentmostrecentcontainertype.BoardingStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.BoardingStatus = ((*AUCodeSetsBoardingType)(v))
      }
      }
      return s.studentmostrecentcontainertype.BoardingStatus
    }
// Returns whether the element value for BoardingStatus is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) BoardingStatus_IsNil() bool {
    return s.studentmostrecentcontainertype.BoardingStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) CensusAge() *Int {
    if s.studentmostrecentcontainertype.CensusAge == nil {
    if v, ok:= IntPointer(0); ok {
      s.studentmostrecentcontainertype.CensusAge = ((*Int)(v))
      }
      }
      return s.studentmostrecentcontainertype.CensusAge
    }
// Returns whether the element value for CensusAge is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) CensusAge_IsNil() bool {
    return s.studentmostrecentcontainertype.CensusAge == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) ClassCode() *String {
    if s.studentmostrecentcontainertype.ClassCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.ClassCode = ((*String)(v))
      }
      }
      return s.studentmostrecentcontainertype.ClassCode
    }
// Returns whether the element value for ClassCode is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) ClassCode_IsNil() bool {
    return s.studentmostrecentcontainertype.ClassCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) DisabilityCategory() *String {
    if s.studentmostrecentcontainertype.DisabilityCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.DisabilityCategory = ((*String)(v))
      }
      }
      return s.studentmostrecentcontainertype.DisabilityCategory
    }
// Returns whether the element value for DisabilityCategory is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) DisabilityCategory_IsNil() bool {
    return s.studentmostrecentcontainertype.DisabilityCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) DisabilityLevelOfAdjustment() *String {
    if s.studentmostrecentcontainertype.DisabilityLevelOfAdjustment == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.DisabilityLevelOfAdjustment = ((*String)(v))
      }
      }
      return s.studentmostrecentcontainertype.DisabilityLevelOfAdjustment
    }
// Returns whether the element value for DisabilityLevelOfAdjustment is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) DisabilityLevelOfAdjustment_IsNil() bool {
    return s.studentmostrecentcontainertype.DisabilityLevelOfAdjustment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) DistanceEducationStudent() *AUCodeSetsYesOrNoCategoryType {
    if s.studentmostrecentcontainertype.DistanceEducationStudent == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.DistanceEducationStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentmostrecentcontainertype.DistanceEducationStudent
    }
// Returns whether the element value for DistanceEducationStudent is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) DistanceEducationStudent_IsNil() bool {
    return s.studentmostrecentcontainertype.DistanceEducationStudent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) FFPOS() *AUCodeSetsFFPOSStatusCodeType {
    if s.studentmostrecentcontainertype.FFPOS == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.FFPOS = ((*AUCodeSetsFFPOSStatusCodeType)(v))
      }
      }
      return s.studentmostrecentcontainertype.FFPOS
    }
// Returns whether the element value for FFPOS is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) FFPOS_IsNil() bool {
    return s.studentmostrecentcontainertype.FFPOS == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) FTE() *FTEType {
    if s.studentmostrecentcontainertype.FTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.FTE = ((*FTEType)(v))
      }
      }
      return s.studentmostrecentcontainertype.FTE
    }
// Returns whether the element value for FTE is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) FTE_IsNil() bool {
    return s.studentmostrecentcontainertype.FTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) Homegroup() *String {
    if s.studentmostrecentcontainertype.Homegroup == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.Homegroup = ((*String)(v))
      }
      }
      return s.studentmostrecentcontainertype.Homegroup
    }
// Returns whether the element value for Homegroup is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) Homegroup_IsNil() bool {
    return s.studentmostrecentcontainertype.Homegroup == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) HomeroomLocalId() *LocalIdType {
    if s.studentmostrecentcontainertype.HomeroomLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.HomeroomLocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentmostrecentcontainertype.HomeroomLocalId
    }
// Returns whether the element value for HomeroomLocalId is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) HomeroomLocalId_IsNil() bool {
    return s.studentmostrecentcontainertype.HomeroomLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) LocalCampusId() *LocalIdType {
    if s.studentmostrecentcontainertype.LocalCampusId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.LocalCampusId = ((*LocalIdType)(v))
      }
      }
      return s.studentmostrecentcontainertype.LocalCampusId
    }
// Returns whether the element value for LocalCampusId is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) LocalCampusId_IsNil() bool {
    return s.studentmostrecentcontainertype.LocalCampusId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) MembershipType() *AUCodeSetsSchoolEnrollmentTypeType {
    if s.studentmostrecentcontainertype.MembershipType == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.MembershipType = ((*AUCodeSetsSchoolEnrollmentTypeType)(v))
      }
      }
      return s.studentmostrecentcontainertype.MembershipType
    }
// Returns whether the element value for MembershipType is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) MembershipType_IsNil() bool {
    return s.studentmostrecentcontainertype.MembershipType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) OtherEnrollmentSchoolACARAId() *LocalIdType {
    if s.studentmostrecentcontainertype.OtherEnrollmentSchoolACARAId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.OtherEnrollmentSchoolACARAId = ((*LocalIdType)(v))
      }
      }
      return s.studentmostrecentcontainertype.OtherEnrollmentSchoolACARAId
    }
// Returns whether the element value for OtherEnrollmentSchoolACARAId is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) OtherEnrollmentSchoolACARAId_IsNil() bool {
    return s.studentmostrecentcontainertype.OtherEnrollmentSchoolACARAId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) OtherSchoolName() *String {
    if s.studentmostrecentcontainertype.OtherSchoolName == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.OtherSchoolName = ((*String)(v))
      }
      }
      return s.studentmostrecentcontainertype.OtherSchoolName
    }
// Returns whether the element value for OtherSchoolName is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) OtherSchoolName_IsNil() bool {
    return s.studentmostrecentcontainertype.OtherSchoolName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) Parent1EmploymentType() *AUCodeSetsEmploymentTypeType {
    if s.studentmostrecentcontainertype.Parent1EmploymentType == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.Parent1EmploymentType = ((*AUCodeSetsEmploymentTypeType)(v))
      }
      }
      return s.studentmostrecentcontainertype.Parent1EmploymentType
    }
// Returns whether the element value for Parent1EmploymentType is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) Parent1EmploymentType_IsNil() bool {
    return s.studentmostrecentcontainertype.Parent1EmploymentType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) Parent1Language() *AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType {
    if s.studentmostrecentcontainertype.Parent1Language == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.Parent1Language = ((*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType)(v))
      }
      }
      return s.studentmostrecentcontainertype.Parent1Language
    }
// Returns whether the element value for Parent1Language is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) Parent1Language_IsNil() bool {
    return s.studentmostrecentcontainertype.Parent1Language == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) Parent1NonSchoolEducation() *AUCodeSetsNonSchoolEducationType {
    if s.studentmostrecentcontainertype.Parent1NonSchoolEducation == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.Parent1NonSchoolEducation = ((*AUCodeSetsNonSchoolEducationType)(v))
      }
      }
      return s.studentmostrecentcontainertype.Parent1NonSchoolEducation
    }
// Returns whether the element value for Parent1NonSchoolEducation is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) Parent1NonSchoolEducation_IsNil() bool {
    return s.studentmostrecentcontainertype.Parent1NonSchoolEducation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) Parent1SchoolEducationLevel() *AUCodeSetsSchoolEducationLevelTypeType {
    if s.studentmostrecentcontainertype.Parent1SchoolEducationLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.Parent1SchoolEducationLevel = ((*AUCodeSetsSchoolEducationLevelTypeType)(v))
      }
      }
      return s.studentmostrecentcontainertype.Parent1SchoolEducationLevel
    }
// Returns whether the element value for Parent1SchoolEducationLevel is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) Parent1SchoolEducationLevel_IsNil() bool {
    return s.studentmostrecentcontainertype.Parent1SchoolEducationLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) Parent2EmploymentType() *AUCodeSetsEmploymentTypeType {
    if s.studentmostrecentcontainertype.Parent2EmploymentType == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.Parent2EmploymentType = ((*AUCodeSetsEmploymentTypeType)(v))
      }
      }
      return s.studentmostrecentcontainertype.Parent2EmploymentType
    }
// Returns whether the element value for Parent2EmploymentType is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) Parent2EmploymentType_IsNil() bool {
    return s.studentmostrecentcontainertype.Parent2EmploymentType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) Parent2Language() *AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType {
    if s.studentmostrecentcontainertype.Parent2Language == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.Parent2Language = ((*AUCodeSetsAustralianStandardClassificationOfLanguagesASCLType)(v))
      }
      }
      return s.studentmostrecentcontainertype.Parent2Language
    }
// Returns whether the element value for Parent2Language is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) Parent2Language_IsNil() bool {
    return s.studentmostrecentcontainertype.Parent2Language == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) Parent2NonSchoolEducation() *AUCodeSetsNonSchoolEducationType {
    if s.studentmostrecentcontainertype.Parent2NonSchoolEducation == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.Parent2NonSchoolEducation = ((*AUCodeSetsNonSchoolEducationType)(v))
      }
      }
      return s.studentmostrecentcontainertype.Parent2NonSchoolEducation
    }
// Returns whether the element value for Parent2NonSchoolEducation is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) Parent2NonSchoolEducation_IsNil() bool {
    return s.studentmostrecentcontainertype.Parent2NonSchoolEducation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) Parent2SchoolEducationLevel() *AUCodeSetsSchoolEducationLevelTypeType {
    if s.studentmostrecentcontainertype.Parent2SchoolEducationLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.Parent2SchoolEducationLevel = ((*AUCodeSetsSchoolEducationLevelTypeType)(v))
      }
      }
      return s.studentmostrecentcontainertype.Parent2SchoolEducationLevel
    }
// Returns whether the element value for Parent2SchoolEducationLevel is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) Parent2SchoolEducationLevel_IsNil() bool {
    return s.studentmostrecentcontainertype.Parent2SchoolEducationLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) ReportingSchoolId() *LocalIdType {
    if s.studentmostrecentcontainertype.ReportingSchoolId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.ReportingSchoolId = ((*LocalIdType)(v))
      }
      }
      return s.studentmostrecentcontainertype.ReportingSchoolId
    }
// Returns whether the element value for ReportingSchoolId is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) ReportingSchoolId_IsNil() bool {
    return s.studentmostrecentcontainertype.ReportingSchoolId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) SchoolACARAId() *LocalIdType {
    if s.studentmostrecentcontainertype.SchoolACARAId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.SchoolACARAId = ((*LocalIdType)(v))
      }
      }
      return s.studentmostrecentcontainertype.SchoolACARAId
    }
// Returns whether the element value for SchoolACARAId is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) SchoolACARAId_IsNil() bool {
    return s.studentmostrecentcontainertype.SchoolACARAId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) SchoolLocalId() *LocalIdType {
    if s.studentmostrecentcontainertype.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentmostrecentcontainertype.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentmostrecentcontainertype.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) SchoolLocalId_IsNil() bool {
    return s.studentmostrecentcontainertype.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) TestLevel() *YearLevelType {
    if s.studentmostrecentcontainertype.TestLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.studentmostrecentcontainertype.TestLevel = v
      }
      }
      return s.studentmostrecentcontainertype.TestLevel
    }
// Returns whether the element value for TestLevel is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) TestLevel_IsNil() bool {
    return s.studentmostrecentcontainertype.TestLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentMostRecentContainerType) YearLevel() *YearLevelType {
    if s.studentmostrecentcontainertype.YearLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.studentmostrecentcontainertype.YearLevel = v
      }
      }
      return s.studentmostrecentcontainertype.YearLevel
    }
// Returns whether the element value for YearLevel is nil in the container StudentMostRecentContainerType.
  func (s *StudentMostRecentContainerType) YearLevel_IsNil() bool {
    return s.studentmostrecentcontainertype.YearLevel == nil
    }

// Set the value of a property to nil
func (n *StudentParticipation) Unset(key string) *StudentParticipation {
        switch key {
  case "EntryPerson":
   n.studentparticipation.EntryPerson = nil
  case "EvaluationDate":
   n.studentparticipation.EvaluationDate = nil
  case "EvaluationExtensionDate":
   n.studentparticipation.EvaluationExtensionDate = nil
  case "EvaluationParentalConsentDate":
   n.studentparticipation.EvaluationParentalConsentDate = nil
  case "ExtendedDay":
   n.studentparticipation.ExtendedDay = nil
  case "ExtendedSchoolYear":
   n.studentparticipation.ExtendedSchoolYear = nil
  case "ExtensionComments":
   n.studentparticipation.ExtensionComments = nil
  case "GiftedEligibilityCriteria":
   n.studentparticipation.GiftedEligibilityCriteria = nil
  case "LocalCodeList":
   n.studentparticipation.LocalCodeList = nil
  case "ManagingSchool":
   n.studentparticipation.ManagingSchool = nil
  case "NOREPDate":
   n.studentparticipation.NOREPDate = nil
  case "ParticipationContact":
   n.studentparticipation.ParticipationContact = nil
  case "PlacementParentalConsentDate":
   n.studentparticipation.PlacementParentalConsentDate = nil
  case "ProgramAvailability":
   n.studentparticipation.ProgramAvailability = nil
  case "ProgramEligibilityDate":
   n.studentparticipation.ProgramEligibilityDate = nil
  case "ProgramFundingSources":
   n.studentparticipation.ProgramFundingSources = nil
  case "ProgramPlacementDate":
   n.studentparticipation.ProgramPlacementDate = nil
  case "ProgramPlanDate":
   n.studentparticipation.ProgramPlanDate = nil
  case "ProgramPlanEffectiveDate":
   n.studentparticipation.ProgramPlanEffectiveDate = nil
  case "ProgramStatus":
   n.studentparticipation.ProgramStatus = nil
  case "ProgramType":
   n.studentparticipation.ProgramType = nil
  case "ReevaluationDate":
   n.studentparticipation.ReevaluationDate = nil
  case "RefId":
   n.studentparticipation.RefId = nil
  case "ReferralDate":
   n.studentparticipation.ReferralDate = nil
  case "ReferralSource":
   n.studentparticipation.ReferralSource = nil
  case "SIF_ExtendedElements":
   n.studentparticipation.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentparticipation.SIF_Metadata = nil
  case "StudentParticipationAsOfDate":
   n.studentparticipation.StudentParticipationAsOfDate = nil
  case "StudentPersonalRefId":
   n.studentparticipation.StudentPersonalRefId = nil
  case "StudentSpecialEducationFTE":
   n.studentparticipation.StudentSpecialEducationFTE = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentParticipation")
        }
        return n
}

// Set a sequence of properties
func (n *StudentParticipation) SetProperties(props ...Prop) *StudentParticipation {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentParticipation) SetProperty(key string, value interface{}) *StudentParticipation {
        if n == nil {
                n, _ = StudentParticipationPointer(StudentParticipation{})
        }
        switch key {
    case "EntryPerson":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.EntryPerson = ((*String)(v))
      }
    case "EvaluationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.EvaluationDate = ((*String)(v))
      }
    case "EvaluationExtensionDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.EvaluationExtensionDate = ((*String)(v))
      }
    case "EvaluationParentalConsentDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.EvaluationParentalConsentDate = ((*String)(v))
      }
    case "ExtendedDay":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentparticipation.ExtendedDay = ((*Bool)(v))
      }
    case "ExtendedSchoolYear":
    
    if v, ok:= BoolPointer(value); ok {
      n.studentparticipation.ExtendedSchoolYear = ((*Bool)(v))
      }
    case "ExtensionComments":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.ExtensionComments = ((*String)(v))
      }
    case "GiftedEligibilityCriteria":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.GiftedEligibilityCriteria = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentparticipation.LocalCodeList = v
      }
    case "ManagingSchool":
    if v, ok:= StudentParticipation_ManagingSchoolPointer(value); ok {
      n.studentparticipation.ManagingSchool = v
      }
    case "NOREPDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.NOREPDate = ((*String)(v))
      }
    case "ParticipationContact":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.ParticipationContact = ((*String)(v))
      }
    case "PlacementParentalConsentDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.PlacementParentalConsentDate = ((*String)(v))
      }
    case "ProgramAvailability":
    if v, ok:= ProgramAvailabilityTypePointer(value); ok {
      n.studentparticipation.ProgramAvailability = v
      }
    case "ProgramEligibilityDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.ProgramEligibilityDate = ((*String)(v))
      }
    case "ProgramFundingSources":
    if v, ok:= ProgramFundingSourcesTypePointer(value); ok {
      n.studentparticipation.ProgramFundingSources = v
      }
    case "ProgramPlacementDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.ProgramPlacementDate = ((*String)(v))
      }
    case "ProgramPlanDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.ProgramPlanDate = ((*String)(v))
      }
    case "ProgramPlanEffectiveDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.ProgramPlanEffectiveDate = ((*String)(v))
      }
    case "ProgramStatus":
    if v, ok:= ProgramStatusTypePointer(value); ok {
      n.studentparticipation.ProgramStatus = v
      }
    case "ProgramType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsStudentFamilyProgramTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsStudentFamilyProgramTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.ProgramType = ((*AUCodeSetsStudentFamilyProgramTypeType)(v))
      }
    case "ReevaluationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.ReevaluationDate = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.RefId = ((*RefIdType)(v))
      }
    case "ReferralDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.ReferralDate = ((*String)(v))
      }
    case "ReferralSource":
    if v, ok:= ReferralSourceTypePointer(value); ok {
      n.studentparticipation.ReferralSource = v
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentparticipation.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentparticipation.SIF_Metadata = v
      }
    case "StudentParticipationAsOfDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.StudentParticipationAsOfDate = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.StudentPersonalRefId = ((*String)(v))
      }
    case "StudentSpecialEducationFTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation.StudentSpecialEducationFTE = ((*FTEType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentParticipation")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) EntryPerson() *String {
    if s.studentparticipation.EntryPerson == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.EntryPerson = ((*String)(v))
      }
      }
      return s.studentparticipation.EntryPerson
    }
// Returns whether the element value for EntryPerson is nil in the container StudentParticipation.
  func (s *StudentParticipation) EntryPerson_IsNil() bool {
    return s.studentparticipation.EntryPerson == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) EvaluationDate() *String {
    if s.studentparticipation.EvaluationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.EvaluationDate = ((*String)(v))
      }
      }
      return s.studentparticipation.EvaluationDate
    }
// Returns whether the element value for EvaluationDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) EvaluationDate_IsNil() bool {
    return s.studentparticipation.EvaluationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) EvaluationExtensionDate() *String {
    if s.studentparticipation.EvaluationExtensionDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.EvaluationExtensionDate = ((*String)(v))
      }
      }
      return s.studentparticipation.EvaluationExtensionDate
    }
// Returns whether the element value for EvaluationExtensionDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) EvaluationExtensionDate_IsNil() bool {
    return s.studentparticipation.EvaluationExtensionDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) EvaluationParentalConsentDate() *String {
    if s.studentparticipation.EvaluationParentalConsentDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.EvaluationParentalConsentDate = ((*String)(v))
      }
      }
      return s.studentparticipation.EvaluationParentalConsentDate
    }
// Returns whether the element value for EvaluationParentalConsentDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) EvaluationParentalConsentDate_IsNil() bool {
    return s.studentparticipation.EvaluationParentalConsentDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ExtendedDay() *Bool {
    if s.studentparticipation.ExtendedDay == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentparticipation.ExtendedDay = ((*Bool)(v))
      }
      }
      return s.studentparticipation.ExtendedDay
    }
// Returns whether the element value for ExtendedDay is nil in the container StudentParticipation.
  func (s *StudentParticipation) ExtendedDay_IsNil() bool {
    return s.studentparticipation.ExtendedDay == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ExtendedSchoolYear() *Bool {
    if s.studentparticipation.ExtendedSchoolYear == nil {
    if v, ok:= BoolPointer(false); ok {
      s.studentparticipation.ExtendedSchoolYear = ((*Bool)(v))
      }
      }
      return s.studentparticipation.ExtendedSchoolYear
    }
// Returns whether the element value for ExtendedSchoolYear is nil in the container StudentParticipation.
  func (s *StudentParticipation) ExtendedSchoolYear_IsNil() bool {
    return s.studentparticipation.ExtendedSchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ExtensionComments() *String {
    if s.studentparticipation.ExtensionComments == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.ExtensionComments = ((*String)(v))
      }
      }
      return s.studentparticipation.ExtensionComments
    }
// Returns whether the element value for ExtensionComments is nil in the container StudentParticipation.
  func (s *StudentParticipation) ExtensionComments_IsNil() bool {
    return s.studentparticipation.ExtensionComments == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) GiftedEligibilityCriteria() *AUCodeSetsYesOrNoCategoryType {
    if s.studentparticipation.GiftedEligibilityCriteria == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.GiftedEligibilityCriteria = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentparticipation.GiftedEligibilityCriteria
    }
// Returns whether the element value for GiftedEligibilityCriteria is nil in the container StudentParticipation.
  func (s *StudentParticipation) GiftedEligibilityCriteria_IsNil() bool {
    return s.studentparticipation.GiftedEligibilityCriteria == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) LocalCodeList() *LocalCodeListType {
    if s.studentparticipation.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentparticipation.LocalCodeList = v
      }
      }
      return s.studentparticipation.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentParticipation.
  func (s *StudentParticipation) LocalCodeList_IsNil() bool {
    return s.studentparticipation.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ManagingSchool() *StudentParticipation_ManagingSchool {
    if s.studentparticipation.ManagingSchool == nil {
     if v, ok:= StudentParticipation_ManagingSchoolPointer(StudentParticipation_ManagingSchool{}); ok {
      s.studentparticipation.ManagingSchool = v
      }
      }
      return s.studentparticipation.ManagingSchool
    }
// Returns whether the element value for ManagingSchool is nil in the container StudentParticipation.
  func (s *StudentParticipation) ManagingSchool_IsNil() bool {
    return s.studentparticipation.ManagingSchool == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) NOREPDate() *String {
    if s.studentparticipation.NOREPDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.NOREPDate = ((*String)(v))
      }
      }
      return s.studentparticipation.NOREPDate
    }
// Returns whether the element value for NOREPDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) NOREPDate_IsNil() bool {
    return s.studentparticipation.NOREPDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ParticipationContact() *String {
    if s.studentparticipation.ParticipationContact == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.ParticipationContact = ((*String)(v))
      }
      }
      return s.studentparticipation.ParticipationContact
    }
// Returns whether the element value for ParticipationContact is nil in the container StudentParticipation.
  func (s *StudentParticipation) ParticipationContact_IsNil() bool {
    return s.studentparticipation.ParticipationContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) PlacementParentalConsentDate() *String {
    if s.studentparticipation.PlacementParentalConsentDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.PlacementParentalConsentDate = ((*String)(v))
      }
      }
      return s.studentparticipation.PlacementParentalConsentDate
    }
// Returns whether the element value for PlacementParentalConsentDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) PlacementParentalConsentDate_IsNil() bool {
    return s.studentparticipation.PlacementParentalConsentDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ProgramAvailability() *ProgramAvailabilityType {
    if s.studentparticipation.ProgramAvailability == nil {
     if v, ok:= ProgramAvailabilityTypePointer(ProgramAvailabilityType{}); ok {
      s.studentparticipation.ProgramAvailability = v
      }
      }
      return s.studentparticipation.ProgramAvailability
    }
// Returns whether the element value for ProgramAvailability is nil in the container StudentParticipation.
  func (s *StudentParticipation) ProgramAvailability_IsNil() bool {
    return s.studentparticipation.ProgramAvailability == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ProgramEligibilityDate() *String {
    if s.studentparticipation.ProgramEligibilityDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.ProgramEligibilityDate = ((*String)(v))
      }
      }
      return s.studentparticipation.ProgramEligibilityDate
    }
// Returns whether the element value for ProgramEligibilityDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) ProgramEligibilityDate_IsNil() bool {
    return s.studentparticipation.ProgramEligibilityDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ProgramFundingSources() *ProgramFundingSourcesType {
    if s.studentparticipation.ProgramFundingSources == nil {
     if v, ok:= ProgramFundingSourcesTypePointer(ProgramFundingSourcesType{}); ok {
      s.studentparticipation.ProgramFundingSources = v
      }
      }
      return s.studentparticipation.ProgramFundingSources
    }
// Returns whether the element value for ProgramFundingSources is nil in the container StudentParticipation.
  func (s *StudentParticipation) ProgramFundingSources_IsNil() bool {
    return s.studentparticipation.ProgramFundingSources == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ProgramPlacementDate() *String {
    if s.studentparticipation.ProgramPlacementDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.ProgramPlacementDate = ((*String)(v))
      }
      }
      return s.studentparticipation.ProgramPlacementDate
    }
// Returns whether the element value for ProgramPlacementDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) ProgramPlacementDate_IsNil() bool {
    return s.studentparticipation.ProgramPlacementDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ProgramPlanDate() *String {
    if s.studentparticipation.ProgramPlanDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.ProgramPlanDate = ((*String)(v))
      }
      }
      return s.studentparticipation.ProgramPlanDate
    }
// Returns whether the element value for ProgramPlanDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) ProgramPlanDate_IsNil() bool {
    return s.studentparticipation.ProgramPlanDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ProgramPlanEffectiveDate() *String {
    if s.studentparticipation.ProgramPlanEffectiveDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.ProgramPlanEffectiveDate = ((*String)(v))
      }
      }
      return s.studentparticipation.ProgramPlanEffectiveDate
    }
// Returns whether the element value for ProgramPlanEffectiveDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) ProgramPlanEffectiveDate_IsNil() bool {
    return s.studentparticipation.ProgramPlanEffectiveDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ProgramStatus() *ProgramStatusType {
    if s.studentparticipation.ProgramStatus == nil {
     if v, ok:= ProgramStatusTypePointer(ProgramStatusType{}); ok {
      s.studentparticipation.ProgramStatus = v
      }
      }
      return s.studentparticipation.ProgramStatus
    }
// Returns whether the element value for ProgramStatus is nil in the container StudentParticipation.
  func (s *StudentParticipation) ProgramStatus_IsNil() bool {
    return s.studentparticipation.ProgramStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ProgramType() *AUCodeSetsStudentFamilyProgramTypeType {
    if s.studentparticipation.ProgramType == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.ProgramType = ((*AUCodeSetsStudentFamilyProgramTypeType)(v))
      }
      }
      return s.studentparticipation.ProgramType
    }
// Returns whether the element value for ProgramType is nil in the container StudentParticipation.
  func (s *StudentParticipation) ProgramType_IsNil() bool {
    return s.studentparticipation.ProgramType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ReevaluationDate() *String {
    if s.studentparticipation.ReevaluationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.ReevaluationDate = ((*String)(v))
      }
      }
      return s.studentparticipation.ReevaluationDate
    }
// Returns whether the element value for ReevaluationDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) ReevaluationDate_IsNil() bool {
    return s.studentparticipation.ReevaluationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) RefId() *RefIdType {
    if s.studentparticipation.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentparticipation.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentParticipation.
  func (s *StudentParticipation) RefId_IsNil() bool {
    return s.studentparticipation.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ReferralDate() *String {
    if s.studentparticipation.ReferralDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.ReferralDate = ((*String)(v))
      }
      }
      return s.studentparticipation.ReferralDate
    }
// Returns whether the element value for ReferralDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) ReferralDate_IsNil() bool {
    return s.studentparticipation.ReferralDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) ReferralSource() *ReferralSourceType {
    if s.studentparticipation.ReferralSource == nil {
     if v, ok:= ReferralSourceTypePointer(ReferralSourceType{}); ok {
      s.studentparticipation.ReferralSource = v
      }
      }
      return s.studentparticipation.ReferralSource
    }
// Returns whether the element value for ReferralSource is nil in the container StudentParticipation.
  func (s *StudentParticipation) ReferralSource_IsNil() bool {
    return s.studentparticipation.ReferralSource == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentparticipation.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentparticipation.SIF_ExtendedElements = v
      }
      }
      return s.studentparticipation.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentParticipation.
  func (s *StudentParticipation) SIF_ExtendedElements_IsNil() bool {
    return s.studentparticipation.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) SIF_Metadata() *SIF_MetadataType {
    if s.studentparticipation.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentparticipation.SIF_Metadata = v
      }
      }
      return s.studentparticipation.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentParticipation.
  func (s *StudentParticipation) SIF_Metadata_IsNil() bool {
    return s.studentparticipation.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) StudentParticipationAsOfDate() *String {
    if s.studentparticipation.StudentParticipationAsOfDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.StudentParticipationAsOfDate = ((*String)(v))
      }
      }
      return s.studentparticipation.StudentParticipationAsOfDate
    }
// Returns whether the element value for StudentParticipationAsOfDate is nil in the container StudentParticipation.
  func (s *StudentParticipation) StudentParticipationAsOfDate_IsNil() bool {
    return s.studentparticipation.StudentParticipationAsOfDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) StudentPersonalRefId() *String {
    if s.studentparticipation.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentparticipation.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentParticipation.
  func (s *StudentParticipation) StudentPersonalRefId_IsNil() bool {
    return s.studentparticipation.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation) StudentSpecialEducationFTE() *FTEType {
    if s.studentparticipation.StudentSpecialEducationFTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation.StudentSpecialEducationFTE = ((*FTEType)(v))
      }
      }
      return s.studentparticipation.StudentSpecialEducationFTE
    }
// Returns whether the element value for StudentSpecialEducationFTE is nil in the container StudentParticipation.
  func (s *StudentParticipation) StudentSpecialEducationFTE_IsNil() bool {
    return s.studentparticipation.StudentSpecialEducationFTE == nil
    }

// Set the value of a property to nil
func (n *StudentParticipation_ManagingSchool) Unset(key string) *StudentParticipation_ManagingSchool {
        switch key {
  case "SIF_RefObject":
   n.studentparticipation_managingschool.SIF_RefObject = nil
  case "Value":
   n.studentparticipation_managingschool.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentParticipation_ManagingSchool")
        }
        return n
}

// Set a sequence of properties
func (n *StudentParticipation_ManagingSchool) SetProperties(props ...Prop) *StudentParticipation_ManagingSchool {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentParticipation_ManagingSchool) SetProperty(key string, value interface{}) *StudentParticipation_ManagingSchool {
        if n == nil {
                n, _ = StudentParticipation_ManagingSchoolPointer(StudentParticipation_ManagingSchool{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation_managingschool.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentparticipation_managingschool.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentParticipation_ManagingSchool")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation_ManagingSchool) SIF_RefObject() *String {
    if s.studentparticipation_managingschool.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation_managingschool.SIF_RefObject = ((*String)(v))
      }
      }
      return s.studentparticipation_managingschool.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container StudentParticipation_ManagingSchool.
  func (s *StudentParticipation_ManagingSchool) SIF_RefObject_IsNil() bool {
    return s.studentparticipation_managingschool.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentParticipation_ManagingSchool) Value() *String {
    if s.studentparticipation_managingschool.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentparticipation_managingschool.Value = ((*String)(v))
      }
      }
      return s.studentparticipation_managingschool.Value
    }
// Returns whether the element value for Value is nil in the container StudentParticipation_ManagingSchool.
  func (s *StudentParticipation_ManagingSchool) Value_IsNil() bool {
    return s.studentparticipation_managingschool.Value == nil
    }

// Set the value of a property to nil
func (n *StudentPeriodAttendance) Unset(key string) *StudentPeriodAttendance {
        switch key {
  case "AttendanceCode":
   n.studentperiodattendance.AttendanceCode = nil
  case "AttendanceComment":
   n.studentperiodattendance.AttendanceComment = nil
  case "AttendanceStatus":
   n.studentperiodattendance.AttendanceStatus = nil
  case "AuditInfo":
   n.studentperiodattendance.AuditInfo = nil
  case "Date":
   n.studentperiodattendance.Date = nil
  case "LocalCodeList":
   n.studentperiodattendance.LocalCodeList = nil
  case "RefId":
   n.studentperiodattendance.RefId = nil
  case "SIF_ExtendedElements":
   n.studentperiodattendance.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentperiodattendance.SIF_Metadata = nil
  case "ScheduledActivityRefId":
   n.studentperiodattendance.ScheduledActivityRefId = nil
  case "SchoolInfoRefId":
   n.studentperiodattendance.SchoolInfoRefId = nil
  case "SchoolYear":
   n.studentperiodattendance.SchoolYear = nil
  case "SessionInfoRefId":
   n.studentperiodattendance.SessionInfoRefId = nil
  case "StudentPersonalRefId":
   n.studentperiodattendance.StudentPersonalRefId = nil
  case "TimeIn":
   n.studentperiodattendance.TimeIn = nil
  case "TimeOut":
   n.studentperiodattendance.TimeOut = nil
  case "TimetablePeriod":
   n.studentperiodattendance.TimetablePeriod = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentPeriodAttendance")
        }
        return n
}

// Set a sequence of properties
func (n *StudentPeriodAttendance) SetProperties(props ...Prop) *StudentPeriodAttendance {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentPeriodAttendance) SetProperty(key string, value interface{}) *StudentPeriodAttendance {
        if n == nil {
                n, _ = StudentPeriodAttendancePointer(StudentPeriodAttendance{})
        }
        switch key {
    case "AttendanceCode":
    if v, ok:= AttendanceCodeTypePointer(value); ok {
      n.studentperiodattendance.AttendanceCode = v
      }
    case "AttendanceComment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.AttendanceComment = ((*String)(v))
      }
    case "AttendanceStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsAttendanceStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsAttendanceStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.AttendanceStatus = ((*AUCodeSetsAttendanceStatusType)(v))
      }
    case "AuditInfo":
    if v, ok:= AuditInfoTypePointer(value); ok {
      n.studentperiodattendance.AuditInfo = v
      }
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.Date = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentperiodattendance.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentperiodattendance.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentperiodattendance.SIF_Metadata = v
      }
    case "ScheduledActivityRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.ScheduledActivityRefId = ((*String)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.SchoolYear = ((*SchoolYearType)(v))
      }
    case "SessionInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.SessionInfoRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.StudentPersonalRefId = ((*String)(v))
      }
    case "TimeIn":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.TimeIn = ((*String)(v))
      }
    case "TimeOut":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.TimeOut = ((*String)(v))
      }
    case "TimetablePeriod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentperiodattendance.TimetablePeriod = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentPeriodAttendance")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) AttendanceCode() *AttendanceCodeType {
    if s.studentperiodattendance.AttendanceCode == nil {
     if v, ok:= AttendanceCodeTypePointer(AttendanceCodeType{}); ok {
      s.studentperiodattendance.AttendanceCode = v
      }
      }
      return s.studentperiodattendance.AttendanceCode
    }
// Returns whether the element value for AttendanceCode is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) AttendanceCode_IsNil() bool {
    return s.studentperiodattendance.AttendanceCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) AttendanceComment() *String {
    if s.studentperiodattendance.AttendanceComment == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.AttendanceComment = ((*String)(v))
      }
      }
      return s.studentperiodattendance.AttendanceComment
    }
// Returns whether the element value for AttendanceComment is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) AttendanceComment_IsNil() bool {
    return s.studentperiodattendance.AttendanceComment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) AttendanceStatus() *AUCodeSetsAttendanceStatusType {
    if s.studentperiodattendance.AttendanceStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.AttendanceStatus = ((*AUCodeSetsAttendanceStatusType)(v))
      }
      }
      return s.studentperiodattendance.AttendanceStatus
    }
// Returns whether the element value for AttendanceStatus is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) AttendanceStatus_IsNil() bool {
    return s.studentperiodattendance.AttendanceStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) AuditInfo() *AuditInfoType {
    if s.studentperiodattendance.AuditInfo == nil {
     if v, ok:= AuditInfoTypePointer(AuditInfoType{}); ok {
      s.studentperiodattendance.AuditInfo = v
      }
      }
      return s.studentperiodattendance.AuditInfo
    }
// Returns whether the element value for AuditInfo is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) AuditInfo_IsNil() bool {
    return s.studentperiodattendance.AuditInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) Date() *String {
    if s.studentperiodattendance.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.Date = ((*String)(v))
      }
      }
      return s.studentperiodattendance.Date
    }
// Returns whether the element value for Date is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) Date_IsNil() bool {
    return s.studentperiodattendance.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) LocalCodeList() *LocalCodeListType {
    if s.studentperiodattendance.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentperiodattendance.LocalCodeList = v
      }
      }
      return s.studentperiodattendance.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) LocalCodeList_IsNil() bool {
    return s.studentperiodattendance.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) RefId() *RefIdType {
    if s.studentperiodattendance.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentperiodattendance.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) RefId_IsNil() bool {
    return s.studentperiodattendance.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentperiodattendance.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentperiodattendance.SIF_ExtendedElements = v
      }
      }
      return s.studentperiodattendance.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) SIF_ExtendedElements_IsNil() bool {
    return s.studentperiodattendance.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) SIF_Metadata() *SIF_MetadataType {
    if s.studentperiodattendance.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentperiodattendance.SIF_Metadata = v
      }
      }
      return s.studentperiodattendance.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) SIF_Metadata_IsNil() bool {
    return s.studentperiodattendance.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) ScheduledActivityRefId() *String {
    if s.studentperiodattendance.ScheduledActivityRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.ScheduledActivityRefId = ((*String)(v))
      }
      }
      return s.studentperiodattendance.ScheduledActivityRefId
    }
// Returns whether the element value for ScheduledActivityRefId is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) ScheduledActivityRefId_IsNil() bool {
    return s.studentperiodattendance.ScheduledActivityRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) SchoolInfoRefId() *String {
    if s.studentperiodattendance.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.studentperiodattendance.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) SchoolInfoRefId_IsNil() bool {
    return s.studentperiodattendance.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) SchoolYear() *SchoolYearType {
    if s.studentperiodattendance.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentperiodattendance.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) SchoolYear_IsNil() bool {
    return s.studentperiodattendance.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) SessionInfoRefId() *String {
    if s.studentperiodattendance.SessionInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.SessionInfoRefId = ((*String)(v))
      }
      }
      return s.studentperiodattendance.SessionInfoRefId
    }
// Returns whether the element value for SessionInfoRefId is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) SessionInfoRefId_IsNil() bool {
    return s.studentperiodattendance.SessionInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) StudentPersonalRefId() *String {
    if s.studentperiodattendance.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentperiodattendance.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) StudentPersonalRefId_IsNil() bool {
    return s.studentperiodattendance.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) TimeIn() *String {
    if s.studentperiodattendance.TimeIn == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.TimeIn = ((*String)(v))
      }
      }
      return s.studentperiodattendance.TimeIn
    }
// Returns whether the element value for TimeIn is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) TimeIn_IsNil() bool {
    return s.studentperiodattendance.TimeIn == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) TimeOut() *String {
    if s.studentperiodattendance.TimeOut == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.TimeOut = ((*String)(v))
      }
      }
      return s.studentperiodattendance.TimeOut
    }
// Returns whether the element value for TimeOut is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) TimeOut_IsNil() bool {
    return s.studentperiodattendance.TimeOut == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPeriodAttendance) TimetablePeriod() *String {
    if s.studentperiodattendance.TimetablePeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentperiodattendance.TimetablePeriod = ((*String)(v))
      }
      }
      return s.studentperiodattendance.TimetablePeriod
    }
// Returns whether the element value for TimetablePeriod is nil in the container StudentPeriodAttendance.
  func (s *StudentPeriodAttendance) TimetablePeriod_IsNil() bool {
    return s.studentperiodattendance.TimetablePeriod == nil
    }

// Set the value of a property to nil
func (n *StudentPersonal) Unset(key string) *StudentPersonal {
        switch key {
  case "AcceptableUsePolicy":
   n.studentpersonal.AcceptableUsePolicy = nil
  case "AlertMessages":
   n.studentpersonal.AlertMessages = nil
  case "CategoryOfDisability":
   n.studentpersonal.CategoryOfDisability = nil
  case "Disability":
   n.studentpersonal.Disability = nil
  case "ESL":
   n.studentpersonal.ESL = nil
  case "ESLDateAssessed":
   n.studentpersonal.ESLDateAssessed = nil
  case "ESLSupport":
   n.studentpersonal.ESLSupport = nil
  case "EconomicDisadvantage":
   n.studentpersonal.EconomicDisadvantage = nil
  case "EducationSupport":
   n.studentpersonal.EducationSupport = nil
  case "ElectronicIdList":
   n.studentpersonal.ElectronicIdList = nil
  case "FirstAUSchoolEnrollment":
   n.studentpersonal.FirstAUSchoolEnrollment = nil
  case "GiftedTalented":
   n.studentpersonal.GiftedTalented = nil
  case "GraduationDate":
   n.studentpersonal.GraduationDate = nil
  case "HomeSchooledStudent":
   n.studentpersonal.HomeSchooledStudent = nil
  case "IndependentStudent":
   n.studentpersonal.IndependentStudent = nil
  case "IntegrationAide":
   n.studentpersonal.IntegrationAide = nil
  case "LocalCodeList":
   n.studentpersonal.LocalCodeList = nil
  case "LocalId":
   n.studentpersonal.LocalId = nil
  case "MedicalAlertMessages":
   n.studentpersonal.MedicalAlertMessages = nil
  case "MostRecent":
   n.studentpersonal.MostRecent = nil
  case "NationalUniqueStudentIdentifier":
   n.studentpersonal.NationalUniqueStudentIdentifier = nil
  case "OfflineDelivery":
   n.studentpersonal.OfflineDelivery = nil
  case "OnTimeGraduationYear":
   n.studentpersonal.OnTimeGraduationYear = nil
  case "OtherIdList":
   n.studentpersonal.OtherIdList = nil
  case "PersonInfo":
   n.studentpersonal.PersonInfo = nil
  case "PrePrimaryEducation":
   n.studentpersonal.PrePrimaryEducation = nil
  case "PrePrimaryEducationHours":
   n.studentpersonal.PrePrimaryEducationHours = nil
  case "ProjectedGraduationYear":
   n.studentpersonal.ProjectedGraduationYear = nil
  case "RefId":
   n.studentpersonal.RefId = nil
  case "SIF_ExtendedElements":
   n.studentpersonal.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentpersonal.SIF_Metadata = nil
  case "Sensitive":
   n.studentpersonal.Sensitive = nil
  case "StateProvinceId":
   n.studentpersonal.StateProvinceId = nil
  case "YoungCarersRole":
   n.studentpersonal.YoungCarersRole = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentPersonal")
        }
        return n
}

// Set a sequence of properties
func (n *StudentPersonal) SetProperties(props ...Prop) *StudentPersonal {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentPersonal) SetProperty(key string, value interface{}) *StudentPersonal {
        if n == nil {
                n, _ = StudentPersonalPointer(StudentPersonal{})
        }
        switch key {
    case "AcceptableUsePolicy":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.AcceptableUsePolicy = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "AlertMessages":
    if v, ok:= AlertMessagesTypePointer(value); ok {
      n.studentpersonal.AlertMessages = v
      }
    case "CategoryOfDisability":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNCCDDisabilityType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNCCDDisabilityType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.CategoryOfDisability = ((*AUCodeSetsNCCDDisabilityType)(v))
      }
    case "Disability":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.Disability = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "ESL":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.ESL = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "ESLDateAssessed":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.ESLDateAssessed = ((*String)(v))
      }
    case "ESLSupport":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.ESLSupport = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "EconomicDisadvantage":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.EconomicDisadvantage = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "EducationSupport":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.EducationSupport = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "ElectronicIdList":
    if v, ok:= ElectronicIdListTypePointer(value); ok {
      n.studentpersonal.ElectronicIdList = v
      }
    case "FirstAUSchoolEnrollment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.FirstAUSchoolEnrollment = ((*String)(v))
      }
    case "GiftedTalented":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.GiftedTalented = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "GraduationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.GraduationDate = ((*GraduationDateType)(v))
      }
    case "HomeSchooledStudent":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.HomeSchooledStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "IndependentStudent":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.IndependentStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "IntegrationAide":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.IntegrationAide = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentpersonal.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.LocalId = ((*LocalIdType)(v))
      }
    case "MedicalAlertMessages":
    if v, ok:= MedicalAlertMessagesTypePointer(value); ok {
      n.studentpersonal.MedicalAlertMessages = v
      }
    case "MostRecent":
    if v, ok:= StudentMostRecentContainerTypePointer(value); ok {
      n.studentpersonal.MostRecent = v
      }
    case "NationalUniqueStudentIdentifier":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.NationalUniqueStudentIdentifier = ((*String)(v))
      }
    case "OfflineDelivery":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.OfflineDelivery = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "OnTimeGraduationYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.OnTimeGraduationYear = ((*OnTimeGraduationYearType)(v))
      }
    case "OtherIdList":
    if v, ok:= OtherIdListTypePointer(value); ok {
      n.studentpersonal.OtherIdList = v
      }
    case "PersonInfo":
    if v, ok:= PersonInfoTypePointer(value); ok {
      n.studentpersonal.PersonInfo = v
      }
    case "PrePrimaryEducation":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.PrePrimaryEducation = ((*String)(v))
      }
    case "PrePrimaryEducationHours":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsPrePrimaryHoursType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsPrePrimaryHoursType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.PrePrimaryEducationHours = ((*AUCodeSetsPrePrimaryHoursType)(v))
      }
    case "ProjectedGraduationYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.ProjectedGraduationYear = ((*ProjectedGraduationYearType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentpersonal.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentpersonal.SIF_Metadata = v
      }
    case "Sensitive":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.Sensitive = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "StateProvinceId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.StateProvinceId = ((*StateProvinceIdType)(v))
      }
    case "YoungCarersRole":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentpersonal.YoungCarersRole = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentPersonal")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) AcceptableUsePolicy() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.AcceptableUsePolicy == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.AcceptableUsePolicy = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.AcceptableUsePolicy
    }
// Returns whether the element value for AcceptableUsePolicy is nil in the container StudentPersonal.
  func (s *StudentPersonal) AcceptableUsePolicy_IsNil() bool {
    return s.studentpersonal.AcceptableUsePolicy == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) AlertMessages() *AlertMessagesType {
    if s.studentpersonal.AlertMessages == nil {
     if v, ok:= AlertMessagesTypePointer(AlertMessagesType{}); ok {
      s.studentpersonal.AlertMessages = v
      }
      }
      return s.studentpersonal.AlertMessages
    }
// Returns whether the element value for AlertMessages is nil in the container StudentPersonal.
  func (s *StudentPersonal) AlertMessages_IsNil() bool {
    return s.studentpersonal.AlertMessages == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) CategoryOfDisability() *AUCodeSetsNCCDDisabilityType {
    if s.studentpersonal.CategoryOfDisability == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.CategoryOfDisability = ((*AUCodeSetsNCCDDisabilityType)(v))
      }
      }
      return s.studentpersonal.CategoryOfDisability
    }
// Returns whether the element value for CategoryOfDisability is nil in the container StudentPersonal.
  func (s *StudentPersonal) CategoryOfDisability_IsNil() bool {
    return s.studentpersonal.CategoryOfDisability == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) Disability() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.Disability == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.Disability = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.Disability
    }
// Returns whether the element value for Disability is nil in the container StudentPersonal.
  func (s *StudentPersonal) Disability_IsNil() bool {
    return s.studentpersonal.Disability == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) ESL() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.ESL == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.ESL = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.ESL
    }
// Returns whether the element value for ESL is nil in the container StudentPersonal.
  func (s *StudentPersonal) ESL_IsNil() bool {
    return s.studentpersonal.ESL == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) ESLDateAssessed() *String {
    if s.studentpersonal.ESLDateAssessed == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.ESLDateAssessed = ((*String)(v))
      }
      }
      return s.studentpersonal.ESLDateAssessed
    }
// Returns whether the element value for ESLDateAssessed is nil in the container StudentPersonal.
  func (s *StudentPersonal) ESLDateAssessed_IsNil() bool {
    return s.studentpersonal.ESLDateAssessed == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) ESLSupport() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.ESLSupport == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.ESLSupport = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.ESLSupport
    }
// Returns whether the element value for ESLSupport is nil in the container StudentPersonal.
  func (s *StudentPersonal) ESLSupport_IsNil() bool {
    return s.studentpersonal.ESLSupport == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) EconomicDisadvantage() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.EconomicDisadvantage == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.EconomicDisadvantage = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.EconomicDisadvantage
    }
// Returns whether the element value for EconomicDisadvantage is nil in the container StudentPersonal.
  func (s *StudentPersonal) EconomicDisadvantage_IsNil() bool {
    return s.studentpersonal.EconomicDisadvantage == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) EducationSupport() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.EducationSupport == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.EducationSupport = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.EducationSupport
    }
// Returns whether the element value for EducationSupport is nil in the container StudentPersonal.
  func (s *StudentPersonal) EducationSupport_IsNil() bool {
    return s.studentpersonal.EducationSupport == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) ElectronicIdList() *ElectronicIdListType {
    if s.studentpersonal.ElectronicIdList == nil {
     if v, ok:= ElectronicIdListTypePointer(ElectronicIdListType{}); ok {
      s.studentpersonal.ElectronicIdList = v
      }
      }
      return s.studentpersonal.ElectronicIdList
    }
// Returns whether the element value for ElectronicIdList is nil in the container StudentPersonal.
  func (s *StudentPersonal) ElectronicIdList_IsNil() bool {
    return s.studentpersonal.ElectronicIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) FirstAUSchoolEnrollment() *String {
    if s.studentpersonal.FirstAUSchoolEnrollment == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.FirstAUSchoolEnrollment = ((*String)(v))
      }
      }
      return s.studentpersonal.FirstAUSchoolEnrollment
    }
// Returns whether the element value for FirstAUSchoolEnrollment is nil in the container StudentPersonal.
  func (s *StudentPersonal) FirstAUSchoolEnrollment_IsNil() bool {
    return s.studentpersonal.FirstAUSchoolEnrollment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) GiftedTalented() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.GiftedTalented == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.GiftedTalented = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.GiftedTalented
    }
// Returns whether the element value for GiftedTalented is nil in the container StudentPersonal.
  func (s *StudentPersonal) GiftedTalented_IsNil() bool {
    return s.studentpersonal.GiftedTalented == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) GraduationDate() *GraduationDateType {
    if s.studentpersonal.GraduationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.GraduationDate = ((*GraduationDateType)(v))
      }
      }
      return s.studentpersonal.GraduationDate
    }
// Returns whether the element value for GraduationDate is nil in the container StudentPersonal.
  func (s *StudentPersonal) GraduationDate_IsNil() bool {
    return s.studentpersonal.GraduationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) HomeSchooledStudent() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.HomeSchooledStudent == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.HomeSchooledStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.HomeSchooledStudent
    }
// Returns whether the element value for HomeSchooledStudent is nil in the container StudentPersonal.
  func (s *StudentPersonal) HomeSchooledStudent_IsNil() bool {
    return s.studentpersonal.HomeSchooledStudent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) IndependentStudent() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.IndependentStudent == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.IndependentStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.IndependentStudent
    }
// Returns whether the element value for IndependentStudent is nil in the container StudentPersonal.
  func (s *StudentPersonal) IndependentStudent_IsNil() bool {
    return s.studentpersonal.IndependentStudent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) IntegrationAide() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.IntegrationAide == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.IntegrationAide = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.IntegrationAide
    }
// Returns whether the element value for IntegrationAide is nil in the container StudentPersonal.
  func (s *StudentPersonal) IntegrationAide_IsNil() bool {
    return s.studentpersonal.IntegrationAide == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) LocalCodeList() *LocalCodeListType {
    if s.studentpersonal.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentpersonal.LocalCodeList = v
      }
      }
      return s.studentpersonal.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentPersonal.
  func (s *StudentPersonal) LocalCodeList_IsNil() bool {
    return s.studentpersonal.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) LocalId() *LocalIdType {
    if s.studentpersonal.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentpersonal.LocalId
    }
// Returns whether the element value for LocalId is nil in the container StudentPersonal.
  func (s *StudentPersonal) LocalId_IsNil() bool {
    return s.studentpersonal.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) MedicalAlertMessages() *MedicalAlertMessagesType {
    if s.studentpersonal.MedicalAlertMessages == nil {
     if v, ok:= MedicalAlertMessagesTypePointer(MedicalAlertMessagesType{}); ok {
      s.studentpersonal.MedicalAlertMessages = v
      }
      }
      return s.studentpersonal.MedicalAlertMessages
    }
// Returns whether the element value for MedicalAlertMessages is nil in the container StudentPersonal.
  func (s *StudentPersonal) MedicalAlertMessages_IsNil() bool {
    return s.studentpersonal.MedicalAlertMessages == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) MostRecent() *StudentMostRecentContainerType {
    if s.studentpersonal.MostRecent == nil {
     if v, ok:= StudentMostRecentContainerTypePointer(StudentMostRecentContainerType{}); ok {
      s.studentpersonal.MostRecent = v
      }
      }
      return s.studentpersonal.MostRecent
    }
// Returns whether the element value for MostRecent is nil in the container StudentPersonal.
  func (s *StudentPersonal) MostRecent_IsNil() bool {
    return s.studentpersonal.MostRecent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) NationalUniqueStudentIdentifier() *String {
    if s.studentpersonal.NationalUniqueStudentIdentifier == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.NationalUniqueStudentIdentifier = ((*String)(v))
      }
      }
      return s.studentpersonal.NationalUniqueStudentIdentifier
    }
// Returns whether the element value for NationalUniqueStudentIdentifier is nil in the container StudentPersonal.
  func (s *StudentPersonal) NationalUniqueStudentIdentifier_IsNil() bool {
    return s.studentpersonal.NationalUniqueStudentIdentifier == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) OfflineDelivery() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.OfflineDelivery == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.OfflineDelivery = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.OfflineDelivery
    }
// Returns whether the element value for OfflineDelivery is nil in the container StudentPersonal.
  func (s *StudentPersonal) OfflineDelivery_IsNil() bool {
    return s.studentpersonal.OfflineDelivery == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) OnTimeGraduationYear() *OnTimeGraduationYearType {
    if s.studentpersonal.OnTimeGraduationYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.OnTimeGraduationYear = ((*OnTimeGraduationYearType)(v))
      }
      }
      return s.studentpersonal.OnTimeGraduationYear
    }
// Returns whether the element value for OnTimeGraduationYear is nil in the container StudentPersonal.
  func (s *StudentPersonal) OnTimeGraduationYear_IsNil() bool {
    return s.studentpersonal.OnTimeGraduationYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) OtherIdList() *OtherIdListType {
    if s.studentpersonal.OtherIdList == nil {
     if v, ok:= OtherIdListTypePointer(OtherIdListType{}); ok {
      s.studentpersonal.OtherIdList = v
      }
      }
      return s.studentpersonal.OtherIdList
    }
// Returns whether the element value for OtherIdList is nil in the container StudentPersonal.
  func (s *StudentPersonal) OtherIdList_IsNil() bool {
    return s.studentpersonal.OtherIdList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) PersonInfo() *PersonInfoType {
    if s.studentpersonal.PersonInfo == nil {
     if v, ok:= PersonInfoTypePointer(PersonInfoType{}); ok {
      s.studentpersonal.PersonInfo = v
      }
      }
      return s.studentpersonal.PersonInfo
    }
// Returns whether the element value for PersonInfo is nil in the container StudentPersonal.
  func (s *StudentPersonal) PersonInfo_IsNil() bool {
    return s.studentpersonal.PersonInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) PrePrimaryEducation() *String {
    if s.studentpersonal.PrePrimaryEducation == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.PrePrimaryEducation = ((*String)(v))
      }
      }
      return s.studentpersonal.PrePrimaryEducation
    }
// Returns whether the element value for PrePrimaryEducation is nil in the container StudentPersonal.
  func (s *StudentPersonal) PrePrimaryEducation_IsNil() bool {
    return s.studentpersonal.PrePrimaryEducation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) PrePrimaryEducationHours() *AUCodeSetsPrePrimaryHoursType {
    if s.studentpersonal.PrePrimaryEducationHours == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.PrePrimaryEducationHours = ((*AUCodeSetsPrePrimaryHoursType)(v))
      }
      }
      return s.studentpersonal.PrePrimaryEducationHours
    }
// Returns whether the element value for PrePrimaryEducationHours is nil in the container StudentPersonal.
  func (s *StudentPersonal) PrePrimaryEducationHours_IsNil() bool {
    return s.studentpersonal.PrePrimaryEducationHours == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) ProjectedGraduationYear() *ProjectedGraduationYearType {
    if s.studentpersonal.ProjectedGraduationYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.ProjectedGraduationYear = ((*ProjectedGraduationYearType)(v))
      }
      }
      return s.studentpersonal.ProjectedGraduationYear
    }
// Returns whether the element value for ProjectedGraduationYear is nil in the container StudentPersonal.
  func (s *StudentPersonal) ProjectedGraduationYear_IsNil() bool {
    return s.studentpersonal.ProjectedGraduationYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) RefId() *RefIdType {
    if s.studentpersonal.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentpersonal.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentPersonal.
  func (s *StudentPersonal) RefId_IsNil() bool {
    return s.studentpersonal.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentpersonal.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentpersonal.SIF_ExtendedElements = v
      }
      }
      return s.studentpersonal.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentPersonal.
  func (s *StudentPersonal) SIF_ExtendedElements_IsNil() bool {
    return s.studentpersonal.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) SIF_Metadata() *SIF_MetadataType {
    if s.studentpersonal.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentpersonal.SIF_Metadata = v
      }
      }
      return s.studentpersonal.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentPersonal.
  func (s *StudentPersonal) SIF_Metadata_IsNil() bool {
    return s.studentpersonal.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) Sensitive() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.Sensitive == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.Sensitive = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.Sensitive
    }
// Returns whether the element value for Sensitive is nil in the container StudentPersonal.
  func (s *StudentPersonal) Sensitive_IsNil() bool {
    return s.studentpersonal.Sensitive == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) StateProvinceId() *StateProvinceIdType {
    if s.studentpersonal.StateProvinceId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.StateProvinceId = ((*StateProvinceIdType)(v))
      }
      }
      return s.studentpersonal.StateProvinceId
    }
// Returns whether the element value for StateProvinceId is nil in the container StudentPersonal.
  func (s *StudentPersonal) StateProvinceId_IsNil() bool {
    return s.studentpersonal.StateProvinceId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentPersonal) YoungCarersRole() *AUCodeSetsYesOrNoCategoryType {
    if s.studentpersonal.YoungCarersRole == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentpersonal.YoungCarersRole = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentpersonal.YoungCarersRole
    }
// Returns whether the element value for YoungCarersRole is nil in the container StudentPersonal.
  func (s *StudentPersonal) YoungCarersRole_IsNil() bool {
    return s.studentpersonal.YoungCarersRole == nil
    }

// Set the value of a property to nil
func (n *StudentSchoolEnrollment) Unset(key string) *StudentSchoolEnrollment {
        switch key {
  case "ACARASchoolId":
   n.studentschoolenrollment.ACARASchoolId = nil
  case "Advisor":
   n.studentschoolenrollment.Advisor = nil
  case "BoardingStatus":
   n.studentschoolenrollment.BoardingStatus = nil
  case "Calendar":
   n.studentschoolenrollment.Calendar = nil
  case "CatchmentStatus":
   n.studentschoolenrollment.CatchmentStatus = nil
  case "CensusAge":
   n.studentschoolenrollment.CensusAge = nil
  case "ClassCode":
   n.studentschoolenrollment.ClassCode = nil
  case "Counselor":
   n.studentschoolenrollment.Counselor = nil
  case "DestinationSchool":
   n.studentschoolenrollment.DestinationSchool = nil
  case "DestinationSchoolName":
   n.studentschoolenrollment.DestinationSchoolName = nil
  case "DisabilityCategory":
   n.studentschoolenrollment.DisabilityCategory = nil
  case "DisabilityLevelOfAdjustment":
   n.studentschoolenrollment.DisabilityLevelOfAdjustment = nil
  case "DistanceEducationStudent":
   n.studentschoolenrollment.DistanceEducationStudent = nil
  case "EntryDate":
   n.studentschoolenrollment.EntryDate = nil
  case "EntryType":
   n.studentschoolenrollment.EntryType = nil
  case "ExitDate":
   n.studentschoolenrollment.ExitDate = nil
  case "ExitStatus":
   n.studentschoolenrollment.ExitStatus = nil
  case "ExitType":
   n.studentschoolenrollment.ExitType = nil
  case "FFPOS":
   n.studentschoolenrollment.FFPOS = nil
  case "FTE":
   n.studentschoolenrollment.FTE = nil
  case "FTPTStatus":
   n.studentschoolenrollment.FTPTStatus = nil
  case "Homegroup":
   n.studentschoolenrollment.Homegroup = nil
  case "Homeroom":
   n.studentschoolenrollment.Homeroom = nil
  case "House":
   n.studentschoolenrollment.House = nil
  case "IndividualLearningPlan":
   n.studentschoolenrollment.IndividualLearningPlan = nil
  case "IntendedEntryDate":
   n.studentschoolenrollment.IntendedEntryDate = nil
  case "InternationalStudent":
   n.studentschoolenrollment.InternationalStudent = nil
  case "LocalCodeList":
   n.studentschoolenrollment.LocalCodeList = nil
  case "LocalId":
   n.studentschoolenrollment.LocalId = nil
  case "MembershipType":
   n.studentschoolenrollment.MembershipType = nil
  case "PreviousSchool":
   n.studentschoolenrollment.PreviousSchool = nil
  case "PreviousSchoolName":
   n.studentschoolenrollment.PreviousSchoolName = nil
  case "PromotionInfo":
   n.studentschoolenrollment.PromotionInfo = nil
  case "PublishingPermissionList":
   n.studentschoolenrollment.PublishingPermissionList = nil
  case "RecordClosureReason":
   n.studentschoolenrollment.RecordClosureReason = nil
  case "RefId":
   n.studentschoolenrollment.RefId = nil
  case "ReportingSchool":
   n.studentschoolenrollment.ReportingSchool = nil
  case "SIF_ExtendedElements":
   n.studentschoolenrollment.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentschoolenrollment.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.studentschoolenrollment.SchoolInfoRefId = nil
  case "SchoolYear":
   n.studentschoolenrollment.SchoolYear = nil
  case "StartedAtSchoolDate":
   n.studentschoolenrollment.StartedAtSchoolDate = nil
  case "StudentGroupList":
   n.studentschoolenrollment.StudentGroupList = nil
  case "StudentPersonalRefId":
   n.studentschoolenrollment.StudentPersonalRefId = nil
  case "StudentSubjectChoiceList":
   n.studentschoolenrollment.StudentSubjectChoiceList = nil
  case "TestLevel":
   n.studentschoolenrollment.TestLevel = nil
  case "TimeFrame":
   n.studentschoolenrollment.TimeFrame = nil
  case "TravelDetails":
   n.studentschoolenrollment.TravelDetails = nil
  case "YearLevel":
   n.studentschoolenrollment.YearLevel = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentSchoolEnrollment")
        }
        return n
}

// Set a sequence of properties
func (n *StudentSchoolEnrollment) SetProperties(props ...Prop) *StudentSchoolEnrollment {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentSchoolEnrollment) SetProperty(key string, value interface{}) *StudentSchoolEnrollment {
        if n == nil {
                n, _ = StudentSchoolEnrollmentPointer(StudentSchoolEnrollment{})
        }
        switch key {
    case "ACARASchoolId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.ACARASchoolId = ((*LocalIdType)(v))
      }
    case "Advisor":
    if v, ok:= StaffRefIdTypePointer(value); ok {
      n.studentschoolenrollment.Advisor = v
      }
    case "BoardingStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsBoardingType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsBoardingType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.BoardingStatus = ((*AUCodeSetsBoardingType)(v))
      }
    case "Calendar":
    if v, ok:= StudentSchoolEnrollment_CalendarPointer(value); ok {
      n.studentschoolenrollment.Calendar = v
      }
    case "CatchmentStatus":
    if v, ok:= CatchmentStatusContainerTypePointer(value); ok {
      n.studentschoolenrollment.CatchmentStatus = v
      }
    case "CensusAge":
    
    if v, ok:= IntPointer(value); ok {
      n.studentschoolenrollment.CensusAge = ((*Int)(v))
      }
    case "ClassCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.ClassCode = ((*String)(v))
      }
    case "Counselor":
    if v, ok:= StaffRefIdTypePointer(value); ok {
      n.studentschoolenrollment.Counselor = v
      }
    case "DestinationSchool":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.DestinationSchool = ((*LocalIdType)(v))
      }
    case "DestinationSchoolName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.DestinationSchoolName = ((*String)(v))
      }
    case "DisabilityCategory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNCCDDisabilityType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNCCDDisabilityType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.DisabilityCategory = ((*AUCodeSetsNCCDDisabilityType)(v))
      }
    case "DisabilityLevelOfAdjustment":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsNCCDAdjustmentType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsNCCDAdjustmentType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.DisabilityLevelOfAdjustment = ((*AUCodeSetsNCCDAdjustmentType)(v))
      }
    case "DistanceEducationStudent":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.DistanceEducationStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "EntryDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.EntryDate = ((*String)(v))
      }
    case "EntryType":
    if v, ok:= StudentEntryContainerTypePointer(value); ok {
      n.studentschoolenrollment.EntryType = v
      }
    case "ExitDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.ExitDate = ((*String)(v))
      }
    case "ExitStatus":
    if v, ok:= StudentExitStatusContainerTypePointer(value); ok {
      n.studentschoolenrollment.ExitStatus = v
      }
    case "ExitType":
    if v, ok:= StudentExitContainerTypePointer(value); ok {
      n.studentschoolenrollment.ExitType = v
      }
    case "FFPOS":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsFFPOSStatusCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsFFPOSStatusCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.FFPOS = ((*AUCodeSetsFFPOSStatusCodeType)(v))
      }
    case "FTE":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.FTE = ((*FTEType)(v))
      }
    case "FTPTStatus":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsFTPTStatusCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsFTPTStatusCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.FTPTStatus = ((*AUCodeSetsFTPTStatusCodeType)(v))
      }
    case "Homegroup":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.Homegroup = ((*String)(v))
      }
    case "Homeroom":
    if v, ok:= HomeroomTypePointer(value); ok {
      n.studentschoolenrollment.Homeroom = v
      }
    case "House":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.House = ((*String)(v))
      }
    case "IndividualLearningPlan":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.IndividualLearningPlan = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "IntendedEntryDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.IntendedEntryDate = ((*String)(v))
      }
    case "InternationalStudent":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.InternationalStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentschoolenrollment.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.LocalId = ((*LocalIdType)(v))
      }
    case "MembershipType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSchoolEnrollmentTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSchoolEnrollmentTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.MembershipType = ((*AUCodeSetsSchoolEnrollmentTypeType)(v))
      }
    case "PreviousSchool":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.PreviousSchool = ((*LocalIdType)(v))
      }
    case "PreviousSchoolName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.PreviousSchoolName = ((*String)(v))
      }
    case "PromotionInfo":
    if v, ok:= PromotionInfoTypePointer(value); ok {
      n.studentschoolenrollment.PromotionInfo = v
      }
    case "PublishingPermissionList":
    if v, ok:= PublishingPermissionListTypePointer(value); ok {
      n.studentschoolenrollment.PublishingPermissionList = v
      }
    case "RecordClosureReason":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.RecordClosureReason = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.RefId = ((*RefIdType)(v))
      }
    case "ReportingSchool":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.ReportingSchool = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentschoolenrollment.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentschoolenrollment.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StartedAtSchoolDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.StartedAtSchoolDate = ((*String)(v))
      }
    case "StudentGroupList":
    if v, ok:= StudentGroupListTypePointer(value); ok {
      n.studentschoolenrollment.StudentGroupList = v
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.StudentPersonalRefId = ((*String)(v))
      }
    case "StudentSubjectChoiceList":
    if v, ok:= StudentSubjectChoiceListTypePointer(value); ok {
      n.studentschoolenrollment.StudentSubjectChoiceList = v
      }
    case "TestLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.studentschoolenrollment.TestLevel = v
      }
    case "TimeFrame":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsEnrollmentTimeFrameType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsEnrollmentTimeFrameType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment.TimeFrame = ((*AUCodeSetsEnrollmentTimeFrameType)(v))
      }
    case "TravelDetails":
    if v, ok:= TravelDetailsContainerTypePointer(value); ok {
      n.studentschoolenrollment.TravelDetails = v
      }
    case "YearLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.studentschoolenrollment.YearLevel = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentSchoolEnrollment")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) ACARASchoolId() *LocalIdType {
    if s.studentschoolenrollment.ACARASchoolId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.ACARASchoolId = ((*LocalIdType)(v))
      }
      }
      return s.studentschoolenrollment.ACARASchoolId
    }
// Returns whether the element value for ACARASchoolId is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) ACARASchoolId_IsNil() bool {
    return s.studentschoolenrollment.ACARASchoolId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) Advisor() *StaffRefIdType {
    if s.studentschoolenrollment.Advisor == nil {
     if v, ok:= StaffRefIdTypePointer(StaffRefIdType{}); ok {
      s.studentschoolenrollment.Advisor = v
      }
      }
      return s.studentschoolenrollment.Advisor
    }
// Returns whether the element value for Advisor is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) Advisor_IsNil() bool {
    return s.studentschoolenrollment.Advisor == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) BoardingStatus() *AUCodeSetsBoardingType {
    if s.studentschoolenrollment.BoardingStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.BoardingStatus = ((*AUCodeSetsBoardingType)(v))
      }
      }
      return s.studentschoolenrollment.BoardingStatus
    }
// Returns whether the element value for BoardingStatus is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) BoardingStatus_IsNil() bool {
    return s.studentschoolenrollment.BoardingStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) Calendar() *StudentSchoolEnrollment_Calendar {
    if s.studentschoolenrollment.Calendar == nil {
     if v, ok:= StudentSchoolEnrollment_CalendarPointer(StudentSchoolEnrollment_Calendar{}); ok {
      s.studentschoolenrollment.Calendar = v
      }
      }
      return s.studentschoolenrollment.Calendar
    }
// Returns whether the element value for Calendar is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) Calendar_IsNil() bool {
    return s.studentschoolenrollment.Calendar == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) CatchmentStatus() *CatchmentStatusContainerType {
    if s.studentschoolenrollment.CatchmentStatus == nil {
     if v, ok:= CatchmentStatusContainerTypePointer(CatchmentStatusContainerType{}); ok {
      s.studentschoolenrollment.CatchmentStatus = v
      }
      }
      return s.studentschoolenrollment.CatchmentStatus
    }
// Returns whether the element value for CatchmentStatus is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) CatchmentStatus_IsNil() bool {
    return s.studentschoolenrollment.CatchmentStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) CensusAge() *Int {
    if s.studentschoolenrollment.CensusAge == nil {
    if v, ok:= IntPointer(0); ok {
      s.studentschoolenrollment.CensusAge = ((*Int)(v))
      }
      }
      return s.studentschoolenrollment.CensusAge
    }
// Returns whether the element value for CensusAge is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) CensusAge_IsNil() bool {
    return s.studentschoolenrollment.CensusAge == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) ClassCode() *String {
    if s.studentschoolenrollment.ClassCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.ClassCode = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.ClassCode
    }
// Returns whether the element value for ClassCode is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) ClassCode_IsNil() bool {
    return s.studentschoolenrollment.ClassCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) Counselor() *StaffRefIdType {
    if s.studentschoolenrollment.Counselor == nil {
     if v, ok:= StaffRefIdTypePointer(StaffRefIdType{}); ok {
      s.studentschoolenrollment.Counselor = v
      }
      }
      return s.studentschoolenrollment.Counselor
    }
// Returns whether the element value for Counselor is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) Counselor_IsNil() bool {
    return s.studentschoolenrollment.Counselor == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) DestinationSchool() *LocalIdType {
    if s.studentschoolenrollment.DestinationSchool == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.DestinationSchool = ((*LocalIdType)(v))
      }
      }
      return s.studentschoolenrollment.DestinationSchool
    }
// Returns whether the element value for DestinationSchool is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) DestinationSchool_IsNil() bool {
    return s.studentschoolenrollment.DestinationSchool == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) DestinationSchoolName() *String {
    if s.studentschoolenrollment.DestinationSchoolName == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.DestinationSchoolName = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.DestinationSchoolName
    }
// Returns whether the element value for DestinationSchoolName is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) DestinationSchoolName_IsNil() bool {
    return s.studentschoolenrollment.DestinationSchoolName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) DisabilityCategory() *AUCodeSetsNCCDDisabilityType {
    if s.studentschoolenrollment.DisabilityCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.DisabilityCategory = ((*AUCodeSetsNCCDDisabilityType)(v))
      }
      }
      return s.studentschoolenrollment.DisabilityCategory
    }
// Returns whether the element value for DisabilityCategory is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) DisabilityCategory_IsNil() bool {
    return s.studentschoolenrollment.DisabilityCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) DisabilityLevelOfAdjustment() *AUCodeSetsNCCDAdjustmentType {
    if s.studentschoolenrollment.DisabilityLevelOfAdjustment == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.DisabilityLevelOfAdjustment = ((*AUCodeSetsNCCDAdjustmentType)(v))
      }
      }
      return s.studentschoolenrollment.DisabilityLevelOfAdjustment
    }
// Returns whether the element value for DisabilityLevelOfAdjustment is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) DisabilityLevelOfAdjustment_IsNil() bool {
    return s.studentschoolenrollment.DisabilityLevelOfAdjustment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) DistanceEducationStudent() *AUCodeSetsYesOrNoCategoryType {
    if s.studentschoolenrollment.DistanceEducationStudent == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.DistanceEducationStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentschoolenrollment.DistanceEducationStudent
    }
// Returns whether the element value for DistanceEducationStudent is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) DistanceEducationStudent_IsNil() bool {
    return s.studentschoolenrollment.DistanceEducationStudent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) EntryDate() *String {
    if s.studentschoolenrollment.EntryDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.EntryDate = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.EntryDate
    }
// Returns whether the element value for EntryDate is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) EntryDate_IsNil() bool {
    return s.studentschoolenrollment.EntryDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) EntryType() *StudentEntryContainerType {
    if s.studentschoolenrollment.EntryType == nil {
     if v, ok:= StudentEntryContainerTypePointer(StudentEntryContainerType{}); ok {
      s.studentschoolenrollment.EntryType = v
      }
      }
      return s.studentschoolenrollment.EntryType
    }
// Returns whether the element value for EntryType is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) EntryType_IsNil() bool {
    return s.studentschoolenrollment.EntryType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) ExitDate() *String {
    if s.studentschoolenrollment.ExitDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.ExitDate = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.ExitDate
    }
// Returns whether the element value for ExitDate is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) ExitDate_IsNil() bool {
    return s.studentschoolenrollment.ExitDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) ExitStatus() *StudentExitStatusContainerType {
    if s.studentschoolenrollment.ExitStatus == nil {
     if v, ok:= StudentExitStatusContainerTypePointer(StudentExitStatusContainerType{}); ok {
      s.studentschoolenrollment.ExitStatus = v
      }
      }
      return s.studentschoolenrollment.ExitStatus
    }
// Returns whether the element value for ExitStatus is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) ExitStatus_IsNil() bool {
    return s.studentschoolenrollment.ExitStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) ExitType() *StudentExitContainerType {
    if s.studentschoolenrollment.ExitType == nil {
     if v, ok:= StudentExitContainerTypePointer(StudentExitContainerType{}); ok {
      s.studentschoolenrollment.ExitType = v
      }
      }
      return s.studentschoolenrollment.ExitType
    }
// Returns whether the element value for ExitType is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) ExitType_IsNil() bool {
    return s.studentschoolenrollment.ExitType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) FFPOS() *AUCodeSetsFFPOSStatusCodeType {
    if s.studentschoolenrollment.FFPOS == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.FFPOS = ((*AUCodeSetsFFPOSStatusCodeType)(v))
      }
      }
      return s.studentschoolenrollment.FFPOS
    }
// Returns whether the element value for FFPOS is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) FFPOS_IsNil() bool {
    return s.studentschoolenrollment.FFPOS == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) FTE() *FTEType {
    if s.studentschoolenrollment.FTE == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.FTE = ((*FTEType)(v))
      }
      }
      return s.studentschoolenrollment.FTE
    }
// Returns whether the element value for FTE is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) FTE_IsNil() bool {
    return s.studentschoolenrollment.FTE == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) FTPTStatus() *AUCodeSetsFTPTStatusCodeType {
    if s.studentschoolenrollment.FTPTStatus == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.FTPTStatus = ((*AUCodeSetsFTPTStatusCodeType)(v))
      }
      }
      return s.studentschoolenrollment.FTPTStatus
    }
// Returns whether the element value for FTPTStatus is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) FTPTStatus_IsNil() bool {
    return s.studentschoolenrollment.FTPTStatus == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) Homegroup() *String {
    if s.studentschoolenrollment.Homegroup == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.Homegroup = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.Homegroup
    }
// Returns whether the element value for Homegroup is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) Homegroup_IsNil() bool {
    return s.studentschoolenrollment.Homegroup == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) Homeroom() *HomeroomType {
    if s.studentschoolenrollment.Homeroom == nil {
     if v, ok:= HomeroomTypePointer(HomeroomType{}); ok {
      s.studentschoolenrollment.Homeroom = v
      }
      }
      return s.studentschoolenrollment.Homeroom
    }
// Returns whether the element value for Homeroom is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) Homeroom_IsNil() bool {
    return s.studentschoolenrollment.Homeroom == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) House() *String {
    if s.studentschoolenrollment.House == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.House = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.House
    }
// Returns whether the element value for House is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) House_IsNil() bool {
    return s.studentschoolenrollment.House == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) IndividualLearningPlan() *AUCodeSetsYesOrNoCategoryType {
    if s.studentschoolenrollment.IndividualLearningPlan == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.IndividualLearningPlan = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentschoolenrollment.IndividualLearningPlan
    }
// Returns whether the element value for IndividualLearningPlan is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) IndividualLearningPlan_IsNil() bool {
    return s.studentschoolenrollment.IndividualLearningPlan == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) IntendedEntryDate() *String {
    if s.studentschoolenrollment.IntendedEntryDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.IntendedEntryDate = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.IntendedEntryDate
    }
// Returns whether the element value for IntendedEntryDate is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) IntendedEntryDate_IsNil() bool {
    return s.studentschoolenrollment.IntendedEntryDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) InternationalStudent() *AUCodeSetsYesOrNoCategoryType {
    if s.studentschoolenrollment.InternationalStudent == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.InternationalStudent = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentschoolenrollment.InternationalStudent
    }
// Returns whether the element value for InternationalStudent is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) InternationalStudent_IsNil() bool {
    return s.studentschoolenrollment.InternationalStudent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) LocalCodeList() *LocalCodeListType {
    if s.studentschoolenrollment.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentschoolenrollment.LocalCodeList = v
      }
      }
      return s.studentschoolenrollment.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) LocalCodeList_IsNil() bool {
    return s.studentschoolenrollment.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) LocalId() *LocalIdType {
    if s.studentschoolenrollment.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentschoolenrollment.LocalId
    }
// Returns whether the element value for LocalId is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) LocalId_IsNil() bool {
    return s.studentschoolenrollment.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) MembershipType() *AUCodeSetsSchoolEnrollmentTypeType {
    if s.studentschoolenrollment.MembershipType == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.MembershipType = ((*AUCodeSetsSchoolEnrollmentTypeType)(v))
      }
      }
      return s.studentschoolenrollment.MembershipType
    }
// Returns whether the element value for MembershipType is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) MembershipType_IsNil() bool {
    return s.studentschoolenrollment.MembershipType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) PreviousSchool() *LocalIdType {
    if s.studentschoolenrollment.PreviousSchool == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.PreviousSchool = ((*LocalIdType)(v))
      }
      }
      return s.studentschoolenrollment.PreviousSchool
    }
// Returns whether the element value for PreviousSchool is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) PreviousSchool_IsNil() bool {
    return s.studentschoolenrollment.PreviousSchool == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) PreviousSchoolName() *String {
    if s.studentschoolenrollment.PreviousSchoolName == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.PreviousSchoolName = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.PreviousSchoolName
    }
// Returns whether the element value for PreviousSchoolName is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) PreviousSchoolName_IsNil() bool {
    return s.studentschoolenrollment.PreviousSchoolName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) PromotionInfo() *PromotionInfoType {
    if s.studentschoolenrollment.PromotionInfo == nil {
     if v, ok:= PromotionInfoTypePointer(PromotionInfoType{}); ok {
      s.studentschoolenrollment.PromotionInfo = v
      }
      }
      return s.studentschoolenrollment.PromotionInfo
    }
// Returns whether the element value for PromotionInfo is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) PromotionInfo_IsNil() bool {
    return s.studentschoolenrollment.PromotionInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) PublishingPermissionList() *PublishingPermissionListType {
    if s.studentschoolenrollment.PublishingPermissionList == nil {
     if v, ok:= PublishingPermissionListTypePointer(PublishingPermissionListType{}); ok {
      s.studentschoolenrollment.PublishingPermissionList = v
      }
      }
      return s.studentschoolenrollment.PublishingPermissionList
    }
// Returns whether the element value for PublishingPermissionList is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) PublishingPermissionList_IsNil() bool {
    return s.studentschoolenrollment.PublishingPermissionList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) RecordClosureReason() *String {
    if s.studentschoolenrollment.RecordClosureReason == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.RecordClosureReason = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.RecordClosureReason
    }
// Returns whether the element value for RecordClosureReason is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) RecordClosureReason_IsNil() bool {
    return s.studentschoolenrollment.RecordClosureReason == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) RefId() *RefIdType {
    if s.studentschoolenrollment.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentschoolenrollment.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) RefId_IsNil() bool {
    return s.studentschoolenrollment.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) ReportingSchool() *AUCodeSetsYesOrNoCategoryType {
    if s.studentschoolenrollment.ReportingSchool == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.ReportingSchool = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.studentschoolenrollment.ReportingSchool
    }
// Returns whether the element value for ReportingSchool is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) ReportingSchool_IsNil() bool {
    return s.studentschoolenrollment.ReportingSchool == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentschoolenrollment.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentschoolenrollment.SIF_ExtendedElements = v
      }
      }
      return s.studentschoolenrollment.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) SIF_ExtendedElements_IsNil() bool {
    return s.studentschoolenrollment.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) SIF_Metadata() *SIF_MetadataType {
    if s.studentschoolenrollment.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentschoolenrollment.SIF_Metadata = v
      }
      }
      return s.studentschoolenrollment.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) SIF_Metadata_IsNil() bool {
    return s.studentschoolenrollment.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) SchoolInfoRefId() *String {
    if s.studentschoolenrollment.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) SchoolInfoRefId_IsNil() bool {
    return s.studentschoolenrollment.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) SchoolYear() *SchoolYearType {
    if s.studentschoolenrollment.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentschoolenrollment.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) SchoolYear_IsNil() bool {
    return s.studentschoolenrollment.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) StartedAtSchoolDate() *String {
    if s.studentschoolenrollment.StartedAtSchoolDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.StartedAtSchoolDate = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.StartedAtSchoolDate
    }
// Returns whether the element value for StartedAtSchoolDate is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) StartedAtSchoolDate_IsNil() bool {
    return s.studentschoolenrollment.StartedAtSchoolDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) StudentGroupList() *StudentGroupListType {
    if s.studentschoolenrollment.StudentGroupList == nil {
     if v, ok:= StudentGroupListTypePointer(StudentGroupListType{}); ok {
      s.studentschoolenrollment.StudentGroupList = v
      }
      }
      return s.studentschoolenrollment.StudentGroupList
    }
// Returns whether the element value for StudentGroupList is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) StudentGroupList_IsNil() bool {
    return s.studentschoolenrollment.StudentGroupList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) StudentPersonalRefId() *String {
    if s.studentschoolenrollment.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentschoolenrollment.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) StudentPersonalRefId_IsNil() bool {
    return s.studentschoolenrollment.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) StudentSubjectChoiceList() *StudentSubjectChoiceListType {
    if s.studentschoolenrollment.StudentSubjectChoiceList == nil {
     if v, ok:= StudentSubjectChoiceListTypePointer(StudentSubjectChoiceListType{}); ok {
      s.studentschoolenrollment.StudentSubjectChoiceList = v
      }
      }
      return s.studentschoolenrollment.StudentSubjectChoiceList
    }
// Returns whether the element value for StudentSubjectChoiceList is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) StudentSubjectChoiceList_IsNil() bool {
    return s.studentschoolenrollment.StudentSubjectChoiceList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) TestLevel() *YearLevelType {
    if s.studentschoolenrollment.TestLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.studentschoolenrollment.TestLevel = v
      }
      }
      return s.studentschoolenrollment.TestLevel
    }
// Returns whether the element value for TestLevel is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) TestLevel_IsNil() bool {
    return s.studentschoolenrollment.TestLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) TimeFrame() *AUCodeSetsEnrollmentTimeFrameType {
    if s.studentschoolenrollment.TimeFrame == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment.TimeFrame = ((*AUCodeSetsEnrollmentTimeFrameType)(v))
      }
      }
      return s.studentschoolenrollment.TimeFrame
    }
// Returns whether the element value for TimeFrame is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) TimeFrame_IsNil() bool {
    return s.studentschoolenrollment.TimeFrame == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) TravelDetails() *TravelDetailsContainerType {
    if s.studentschoolenrollment.TravelDetails == nil {
     if v, ok:= TravelDetailsContainerTypePointer(TravelDetailsContainerType{}); ok {
      s.studentschoolenrollment.TravelDetails = v
      }
      }
      return s.studentschoolenrollment.TravelDetails
    }
// Returns whether the element value for TravelDetails is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) TravelDetails_IsNil() bool {
    return s.studentschoolenrollment.TravelDetails == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment) YearLevel() *YearLevelType {
    if s.studentschoolenrollment.YearLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.studentschoolenrollment.YearLevel = v
      }
      }
      return s.studentschoolenrollment.YearLevel
    }
// Returns whether the element value for YearLevel is nil in the container StudentSchoolEnrollment.
  func (s *StudentSchoolEnrollment) YearLevel_IsNil() bool {
    return s.studentschoolenrollment.YearLevel == nil
    }

// Set the value of a property to nil
func (n *StudentSchoolEnrollment_Calendar) Unset(key string) *StudentSchoolEnrollment_Calendar {
        switch key {
  case "SIF_RefObject":
   n.studentschoolenrollment_calendar.SIF_RefObject = nil
  case "Value":
   n.studentschoolenrollment_calendar.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentSchoolEnrollment_Calendar")
        }
        return n
}

// Set a sequence of properties
func (n *StudentSchoolEnrollment_Calendar) SetProperties(props ...Prop) *StudentSchoolEnrollment_Calendar {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentSchoolEnrollment_Calendar) SetProperty(key string, value interface{}) *StudentSchoolEnrollment_Calendar {
        if n == nil {
                n, _ = StudentSchoolEnrollment_CalendarPointer(StudentSchoolEnrollment_Calendar{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment_calendar.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentschoolenrollment_calendar.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentSchoolEnrollment_Calendar")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment_Calendar) SIF_RefObject() *String {
    if s.studentschoolenrollment_calendar.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment_calendar.SIF_RefObject = ((*String)(v))
      }
      }
      return s.studentschoolenrollment_calendar.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container StudentSchoolEnrollment_Calendar.
  func (s *StudentSchoolEnrollment_Calendar) SIF_RefObject_IsNil() bool {
    return s.studentschoolenrollment_calendar.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSchoolEnrollment_Calendar) Value() *String {
    if s.studentschoolenrollment_calendar.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentschoolenrollment_calendar.Value = ((*String)(v))
      }
      }
      return s.studentschoolenrollment_calendar.Value
    }
// Returns whether the element value for Value is nil in the container StudentSchoolEnrollment_Calendar.
  func (s *StudentSchoolEnrollment_Calendar) Value_IsNil() bool {
    return s.studentschoolenrollment_calendar.Value == nil
    }

// Set the value of a property to nil
func (n *StudentScoreJudgementAgainstStandard) Unset(key string) *StudentScoreJudgementAgainstStandard {
        switch key {
  case "ClassLocalId":
   n.studentscorejudgementagainststandard.ClassLocalId = nil
  case "CurriculumCode":
   n.studentscorejudgementagainststandard.CurriculumCode = nil
  case "CurriculumNodeCode":
   n.studentscorejudgementagainststandard.CurriculumNodeCode = nil
  case "Grade":
   n.studentscorejudgementagainststandard.Grade = nil
  case "LearningStandardList":
   n.studentscorejudgementagainststandard.LearningStandardList = nil
  case "LocalCodeList":
   n.studentscorejudgementagainststandard.LocalCodeList = nil
  case "LocalTermCode":
   n.studentscorejudgementagainststandard.LocalTermCode = nil
  case "ManagedPathwayLocalCode":
   n.studentscorejudgementagainststandard.ManagedPathwayLocalCode = nil
  case "RefId":
   n.studentscorejudgementagainststandard.RefId = nil
  case "SIF_ExtendedElements":
   n.studentscorejudgementagainststandard.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentscorejudgementagainststandard.SIF_Metadata = nil
  case "SchoolCommonwealthId":
   n.studentscorejudgementagainststandard.SchoolCommonwealthId = nil
  case "SchoolInfoRefId":
   n.studentscorejudgementagainststandard.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.studentscorejudgementagainststandard.SchoolLocalId = nil
  case "SchoolYear":
   n.studentscorejudgementagainststandard.SchoolYear = nil
  case "Score":
   n.studentscorejudgementagainststandard.Score = nil
  case "SpecialCircumstanceLocalCode":
   n.studentscorejudgementagainststandard.SpecialCircumstanceLocalCode = nil
  case "StaffLocalId":
   n.studentscorejudgementagainststandard.StaffLocalId = nil
  case "StaffPersonalRefId":
   n.studentscorejudgementagainststandard.StaffPersonalRefId = nil
  case "StudentLocalId":
   n.studentscorejudgementagainststandard.StudentLocalId = nil
  case "StudentPersonalRefId":
   n.studentscorejudgementagainststandard.StudentPersonalRefId = nil
  case "StudentStateProvinceId":
   n.studentscorejudgementagainststandard.StudentStateProvinceId = nil
  case "TeacherJudgement":
   n.studentscorejudgementagainststandard.TeacherJudgement = nil
  case "TeachingGroupRefId":
   n.studentscorejudgementagainststandard.TeachingGroupRefId = nil
  case "TermInfoRefId":
   n.studentscorejudgementagainststandard.TermInfoRefId = nil
  case "YearLevel":
   n.studentscorejudgementagainststandard.YearLevel = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentScoreJudgementAgainstStandard")
        }
        return n
}

// Set a sequence of properties
func (n *StudentScoreJudgementAgainstStandard) SetProperties(props ...Prop) *StudentScoreJudgementAgainstStandard {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentScoreJudgementAgainstStandard) SetProperty(key string, value interface{}) *StudentScoreJudgementAgainstStandard {
        if n == nil {
                n, _ = StudentScoreJudgementAgainstStandardPointer(StudentScoreJudgementAgainstStandard{})
        }
        switch key {
    case "ClassLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.ClassLocalId = ((*String)(v))
      }
    case "CurriculumCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.CurriculumCode = ((*LocalIdType)(v))
      }
    case "CurriculumNodeCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.CurriculumNodeCode = ((*LocalIdType)(v))
      }
    case "Grade":
    if v, ok:= GradeTypePointer(value); ok {
      n.studentscorejudgementagainststandard.Grade = v
      }
    case "LearningStandardList":
    if v, ok:= LearningStandardListTypePointer(value); ok {
      n.studentscorejudgementagainststandard.LearningStandardList = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentscorejudgementagainststandard.LocalCodeList = v
      }
    case "LocalTermCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.LocalTermCode = ((*LocalIdType)(v))
      }
    case "ManagedPathwayLocalCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.ManagedPathwayLocalCode = ((*LocalIdType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentscorejudgementagainststandard.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentscorejudgementagainststandard.SIF_Metadata = v
      }
    case "SchoolCommonwealthId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.SchoolCommonwealthId = ((*String)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.SchoolYear = ((*SchoolYearType)(v))
      }
    case "Score":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.Score = ((*String)(v))
      }
    case "SpecialCircumstanceLocalCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.SpecialCircumstanceLocalCode = ((*LocalIdType)(v))
      }
    case "StaffLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.StaffLocalId = ((*LocalIdType)(v))
      }
    case "StaffPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.StaffPersonalRefId = ((*String)(v))
      }
    case "StudentLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.StudentLocalId = ((*LocalIdType)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.StudentPersonalRefId = ((*String)(v))
      }
    case "StudentStateProvinceId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.StudentStateProvinceId = ((*StateProvinceIdType)(v))
      }
    case "TeacherJudgement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.TeacherJudgement = ((*String)(v))
      }
    case "TeachingGroupRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.TeachingGroupRefId = ((*String)(v))
      }
    case "TermInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentscorejudgementagainststandard.TermInfoRefId = ((*String)(v))
      }
    case "YearLevel":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.studentscorejudgementagainststandard.YearLevel = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentScoreJudgementAgainstStandard")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) ClassLocalId() *String {
    if s.studentscorejudgementagainststandard.ClassLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.ClassLocalId = ((*String)(v))
      }
      }
      return s.studentscorejudgementagainststandard.ClassLocalId
    }
// Returns whether the element value for ClassLocalId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) ClassLocalId_IsNil() bool {
    return s.studentscorejudgementagainststandard.ClassLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) CurriculumCode() *LocalIdType {
    if s.studentscorejudgementagainststandard.CurriculumCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.CurriculumCode = ((*LocalIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.CurriculumCode
    }
// Returns whether the element value for CurriculumCode is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) CurriculumCode_IsNil() bool {
    return s.studentscorejudgementagainststandard.CurriculumCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) CurriculumNodeCode() *LocalIdType {
    if s.studentscorejudgementagainststandard.CurriculumNodeCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.CurriculumNodeCode = ((*LocalIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.CurriculumNodeCode
    }
// Returns whether the element value for CurriculumNodeCode is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) CurriculumNodeCode_IsNil() bool {
    return s.studentscorejudgementagainststandard.CurriculumNodeCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) Grade() *GradeType {
    if s.studentscorejudgementagainststandard.Grade == nil {
     if v, ok:= GradeTypePointer(GradeType{}); ok {
      s.studentscorejudgementagainststandard.Grade = v
      }
      }
      return s.studentscorejudgementagainststandard.Grade
    }
// Returns whether the element value for Grade is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) Grade_IsNil() bool {
    return s.studentscorejudgementagainststandard.Grade == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) LearningStandardList() *LearningStandardListType {
    if s.studentscorejudgementagainststandard.LearningStandardList == nil {
     if v, ok:= LearningStandardListTypePointer(LearningStandardListType{}); ok {
      s.studentscorejudgementagainststandard.LearningStandardList = v
      }
      }
      return s.studentscorejudgementagainststandard.LearningStandardList
    }
// Returns whether the element value for LearningStandardList is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) LearningStandardList_IsNil() bool {
    return s.studentscorejudgementagainststandard.LearningStandardList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) LocalCodeList() *LocalCodeListType {
    if s.studentscorejudgementagainststandard.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentscorejudgementagainststandard.LocalCodeList = v
      }
      }
      return s.studentscorejudgementagainststandard.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) LocalCodeList_IsNil() bool {
    return s.studentscorejudgementagainststandard.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) LocalTermCode() *LocalIdType {
    if s.studentscorejudgementagainststandard.LocalTermCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.LocalTermCode = ((*LocalIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.LocalTermCode
    }
// Returns whether the element value for LocalTermCode is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) LocalTermCode_IsNil() bool {
    return s.studentscorejudgementagainststandard.LocalTermCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) ManagedPathwayLocalCode() *LocalIdType {
    if s.studentscorejudgementagainststandard.ManagedPathwayLocalCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.ManagedPathwayLocalCode = ((*LocalIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.ManagedPathwayLocalCode
    }
// Returns whether the element value for ManagedPathwayLocalCode is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) ManagedPathwayLocalCode_IsNil() bool {
    return s.studentscorejudgementagainststandard.ManagedPathwayLocalCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) RefId() *RefIdType {
    if s.studentscorejudgementagainststandard.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) RefId_IsNil() bool {
    return s.studentscorejudgementagainststandard.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentscorejudgementagainststandard.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentscorejudgementagainststandard.SIF_ExtendedElements = v
      }
      }
      return s.studentscorejudgementagainststandard.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) SIF_ExtendedElements_IsNil() bool {
    return s.studentscorejudgementagainststandard.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) SIF_Metadata() *SIF_MetadataType {
    if s.studentscorejudgementagainststandard.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentscorejudgementagainststandard.SIF_Metadata = v
      }
      }
      return s.studentscorejudgementagainststandard.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) SIF_Metadata_IsNil() bool {
    return s.studentscorejudgementagainststandard.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) SchoolCommonwealthId() *String {
    if s.studentscorejudgementagainststandard.SchoolCommonwealthId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.SchoolCommonwealthId = ((*String)(v))
      }
      }
      return s.studentscorejudgementagainststandard.SchoolCommonwealthId
    }
// Returns whether the element value for SchoolCommonwealthId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) SchoolCommonwealthId_IsNil() bool {
    return s.studentscorejudgementagainststandard.SchoolCommonwealthId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) SchoolInfoRefId() *String {
    if s.studentscorejudgementagainststandard.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.studentscorejudgementagainststandard.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) SchoolInfoRefId_IsNil() bool {
    return s.studentscorejudgementagainststandard.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) SchoolLocalId() *LocalIdType {
    if s.studentscorejudgementagainststandard.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) SchoolLocalId_IsNil() bool {
    return s.studentscorejudgementagainststandard.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) SchoolYear() *SchoolYearType {
    if s.studentscorejudgementagainststandard.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) SchoolYear_IsNil() bool {
    return s.studentscorejudgementagainststandard.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) Score() *String {
    if s.studentscorejudgementagainststandard.Score == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.Score = ((*String)(v))
      }
      }
      return s.studentscorejudgementagainststandard.Score
    }
// Returns whether the element value for Score is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) Score_IsNil() bool {
    return s.studentscorejudgementagainststandard.Score == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) SpecialCircumstanceLocalCode() *LocalIdType {
    if s.studentscorejudgementagainststandard.SpecialCircumstanceLocalCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.SpecialCircumstanceLocalCode = ((*LocalIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.SpecialCircumstanceLocalCode
    }
// Returns whether the element value for SpecialCircumstanceLocalCode is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) SpecialCircumstanceLocalCode_IsNil() bool {
    return s.studentscorejudgementagainststandard.SpecialCircumstanceLocalCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) StaffLocalId() *LocalIdType {
    if s.studentscorejudgementagainststandard.StaffLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.StaffLocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.StaffLocalId
    }
// Returns whether the element value for StaffLocalId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) StaffLocalId_IsNil() bool {
    return s.studentscorejudgementagainststandard.StaffLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) StaffPersonalRefId() *String {
    if s.studentscorejudgementagainststandard.StaffPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.StaffPersonalRefId = ((*String)(v))
      }
      }
      return s.studentscorejudgementagainststandard.StaffPersonalRefId
    }
// Returns whether the element value for StaffPersonalRefId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) StaffPersonalRefId_IsNil() bool {
    return s.studentscorejudgementagainststandard.StaffPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) StudentLocalId() *LocalIdType {
    if s.studentscorejudgementagainststandard.StudentLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.StudentLocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.StudentLocalId
    }
// Returns whether the element value for StudentLocalId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) StudentLocalId_IsNil() bool {
    return s.studentscorejudgementagainststandard.StudentLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) StudentPersonalRefId() *String {
    if s.studentscorejudgementagainststandard.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentscorejudgementagainststandard.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) StudentPersonalRefId_IsNil() bool {
    return s.studentscorejudgementagainststandard.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) StudentStateProvinceId() *StateProvinceIdType {
    if s.studentscorejudgementagainststandard.StudentStateProvinceId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.StudentStateProvinceId = ((*StateProvinceIdType)(v))
      }
      }
      return s.studentscorejudgementagainststandard.StudentStateProvinceId
    }
// Returns whether the element value for StudentStateProvinceId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) StudentStateProvinceId_IsNil() bool {
    return s.studentscorejudgementagainststandard.StudentStateProvinceId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) TeacherJudgement() *String {
    if s.studentscorejudgementagainststandard.TeacherJudgement == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.TeacherJudgement = ((*String)(v))
      }
      }
      return s.studentscorejudgementagainststandard.TeacherJudgement
    }
// Returns whether the element value for TeacherJudgement is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) TeacherJudgement_IsNil() bool {
    return s.studentscorejudgementagainststandard.TeacherJudgement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) TeachingGroupRefId() *String {
    if s.studentscorejudgementagainststandard.TeachingGroupRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.TeachingGroupRefId = ((*String)(v))
      }
      }
      return s.studentscorejudgementagainststandard.TeachingGroupRefId
    }
// Returns whether the element value for TeachingGroupRefId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) TeachingGroupRefId_IsNil() bool {
    return s.studentscorejudgementagainststandard.TeachingGroupRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) TermInfoRefId() *String {
    if s.studentscorejudgementagainststandard.TermInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentscorejudgementagainststandard.TermInfoRefId = ((*String)(v))
      }
      }
      return s.studentscorejudgementagainststandard.TermInfoRefId
    }
// Returns whether the element value for TermInfoRefId is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) TermInfoRefId_IsNil() bool {
    return s.studentscorejudgementagainststandard.TermInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentScoreJudgementAgainstStandard) YearLevel() *YearLevelType {
    if s.studentscorejudgementagainststandard.YearLevel == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.studentscorejudgementagainststandard.YearLevel = v
      }
      }
      return s.studentscorejudgementagainststandard.YearLevel
    }
// Returns whether the element value for YearLevel is nil in the container StudentScoreJudgementAgainstStandard.
  func (s *StudentScoreJudgementAgainstStandard) YearLevel_IsNil() bool {
    return s.studentscorejudgementagainststandard.YearLevel == nil
    }

// Set the value of a property to nil
func (n *StudentSectionEnrollment) Unset(key string) *StudentSectionEnrollment {
        switch key {
  case "EntryDate":
   n.studentsectionenrollment.EntryDate = nil
  case "ExitDate":
   n.studentsectionenrollment.ExitDate = nil
  case "LocalCodeList":
   n.studentsectionenrollment.LocalCodeList = nil
  case "RefId":
   n.studentsectionenrollment.RefId = nil
  case "SIF_ExtendedElements":
   n.studentsectionenrollment.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.studentsectionenrollment.SIF_Metadata = nil
  case "SchoolYear":
   n.studentsectionenrollment.SchoolYear = nil
  case "SectionInfoRefId":
   n.studentsectionenrollment.SectionInfoRefId = nil
  case "StudentPersonalRefId":
   n.studentsectionenrollment.StudentPersonalRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentSectionEnrollment")
        }
        return n
}

// Set a sequence of properties
func (n *StudentSectionEnrollment) SetProperties(props ...Prop) *StudentSectionEnrollment {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentSectionEnrollment) SetProperty(key string, value interface{}) *StudentSectionEnrollment {
        if n == nil {
                n, _ = StudentSectionEnrollmentPointer(StudentSectionEnrollment{})
        }
        switch key {
    case "EntryDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentsectionenrollment.EntryDate = ((*String)(v))
      }
    case "ExitDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentsectionenrollment.ExitDate = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.studentsectionenrollment.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentsectionenrollment.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.studentsectionenrollment.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.studentsectionenrollment.SIF_Metadata = v
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentsectionenrollment.SchoolYear = ((*SchoolYearType)(v))
      }
    case "SectionInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentsectionenrollment.SectionInfoRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentsectionenrollment.StudentPersonalRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentSectionEnrollment")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSectionEnrollment) EntryDate() *String {
    if s.studentsectionenrollment.EntryDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentsectionenrollment.EntryDate = ((*String)(v))
      }
      }
      return s.studentsectionenrollment.EntryDate
    }
// Returns whether the element value for EntryDate is nil in the container StudentSectionEnrollment.
  func (s *StudentSectionEnrollment) EntryDate_IsNil() bool {
    return s.studentsectionenrollment.EntryDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSectionEnrollment) ExitDate() *String {
    if s.studentsectionenrollment.ExitDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentsectionenrollment.ExitDate = ((*String)(v))
      }
      }
      return s.studentsectionenrollment.ExitDate
    }
// Returns whether the element value for ExitDate is nil in the container StudentSectionEnrollment.
  func (s *StudentSectionEnrollment) ExitDate_IsNil() bool {
    return s.studentsectionenrollment.ExitDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSectionEnrollment) LocalCodeList() *LocalCodeListType {
    if s.studentsectionenrollment.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.studentsectionenrollment.LocalCodeList = v
      }
      }
      return s.studentsectionenrollment.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container StudentSectionEnrollment.
  func (s *StudentSectionEnrollment) LocalCodeList_IsNil() bool {
    return s.studentsectionenrollment.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSectionEnrollment) RefId() *RefIdType {
    if s.studentsectionenrollment.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentsectionenrollment.RefId = ((*RefIdType)(v))
      }
      }
      return s.studentsectionenrollment.RefId
    }
// Returns whether the element value for RefId is nil in the container StudentSectionEnrollment.
  func (s *StudentSectionEnrollment) RefId_IsNil() bool {
    return s.studentsectionenrollment.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSectionEnrollment) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.studentsectionenrollment.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.studentsectionenrollment.SIF_ExtendedElements = v
      }
      }
      return s.studentsectionenrollment.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container StudentSectionEnrollment.
  func (s *StudentSectionEnrollment) SIF_ExtendedElements_IsNil() bool {
    return s.studentsectionenrollment.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSectionEnrollment) SIF_Metadata() *SIF_MetadataType {
    if s.studentsectionenrollment.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.studentsectionenrollment.SIF_Metadata = v
      }
      }
      return s.studentsectionenrollment.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container StudentSectionEnrollment.
  func (s *StudentSectionEnrollment) SIF_Metadata_IsNil() bool {
    return s.studentsectionenrollment.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSectionEnrollment) SchoolYear() *SchoolYearType {
    if s.studentsectionenrollment.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentsectionenrollment.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.studentsectionenrollment.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container StudentSectionEnrollment.
  func (s *StudentSectionEnrollment) SchoolYear_IsNil() bool {
    return s.studentsectionenrollment.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSectionEnrollment) SectionInfoRefId() *String {
    if s.studentsectionenrollment.SectionInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentsectionenrollment.SectionInfoRefId = ((*String)(v))
      }
      }
      return s.studentsectionenrollment.SectionInfoRefId
    }
// Returns whether the element value for SectionInfoRefId is nil in the container StudentSectionEnrollment.
  func (s *StudentSectionEnrollment) SectionInfoRefId_IsNil() bool {
    return s.studentsectionenrollment.SectionInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSectionEnrollment) StudentPersonalRefId() *String {
    if s.studentsectionenrollment.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentsectionenrollment.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.studentsectionenrollment.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container StudentSectionEnrollment.
  func (s *StudentSectionEnrollment) StudentPersonalRefId_IsNil() bool {
    return s.studentsectionenrollment.StudentPersonalRefId == nil
    }

// Set the value of a property to nil
func (n *StudentSubjectChoiceType) Unset(key string) *StudentSubjectChoiceType {
        switch key {
  case "OtherSchoolLocalId":
   n.studentsubjectchoicetype.OtherSchoolLocalId = nil
  case "PreferenceNumber":
   n.studentsubjectchoicetype.PreferenceNumber = nil
  case "StudyDescription":
   n.studentsubjectchoicetype.StudyDescription = nil
  case "SubjectLocalId":
   n.studentsubjectchoicetype.SubjectLocalId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentSubjectChoiceType")
        }
        return n
}

// Set a sequence of properties
func (n *StudentSubjectChoiceType) SetProperties(props ...Prop) *StudentSubjectChoiceType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *StudentSubjectChoiceType) SetProperty(key string, value interface{}) *StudentSubjectChoiceType {
        if n == nil {
                n, _ = StudentSubjectChoiceTypePointer(StudentSubjectChoiceType{})
        }
        switch key {
    case "OtherSchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentsubjectchoicetype.OtherSchoolLocalId = ((*LocalIdType)(v))
      }
    case "PreferenceNumber":
    
    if v, ok:= IntPointer(value); ok {
      n.studentsubjectchoicetype.PreferenceNumber = ((*Int)(v))
      }
    case "StudyDescription":
    if v, ok:= SubjectAreaTypePointer(value); ok {
      n.studentsubjectchoicetype.StudyDescription = v
      }
    case "SubjectLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.studentsubjectchoicetype.SubjectLocalId = ((*LocalIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "StudentSubjectChoiceType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSubjectChoiceType) OtherSchoolLocalId() *LocalIdType {
    if s.studentsubjectchoicetype.OtherSchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentsubjectchoicetype.OtherSchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentsubjectchoicetype.OtherSchoolLocalId
    }
// Returns whether the element value for OtherSchoolLocalId is nil in the container StudentSubjectChoiceType.
  func (s *StudentSubjectChoiceType) OtherSchoolLocalId_IsNil() bool {
    return s.studentsubjectchoicetype.OtherSchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSubjectChoiceType) PreferenceNumber() *Int {
    if s.studentsubjectchoicetype.PreferenceNumber == nil {
    if v, ok:= IntPointer(0); ok {
      s.studentsubjectchoicetype.PreferenceNumber = ((*Int)(v))
      }
      }
      return s.studentsubjectchoicetype.PreferenceNumber
    }
// Returns whether the element value for PreferenceNumber is nil in the container StudentSubjectChoiceType.
  func (s *StudentSubjectChoiceType) PreferenceNumber_IsNil() bool {
    return s.studentsubjectchoicetype.PreferenceNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSubjectChoiceType) StudyDescription() *SubjectAreaType {
    if s.studentsubjectchoicetype.StudyDescription == nil {
     if v, ok:= SubjectAreaTypePointer(SubjectAreaType{}); ok {
      s.studentsubjectchoicetype.StudyDescription = v
      }
      }
      return s.studentsubjectchoicetype.StudyDescription
    }
// Returns whether the element value for StudyDescription is nil in the container StudentSubjectChoiceType.
  func (s *StudentSubjectChoiceType) StudyDescription_IsNil() bool {
    return s.studentsubjectchoicetype.StudyDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *StudentSubjectChoiceType) SubjectLocalId() *LocalIdType {
    if s.studentsubjectchoicetype.SubjectLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.studentsubjectchoicetype.SubjectLocalId = ((*LocalIdType)(v))
      }
      }
      return s.studentsubjectchoicetype.SubjectLocalId
    }
// Returns whether the element value for SubjectLocalId is nil in the container StudentSubjectChoiceType.
  func (s *StudentSubjectChoiceType) SubjectLocalId_IsNil() bool {
    return s.studentsubjectchoicetype.SubjectLocalId == nil
    }

// Set the value of a property to nil
func (n *SubjectAreaType) Unset(key string) *SubjectAreaType {
        switch key {
  case "Code":
   n.subjectareatype.Code = nil
  case "OtherCodeList":
   n.subjectareatype.OtherCodeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SubjectAreaType")
        }
        return n
}

// Set a sequence of properties
func (n *SubjectAreaType) SetProperties(props ...Prop) *SubjectAreaType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SubjectAreaType) SetProperty(key string, value interface{}) *SubjectAreaType {
        if n == nil {
                n, _ = SubjectAreaTypePointer(SubjectAreaType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.subjectareatype.Code = ((*String)(v))
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.subjectareatype.OtherCodeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SubjectAreaType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SubjectAreaType) Code() *String {
    if s.subjectareatype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.subjectareatype.Code = ((*String)(v))
      }
      }
      return s.subjectareatype.Code
    }
// Returns whether the element value for Code is nil in the container SubjectAreaType.
  func (s *SubjectAreaType) Code_IsNil() bool {
    return s.subjectareatype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SubjectAreaType) OtherCodeList() *OtherCodeListType {
    if s.subjectareatype.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.subjectareatype.OtherCodeList = v
      }
      }
      return s.subjectareatype.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container SubjectAreaType.
  func (s *SubjectAreaType) OtherCodeList_IsNil() bool {
    return s.subjectareatype.OtherCodeList == nil
    }

// Set the value of a property to nil
func (n *SubstituteItemType) Unset(key string) *SubstituteItemType {
        switch key {
  case "PNPCodeList":
   n.substituteitemtype.PNPCodeList = nil
  case "SubstituteItemLocalId":
   n.substituteitemtype.SubstituteItemLocalId = nil
  case "SubstituteItemRefId":
   n.substituteitemtype.SubstituteItemRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SubstituteItemType")
        }
        return n
}

// Set a sequence of properties
func (n *SubstituteItemType) SetProperties(props ...Prop) *SubstituteItemType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SubstituteItemType) SetProperty(key string, value interface{}) *SubstituteItemType {
        if n == nil {
                n, _ = SubstituteItemTypePointer(SubstituteItemType{})
        }
        switch key {
    case "PNPCodeList":
    if v, ok:= PNPCodeListTypePointer(value); ok {
      n.substituteitemtype.PNPCodeList = v
      }
    case "SubstituteItemLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.substituteitemtype.SubstituteItemLocalId = ((*LocalIdType)(v))
      }
    case "SubstituteItemRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.substituteitemtype.SubstituteItemRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SubstituteItemType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SubstituteItemType) PNPCodeList() *PNPCodeListType {
    if s.substituteitemtype.PNPCodeList == nil {
     if v, ok:= PNPCodeListTypePointer(PNPCodeListType{}); ok {
      s.substituteitemtype.PNPCodeList = v
      }
      }
      return s.substituteitemtype.PNPCodeList
    }
// Returns whether the element value for PNPCodeList is nil in the container SubstituteItemType.
  func (s *SubstituteItemType) PNPCodeList_IsNil() bool {
    return s.substituteitemtype.PNPCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SubstituteItemType) SubstituteItemLocalId() *LocalIdType {
    if s.substituteitemtype.SubstituteItemLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.substituteitemtype.SubstituteItemLocalId = ((*LocalIdType)(v))
      }
      }
      return s.substituteitemtype.SubstituteItemLocalId
    }
// Returns whether the element value for SubstituteItemLocalId is nil in the container SubstituteItemType.
  func (s *SubstituteItemType) SubstituteItemLocalId_IsNil() bool {
    return s.substituteitemtype.SubstituteItemLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SubstituteItemType) SubstituteItemRefId() *String {
    if s.substituteitemtype.SubstituteItemRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.substituteitemtype.SubstituteItemRefId = ((*String)(v))
      }
      }
      return s.substituteitemtype.SubstituteItemRefId
    }
// Returns whether the element value for SubstituteItemRefId is nil in the container SubstituteItemType.
  func (s *SubstituteItemType) SubstituteItemRefId_IsNil() bool {
    return s.substituteitemtype.SubstituteItemRefId == nil
    }

// Set the value of a property to nil
func (n *SuspensionContainerType) Unset(key string) *SuspensionContainerType {
        switch key {
  case "AdvisementDate":
   n.suspensioncontainertype.AdvisementDate = nil
  case "Duration":
   n.suspensioncontainertype.Duration = nil
  case "EarlyReturnDate":
   n.suspensioncontainertype.EarlyReturnDate = nil
  case "ResolutionMeetingTime":
   n.suspensioncontainertype.ResolutionMeetingTime = nil
  case "ResolutionNotes":
   n.suspensioncontainertype.ResolutionNotes = nil
  case "Status":
   n.suspensioncontainertype.Status = nil
  case "SuspensionCategory":
   n.suspensioncontainertype.SuspensionCategory = nil
  case "SuspensionNotes":
   n.suspensioncontainertype.SuspensionNotes = nil
  case "WithdrawalTimeList":
   n.suspensioncontainertype.WithdrawalTimeList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SuspensionContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *SuspensionContainerType) SetProperties(props ...Prop) *SuspensionContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *SuspensionContainerType) SetProperty(key string, value interface{}) *SuspensionContainerType {
        if n == nil {
                n, _ = SuspensionContainerTypePointer(SuspensionContainerType{})
        }
        switch key {
    case "AdvisementDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.suspensioncontainertype.AdvisementDate = ((*String)(v))
      }
    case "Duration":
    
    if v, ok:= FloatPointer(value); ok {
      n.suspensioncontainertype.Duration = ((*Float)(v))
      }
    case "EarlyReturnDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.suspensioncontainertype.EarlyReturnDate = ((*String)(v))
      }
    case "ResolutionMeetingTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.suspensioncontainertype.ResolutionMeetingTime = ((*String)(v))
      }
    case "ResolutionNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.suspensioncontainertype.ResolutionNotes = ((*String)(v))
      }
    case "Status":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.suspensioncontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
    case "SuspensionCategory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSuspensionCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSuspensionCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.suspensioncontainertype.SuspensionCategory = ((*AUCodeSetsSuspensionCategoryType)(v))
      }
    case "SuspensionNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.suspensioncontainertype.SuspensionNotes = ((*String)(v))
      }
    case "WithdrawalTimeList":
    if v, ok:= WithdrawalTimeListTypePointer(value); ok {
      n.suspensioncontainertype.WithdrawalTimeList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "SuspensionContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SuspensionContainerType) AdvisementDate() *String {
    if s.suspensioncontainertype.AdvisementDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.suspensioncontainertype.AdvisementDate = ((*String)(v))
      }
      }
      return s.suspensioncontainertype.AdvisementDate
    }
// Returns whether the element value for AdvisementDate is nil in the container SuspensionContainerType.
  func (s *SuspensionContainerType) AdvisementDate_IsNil() bool {
    return s.suspensioncontainertype.AdvisementDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SuspensionContainerType) Duration() *Float {
    if s.suspensioncontainertype.Duration == nil {
    if v, ok:= FloatPointer(0); ok {
      s.suspensioncontainertype.Duration = ((*Float)(v))
      }
      }
      return s.suspensioncontainertype.Duration
    }
// Returns whether the element value for Duration is nil in the container SuspensionContainerType.
  func (s *SuspensionContainerType) Duration_IsNil() bool {
    return s.suspensioncontainertype.Duration == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SuspensionContainerType) EarlyReturnDate() *String {
    if s.suspensioncontainertype.EarlyReturnDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.suspensioncontainertype.EarlyReturnDate = ((*String)(v))
      }
      }
      return s.suspensioncontainertype.EarlyReturnDate
    }
// Returns whether the element value for EarlyReturnDate is nil in the container SuspensionContainerType.
  func (s *SuspensionContainerType) EarlyReturnDate_IsNil() bool {
    return s.suspensioncontainertype.EarlyReturnDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SuspensionContainerType) ResolutionMeetingTime() *String {
    if s.suspensioncontainertype.ResolutionMeetingTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.suspensioncontainertype.ResolutionMeetingTime = ((*String)(v))
      }
      }
      return s.suspensioncontainertype.ResolutionMeetingTime
    }
// Returns whether the element value for ResolutionMeetingTime is nil in the container SuspensionContainerType.
  func (s *SuspensionContainerType) ResolutionMeetingTime_IsNil() bool {
    return s.suspensioncontainertype.ResolutionMeetingTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SuspensionContainerType) ResolutionNotes() *String {
    if s.suspensioncontainertype.ResolutionNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.suspensioncontainertype.ResolutionNotes = ((*String)(v))
      }
      }
      return s.suspensioncontainertype.ResolutionNotes
    }
// Returns whether the element value for ResolutionNotes is nil in the container SuspensionContainerType.
  func (s *SuspensionContainerType) ResolutionNotes_IsNil() bool {
    return s.suspensioncontainertype.ResolutionNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SuspensionContainerType) Status() *AUCodeSetsWellbeingStatusType {
    if s.suspensioncontainertype.Status == nil {
    if v, ok:= StringPointer(""); ok {
      s.suspensioncontainertype.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
      }
      return s.suspensioncontainertype.Status
    }
// Returns whether the element value for Status is nil in the container SuspensionContainerType.
  func (s *SuspensionContainerType) Status_IsNil() bool {
    return s.suspensioncontainertype.Status == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SuspensionContainerType) SuspensionCategory() *AUCodeSetsSuspensionCategoryType {
    if s.suspensioncontainertype.SuspensionCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.suspensioncontainertype.SuspensionCategory = ((*AUCodeSetsSuspensionCategoryType)(v))
      }
      }
      return s.suspensioncontainertype.SuspensionCategory
    }
// Returns whether the element value for SuspensionCategory is nil in the container SuspensionContainerType.
  func (s *SuspensionContainerType) SuspensionCategory_IsNil() bool {
    return s.suspensioncontainertype.SuspensionCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SuspensionContainerType) SuspensionNotes() *String {
    if s.suspensioncontainertype.SuspensionNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.suspensioncontainertype.SuspensionNotes = ((*String)(v))
      }
      }
      return s.suspensioncontainertype.SuspensionNotes
    }
// Returns whether the element value for SuspensionNotes is nil in the container SuspensionContainerType.
  func (s *SuspensionContainerType) SuspensionNotes_IsNil() bool {
    return s.suspensioncontainertype.SuspensionNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *SuspensionContainerType) WithdrawalTimeList() *WithdrawalTimeListType {
    if s.suspensioncontainertype.WithdrawalTimeList == nil {
     if v, ok:= WithdrawalTimeListTypePointer(WithdrawalTimeListType{}); ok {
      s.suspensioncontainertype.WithdrawalTimeList = v
      }
      }
      return s.suspensioncontainertype.WithdrawalTimeList
    }
// Returns whether the element value for WithdrawalTimeList is nil in the container SuspensionContainerType.
  func (s *SuspensionContainerType) WithdrawalTimeList_IsNil() bool {
    return s.suspensioncontainertype.WithdrawalTimeList == nil
    }

// Set the value of a property to nil
func (n *TeacherCoverType) Unset(key string) *TeacherCoverType {
        switch key {
  case "Credit":
   n.teachercovertype.Credit = nil
  case "FinishTime":
   n.teachercovertype.FinishTime = nil
  case "StaffLocalId":
   n.teachercovertype.StaffLocalId = nil
  case "StaffPersonalRefId":
   n.teachercovertype.StaffPersonalRefId = nil
  case "StartTime":
   n.teachercovertype.StartTime = nil
  case "Supervision":
   n.teachercovertype.Supervision = nil
  case "Weighting":
   n.teachercovertype.Weighting = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeacherCoverType")
        }
        return n
}

// Set a sequence of properties
func (n *TeacherCoverType) SetProperties(props ...Prop) *TeacherCoverType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TeacherCoverType) SetProperty(key string, value interface{}) *TeacherCoverType {
        if n == nil {
                n, _ = TeacherCoverTypePointer(TeacherCoverType{})
        }
        switch key {
    case "Credit":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsTeacherCoverCreditType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsTeacherCoverCreditType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.teachercovertype.Credit = ((*AUCodeSetsTeacherCoverCreditType)(v))
      }
    case "FinishTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachercovertype.FinishTime = ((*String)(v))
      }
    case "StaffLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachercovertype.StaffLocalId = ((*LocalIdType)(v))
      }
    case "StaffPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachercovertype.StaffPersonalRefId = ((*String)(v))
      }
    case "StartTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachercovertype.StartTime = ((*String)(v))
      }
    case "Supervision":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsTeacherCoverSupervisionType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsTeacherCoverSupervisionType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.teachercovertype.Supervision = ((*AUCodeSetsTeacherCoverSupervisionType)(v))
      }
    case "Weighting":
    
    if v, ok:= FloatPointer(value); ok {
      n.teachercovertype.Weighting = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeacherCoverType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeacherCoverType) Credit() *AUCodeSetsTeacherCoverCreditType {
    if s.teachercovertype.Credit == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachercovertype.Credit = ((*AUCodeSetsTeacherCoverCreditType)(v))
      }
      }
      return s.teachercovertype.Credit
    }
// Returns whether the element value for Credit is nil in the container TeacherCoverType.
  func (s *TeacherCoverType) Credit_IsNil() bool {
    return s.teachercovertype.Credit == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeacherCoverType) FinishTime() *String {
    if s.teachercovertype.FinishTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachercovertype.FinishTime = ((*String)(v))
      }
      }
      return s.teachercovertype.FinishTime
    }
// Returns whether the element value for FinishTime is nil in the container TeacherCoverType.
  func (s *TeacherCoverType) FinishTime_IsNil() bool {
    return s.teachercovertype.FinishTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeacherCoverType) StaffLocalId() *LocalIdType {
    if s.teachercovertype.StaffLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachercovertype.StaffLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachercovertype.StaffLocalId
    }
// Returns whether the element value for StaffLocalId is nil in the container TeacherCoverType.
  func (s *TeacherCoverType) StaffLocalId_IsNil() bool {
    return s.teachercovertype.StaffLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeacherCoverType) StaffPersonalRefId() *String {
    if s.teachercovertype.StaffPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachercovertype.StaffPersonalRefId = ((*String)(v))
      }
      }
      return s.teachercovertype.StaffPersonalRefId
    }
// Returns whether the element value for StaffPersonalRefId is nil in the container TeacherCoverType.
  func (s *TeacherCoverType) StaffPersonalRefId_IsNil() bool {
    return s.teachercovertype.StaffPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeacherCoverType) StartTime() *String {
    if s.teachercovertype.StartTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachercovertype.StartTime = ((*String)(v))
      }
      }
      return s.teachercovertype.StartTime
    }
// Returns whether the element value for StartTime is nil in the container TeacherCoverType.
  func (s *TeacherCoverType) StartTime_IsNil() bool {
    return s.teachercovertype.StartTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeacherCoverType) Supervision() *AUCodeSetsTeacherCoverSupervisionType {
    if s.teachercovertype.Supervision == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachercovertype.Supervision = ((*AUCodeSetsTeacherCoverSupervisionType)(v))
      }
      }
      return s.teachercovertype.Supervision
    }
// Returns whether the element value for Supervision is nil in the container TeacherCoverType.
  func (s *TeacherCoverType) Supervision_IsNil() bool {
    return s.teachercovertype.Supervision == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeacherCoverType) Weighting() *Float {
    if s.teachercovertype.Weighting == nil {
    if v, ok:= FloatPointer(0); ok {
      s.teachercovertype.Weighting = ((*Float)(v))
      }
      }
      return s.teachercovertype.Weighting
    }
// Returns whether the element value for Weighting is nil in the container TeacherCoverType.
  func (s *TeacherCoverType) Weighting_IsNil() bool {
    return s.teachercovertype.Weighting == nil
    }

// Set the value of a property to nil
func (n *TeachingGroup) Unset(key string) *TeachingGroup {
        switch key {
  case "Block":
   n.teachinggroup.Block = nil
  case "CurriculumLevel":
   n.teachinggroup.CurriculumLevel = nil
  case "GroupType":
   n.teachinggroup.GroupType = nil
  case "KeyLearningArea":
   n.teachinggroup.KeyLearningArea = nil
  case "LocalCodeList":
   n.teachinggroup.LocalCodeList = nil
  case "LocalId":
   n.teachinggroup.LocalId = nil
  case "LongName":
   n.teachinggroup.LongName = nil
  case "MaxClassSize":
   n.teachinggroup.MaxClassSize = nil
  case "MinClassSize":
   n.teachinggroup.MinClassSize = nil
  case "RefId":
   n.teachinggroup.RefId = nil
  case "SIF_ExtendedElements":
   n.teachinggroup.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.teachinggroup.SIF_Metadata = nil
  case "SchoolCourseInfoRefId":
   n.teachinggroup.SchoolCourseInfoRefId = nil
  case "SchoolCourseLocalId":
   n.teachinggroup.SchoolCourseLocalId = nil
  case "SchoolInfoRefId":
   n.teachinggroup.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.teachinggroup.SchoolLocalId = nil
  case "SchoolYear":
   n.teachinggroup.SchoolYear = nil
  case "Semester":
   n.teachinggroup.Semester = nil
  case "Set":
   n.teachinggroup.Set = nil
  case "ShortName":
   n.teachinggroup.ShortName = nil
  case "StudentList":
   n.teachinggroup.StudentList = nil
  case "TeacherList":
   n.teachinggroup.TeacherList = nil
  case "TeachingGroupPeriodList":
   n.teachinggroup.TeachingGroupPeriodList = nil
  case "TimeTableSubjectLocalId":
   n.teachinggroup.TimeTableSubjectLocalId = nil
  case "TimeTableSubjectRefId":
   n.teachinggroup.TimeTableSubjectRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroup")
        }
        return n
}

// Set a sequence of properties
func (n *TeachingGroup) SetProperties(props ...Prop) *TeachingGroup {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TeachingGroup) SetProperty(key string, value interface{}) *TeachingGroup {
        if n == nil {
                n, _ = TeachingGroupPointer(TeachingGroup{})
        }
        switch key {
    case "Block":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.Block = ((*String)(v))
      }
    case "CurriculumLevel":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.CurriculumLevel = ((*String)(v))
      }
    case "GroupType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.GroupType = ((*String)(v))
      }
    case "KeyLearningArea":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsACStrandType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsACStrandType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.KeyLearningArea = ((*AUCodeSetsACStrandType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.teachinggroup.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.LocalId = ((*LocalIdType)(v))
      }
    case "LongName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.LongName = ((*String)(v))
      }
    case "MaxClassSize":
    
    if v, ok:= IntPointer(value); ok {
      n.teachinggroup.MaxClassSize = ((*Int)(v))
      }
    case "MinClassSize":
    
    if v, ok:= IntPointer(value); ok {
      n.teachinggroup.MinClassSize = ((*Int)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.teachinggroup.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.teachinggroup.SIF_Metadata = v
      }
    case "SchoolCourseInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.SchoolCourseInfoRefId = ((*RefIdType)(v))
      }
    case "SchoolCourseLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.SchoolCourseLocalId = ((*LocalIdType)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.SchoolInfoRefId = ((*RefIdType)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.SchoolYear = ((*SchoolYearType)(v))
      }
    case "Semester":
    
    if v, ok:= IntPointer(value); ok {
      n.teachinggroup.Semester = ((*Int)(v))
      }
    case "Set":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.Set = ((*String)(v))
      }
    case "ShortName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.ShortName = ((*String)(v))
      }
    case "StudentList":
    if v, ok:= StudentListTypePointer(value); ok {
      n.teachinggroup.StudentList = v
      }
    case "TeacherList":
    if v, ok:= TeacherListTypePointer(value); ok {
      n.teachinggroup.TeacherList = v
      }
    case "TeachingGroupPeriodList":
    if v, ok:= TeachingGroupPeriodListTypePointer(value); ok {
      n.teachinggroup.TeachingGroupPeriodList = v
      }
    case "TimeTableSubjectLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.TimeTableSubjectLocalId = ((*LocalIdType)(v))
      }
    case "TimeTableSubjectRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroup.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroup")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) Block() *String {
    if s.teachinggroup.Block == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.Block = ((*String)(v))
      }
      }
      return s.teachinggroup.Block
    }
// Returns whether the element value for Block is nil in the container TeachingGroup.
  func (s *TeachingGroup) Block_IsNil() bool {
    return s.teachinggroup.Block == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) CurriculumLevel() *String {
    if s.teachinggroup.CurriculumLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.CurriculumLevel = ((*String)(v))
      }
      }
      return s.teachinggroup.CurriculumLevel
    }
// Returns whether the element value for CurriculumLevel is nil in the container TeachingGroup.
  func (s *TeachingGroup) CurriculumLevel_IsNil() bool {
    return s.teachinggroup.CurriculumLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) GroupType() *String {
    if s.teachinggroup.GroupType == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.GroupType = ((*String)(v))
      }
      }
      return s.teachinggroup.GroupType
    }
// Returns whether the element value for GroupType is nil in the container TeachingGroup.
  func (s *TeachingGroup) GroupType_IsNil() bool {
    return s.teachinggroup.GroupType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) KeyLearningArea() *AUCodeSetsACStrandType {
    if s.teachinggroup.KeyLearningArea == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.KeyLearningArea = ((*AUCodeSetsACStrandType)(v))
      }
      }
      return s.teachinggroup.KeyLearningArea
    }
// Returns whether the element value for KeyLearningArea is nil in the container TeachingGroup.
  func (s *TeachingGroup) KeyLearningArea_IsNil() bool {
    return s.teachinggroup.KeyLearningArea == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) LocalCodeList() *LocalCodeListType {
    if s.teachinggroup.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.teachinggroup.LocalCodeList = v
      }
      }
      return s.teachinggroup.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container TeachingGroup.
  func (s *TeachingGroup) LocalCodeList_IsNil() bool {
    return s.teachinggroup.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) LocalId() *LocalIdType {
    if s.teachinggroup.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroup.LocalId
    }
// Returns whether the element value for LocalId is nil in the container TeachingGroup.
  func (s *TeachingGroup) LocalId_IsNil() bool {
    return s.teachinggroup.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) LongName() *String {
    if s.teachinggroup.LongName == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.LongName = ((*String)(v))
      }
      }
      return s.teachinggroup.LongName
    }
// Returns whether the element value for LongName is nil in the container TeachingGroup.
  func (s *TeachingGroup) LongName_IsNil() bool {
    return s.teachinggroup.LongName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) MaxClassSize() *Int {
    if s.teachinggroup.MaxClassSize == nil {
    if v, ok:= IntPointer(0); ok {
      s.teachinggroup.MaxClassSize = ((*Int)(v))
      }
      }
      return s.teachinggroup.MaxClassSize
    }
// Returns whether the element value for MaxClassSize is nil in the container TeachingGroup.
  func (s *TeachingGroup) MaxClassSize_IsNil() bool {
    return s.teachinggroup.MaxClassSize == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) MinClassSize() *Int {
    if s.teachinggroup.MinClassSize == nil {
    if v, ok:= IntPointer(0); ok {
      s.teachinggroup.MinClassSize = ((*Int)(v))
      }
      }
      return s.teachinggroup.MinClassSize
    }
// Returns whether the element value for MinClassSize is nil in the container TeachingGroup.
  func (s *TeachingGroup) MinClassSize_IsNil() bool {
    return s.teachinggroup.MinClassSize == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) RefId() *RefIdType {
    if s.teachinggroup.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.RefId = ((*RefIdType)(v))
      }
      }
      return s.teachinggroup.RefId
    }
// Returns whether the element value for RefId is nil in the container TeachingGroup.
  func (s *TeachingGroup) RefId_IsNil() bool {
    return s.teachinggroup.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.teachinggroup.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.teachinggroup.SIF_ExtendedElements = v
      }
      }
      return s.teachinggroup.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container TeachingGroup.
  func (s *TeachingGroup) SIF_ExtendedElements_IsNil() bool {
    return s.teachinggroup.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) SIF_Metadata() *SIF_MetadataType {
    if s.teachinggroup.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.teachinggroup.SIF_Metadata = v
      }
      }
      return s.teachinggroup.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container TeachingGroup.
  func (s *TeachingGroup) SIF_Metadata_IsNil() bool {
    return s.teachinggroup.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) SchoolCourseInfoRefId() *RefIdType {
    if s.teachinggroup.SchoolCourseInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.SchoolCourseInfoRefId = ((*RefIdType)(v))
      }
      }
      return s.teachinggroup.SchoolCourseInfoRefId
    }
// Returns whether the element value for SchoolCourseInfoRefId is nil in the container TeachingGroup.
  func (s *TeachingGroup) SchoolCourseInfoRefId_IsNil() bool {
    return s.teachinggroup.SchoolCourseInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) SchoolCourseLocalId() *LocalIdType {
    if s.teachinggroup.SchoolCourseLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.SchoolCourseLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroup.SchoolCourseLocalId
    }
// Returns whether the element value for SchoolCourseLocalId is nil in the container TeachingGroup.
  func (s *TeachingGroup) SchoolCourseLocalId_IsNil() bool {
    return s.teachinggroup.SchoolCourseLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) SchoolInfoRefId() *RefIdType {
    if s.teachinggroup.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.SchoolInfoRefId = ((*RefIdType)(v))
      }
      }
      return s.teachinggroup.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container TeachingGroup.
  func (s *TeachingGroup) SchoolInfoRefId_IsNil() bool {
    return s.teachinggroup.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) SchoolLocalId() *LocalIdType {
    if s.teachinggroup.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroup.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container TeachingGroup.
  func (s *TeachingGroup) SchoolLocalId_IsNil() bool {
    return s.teachinggroup.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) SchoolYear() *SchoolYearType {
    if s.teachinggroup.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.teachinggroup.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container TeachingGroup.
  func (s *TeachingGroup) SchoolYear_IsNil() bool {
    return s.teachinggroup.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) Semester() *Int {
    if s.teachinggroup.Semester == nil {
    if v, ok:= IntPointer(0); ok {
      s.teachinggroup.Semester = ((*Int)(v))
      }
      }
      return s.teachinggroup.Semester
    }
// Returns whether the element value for Semester is nil in the container TeachingGroup.
  func (s *TeachingGroup) Semester_IsNil() bool {
    return s.teachinggroup.Semester == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) Set() *String {
    if s.teachinggroup.Set == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.Set = ((*String)(v))
      }
      }
      return s.teachinggroup.Set
    }
// Returns whether the element value for Set is nil in the container TeachingGroup.
  func (s *TeachingGroup) Set_IsNil() bool {
    return s.teachinggroup.Set == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) ShortName() *String {
    if s.teachinggroup.ShortName == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.ShortName = ((*String)(v))
      }
      }
      return s.teachinggroup.ShortName
    }
// Returns whether the element value for ShortName is nil in the container TeachingGroup.
  func (s *TeachingGroup) ShortName_IsNil() bool {
    return s.teachinggroup.ShortName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) StudentList() *StudentListType {
    if s.teachinggroup.StudentList == nil {
     if v, ok:= StudentListTypePointer(StudentListType{}); ok {
      s.teachinggroup.StudentList = v
      }
      }
      return s.teachinggroup.StudentList
    }
// Returns whether the element value for StudentList is nil in the container TeachingGroup.
  func (s *TeachingGroup) StudentList_IsNil() bool {
    return s.teachinggroup.StudentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) TeacherList() *TeacherListType {
    if s.teachinggroup.TeacherList == nil {
     if v, ok:= TeacherListTypePointer(TeacherListType{}); ok {
      s.teachinggroup.TeacherList = v
      }
      }
      return s.teachinggroup.TeacherList
    }
// Returns whether the element value for TeacherList is nil in the container TeachingGroup.
  func (s *TeachingGroup) TeacherList_IsNil() bool {
    return s.teachinggroup.TeacherList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) TeachingGroupPeriodList() *TeachingGroupPeriodListType {
    if s.teachinggroup.TeachingGroupPeriodList == nil {
     if v, ok:= TeachingGroupPeriodListTypePointer(TeachingGroupPeriodListType{}); ok {
      s.teachinggroup.TeachingGroupPeriodList = v
      }
      }
      return s.teachinggroup.TeachingGroupPeriodList
    }
// Returns whether the element value for TeachingGroupPeriodList is nil in the container TeachingGroup.
  func (s *TeachingGroup) TeachingGroupPeriodList_IsNil() bool {
    return s.teachinggroup.TeachingGroupPeriodList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) TimeTableSubjectLocalId() *LocalIdType {
    if s.teachinggroup.TimeTableSubjectLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.TimeTableSubjectLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroup.TimeTableSubjectLocalId
    }
// Returns whether the element value for TimeTableSubjectLocalId is nil in the container TeachingGroup.
  func (s *TeachingGroup) TimeTableSubjectLocalId_IsNil() bool {
    return s.teachinggroup.TimeTableSubjectLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroup) TimeTableSubjectRefId() *RefIdType {
    if s.teachinggroup.TimeTableSubjectRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroup.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
      }
      return s.teachinggroup.TimeTableSubjectRefId
    }
// Returns whether the element value for TimeTableSubjectRefId is nil in the container TeachingGroup.
  func (s *TeachingGroup) TimeTableSubjectRefId_IsNil() bool {
    return s.teachinggroup.TimeTableSubjectRefId == nil
    }

// Set the value of a property to nil
func (n *TeachingGroupPeriodType) Unset(key string) *TeachingGroupPeriodType {
        switch key {
  case "CellType":
   n.teachinggroupperiodtype.CellType = nil
  case "DayId":
   n.teachinggroupperiodtype.DayId = nil
  case "PeriodId":
   n.teachinggroupperiodtype.PeriodId = nil
  case "RoomNumber":
   n.teachinggroupperiodtype.RoomNumber = nil
  case "StaffLocalId":
   n.teachinggroupperiodtype.StaffLocalId = nil
  case "StartTime":
   n.teachinggroupperiodtype.StartTime = nil
  case "TimeTableCellRefId":
   n.teachinggroupperiodtype.TimeTableCellRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroupPeriodType")
        }
        return n
}

// Set a sequence of properties
func (n *TeachingGroupPeriodType) SetProperties(props ...Prop) *TeachingGroupPeriodType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TeachingGroupPeriodType) SetProperty(key string, value interface{}) *TeachingGroupPeriodType {
        if n == nil {
                n, _ = TeachingGroupPeriodTypePointer(TeachingGroupPeriodType{})
        }
        switch key {
    case "CellType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupperiodtype.CellType = ((*String)(v))
      }
    case "DayId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupperiodtype.DayId = ((*LocalIdType)(v))
      }
    case "PeriodId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupperiodtype.PeriodId = ((*LocalIdType)(v))
      }
    case "RoomNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupperiodtype.RoomNumber = ((*HomeroomNumberType)(v))
      }
    case "StaffLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupperiodtype.StaffLocalId = ((*LocalIdType)(v))
      }
    case "StartTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupperiodtype.StartTime = ((*String)(v))
      }
    case "TimeTableCellRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupperiodtype.TimeTableCellRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroupPeriodType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupPeriodType) CellType() *String {
    if s.teachinggroupperiodtype.CellType == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupperiodtype.CellType = ((*String)(v))
      }
      }
      return s.teachinggroupperiodtype.CellType
    }
// Returns whether the element value for CellType is nil in the container TeachingGroupPeriodType.
  func (s *TeachingGroupPeriodType) CellType_IsNil() bool {
    return s.teachinggroupperiodtype.CellType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupPeriodType) DayId() *LocalIdType {
    if s.teachinggroupperiodtype.DayId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupperiodtype.DayId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroupperiodtype.DayId
    }
// Returns whether the element value for DayId is nil in the container TeachingGroupPeriodType.
  func (s *TeachingGroupPeriodType) DayId_IsNil() bool {
    return s.teachinggroupperiodtype.DayId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupPeriodType) PeriodId() *LocalIdType {
    if s.teachinggroupperiodtype.PeriodId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupperiodtype.PeriodId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroupperiodtype.PeriodId
    }
// Returns whether the element value for PeriodId is nil in the container TeachingGroupPeriodType.
  func (s *TeachingGroupPeriodType) PeriodId_IsNil() bool {
    return s.teachinggroupperiodtype.PeriodId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupPeriodType) RoomNumber() *HomeroomNumberType {
    if s.teachinggroupperiodtype.RoomNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupperiodtype.RoomNumber = ((*HomeroomNumberType)(v))
      }
      }
      return s.teachinggroupperiodtype.RoomNumber
    }
// Returns whether the element value for RoomNumber is nil in the container TeachingGroupPeriodType.
  func (s *TeachingGroupPeriodType) RoomNumber_IsNil() bool {
    return s.teachinggroupperiodtype.RoomNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupPeriodType) StaffLocalId() *LocalIdType {
    if s.teachinggroupperiodtype.StaffLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupperiodtype.StaffLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroupperiodtype.StaffLocalId
    }
// Returns whether the element value for StaffLocalId is nil in the container TeachingGroupPeriodType.
  func (s *TeachingGroupPeriodType) StaffLocalId_IsNil() bool {
    return s.teachinggroupperiodtype.StaffLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupPeriodType) StartTime() *String {
    if s.teachinggroupperiodtype.StartTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupperiodtype.StartTime = ((*String)(v))
      }
      }
      return s.teachinggroupperiodtype.StartTime
    }
// Returns whether the element value for StartTime is nil in the container TeachingGroupPeriodType.
  func (s *TeachingGroupPeriodType) StartTime_IsNil() bool {
    return s.teachinggroupperiodtype.StartTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupPeriodType) TimeTableCellRefId() *String {
    if s.teachinggroupperiodtype.TimeTableCellRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupperiodtype.TimeTableCellRefId = ((*String)(v))
      }
      }
      return s.teachinggroupperiodtype.TimeTableCellRefId
    }
// Returns whether the element value for TimeTableCellRefId is nil in the container TeachingGroupPeriodType.
  func (s *TeachingGroupPeriodType) TimeTableCellRefId_IsNil() bool {
    return s.teachinggroupperiodtype.TimeTableCellRefId == nil
    }

// Set the value of a property to nil
func (n *TeachingGroupScheduleType) Unset(key string) *TeachingGroupScheduleType {
        switch key {
  case "Block":
   n.teachinggroupscheduletype.Block = nil
  case "CurriculumLevel":
   n.teachinggroupscheduletype.CurriculumLevel = nil
  case "EditorGUID":
   n.teachinggroupscheduletype.EditorGUID = nil
  case "GroupType":
   n.teachinggroupscheduletype.GroupType = nil
  case "LocalId":
   n.teachinggroupscheduletype.LocalId = nil
  case "LongName":
   n.teachinggroupscheduletype.LongName = nil
  case "MaxClassSize":
   n.teachinggroupscheduletype.MaxClassSize = nil
  case "MinClassSize":
   n.teachinggroupscheduletype.MinClassSize = nil
  case "SchoolCourseInfoRefId":
   n.teachinggroupscheduletype.SchoolCourseInfoRefId = nil
  case "SchoolCourseLocalId":
   n.teachinggroupscheduletype.SchoolCourseLocalId = nil
  case "SchoolInfoRefId":
   n.teachinggroupscheduletype.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.teachinggroupscheduletype.SchoolLocalId = nil
  case "SchoolYear":
   n.teachinggroupscheduletype.SchoolYear = nil
  case "Semester":
   n.teachinggroupscheduletype.Semester = nil
  case "Set":
   n.teachinggroupscheduletype.Set = nil
  case "ShortName":
   n.teachinggroupscheduletype.ShortName = nil
  case "StudentList":
   n.teachinggroupscheduletype.StudentList = nil
  case "TeacherList":
   n.teachinggroupscheduletype.TeacherList = nil
  case "TeachingGroupPeriodList":
   n.teachinggroupscheduletype.TeachingGroupPeriodList = nil
  case "TimeTableSubjectLocalId":
   n.teachinggroupscheduletype.TimeTableSubjectLocalId = nil
  case "TimeTableSubjectRefId":
   n.teachinggroupscheduletype.TimeTableSubjectRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroupScheduleType")
        }
        return n
}

// Set a sequence of properties
func (n *TeachingGroupScheduleType) SetProperties(props ...Prop) *TeachingGroupScheduleType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TeachingGroupScheduleType) SetProperty(key string, value interface{}) *TeachingGroupScheduleType {
        if n == nil {
                n, _ = TeachingGroupScheduleTypePointer(TeachingGroupScheduleType{})
        }
        switch key {
    case "Block":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.Block = ((*String)(v))
      }
    case "CurriculumLevel":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.CurriculumLevel = ((*String)(v))
      }
    case "EditorGUID":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.EditorGUID = ((*RefIdType)(v))
      }
    case "GroupType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.GroupType = ((*String)(v))
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.LocalId = ((*LocalIdType)(v))
      }
    case "LongName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.LongName = ((*String)(v))
      }
    case "MaxClassSize":
    
    if v, ok:= IntPointer(value); ok {
      n.teachinggroupscheduletype.MaxClassSize = ((*Int)(v))
      }
    case "MinClassSize":
    
    if v, ok:= IntPointer(value); ok {
      n.teachinggroupscheduletype.MinClassSize = ((*Int)(v))
      }
    case "SchoolCourseInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.SchoolCourseInfoRefId = ((*RefIdType)(v))
      }
    case "SchoolCourseLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.SchoolCourseLocalId = ((*LocalIdType)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.SchoolInfoRefId = ((*RefIdType)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.SchoolYear = ((*SchoolYearType)(v))
      }
    case "Semester":
    
    if v, ok:= IntPointer(value); ok {
      n.teachinggroupscheduletype.Semester = ((*Int)(v))
      }
    case "Set":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.Set = ((*String)(v))
      }
    case "ShortName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.ShortName = ((*String)(v))
      }
    case "StudentList":
    if v, ok:= StudentListTypePointer(value); ok {
      n.teachinggroupscheduletype.StudentList = v
      }
    case "TeacherList":
    if v, ok:= TeacherListTypePointer(value); ok {
      n.teachinggroupscheduletype.TeacherList = v
      }
    case "TeachingGroupPeriodList":
    if v, ok:= TeachingGroupPeriodListTypePointer(value); ok {
      n.teachinggroupscheduletype.TeachingGroupPeriodList = v
      }
    case "TimeTableSubjectLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.TimeTableSubjectLocalId = ((*LocalIdType)(v))
      }
    case "TimeTableSubjectRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupscheduletype.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroupScheduleType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) Block() *String {
    if s.teachinggroupscheduletype.Block == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.Block = ((*String)(v))
      }
      }
      return s.teachinggroupscheduletype.Block
    }
// Returns whether the element value for Block is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) Block_IsNil() bool {
    return s.teachinggroupscheduletype.Block == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) CurriculumLevel() *String {
    if s.teachinggroupscheduletype.CurriculumLevel == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.CurriculumLevel = ((*String)(v))
      }
      }
      return s.teachinggroupscheduletype.CurriculumLevel
    }
// Returns whether the element value for CurriculumLevel is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) CurriculumLevel_IsNil() bool {
    return s.teachinggroupscheduletype.CurriculumLevel == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) EditorGUID() *RefIdType {
    if s.teachinggroupscheduletype.EditorGUID == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.EditorGUID = ((*RefIdType)(v))
      }
      }
      return s.teachinggroupscheduletype.EditorGUID
    }
// Returns whether the element value for EditorGUID is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) EditorGUID_IsNil() bool {
    return s.teachinggroupscheduletype.EditorGUID == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) GroupType() *String {
    if s.teachinggroupscheduletype.GroupType == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.GroupType = ((*String)(v))
      }
      }
      return s.teachinggroupscheduletype.GroupType
    }
// Returns whether the element value for GroupType is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) GroupType_IsNil() bool {
    return s.teachinggroupscheduletype.GroupType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) LocalId() *LocalIdType {
    if s.teachinggroupscheduletype.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroupscheduletype.LocalId
    }
// Returns whether the element value for LocalId is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) LocalId_IsNil() bool {
    return s.teachinggroupscheduletype.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) LongName() *String {
    if s.teachinggroupscheduletype.LongName == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.LongName = ((*String)(v))
      }
      }
      return s.teachinggroupscheduletype.LongName
    }
// Returns whether the element value for LongName is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) LongName_IsNil() bool {
    return s.teachinggroupscheduletype.LongName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) MaxClassSize() *Int {
    if s.teachinggroupscheduletype.MaxClassSize == nil {
    if v, ok:= IntPointer(0); ok {
      s.teachinggroupscheduletype.MaxClassSize = ((*Int)(v))
      }
      }
      return s.teachinggroupscheduletype.MaxClassSize
    }
// Returns whether the element value for MaxClassSize is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) MaxClassSize_IsNil() bool {
    return s.teachinggroupscheduletype.MaxClassSize == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) MinClassSize() *Int {
    if s.teachinggroupscheduletype.MinClassSize == nil {
    if v, ok:= IntPointer(0); ok {
      s.teachinggroupscheduletype.MinClassSize = ((*Int)(v))
      }
      }
      return s.teachinggroupscheduletype.MinClassSize
    }
// Returns whether the element value for MinClassSize is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) MinClassSize_IsNil() bool {
    return s.teachinggroupscheduletype.MinClassSize == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) SchoolCourseInfoRefId() *RefIdType {
    if s.teachinggroupscheduletype.SchoolCourseInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.SchoolCourseInfoRefId = ((*RefIdType)(v))
      }
      }
      return s.teachinggroupscheduletype.SchoolCourseInfoRefId
    }
// Returns whether the element value for SchoolCourseInfoRefId is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) SchoolCourseInfoRefId_IsNil() bool {
    return s.teachinggroupscheduletype.SchoolCourseInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) SchoolCourseLocalId() *LocalIdType {
    if s.teachinggroupscheduletype.SchoolCourseLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.SchoolCourseLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroupscheduletype.SchoolCourseLocalId
    }
// Returns whether the element value for SchoolCourseLocalId is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) SchoolCourseLocalId_IsNil() bool {
    return s.teachinggroupscheduletype.SchoolCourseLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) SchoolInfoRefId() *RefIdType {
    if s.teachinggroupscheduletype.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.SchoolInfoRefId = ((*RefIdType)(v))
      }
      }
      return s.teachinggroupscheduletype.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) SchoolInfoRefId_IsNil() bool {
    return s.teachinggroupscheduletype.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) SchoolLocalId() *LocalIdType {
    if s.teachinggroupscheduletype.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroupscheduletype.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) SchoolLocalId_IsNil() bool {
    return s.teachinggroupscheduletype.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) SchoolYear() *SchoolYearType {
    if s.teachinggroupscheduletype.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.teachinggroupscheduletype.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) SchoolYear_IsNil() bool {
    return s.teachinggroupscheduletype.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) Semester() *Int {
    if s.teachinggroupscheduletype.Semester == nil {
    if v, ok:= IntPointer(0); ok {
      s.teachinggroupscheduletype.Semester = ((*Int)(v))
      }
      }
      return s.teachinggroupscheduletype.Semester
    }
// Returns whether the element value for Semester is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) Semester_IsNil() bool {
    return s.teachinggroupscheduletype.Semester == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) Set() *String {
    if s.teachinggroupscheduletype.Set == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.Set = ((*String)(v))
      }
      }
      return s.teachinggroupscheduletype.Set
    }
// Returns whether the element value for Set is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) Set_IsNil() bool {
    return s.teachinggroupscheduletype.Set == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) ShortName() *String {
    if s.teachinggroupscheduletype.ShortName == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.ShortName = ((*String)(v))
      }
      }
      return s.teachinggroupscheduletype.ShortName
    }
// Returns whether the element value for ShortName is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) ShortName_IsNil() bool {
    return s.teachinggroupscheduletype.ShortName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) StudentList() *StudentListType {
    if s.teachinggroupscheduletype.StudentList == nil {
     if v, ok:= StudentListTypePointer(StudentListType{}); ok {
      s.teachinggroupscheduletype.StudentList = v
      }
      }
      return s.teachinggroupscheduletype.StudentList
    }
// Returns whether the element value for StudentList is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) StudentList_IsNil() bool {
    return s.teachinggroupscheduletype.StudentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) TeacherList() *TeacherListType {
    if s.teachinggroupscheduletype.TeacherList == nil {
     if v, ok:= TeacherListTypePointer(TeacherListType{}); ok {
      s.teachinggroupscheduletype.TeacherList = v
      }
      }
      return s.teachinggroupscheduletype.TeacherList
    }
// Returns whether the element value for TeacherList is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) TeacherList_IsNil() bool {
    return s.teachinggroupscheduletype.TeacherList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) TeachingGroupPeriodList() *TeachingGroupPeriodListType {
    if s.teachinggroupscheduletype.TeachingGroupPeriodList == nil {
     if v, ok:= TeachingGroupPeriodListTypePointer(TeachingGroupPeriodListType{}); ok {
      s.teachinggroupscheduletype.TeachingGroupPeriodList = v
      }
      }
      return s.teachinggroupscheduletype.TeachingGroupPeriodList
    }
// Returns whether the element value for TeachingGroupPeriodList is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) TeachingGroupPeriodList_IsNil() bool {
    return s.teachinggroupscheduletype.TeachingGroupPeriodList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) TimeTableSubjectLocalId() *LocalIdType {
    if s.teachinggroupscheduletype.TimeTableSubjectLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.TimeTableSubjectLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroupscheduletype.TimeTableSubjectLocalId
    }
// Returns whether the element value for TimeTableSubjectLocalId is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) TimeTableSubjectLocalId_IsNil() bool {
    return s.teachinggroupscheduletype.TimeTableSubjectLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupScheduleType) TimeTableSubjectRefId() *RefIdType {
    if s.teachinggroupscheduletype.TimeTableSubjectRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupscheduletype.TimeTableSubjectRefId = ((*RefIdType)(v))
      }
      }
      return s.teachinggroupscheduletype.TimeTableSubjectRefId
    }
// Returns whether the element value for TimeTableSubjectRefId is nil in the container TeachingGroupScheduleType.
  func (s *TeachingGroupScheduleType) TimeTableSubjectRefId_IsNil() bool {
    return s.teachinggroupscheduletype.TimeTableSubjectRefId == nil
    }

// Set the value of a property to nil
func (n *TeachingGroupStudentType) Unset(key string) *TeachingGroupStudentType {
        switch key {
  case "Name":
   n.teachinggroupstudenttype.Name = nil
  case "StudentLocalId":
   n.teachinggroupstudenttype.StudentLocalId = nil
  case "StudentPersonalRefId":
   n.teachinggroupstudenttype.StudentPersonalRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroupStudentType")
        }
        return n
}

// Set a sequence of properties
func (n *TeachingGroupStudentType) SetProperties(props ...Prop) *TeachingGroupStudentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TeachingGroupStudentType) SetProperty(key string, value interface{}) *TeachingGroupStudentType {
        if n == nil {
                n, _ = TeachingGroupStudentTypePointer(TeachingGroupStudentType{})
        }
        switch key {
    case "Name":
    if v, ok:= NameOfRecordTypePointer(value); ok {
      n.teachinggroupstudenttype.Name = v
      }
    case "StudentLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupstudenttype.StudentLocalId = ((*LocalIdType)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupstudenttype.StudentPersonalRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroupStudentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupStudentType) Name() *NameOfRecordType {
    if s.teachinggroupstudenttype.Name == nil {
     if v, ok:= NameOfRecordTypePointer(NameOfRecordType{}); ok {
      s.teachinggroupstudenttype.Name = v
      }
      }
      return s.teachinggroupstudenttype.Name
    }
// Returns whether the element value for Name is nil in the container TeachingGroupStudentType.
  func (s *TeachingGroupStudentType) Name_IsNil() bool {
    return s.teachinggroupstudenttype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupStudentType) StudentLocalId() *LocalIdType {
    if s.teachinggroupstudenttype.StudentLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupstudenttype.StudentLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroupstudenttype.StudentLocalId
    }
// Returns whether the element value for StudentLocalId is nil in the container TeachingGroupStudentType.
  func (s *TeachingGroupStudentType) StudentLocalId_IsNil() bool {
    return s.teachinggroupstudenttype.StudentLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupStudentType) StudentPersonalRefId() *String {
    if s.teachinggroupstudenttype.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupstudenttype.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.teachinggroupstudenttype.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container TeachingGroupStudentType.
  func (s *TeachingGroupStudentType) StudentPersonalRefId_IsNil() bool {
    return s.teachinggroupstudenttype.StudentPersonalRefId == nil
    }

// Set the value of a property to nil
func (n *TeachingGroupTeacherType) Unset(key string) *TeachingGroupTeacherType {
        switch key {
  case "Association":
   n.teachinggroupteachertype.Association = nil
  case "Name":
   n.teachinggroupteachertype.Name = nil
  case "StaffLocalId":
   n.teachinggroupteachertype.StaffLocalId = nil
  case "StaffPersonalRefId":
   n.teachinggroupteachertype.StaffPersonalRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroupTeacherType")
        }
        return n
}

// Set a sequence of properties
func (n *TeachingGroupTeacherType) SetProperties(props ...Prop) *TeachingGroupTeacherType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TeachingGroupTeacherType) SetProperty(key string, value interface{}) *TeachingGroupTeacherType {
        if n == nil {
                n, _ = TeachingGroupTeacherTypePointer(TeachingGroupTeacherType{})
        }
        switch key {
    case "Association":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupteachertype.Association = ((*String)(v))
      }
    case "Name":
    if v, ok:= NameOfRecordTypePointer(value); ok {
      n.teachinggroupteachertype.Name = v
      }
    case "StaffLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupteachertype.StaffLocalId = ((*LocalIdType)(v))
      }
    case "StaffPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.teachinggroupteachertype.StaffPersonalRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TeachingGroupTeacherType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupTeacherType) Association() *String {
    if s.teachinggroupteachertype.Association == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupteachertype.Association = ((*String)(v))
      }
      }
      return s.teachinggroupteachertype.Association
    }
// Returns whether the element value for Association is nil in the container TeachingGroupTeacherType.
  func (s *TeachingGroupTeacherType) Association_IsNil() bool {
    return s.teachinggroupteachertype.Association == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupTeacherType) Name() *NameOfRecordType {
    if s.teachinggroupteachertype.Name == nil {
     if v, ok:= NameOfRecordTypePointer(NameOfRecordType{}); ok {
      s.teachinggroupteachertype.Name = v
      }
      }
      return s.teachinggroupteachertype.Name
    }
// Returns whether the element value for Name is nil in the container TeachingGroupTeacherType.
  func (s *TeachingGroupTeacherType) Name_IsNil() bool {
    return s.teachinggroupteachertype.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupTeacherType) StaffLocalId() *LocalIdType {
    if s.teachinggroupteachertype.StaffLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupteachertype.StaffLocalId = ((*LocalIdType)(v))
      }
      }
      return s.teachinggroupteachertype.StaffLocalId
    }
// Returns whether the element value for StaffLocalId is nil in the container TeachingGroupTeacherType.
  func (s *TeachingGroupTeacherType) StaffLocalId_IsNil() bool {
    return s.teachinggroupteachertype.StaffLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TeachingGroupTeacherType) StaffPersonalRefId() *String {
    if s.teachinggroupteachertype.StaffPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.teachinggroupteachertype.StaffPersonalRefId = ((*String)(v))
      }
      }
      return s.teachinggroupteachertype.StaffPersonalRefId
    }
// Returns whether the element value for StaffPersonalRefId is nil in the container TeachingGroupTeacherType.
  func (s *TeachingGroupTeacherType) StaffPersonalRefId_IsNil() bool {
    return s.teachinggroupteachertype.StaffPersonalRefId == nil
    }

// Set the value of a property to nil
func (n *TechnicalRequirementsType) Unset(key string) *TechnicalRequirementsType {
        switch key {
  case "TechnicalRequirement":
   n.technicalrequirementstype.TechnicalRequirement = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TechnicalRequirementsType")
        }
        return n
}

// Set a sequence of properties
func (n *TechnicalRequirementsType) SetProperties(props ...Prop) *TechnicalRequirementsType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TechnicalRequirementsType) SetProperty(key string, value interface{}) *TechnicalRequirementsType {
        if n == nil {
                n, _ = TechnicalRequirementsTypePointer(TechnicalRequirementsType{})
        }
        switch key {
    case "TechnicalRequirement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.technicalrequirementstype.TechnicalRequirement = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TechnicalRequirementsType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TechnicalRequirementsType) TechnicalRequirement() *String {
    if s.technicalrequirementstype.TechnicalRequirement == nil {
    if v, ok:= StringPointer(""); ok {
      s.technicalrequirementstype.TechnicalRequirement = ((*String)(v))
      }
      }
      return s.technicalrequirementstype.TechnicalRequirement
    }
// Returns whether the element value for TechnicalRequirement is nil in the container TechnicalRequirementsType.
  func (s *TechnicalRequirementsType) TechnicalRequirement_IsNil() bool {
    return s.technicalrequirementstype.TechnicalRequirement == nil
    }

// Set the value of a property to nil
func (n *TermInfo) Unset(key string) *TermInfo {
        switch key {
  case "AttendanceTerm":
   n.terminfo.AttendanceTerm = nil
  case "Description":
   n.terminfo.Description = nil
  case "EndDate":
   n.terminfo.EndDate = nil
  case "LocalCodeList":
   n.terminfo.LocalCodeList = nil
  case "MarkingTerm":
   n.terminfo.MarkingTerm = nil
  case "RefId":
   n.terminfo.RefId = nil
  case "RelativeDuration":
   n.terminfo.RelativeDuration = nil
  case "SIF_ExtendedElements":
   n.terminfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.terminfo.SIF_Metadata = nil
  case "SchedulingTerm":
   n.terminfo.SchedulingTerm = nil
  case "SchoolInfoRefId":
   n.terminfo.SchoolInfoRefId = nil
  case "SchoolYear":
   n.terminfo.SchoolYear = nil
  case "StartDate":
   n.terminfo.StartDate = nil
  case "TermCode":
   n.terminfo.TermCode = nil
  case "TermSpan":
   n.terminfo.TermSpan = nil
  case "Track":
   n.terminfo.Track = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TermInfo")
        }
        return n
}

// Set a sequence of properties
func (n *TermInfo) SetProperties(props ...Prop) *TermInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TermInfo) SetProperty(key string, value interface{}) *TermInfo {
        if n == nil {
                n, _ = TermInfoPointer(TermInfo{})
        }
        switch key {
    case "AttendanceTerm":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.terminfo.AttendanceTerm = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.terminfo.Description = ((*String)(v))
      }
    case "EndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.terminfo.EndDate = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.terminfo.LocalCodeList = v
      }
    case "MarkingTerm":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.terminfo.MarkingTerm = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.terminfo.RefId = ((*RefIdType)(v))
      }
    case "RelativeDuration":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.terminfo.RelativeDuration = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.terminfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.terminfo.SIF_Metadata = v
      }
    case "SchedulingTerm":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.terminfo.SchedulingTerm = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.terminfo.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.terminfo.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.terminfo.StartDate = ((*String)(v))
      }
    case "TermCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.terminfo.TermCode = ((*String)(v))
      }
    case "TermSpan":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsSessionTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsSessionTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.terminfo.TermSpan = ((*AUCodeSetsSessionTypeType)(v))
      }
    case "Track":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.terminfo.Track = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TermInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) AttendanceTerm() *AUCodeSetsYesOrNoCategoryType {
    if s.terminfo.AttendanceTerm == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.AttendanceTerm = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.terminfo.AttendanceTerm
    }
// Returns whether the element value for AttendanceTerm is nil in the container TermInfo.
  func (s *TermInfo) AttendanceTerm_IsNil() bool {
    return s.terminfo.AttendanceTerm == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) Description() *String {
    if s.terminfo.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.Description = ((*String)(v))
      }
      }
      return s.terminfo.Description
    }
// Returns whether the element value for Description is nil in the container TermInfo.
  func (s *TermInfo) Description_IsNil() bool {
    return s.terminfo.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) EndDate() *String {
    if s.terminfo.EndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.EndDate = ((*String)(v))
      }
      }
      return s.terminfo.EndDate
    }
// Returns whether the element value for EndDate is nil in the container TermInfo.
  func (s *TermInfo) EndDate_IsNil() bool {
    return s.terminfo.EndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) LocalCodeList() *LocalCodeListType {
    if s.terminfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.terminfo.LocalCodeList = v
      }
      }
      return s.terminfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container TermInfo.
  func (s *TermInfo) LocalCodeList_IsNil() bool {
    return s.terminfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) MarkingTerm() *AUCodeSetsYesOrNoCategoryType {
    if s.terminfo.MarkingTerm == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.MarkingTerm = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.terminfo.MarkingTerm
    }
// Returns whether the element value for MarkingTerm is nil in the container TermInfo.
  func (s *TermInfo) MarkingTerm_IsNil() bool {
    return s.terminfo.MarkingTerm == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) RefId() *RefIdType {
    if s.terminfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.terminfo.RefId
    }
// Returns whether the element value for RefId is nil in the container TermInfo.
  func (s *TermInfo) RefId_IsNil() bool {
    return s.terminfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) RelativeDuration() *String {
    if s.terminfo.RelativeDuration == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.RelativeDuration = ((*String)(v))
      }
      }
      return s.terminfo.RelativeDuration
    }
// Returns whether the element value for RelativeDuration is nil in the container TermInfo.
  func (s *TermInfo) RelativeDuration_IsNil() bool {
    return s.terminfo.RelativeDuration == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.terminfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.terminfo.SIF_ExtendedElements = v
      }
      }
      return s.terminfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container TermInfo.
  func (s *TermInfo) SIF_ExtendedElements_IsNil() bool {
    return s.terminfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) SIF_Metadata() *SIF_MetadataType {
    if s.terminfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.terminfo.SIF_Metadata = v
      }
      }
      return s.terminfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container TermInfo.
  func (s *TermInfo) SIF_Metadata_IsNil() bool {
    return s.terminfo.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) SchedulingTerm() *AUCodeSetsYesOrNoCategoryType {
    if s.terminfo.SchedulingTerm == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.SchedulingTerm = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.terminfo.SchedulingTerm
    }
// Returns whether the element value for SchedulingTerm is nil in the container TermInfo.
  func (s *TermInfo) SchedulingTerm_IsNil() bool {
    return s.terminfo.SchedulingTerm == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) SchoolInfoRefId() *String {
    if s.terminfo.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.terminfo.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container TermInfo.
  func (s *TermInfo) SchoolInfoRefId_IsNil() bool {
    return s.terminfo.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) SchoolYear() *SchoolYearType {
    if s.terminfo.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.terminfo.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container TermInfo.
  func (s *TermInfo) SchoolYear_IsNil() bool {
    return s.terminfo.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) StartDate() *String {
    if s.terminfo.StartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.StartDate = ((*String)(v))
      }
      }
      return s.terminfo.StartDate
    }
// Returns whether the element value for StartDate is nil in the container TermInfo.
  func (s *TermInfo) StartDate_IsNil() bool {
    return s.terminfo.StartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) TermCode() *String {
    if s.terminfo.TermCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.TermCode = ((*String)(v))
      }
      }
      return s.terminfo.TermCode
    }
// Returns whether the element value for TermCode is nil in the container TermInfo.
  func (s *TermInfo) TermCode_IsNil() bool {
    return s.terminfo.TermCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) TermSpan() *AUCodeSetsSessionTypeType {
    if s.terminfo.TermSpan == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.TermSpan = ((*AUCodeSetsSessionTypeType)(v))
      }
      }
      return s.terminfo.TermSpan
    }
// Returns whether the element value for TermSpan is nil in the container TermInfo.
  func (s *TermInfo) TermSpan_IsNil() bool {
    return s.terminfo.TermSpan == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TermInfo) Track() *String {
    if s.terminfo.Track == nil {
    if v, ok:= StringPointer(""); ok {
      s.terminfo.Track = ((*String)(v))
      }
      }
      return s.terminfo.Track
    }
// Returns whether the element value for Track is nil in the container TermInfo.
  func (s *TermInfo) Track_IsNil() bool {
    return s.terminfo.Track == nil
    }

// Set the value of a property to nil
func (n *TestDisruptionType) Unset(key string) *TestDisruptionType {
        switch key {
  case "Event":
   n.testdisruptiontype.Event = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TestDisruptionType")
        }
        return n
}

// Set a sequence of properties
func (n *TestDisruptionType) SetProperties(props ...Prop) *TestDisruptionType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TestDisruptionType) SetProperty(key string, value interface{}) *TestDisruptionType {
        if n == nil {
                n, _ = TestDisruptionTypePointer(TestDisruptionType{})
        }
        switch key {
    case "Event":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.testdisruptiontype.Event = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TestDisruptionType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TestDisruptionType) Event() *String {
    if s.testdisruptiontype.Event == nil {
    if v, ok:= StringPointer(""); ok {
      s.testdisruptiontype.Event = ((*String)(v))
      }
      }
      return s.testdisruptiontype.Event
    }
// Returns whether the element value for Event is nil in the container TestDisruptionType.
  func (s *TestDisruptionType) Event_IsNil() bool {
    return s.testdisruptiontype.Event == nil
    }

// Set the value of a property to nil
func (n *TextDataType) Unset(key string) *TextDataType {
        switch key {
  case "Description":
   n.textdatatype.Description = nil
  case "FileName":
   n.textdatatype.FileName = nil
  case "MIMEType":
   n.textdatatype.MIMEType = nil
  case "Value":
   n.textdatatype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TextDataType")
        }
        return n
}

// Set a sequence of properties
func (n *TextDataType) SetProperties(props ...Prop) *TextDataType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TextDataType) SetProperty(key string, value interface{}) *TextDataType {
        if n == nil {
                n, _ = TextDataTypePointer(TextDataType{})
        }
        switch key {
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.textdatatype.Description = ((*String)(v))
      }
    case "FileName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.textdatatype.FileName = ((*String)(v))
      }
    case "MIMEType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.textdatatype.MIMEType = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.textdatatype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TextDataType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TextDataType) Description() *String {
    if s.textdatatype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.textdatatype.Description = ((*String)(v))
      }
      }
      return s.textdatatype.Description
    }
// Returns whether the element value for Description is nil in the container TextDataType.
  func (s *TextDataType) Description_IsNil() bool {
    return s.textdatatype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TextDataType) FileName() *String {
    if s.textdatatype.FileName == nil {
    if v, ok:= StringPointer(""); ok {
      s.textdatatype.FileName = ((*String)(v))
      }
      }
      return s.textdatatype.FileName
    }
// Returns whether the element value for FileName is nil in the container TextDataType.
  func (s *TextDataType) FileName_IsNil() bool {
    return s.textdatatype.FileName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TextDataType) MIMEType() *String {
    if s.textdatatype.MIMEType == nil {
    if v, ok:= StringPointer(""); ok {
      s.textdatatype.MIMEType = ((*String)(v))
      }
      }
      return s.textdatatype.MIMEType
    }
// Returns whether the element value for MIMEType is nil in the container TextDataType.
  func (s *TextDataType) MIMEType_IsNil() bool {
    return s.textdatatype.MIMEType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TextDataType) Value() *String {
    if s.textdatatype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.textdatatype.Value = ((*String)(v))
      }
      }
      return s.textdatatype.Value
    }
// Returns whether the element value for Value is nil in the container TextDataType.
  func (s *TextDataType) Value_IsNil() bool {
    return s.textdatatype.Value == nil
    }

// Set the value of a property to nil
func (n *TimeElementType) Unset(key string) *TimeElementType {
        switch key {
  case "EndDateTime":
   n.timeelementtype.EndDateTime = nil
  case "IsCurrent":
   n.timeelementtype.IsCurrent = nil
  case "SpanGaps":
   n.timeelementtype.SpanGaps = nil
  case "StartDateTime":
   n.timeelementtype.StartDateTime = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeElementType")
        }
        return n
}

// Set a sequence of properties
func (n *TimeElementType) SetProperties(props ...Prop) *TimeElementType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeElementType) SetProperty(key string, value interface{}) *TimeElementType {
        if n == nil {
                n, _ = TimeElementTypePointer(TimeElementType{})
        }
        switch key {
    case "EndDateTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timeelementtype.EndDateTime = ((*String)(v))
      }
    case "IsCurrent":
    
    if v, ok:= BoolPointer(value); ok {
      n.timeelementtype.IsCurrent = ((*Bool)(v))
      }
    case "SpanGaps":
    if v, ok:= SpanGapListTypePointer(value); ok {
      n.timeelementtype.SpanGaps = v
      }
    case "StartDateTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timeelementtype.StartDateTime = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeElementType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeElementType) EndDateTime() *String {
    if s.timeelementtype.EndDateTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.timeelementtype.EndDateTime = ((*String)(v))
      }
      }
      return s.timeelementtype.EndDateTime
    }
// Returns whether the element value for EndDateTime is nil in the container TimeElementType.
  func (s *TimeElementType) EndDateTime_IsNil() bool {
    return s.timeelementtype.EndDateTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeElementType) IsCurrent() *Bool {
    if s.timeelementtype.IsCurrent == nil {
    if v, ok:= BoolPointer(false); ok {
      s.timeelementtype.IsCurrent = ((*Bool)(v))
      }
      }
      return s.timeelementtype.IsCurrent
    }
// Returns whether the element value for IsCurrent is nil in the container TimeElementType.
  func (s *TimeElementType) IsCurrent_IsNil() bool {
    return s.timeelementtype.IsCurrent == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeElementType) SpanGaps() *SpanGapListType {
    if s.timeelementtype.SpanGaps == nil {
     if v, ok:= SpanGapListTypePointer(SpanGapListType{}); ok {
      s.timeelementtype.SpanGaps = v
      }
      }
      return s.timeelementtype.SpanGaps
    }
// Returns whether the element value for SpanGaps is nil in the container TimeElementType.
  func (s *TimeElementType) SpanGaps_IsNil() bool {
    return s.timeelementtype.SpanGaps == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeElementType) StartDateTime() *String {
    if s.timeelementtype.StartDateTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.timeelementtype.StartDateTime = ((*String)(v))
      }
      }
      return s.timeelementtype.StartDateTime
    }
// Returns whether the element value for StartDateTime is nil in the container TimeElementType.
  func (s *TimeElementType) StartDateTime_IsNil() bool {
    return s.timeelementtype.StartDateTime == nil
    }

// Set the value of a property to nil
func (n *TimeTable) Unset(key string) *TimeTable {
        switch key {
  case "DaysPerCycle":
   n.timetable.DaysPerCycle = nil
  case "EndDate":
   n.timetable.EndDate = nil
  case "LocalCodeList":
   n.timetable.LocalCodeList = nil
  case "LocalId":
   n.timetable.LocalId = nil
  case "PeriodsPerDay":
   n.timetable.PeriodsPerDay = nil
  case "RefId":
   n.timetable.RefId = nil
  case "SIF_ExtendedElements":
   n.timetable.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.timetable.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.timetable.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.timetable.SchoolLocalId = nil
  case "SchoolName":
   n.timetable.SchoolName = nil
  case "SchoolYear":
   n.timetable.SchoolYear = nil
  case "StartDate":
   n.timetable.StartDate = nil
  case "TeachingPeriodsPerDay":
   n.timetable.TeachingPeriodsPerDay = nil
  case "TimeTableCreationDate":
   n.timetable.TimeTableCreationDate = nil
  case "TimeTableDayList":
   n.timetable.TimeTableDayList = nil
  case "Title":
   n.timetable.Title = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTable")
        }
        return n
}

// Set a sequence of properties
func (n *TimeTable) SetProperties(props ...Prop) *TimeTable {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeTable) SetProperty(key string, value interface{}) *TimeTable {
        if n == nil {
                n, _ = TimeTablePointer(TimeTable{})
        }
        switch key {
    case "DaysPerCycle":
    
    if v, ok:= IntPointer(value); ok {
      n.timetable.DaysPerCycle = ((*Int)(v))
      }
    case "EndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.EndDate = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.timetable.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.LocalId = ((*LocalIdType)(v))
      }
    case "PeriodsPerDay":
    
    if v, ok:= IntPointer(value); ok {
      n.timetable.PeriodsPerDay = ((*Int)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.timetable.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.timetable.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "SchoolName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.SchoolName = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.StartDate = ((*String)(v))
      }
    case "TeachingPeriodsPerDay":
    
    if v, ok:= IntPointer(value); ok {
      n.timetable.TeachingPeriodsPerDay = ((*Int)(v))
      }
    case "TimeTableCreationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.TimeTableCreationDate = ((*String)(v))
      }
    case "TimeTableDayList":
    if v, ok:= TimeTableDayListTypePointer(value); ok {
      n.timetable.TimeTableDayList = v
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetable.Title = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTable")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) DaysPerCycle() *Int {
    if s.timetable.DaysPerCycle == nil {
    if v, ok:= IntPointer(0); ok {
      s.timetable.DaysPerCycle = ((*Int)(v))
      }
      }
      return s.timetable.DaysPerCycle
    }
// Returns whether the element value for DaysPerCycle is nil in the container TimeTable.
  func (s *TimeTable) DaysPerCycle_IsNil() bool {
    return s.timetable.DaysPerCycle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) EndDate() *String {
    if s.timetable.EndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.EndDate = ((*String)(v))
      }
      }
      return s.timetable.EndDate
    }
// Returns whether the element value for EndDate is nil in the container TimeTable.
  func (s *TimeTable) EndDate_IsNil() bool {
    return s.timetable.EndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) LocalCodeList() *LocalCodeListType {
    if s.timetable.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.timetable.LocalCodeList = v
      }
      }
      return s.timetable.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container TimeTable.
  func (s *TimeTable) LocalCodeList_IsNil() bool {
    return s.timetable.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) LocalId() *LocalIdType {
    if s.timetable.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetable.LocalId
    }
// Returns whether the element value for LocalId is nil in the container TimeTable.
  func (s *TimeTable) LocalId_IsNil() bool {
    return s.timetable.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) PeriodsPerDay() *Int {
    if s.timetable.PeriodsPerDay == nil {
    if v, ok:= IntPointer(0); ok {
      s.timetable.PeriodsPerDay = ((*Int)(v))
      }
      }
      return s.timetable.PeriodsPerDay
    }
// Returns whether the element value for PeriodsPerDay is nil in the container TimeTable.
  func (s *TimeTable) PeriodsPerDay_IsNil() bool {
    return s.timetable.PeriodsPerDay == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) RefId() *RefIdType {
    if s.timetable.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.RefId = ((*RefIdType)(v))
      }
      }
      return s.timetable.RefId
    }
// Returns whether the element value for RefId is nil in the container TimeTable.
  func (s *TimeTable) RefId_IsNil() bool {
    return s.timetable.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.timetable.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.timetable.SIF_ExtendedElements = v
      }
      }
      return s.timetable.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container TimeTable.
  func (s *TimeTable) SIF_ExtendedElements_IsNil() bool {
    return s.timetable.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) SIF_Metadata() *SIF_MetadataType {
    if s.timetable.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.timetable.SIF_Metadata = v
      }
      }
      return s.timetable.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container TimeTable.
  func (s *TimeTable) SIF_Metadata_IsNil() bool {
    return s.timetable.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) SchoolInfoRefId() *String {
    if s.timetable.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.timetable.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container TimeTable.
  func (s *TimeTable) SchoolInfoRefId_IsNil() bool {
    return s.timetable.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) SchoolLocalId() *LocalIdType {
    if s.timetable.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetable.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container TimeTable.
  func (s *TimeTable) SchoolLocalId_IsNil() bool {
    return s.timetable.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) SchoolName() *String {
    if s.timetable.SchoolName == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.SchoolName = ((*String)(v))
      }
      }
      return s.timetable.SchoolName
    }
// Returns whether the element value for SchoolName is nil in the container TimeTable.
  func (s *TimeTable) SchoolName_IsNil() bool {
    return s.timetable.SchoolName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) SchoolYear() *SchoolYearType {
    if s.timetable.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.timetable.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container TimeTable.
  func (s *TimeTable) SchoolYear_IsNil() bool {
    return s.timetable.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) StartDate() *String {
    if s.timetable.StartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.StartDate = ((*String)(v))
      }
      }
      return s.timetable.StartDate
    }
// Returns whether the element value for StartDate is nil in the container TimeTable.
  func (s *TimeTable) StartDate_IsNil() bool {
    return s.timetable.StartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) TeachingPeriodsPerDay() *Int {
    if s.timetable.TeachingPeriodsPerDay == nil {
    if v, ok:= IntPointer(0); ok {
      s.timetable.TeachingPeriodsPerDay = ((*Int)(v))
      }
      }
      return s.timetable.TeachingPeriodsPerDay
    }
// Returns whether the element value for TeachingPeriodsPerDay is nil in the container TimeTable.
  func (s *TimeTable) TeachingPeriodsPerDay_IsNil() bool {
    return s.timetable.TeachingPeriodsPerDay == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) TimeTableCreationDate() *String {
    if s.timetable.TimeTableCreationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.TimeTableCreationDate = ((*String)(v))
      }
      }
      return s.timetable.TimeTableCreationDate
    }
// Returns whether the element value for TimeTableCreationDate is nil in the container TimeTable.
  func (s *TimeTable) TimeTableCreationDate_IsNil() bool {
    return s.timetable.TimeTableCreationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) TimeTableDayList() *TimeTableDayListType {
    if s.timetable.TimeTableDayList == nil {
     if v, ok:= TimeTableDayListTypePointer(TimeTableDayListType{}); ok {
      s.timetable.TimeTableDayList = v
      }
      }
      return s.timetable.TimeTableDayList
    }
// Returns whether the element value for TimeTableDayList is nil in the container TimeTable.
  func (s *TimeTable) TimeTableDayList_IsNil() bool {
    return s.timetable.TimeTableDayList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTable) Title() *String {
    if s.timetable.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetable.Title = ((*String)(v))
      }
      }
      return s.timetable.Title
    }
// Returns whether the element value for Title is nil in the container TimeTable.
  func (s *TimeTable) Title_IsNil() bool {
    return s.timetable.Title == nil
    }

// Set the value of a property to nil
func (n *TimeTableCell) Unset(key string) *TimeTableCell {
        switch key {
  case "CellType":
   n.timetablecell.CellType = nil
  case "DayId":
   n.timetablecell.DayId = nil
  case "LocalCodeList":
   n.timetablecell.LocalCodeList = nil
  case "PeriodId":
   n.timetablecell.PeriodId = nil
  case "RefId":
   n.timetablecell.RefId = nil
  case "RoomInfoRefId":
   n.timetablecell.RoomInfoRefId = nil
  case "RoomList":
   n.timetablecell.RoomList = nil
  case "RoomNumber":
   n.timetablecell.RoomNumber = nil
  case "SIF_ExtendedElements":
   n.timetablecell.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.timetablecell.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.timetablecell.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.timetablecell.SchoolLocalId = nil
  case "StaffLocalId":
   n.timetablecell.StaffLocalId = nil
  case "StaffPersonalRefId":
   n.timetablecell.StaffPersonalRefId = nil
  case "SubjectLocalId":
   n.timetablecell.SubjectLocalId = nil
  case "TeacherList":
   n.timetablecell.TeacherList = nil
  case "TeachingGroupLocalId":
   n.timetablecell.TeachingGroupLocalId = nil
  case "TeachingGroupRefId":
   n.timetablecell.TeachingGroupRefId = nil
  case "TimeTableLocalId":
   n.timetablecell.TimeTableLocalId = nil
  case "TimeTableRefId":
   n.timetablecell.TimeTableRefId = nil
  case "TimeTableSubjectRefId":
   n.timetablecell.TimeTableSubjectRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableCell")
        }
        return n
}

// Set a sequence of properties
func (n *TimeTableCell) SetProperties(props ...Prop) *TimeTableCell {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeTableCell) SetProperty(key string, value interface{}) *TimeTableCell {
        if n == nil {
                n, _ = TimeTableCellPointer(TimeTableCell{})
        }
        switch key {
    case "CellType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.CellType = ((*String)(v))
      }
    case "DayId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.DayId = ((*LocalIdType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.timetablecell.LocalCodeList = v
      }
    case "PeriodId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.PeriodId = ((*LocalIdType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.RefId = ((*RefIdType)(v))
      }
    case "RoomInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.RoomInfoRefId = ((*String)(v))
      }
    case "RoomList":
    if v, ok:= RoomListTypePointer(value); ok {
      n.timetablecell.RoomList = v
      }
    case "RoomNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.RoomNumber = ((*HomeroomNumberType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.timetablecell.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.timetablecell.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "StaffLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.StaffLocalId = ((*LocalIdType)(v))
      }
    case "StaffPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.StaffPersonalRefId = ((*String)(v))
      }
    case "SubjectLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.SubjectLocalId = ((*LocalIdType)(v))
      }
    case "TeacherList":
    if v, ok:= ScheduledTeacherListTypePointer(value); ok {
      n.timetablecell.TeacherList = v
      }
    case "TeachingGroupLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.TeachingGroupLocalId = ((*LocalIdType)(v))
      }
    case "TeachingGroupRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.TeachingGroupRefId = ((*String)(v))
      }
    case "TimeTableLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.TimeTableLocalId = ((*LocalIdType)(v))
      }
    case "TimeTableRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.TimeTableRefId = ((*String)(v))
      }
    case "TimeTableSubjectRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecell.TimeTableSubjectRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableCell")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) CellType() *String {
    if s.timetablecell.CellType == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.CellType = ((*String)(v))
      }
      }
      return s.timetablecell.CellType
    }
// Returns whether the element value for CellType is nil in the container TimeTableCell.
  func (s *TimeTableCell) CellType_IsNil() bool {
    return s.timetablecell.CellType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) DayId() *LocalIdType {
    if s.timetablecell.DayId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.DayId = ((*LocalIdType)(v))
      }
      }
      return s.timetablecell.DayId
    }
// Returns whether the element value for DayId is nil in the container TimeTableCell.
  func (s *TimeTableCell) DayId_IsNil() bool {
    return s.timetablecell.DayId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) LocalCodeList() *LocalCodeListType {
    if s.timetablecell.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.timetablecell.LocalCodeList = v
      }
      }
      return s.timetablecell.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container TimeTableCell.
  func (s *TimeTableCell) LocalCodeList_IsNil() bool {
    return s.timetablecell.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) PeriodId() *LocalIdType {
    if s.timetablecell.PeriodId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.PeriodId = ((*LocalIdType)(v))
      }
      }
      return s.timetablecell.PeriodId
    }
// Returns whether the element value for PeriodId is nil in the container TimeTableCell.
  func (s *TimeTableCell) PeriodId_IsNil() bool {
    return s.timetablecell.PeriodId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) RefId() *RefIdType {
    if s.timetablecell.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.RefId = ((*RefIdType)(v))
      }
      }
      return s.timetablecell.RefId
    }
// Returns whether the element value for RefId is nil in the container TimeTableCell.
  func (s *TimeTableCell) RefId_IsNil() bool {
    return s.timetablecell.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) RoomInfoRefId() *String {
    if s.timetablecell.RoomInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.RoomInfoRefId = ((*String)(v))
      }
      }
      return s.timetablecell.RoomInfoRefId
    }
// Returns whether the element value for RoomInfoRefId is nil in the container TimeTableCell.
  func (s *TimeTableCell) RoomInfoRefId_IsNil() bool {
    return s.timetablecell.RoomInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) RoomList() *RoomListType {
    if s.timetablecell.RoomList == nil {
     if v, ok:= RoomListTypePointer(RoomListType{}); ok {
      s.timetablecell.RoomList = v
      }
      }
      return s.timetablecell.RoomList
    }
// Returns whether the element value for RoomList is nil in the container TimeTableCell.
  func (s *TimeTableCell) RoomList_IsNil() bool {
    return s.timetablecell.RoomList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) RoomNumber() *HomeroomNumberType {
    if s.timetablecell.RoomNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.RoomNumber = ((*HomeroomNumberType)(v))
      }
      }
      return s.timetablecell.RoomNumber
    }
// Returns whether the element value for RoomNumber is nil in the container TimeTableCell.
  func (s *TimeTableCell) RoomNumber_IsNil() bool {
    return s.timetablecell.RoomNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.timetablecell.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.timetablecell.SIF_ExtendedElements = v
      }
      }
      return s.timetablecell.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container TimeTableCell.
  func (s *TimeTableCell) SIF_ExtendedElements_IsNil() bool {
    return s.timetablecell.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) SIF_Metadata() *SIF_MetadataType {
    if s.timetablecell.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.timetablecell.SIF_Metadata = v
      }
      }
      return s.timetablecell.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container TimeTableCell.
  func (s *TimeTableCell) SIF_Metadata_IsNil() bool {
    return s.timetablecell.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) SchoolInfoRefId() *String {
    if s.timetablecell.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.timetablecell.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container TimeTableCell.
  func (s *TimeTableCell) SchoolInfoRefId_IsNil() bool {
    return s.timetablecell.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) SchoolLocalId() *LocalIdType {
    if s.timetablecell.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablecell.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container TimeTableCell.
  func (s *TimeTableCell) SchoolLocalId_IsNil() bool {
    return s.timetablecell.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) StaffLocalId() *LocalIdType {
    if s.timetablecell.StaffLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.StaffLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablecell.StaffLocalId
    }
// Returns whether the element value for StaffLocalId is nil in the container TimeTableCell.
  func (s *TimeTableCell) StaffLocalId_IsNil() bool {
    return s.timetablecell.StaffLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) StaffPersonalRefId() *String {
    if s.timetablecell.StaffPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.StaffPersonalRefId = ((*String)(v))
      }
      }
      return s.timetablecell.StaffPersonalRefId
    }
// Returns whether the element value for StaffPersonalRefId is nil in the container TimeTableCell.
  func (s *TimeTableCell) StaffPersonalRefId_IsNil() bool {
    return s.timetablecell.StaffPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) SubjectLocalId() *LocalIdType {
    if s.timetablecell.SubjectLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.SubjectLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablecell.SubjectLocalId
    }
// Returns whether the element value for SubjectLocalId is nil in the container TimeTableCell.
  func (s *TimeTableCell) SubjectLocalId_IsNil() bool {
    return s.timetablecell.SubjectLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) TeacherList() *ScheduledTeacherListType {
    if s.timetablecell.TeacherList == nil {
     if v, ok:= ScheduledTeacherListTypePointer(ScheduledTeacherListType{}); ok {
      s.timetablecell.TeacherList = v
      }
      }
      return s.timetablecell.TeacherList
    }
// Returns whether the element value for TeacherList is nil in the container TimeTableCell.
  func (s *TimeTableCell) TeacherList_IsNil() bool {
    return s.timetablecell.TeacherList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) TeachingGroupLocalId() *LocalIdType {
    if s.timetablecell.TeachingGroupLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.TeachingGroupLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablecell.TeachingGroupLocalId
    }
// Returns whether the element value for TeachingGroupLocalId is nil in the container TimeTableCell.
  func (s *TimeTableCell) TeachingGroupLocalId_IsNil() bool {
    return s.timetablecell.TeachingGroupLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) TeachingGroupRefId() *String {
    if s.timetablecell.TeachingGroupRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.TeachingGroupRefId = ((*String)(v))
      }
      }
      return s.timetablecell.TeachingGroupRefId
    }
// Returns whether the element value for TeachingGroupRefId is nil in the container TimeTableCell.
  func (s *TimeTableCell) TeachingGroupRefId_IsNil() bool {
    return s.timetablecell.TeachingGroupRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) TimeTableLocalId() *LocalIdType {
    if s.timetablecell.TimeTableLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.TimeTableLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablecell.TimeTableLocalId
    }
// Returns whether the element value for TimeTableLocalId is nil in the container TimeTableCell.
  func (s *TimeTableCell) TimeTableLocalId_IsNil() bool {
    return s.timetablecell.TimeTableLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) TimeTableRefId() *String {
    if s.timetablecell.TimeTableRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.TimeTableRefId = ((*String)(v))
      }
      }
      return s.timetablecell.TimeTableRefId
    }
// Returns whether the element value for TimeTableRefId is nil in the container TimeTableCell.
  func (s *TimeTableCell) TimeTableRefId_IsNil() bool {
    return s.timetablecell.TimeTableRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableCell) TimeTableSubjectRefId() *String {
    if s.timetablecell.TimeTableSubjectRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecell.TimeTableSubjectRefId = ((*String)(v))
      }
      }
      return s.timetablecell.TimeTableSubjectRefId
    }
// Returns whether the element value for TimeTableSubjectRefId is nil in the container TimeTableCell.
  func (s *TimeTableCell) TimeTableSubjectRefId_IsNil() bool {
    return s.timetablecell.TimeTableSubjectRefId == nil
    }

// Set the value of a property to nil
func (n *TimeTableChangeReasonType) Unset(key string) *TimeTableChangeReasonType {
        switch key {
  case "TimeTableChangeNotes":
   n.timetablechangereasontype.TimeTableChangeNotes = nil
  case "TimeTableChangeType":
   n.timetablechangereasontype.TimeTableChangeType = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableChangeReasonType")
        }
        return n
}

// Set a sequence of properties
func (n *TimeTableChangeReasonType) SetProperties(props ...Prop) *TimeTableChangeReasonType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeTableChangeReasonType) SetProperty(key string, value interface{}) *TimeTableChangeReasonType {
        if n == nil {
                n, _ = TimeTableChangeReasonTypePointer(TimeTableChangeReasonType{})
        }
        switch key {
    case "TimeTableChangeNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablechangereasontype.TimeTableChangeNotes = ((*String)(v))
      }
    case "TimeTableChangeType":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsTimeTableChangeTypeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsTimeTableChangeTypeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.timetablechangereasontype.TimeTableChangeType = ((*AUCodeSetsTimeTableChangeTypeType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableChangeReasonType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableChangeReasonType) TimeTableChangeNotes() *String {
    if s.timetablechangereasontype.TimeTableChangeNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablechangereasontype.TimeTableChangeNotes = ((*String)(v))
      }
      }
      return s.timetablechangereasontype.TimeTableChangeNotes
    }
// Returns whether the element value for TimeTableChangeNotes is nil in the container TimeTableChangeReasonType.
  func (s *TimeTableChangeReasonType) TimeTableChangeNotes_IsNil() bool {
    return s.timetablechangereasontype.TimeTableChangeNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableChangeReasonType) TimeTableChangeType() *AUCodeSetsTimeTableChangeTypeType {
    if s.timetablechangereasontype.TimeTableChangeType == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablechangereasontype.TimeTableChangeType = ((*AUCodeSetsTimeTableChangeTypeType)(v))
      }
      }
      return s.timetablechangereasontype.TimeTableChangeType
    }
// Returns whether the element value for TimeTableChangeType is nil in the container TimeTableChangeReasonType.
  func (s *TimeTableChangeReasonType) TimeTableChangeType_IsNil() bool {
    return s.timetablechangereasontype.TimeTableChangeType == nil
    }

// Set the value of a property to nil
func (n *TimeTableContainer) Unset(key string) *TimeTableContainer {
        switch key {
  case "LocalCodeList":
   n.timetablecontainer.LocalCodeList = nil
  case "RefId":
   n.timetablecontainer.RefId = nil
  case "SIF_ExtendedElements":
   n.timetablecontainer.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.timetablecontainer.SIF_Metadata = nil
  case "TeachingGroupScheduleList":
   n.timetablecontainer.TeachingGroupScheduleList = nil
  case "TimeTableSchedule":
   n.timetablecontainer.TimeTableSchedule = nil
  case "TimeTableScheduleCellList":
   n.timetablecontainer.TimeTableScheduleCellList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableContainer")
        }
        return n
}

// Set a sequence of properties
func (n *TimeTableContainer) SetProperties(props ...Prop) *TimeTableContainer {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeTableContainer) SetProperty(key string, value interface{}) *TimeTableContainer {
        if n == nil {
                n, _ = TimeTableContainerPointer(TimeTableContainer{})
        }
        switch key {
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.timetablecontainer.LocalCodeList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablecontainer.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.timetablecontainer.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.timetablecontainer.SIF_Metadata = v
      }
    case "TeachingGroupScheduleList":
    if v, ok:= TeachingGroupScheduleTypePointer(value); ok {
      n.timetablecontainer.TeachingGroupScheduleList = v
      }
    case "TimeTableSchedule":
    if v, ok:= TimeTableScheduleTypePointer(value); ok {
      n.timetablecontainer.TimeTableSchedule = v
      }
    case "TimeTableScheduleCellList":
    if v, ok:= TimeTableScheduleCellListTypePointer(value); ok {
      n.timetablecontainer.TimeTableScheduleCellList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableContainer")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableContainer) LocalCodeList() *LocalCodeListType {
    if s.timetablecontainer.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.timetablecontainer.LocalCodeList = v
      }
      }
      return s.timetablecontainer.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container TimeTableContainer.
  func (s *TimeTableContainer) LocalCodeList_IsNil() bool {
    return s.timetablecontainer.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableContainer) RefId() *RefIdType {
    if s.timetablecontainer.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablecontainer.RefId = ((*RefIdType)(v))
      }
      }
      return s.timetablecontainer.RefId
    }
// Returns whether the element value for RefId is nil in the container TimeTableContainer.
  func (s *TimeTableContainer) RefId_IsNil() bool {
    return s.timetablecontainer.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableContainer) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.timetablecontainer.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.timetablecontainer.SIF_ExtendedElements = v
      }
      }
      return s.timetablecontainer.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container TimeTableContainer.
  func (s *TimeTableContainer) SIF_ExtendedElements_IsNil() bool {
    return s.timetablecontainer.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableContainer) SIF_Metadata() *SIF_MetadataType {
    if s.timetablecontainer.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.timetablecontainer.SIF_Metadata = v
      }
      }
      return s.timetablecontainer.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container TimeTableContainer.
  func (s *TimeTableContainer) SIF_Metadata_IsNil() bool {
    return s.timetablecontainer.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableContainer) TeachingGroupScheduleList() *TeachingGroupScheduleType {
    if s.timetablecontainer.TeachingGroupScheduleList == nil {
     if v, ok:= TeachingGroupScheduleTypePointer(TeachingGroupScheduleType{}); ok {
      s.timetablecontainer.TeachingGroupScheduleList = v
      }
      }
      return s.timetablecontainer.TeachingGroupScheduleList
    }
// Returns whether the element value for TeachingGroupScheduleList is nil in the container TimeTableContainer.
  func (s *TimeTableContainer) TeachingGroupScheduleList_IsNil() bool {
    return s.timetablecontainer.TeachingGroupScheduleList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableContainer) TimeTableSchedule() *TimeTableScheduleType {
    if s.timetablecontainer.TimeTableSchedule == nil {
     if v, ok:= TimeTableScheduleTypePointer(TimeTableScheduleType{}); ok {
      s.timetablecontainer.TimeTableSchedule = v
      }
      }
      return s.timetablecontainer.TimeTableSchedule
    }
// Returns whether the element value for TimeTableSchedule is nil in the container TimeTableContainer.
  func (s *TimeTableContainer) TimeTableSchedule_IsNil() bool {
    return s.timetablecontainer.TimeTableSchedule == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableContainer) TimeTableScheduleCellList() *TimeTableScheduleCellListType {
    if s.timetablecontainer.TimeTableScheduleCellList == nil {
     if v, ok:= TimeTableScheduleCellListTypePointer(TimeTableScheduleCellListType{}); ok {
      s.timetablecontainer.TimeTableScheduleCellList = v
      }
      }
      return s.timetablecontainer.TimeTableScheduleCellList
    }
// Returns whether the element value for TimeTableScheduleCellList is nil in the container TimeTableContainer.
  func (s *TimeTableContainer) TimeTableScheduleCellList_IsNil() bool {
    return s.timetablecontainer.TimeTableScheduleCellList == nil
    }

// Set the value of a property to nil
func (n *TimeTableDayType) Unset(key string) *TimeTableDayType {
        switch key {
  case "DayId":
   n.timetabledaytype.DayId = nil
  case "DayTitle":
   n.timetabledaytype.DayTitle = nil
  case "TimeTablePeriodList":
   n.timetabledaytype.TimeTablePeriodList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableDayType")
        }
        return n
}

// Set a sequence of properties
func (n *TimeTableDayType) SetProperties(props ...Prop) *TimeTableDayType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeTableDayType) SetProperty(key string, value interface{}) *TimeTableDayType {
        if n == nil {
                n, _ = TimeTableDayTypePointer(TimeTableDayType{})
        }
        switch key {
    case "DayId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetabledaytype.DayId = ((*LocalIdType)(v))
      }
    case "DayTitle":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetabledaytype.DayTitle = ((*String)(v))
      }
    case "TimeTablePeriodList":
    if v, ok:= TimeTablePeriodListTypePointer(value); ok {
      n.timetabledaytype.TimeTablePeriodList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableDayType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableDayType) DayId() *LocalIdType {
    if s.timetabledaytype.DayId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetabledaytype.DayId = ((*LocalIdType)(v))
      }
      }
      return s.timetabledaytype.DayId
    }
// Returns whether the element value for DayId is nil in the container TimeTableDayType.
  func (s *TimeTableDayType) DayId_IsNil() bool {
    return s.timetabledaytype.DayId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableDayType) DayTitle() *String {
    if s.timetabledaytype.DayTitle == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetabledaytype.DayTitle = ((*String)(v))
      }
      }
      return s.timetabledaytype.DayTitle
    }
// Returns whether the element value for DayTitle is nil in the container TimeTableDayType.
  func (s *TimeTableDayType) DayTitle_IsNil() bool {
    return s.timetabledaytype.DayTitle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableDayType) TimeTablePeriodList() *TimeTablePeriodListType {
    if s.timetabledaytype.TimeTablePeriodList == nil {
     if v, ok:= TimeTablePeriodListTypePointer(TimeTablePeriodListType{}); ok {
      s.timetabledaytype.TimeTablePeriodList = v
      }
      }
      return s.timetabledaytype.TimeTablePeriodList
    }
// Returns whether the element value for TimeTablePeriodList is nil in the container TimeTableDayType.
  func (s *TimeTableDayType) TimeTablePeriodList_IsNil() bool {
    return s.timetabledaytype.TimeTablePeriodList == nil
    }

// Set the value of a property to nil
func (n *TimeTablePeriodType) Unset(key string) *TimeTablePeriodType {
        switch key {
  case "BellPeriod":
   n.timetableperiodtype.BellPeriod = nil
  case "EndTime":
   n.timetableperiodtype.EndTime = nil
  case "InstructionalMinutes":
   n.timetableperiodtype.InstructionalMinutes = nil
  case "PeriodId":
   n.timetableperiodtype.PeriodId = nil
  case "PeriodTitle":
   n.timetableperiodtype.PeriodTitle = nil
  case "RegularSchoolPeriod":
   n.timetableperiodtype.RegularSchoolPeriod = nil
  case "StartTime":
   n.timetableperiodtype.StartTime = nil
  case "UseInAttendanceCalculations":
   n.timetableperiodtype.UseInAttendanceCalculations = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTablePeriodType")
        }
        return n
}

// Set a sequence of properties
func (n *TimeTablePeriodType) SetProperties(props ...Prop) *TimeTablePeriodType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeTablePeriodType) SetProperty(key string, value interface{}) *TimeTablePeriodType {
        if n == nil {
                n, _ = TimeTablePeriodTypePointer(TimeTablePeriodType{})
        }
        switch key {
    case "BellPeriod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableperiodtype.BellPeriod = ((*String)(v))
      }
    case "EndTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableperiodtype.EndTime = ((*String)(v))
      }
    case "InstructionalMinutes":
    
    if v, ok:= IntPointer(value); ok {
      n.timetableperiodtype.InstructionalMinutes = ((*Int)(v))
      }
    case "PeriodId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableperiodtype.PeriodId = ((*LocalIdType)(v))
      }
    case "PeriodTitle":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableperiodtype.PeriodTitle = ((*String)(v))
      }
    case "RegularSchoolPeriod":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableperiodtype.RegularSchoolPeriod = ((*String)(v))
      }
    case "StartTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableperiodtype.StartTime = ((*String)(v))
      }
    case "UseInAttendanceCalculations":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableperiodtype.UseInAttendanceCalculations = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTablePeriodType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTablePeriodType) BellPeriod() *String {
    if s.timetableperiodtype.BellPeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableperiodtype.BellPeriod = ((*String)(v))
      }
      }
      return s.timetableperiodtype.BellPeriod
    }
// Returns whether the element value for BellPeriod is nil in the container TimeTablePeriodType.
  func (s *TimeTablePeriodType) BellPeriod_IsNil() bool {
    return s.timetableperiodtype.BellPeriod == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTablePeriodType) EndTime() *String {
    if s.timetableperiodtype.EndTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableperiodtype.EndTime = ((*String)(v))
      }
      }
      return s.timetableperiodtype.EndTime
    }
// Returns whether the element value for EndTime is nil in the container TimeTablePeriodType.
  func (s *TimeTablePeriodType) EndTime_IsNil() bool {
    return s.timetableperiodtype.EndTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTablePeriodType) InstructionalMinutes() *Int {
    if s.timetableperiodtype.InstructionalMinutes == nil {
    if v, ok:= IntPointer(0); ok {
      s.timetableperiodtype.InstructionalMinutes = ((*Int)(v))
      }
      }
      return s.timetableperiodtype.InstructionalMinutes
    }
// Returns whether the element value for InstructionalMinutes is nil in the container TimeTablePeriodType.
  func (s *TimeTablePeriodType) InstructionalMinutes_IsNil() bool {
    return s.timetableperiodtype.InstructionalMinutes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTablePeriodType) PeriodId() *LocalIdType {
    if s.timetableperiodtype.PeriodId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableperiodtype.PeriodId = ((*LocalIdType)(v))
      }
      }
      return s.timetableperiodtype.PeriodId
    }
// Returns whether the element value for PeriodId is nil in the container TimeTablePeriodType.
  func (s *TimeTablePeriodType) PeriodId_IsNil() bool {
    return s.timetableperiodtype.PeriodId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTablePeriodType) PeriodTitle() *String {
    if s.timetableperiodtype.PeriodTitle == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableperiodtype.PeriodTitle = ((*String)(v))
      }
      }
      return s.timetableperiodtype.PeriodTitle
    }
// Returns whether the element value for PeriodTitle is nil in the container TimeTablePeriodType.
  func (s *TimeTablePeriodType) PeriodTitle_IsNil() bool {
    return s.timetableperiodtype.PeriodTitle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTablePeriodType) RegularSchoolPeriod() *String {
    if s.timetableperiodtype.RegularSchoolPeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableperiodtype.RegularSchoolPeriod = ((*String)(v))
      }
      }
      return s.timetableperiodtype.RegularSchoolPeriod
    }
// Returns whether the element value for RegularSchoolPeriod is nil in the container TimeTablePeriodType.
  func (s *TimeTablePeriodType) RegularSchoolPeriod_IsNil() bool {
    return s.timetableperiodtype.RegularSchoolPeriod == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTablePeriodType) StartTime() *String {
    if s.timetableperiodtype.StartTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableperiodtype.StartTime = ((*String)(v))
      }
      }
      return s.timetableperiodtype.StartTime
    }
// Returns whether the element value for StartTime is nil in the container TimeTablePeriodType.
  func (s *TimeTablePeriodType) StartTime_IsNil() bool {
    return s.timetableperiodtype.StartTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTablePeriodType) UseInAttendanceCalculations() *String {
    if s.timetableperiodtype.UseInAttendanceCalculations == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableperiodtype.UseInAttendanceCalculations = ((*String)(v))
      }
      }
      return s.timetableperiodtype.UseInAttendanceCalculations
    }
// Returns whether the element value for UseInAttendanceCalculations is nil in the container TimeTablePeriodType.
  func (s *TimeTablePeriodType) UseInAttendanceCalculations_IsNil() bool {
    return s.timetableperiodtype.UseInAttendanceCalculations == nil
    }

// Set the value of a property to nil
func (n *TimeTableScheduleCellType) Unset(key string) *TimeTableScheduleCellType {
        switch key {
  case "CellType":
   n.timetableschedulecelltype.CellType = nil
  case "DayId":
   n.timetableschedulecelltype.DayId = nil
  case "PeriodId":
   n.timetableschedulecelltype.PeriodId = nil
  case "RoomInfoRefId":
   n.timetableschedulecelltype.RoomInfoRefId = nil
  case "RoomList":
   n.timetableschedulecelltype.RoomList = nil
  case "RoomNumber":
   n.timetableschedulecelltype.RoomNumber = nil
  case "SchoolInfoRefId":
   n.timetableschedulecelltype.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.timetableschedulecelltype.SchoolLocalId = nil
  case "StaffLocalId":
   n.timetableschedulecelltype.StaffLocalId = nil
  case "StaffPersonalRefId":
   n.timetableschedulecelltype.StaffPersonalRefId = nil
  case "SubjectLocalId":
   n.timetableschedulecelltype.SubjectLocalId = nil
  case "TeacherList":
   n.timetableschedulecelltype.TeacherList = nil
  case "TeachingGroupGUID":
   n.timetableschedulecelltype.TeachingGroupGUID = nil
  case "TeachingGroupLocalId":
   n.timetableschedulecelltype.TeachingGroupLocalId = nil
  case "TimeTableLocalId":
   n.timetableschedulecelltype.TimeTableLocalId = nil
  case "TimeTableScheduleCellLocalId":
   n.timetableschedulecelltype.TimeTableScheduleCellLocalId = nil
  case "TimeTableSubjectRefId":
   n.timetableschedulecelltype.TimeTableSubjectRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableScheduleCellType")
        }
        return n
}

// Set a sequence of properties
func (n *TimeTableScheduleCellType) SetProperties(props ...Prop) *TimeTableScheduleCellType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeTableScheduleCellType) SetProperty(key string, value interface{}) *TimeTableScheduleCellType {
        if n == nil {
                n, _ = TimeTableScheduleCellTypePointer(TimeTableScheduleCellType{})
        }
        switch key {
    case "CellType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.CellType = ((*String)(v))
      }
    case "DayId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.DayId = ((*LocalIdType)(v))
      }
    case "PeriodId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.PeriodId = ((*LocalIdType)(v))
      }
    case "RoomInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.RoomInfoRefId = ((*String)(v))
      }
    case "RoomList":
    if v, ok:= RoomListTypePointer(value); ok {
      n.timetableschedulecelltype.RoomList = v
      }
    case "RoomNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.RoomNumber = ((*HomeroomNumberType)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "StaffLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.StaffLocalId = ((*LocalIdType)(v))
      }
    case "StaffPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.StaffPersonalRefId = ((*String)(v))
      }
    case "SubjectLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.SubjectLocalId = ((*LocalIdType)(v))
      }
    case "TeacherList":
    if v, ok:= ScheduledTeacherListTypePointer(value); ok {
      n.timetableschedulecelltype.TeacherList = v
      }
    case "TeachingGroupGUID":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.TeachingGroupGUID = ((*String)(v))
      }
    case "TeachingGroupLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.TeachingGroupLocalId = ((*LocalIdType)(v))
      }
    case "TimeTableLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.TimeTableLocalId = ((*LocalIdType)(v))
      }
    case "TimeTableScheduleCellLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.TimeTableScheduleCellLocalId = ((*LocalIdType)(v))
      }
    case "TimeTableSubjectRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetableschedulecelltype.TimeTableSubjectRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableScheduleCellType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) CellType() *String {
    if s.timetableschedulecelltype.CellType == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.CellType = ((*String)(v))
      }
      }
      return s.timetableschedulecelltype.CellType
    }
// Returns whether the element value for CellType is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) CellType_IsNil() bool {
    return s.timetableschedulecelltype.CellType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) DayId() *LocalIdType {
    if s.timetableschedulecelltype.DayId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.DayId = ((*LocalIdType)(v))
      }
      }
      return s.timetableschedulecelltype.DayId
    }
// Returns whether the element value for DayId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) DayId_IsNil() bool {
    return s.timetableschedulecelltype.DayId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) PeriodId() *LocalIdType {
    if s.timetableschedulecelltype.PeriodId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.PeriodId = ((*LocalIdType)(v))
      }
      }
      return s.timetableschedulecelltype.PeriodId
    }
// Returns whether the element value for PeriodId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) PeriodId_IsNil() bool {
    return s.timetableschedulecelltype.PeriodId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) RoomInfoRefId() *String {
    if s.timetableschedulecelltype.RoomInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.RoomInfoRefId = ((*String)(v))
      }
      }
      return s.timetableschedulecelltype.RoomInfoRefId
    }
// Returns whether the element value for RoomInfoRefId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) RoomInfoRefId_IsNil() bool {
    return s.timetableschedulecelltype.RoomInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) RoomList() *RoomListType {
    if s.timetableschedulecelltype.RoomList == nil {
     if v, ok:= RoomListTypePointer(RoomListType{}); ok {
      s.timetableschedulecelltype.RoomList = v
      }
      }
      return s.timetableschedulecelltype.RoomList
    }
// Returns whether the element value for RoomList is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) RoomList_IsNil() bool {
    return s.timetableschedulecelltype.RoomList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) RoomNumber() *HomeroomNumberType {
    if s.timetableschedulecelltype.RoomNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.RoomNumber = ((*HomeroomNumberType)(v))
      }
      }
      return s.timetableschedulecelltype.RoomNumber
    }
// Returns whether the element value for RoomNumber is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) RoomNumber_IsNil() bool {
    return s.timetableschedulecelltype.RoomNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) SchoolInfoRefId() *String {
    if s.timetableschedulecelltype.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.timetableschedulecelltype.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) SchoolInfoRefId_IsNil() bool {
    return s.timetableschedulecelltype.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) SchoolLocalId() *LocalIdType {
    if s.timetableschedulecelltype.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetableschedulecelltype.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) SchoolLocalId_IsNil() bool {
    return s.timetableschedulecelltype.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) StaffLocalId() *LocalIdType {
    if s.timetableschedulecelltype.StaffLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.StaffLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetableschedulecelltype.StaffLocalId
    }
// Returns whether the element value for StaffLocalId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) StaffLocalId_IsNil() bool {
    return s.timetableschedulecelltype.StaffLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) StaffPersonalRefId() *String {
    if s.timetableschedulecelltype.StaffPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.StaffPersonalRefId = ((*String)(v))
      }
      }
      return s.timetableschedulecelltype.StaffPersonalRefId
    }
// Returns whether the element value for StaffPersonalRefId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) StaffPersonalRefId_IsNil() bool {
    return s.timetableschedulecelltype.StaffPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) SubjectLocalId() *LocalIdType {
    if s.timetableschedulecelltype.SubjectLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.SubjectLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetableschedulecelltype.SubjectLocalId
    }
// Returns whether the element value for SubjectLocalId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) SubjectLocalId_IsNil() bool {
    return s.timetableschedulecelltype.SubjectLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) TeacherList() *ScheduledTeacherListType {
    if s.timetableschedulecelltype.TeacherList == nil {
     if v, ok:= ScheduledTeacherListTypePointer(ScheduledTeacherListType{}); ok {
      s.timetableschedulecelltype.TeacherList = v
      }
      }
      return s.timetableschedulecelltype.TeacherList
    }
// Returns whether the element value for TeacherList is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) TeacherList_IsNil() bool {
    return s.timetableschedulecelltype.TeacherList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) TeachingGroupGUID() *String {
    if s.timetableschedulecelltype.TeachingGroupGUID == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.TeachingGroupGUID = ((*String)(v))
      }
      }
      return s.timetableschedulecelltype.TeachingGroupGUID
    }
// Returns whether the element value for TeachingGroupGUID is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) TeachingGroupGUID_IsNil() bool {
    return s.timetableschedulecelltype.TeachingGroupGUID == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) TeachingGroupLocalId() *LocalIdType {
    if s.timetableschedulecelltype.TeachingGroupLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.TeachingGroupLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetableschedulecelltype.TeachingGroupLocalId
    }
// Returns whether the element value for TeachingGroupLocalId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) TeachingGroupLocalId_IsNil() bool {
    return s.timetableschedulecelltype.TeachingGroupLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) TimeTableLocalId() *LocalIdType {
    if s.timetableschedulecelltype.TimeTableLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.TimeTableLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetableschedulecelltype.TimeTableLocalId
    }
// Returns whether the element value for TimeTableLocalId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) TimeTableLocalId_IsNil() bool {
    return s.timetableschedulecelltype.TimeTableLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) TimeTableScheduleCellLocalId() *LocalIdType {
    if s.timetableschedulecelltype.TimeTableScheduleCellLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.TimeTableScheduleCellLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetableschedulecelltype.TimeTableScheduleCellLocalId
    }
// Returns whether the element value for TimeTableScheduleCellLocalId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) TimeTableScheduleCellLocalId_IsNil() bool {
    return s.timetableschedulecelltype.TimeTableScheduleCellLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleCellType) TimeTableSubjectRefId() *String {
    if s.timetableschedulecelltype.TimeTableSubjectRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetableschedulecelltype.TimeTableSubjectRefId = ((*String)(v))
      }
      }
      return s.timetableschedulecelltype.TimeTableSubjectRefId
    }
// Returns whether the element value for TimeTableSubjectRefId is nil in the container TimeTableScheduleCellType.
  func (s *TimeTableScheduleCellType) TimeTableSubjectRefId_IsNil() bool {
    return s.timetableschedulecelltype.TimeTableSubjectRefId == nil
    }

// Set the value of a property to nil
func (n *TimeTableScheduleType) Unset(key string) *TimeTableScheduleType {
        switch key {
  case "DaysPerCycle":
   n.timetablescheduletype.DaysPerCycle = nil
  case "EndDate":
   n.timetablescheduletype.EndDate = nil
  case "LocalId":
   n.timetablescheduletype.LocalId = nil
  case "PeriodsPerDay":
   n.timetablescheduletype.PeriodsPerDay = nil
  case "SchoolInfoRefId":
   n.timetablescheduletype.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.timetablescheduletype.SchoolLocalId = nil
  case "SchoolName":
   n.timetablescheduletype.SchoolName = nil
  case "SchoolYear":
   n.timetablescheduletype.SchoolYear = nil
  case "StartDate":
   n.timetablescheduletype.StartDate = nil
  case "TeachingPeriodsPerDay":
   n.timetablescheduletype.TeachingPeriodsPerDay = nil
  case "TimeTableCreationDate":
   n.timetablescheduletype.TimeTableCreationDate = nil
  case "TimeTableDayList":
   n.timetablescheduletype.TimeTableDayList = nil
  case "Title":
   n.timetablescheduletype.Title = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableScheduleType")
        }
        return n
}

// Set a sequence of properties
func (n *TimeTableScheduleType) SetProperties(props ...Prop) *TimeTableScheduleType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeTableScheduleType) SetProperty(key string, value interface{}) *TimeTableScheduleType {
        if n == nil {
                n, _ = TimeTableScheduleTypePointer(TimeTableScheduleType{})
        }
        switch key {
    case "DaysPerCycle":
    
    if v, ok:= IntPointer(value); ok {
      n.timetablescheduletype.DaysPerCycle = ((*Int)(v))
      }
    case "EndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablescheduletype.EndDate = ((*String)(v))
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablescheduletype.LocalId = ((*LocalIdType)(v))
      }
    case "PeriodsPerDay":
    
    if v, ok:= IntPointer(value); ok {
      n.timetablescheduletype.PeriodsPerDay = ((*Int)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablescheduletype.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablescheduletype.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "SchoolName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablescheduletype.SchoolName = ((*String)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablescheduletype.SchoolYear = ((*SchoolYearType)(v))
      }
    case "StartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablescheduletype.StartDate = ((*String)(v))
      }
    case "TeachingPeriodsPerDay":
    
    if v, ok:= IntPointer(value); ok {
      n.timetablescheduletype.TeachingPeriodsPerDay = ((*Int)(v))
      }
    case "TimeTableCreationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablescheduletype.TimeTableCreationDate = ((*String)(v))
      }
    case "TimeTableDayList":
    if v, ok:= TimeTableDayListTypePointer(value); ok {
      n.timetablescheduletype.TimeTableDayList = v
      }
    case "Title":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablescheduletype.Title = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableScheduleType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) DaysPerCycle() *Int {
    if s.timetablescheduletype.DaysPerCycle == nil {
    if v, ok:= IntPointer(0); ok {
      s.timetablescheduletype.DaysPerCycle = ((*Int)(v))
      }
      }
      return s.timetablescheduletype.DaysPerCycle
    }
// Returns whether the element value for DaysPerCycle is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) DaysPerCycle_IsNil() bool {
    return s.timetablescheduletype.DaysPerCycle == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) EndDate() *String {
    if s.timetablescheduletype.EndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablescheduletype.EndDate = ((*String)(v))
      }
      }
      return s.timetablescheduletype.EndDate
    }
// Returns whether the element value for EndDate is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) EndDate_IsNil() bool {
    return s.timetablescheduletype.EndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) LocalId() *LocalIdType {
    if s.timetablescheduletype.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablescheduletype.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablescheduletype.LocalId
    }
// Returns whether the element value for LocalId is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) LocalId_IsNil() bool {
    return s.timetablescheduletype.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) PeriodsPerDay() *Int {
    if s.timetablescheduletype.PeriodsPerDay == nil {
    if v, ok:= IntPointer(0); ok {
      s.timetablescheduletype.PeriodsPerDay = ((*Int)(v))
      }
      }
      return s.timetablescheduletype.PeriodsPerDay
    }
// Returns whether the element value for PeriodsPerDay is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) PeriodsPerDay_IsNil() bool {
    return s.timetablescheduletype.PeriodsPerDay == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) SchoolInfoRefId() *String {
    if s.timetablescheduletype.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablescheduletype.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.timetablescheduletype.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) SchoolInfoRefId_IsNil() bool {
    return s.timetablescheduletype.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) SchoolLocalId() *LocalIdType {
    if s.timetablescheduletype.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablescheduletype.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablescheduletype.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) SchoolLocalId_IsNil() bool {
    return s.timetablescheduletype.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) SchoolName() *String {
    if s.timetablescheduletype.SchoolName == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablescheduletype.SchoolName = ((*String)(v))
      }
      }
      return s.timetablescheduletype.SchoolName
    }
// Returns whether the element value for SchoolName is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) SchoolName_IsNil() bool {
    return s.timetablescheduletype.SchoolName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) SchoolYear() *SchoolYearType {
    if s.timetablescheduletype.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablescheduletype.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.timetablescheduletype.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) SchoolYear_IsNil() bool {
    return s.timetablescheduletype.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) StartDate() *String {
    if s.timetablescheduletype.StartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablescheduletype.StartDate = ((*String)(v))
      }
      }
      return s.timetablescheduletype.StartDate
    }
// Returns whether the element value for StartDate is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) StartDate_IsNil() bool {
    return s.timetablescheduletype.StartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) TeachingPeriodsPerDay() *Int {
    if s.timetablescheduletype.TeachingPeriodsPerDay == nil {
    if v, ok:= IntPointer(0); ok {
      s.timetablescheduletype.TeachingPeriodsPerDay = ((*Int)(v))
      }
      }
      return s.timetablescheduletype.TeachingPeriodsPerDay
    }
// Returns whether the element value for TeachingPeriodsPerDay is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) TeachingPeriodsPerDay_IsNil() bool {
    return s.timetablescheduletype.TeachingPeriodsPerDay == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) TimeTableCreationDate() *String {
    if s.timetablescheduletype.TimeTableCreationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablescheduletype.TimeTableCreationDate = ((*String)(v))
      }
      }
      return s.timetablescheduletype.TimeTableCreationDate
    }
// Returns whether the element value for TimeTableCreationDate is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) TimeTableCreationDate_IsNil() bool {
    return s.timetablescheduletype.TimeTableCreationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) TimeTableDayList() *TimeTableDayListType {
    if s.timetablescheduletype.TimeTableDayList == nil {
     if v, ok:= TimeTableDayListTypePointer(TimeTableDayListType{}); ok {
      s.timetablescheduletype.TimeTableDayList = v
      }
      }
      return s.timetablescheduletype.TimeTableDayList
    }
// Returns whether the element value for TimeTableDayList is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) TimeTableDayList_IsNil() bool {
    return s.timetablescheduletype.TimeTableDayList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableScheduleType) Title() *String {
    if s.timetablescheduletype.Title == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablescheduletype.Title = ((*String)(v))
      }
      }
      return s.timetablescheduletype.Title
    }
// Returns whether the element value for Title is nil in the container TimeTableScheduleType.
  func (s *TimeTableScheduleType) Title_IsNil() bool {
    return s.timetablescheduletype.Title == nil
    }

// Set the value of a property to nil
func (n *TimeTableSubject) Unset(key string) *TimeTableSubject {
        switch key {
  case "AcademicYear":
   n.timetablesubject.AcademicYear = nil
  case "AcademicYearRange":
   n.timetablesubject.AcademicYearRange = nil
  case "CourseLocalId":
   n.timetablesubject.CourseLocalId = nil
  case "Faculty":
   n.timetablesubject.Faculty = nil
  case "LocalCodeList":
   n.timetablesubject.LocalCodeList = nil
  case "OtherCodeList":
   n.timetablesubject.OtherCodeList = nil
  case "ProposedMaxClassSize":
   n.timetablesubject.ProposedMaxClassSize = nil
  case "ProposedMinClassSize":
   n.timetablesubject.ProposedMinClassSize = nil
  case "RefId":
   n.timetablesubject.RefId = nil
  case "SIF_ExtendedElements":
   n.timetablesubject.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.timetablesubject.SIF_Metadata = nil
  case "SchoolCourseInfoRefId":
   n.timetablesubject.SchoolCourseInfoRefId = nil
  case "SchoolInfoRefId":
   n.timetablesubject.SchoolInfoRefId = nil
  case "SchoolLocalId":
   n.timetablesubject.SchoolLocalId = nil
  case "SchoolYear":
   n.timetablesubject.SchoolYear = nil
  case "Semester":
   n.timetablesubject.Semester = nil
  case "SubjectLocalId":
   n.timetablesubject.SubjectLocalId = nil
  case "SubjectLongName":
   n.timetablesubject.SubjectLongName = nil
  case "SubjectShortName":
   n.timetablesubject.SubjectShortName = nil
  case "SubjectType":
   n.timetablesubject.SubjectType = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableSubject")
        }
        return n
}

// Set a sequence of properties
func (n *TimeTableSubject) SetProperties(props ...Prop) *TimeTableSubject {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TimeTableSubject) SetProperty(key string, value interface{}) *TimeTableSubject {
        if n == nil {
                n, _ = TimeTableSubjectPointer(TimeTableSubject{})
        }
        switch key {
    case "AcademicYear":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.timetablesubject.AcademicYear = v
      }
    case "AcademicYearRange":
    if v, ok:= YearRangeTypePointer(value); ok {
      n.timetablesubject.AcademicYearRange = v
      }
    case "CourseLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.CourseLocalId = ((*LocalIdType)(v))
      }
    case "Faculty":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.Faculty = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.timetablesubject.LocalCodeList = v
      }
    case "OtherCodeList":
    if v, ok:= OtherCodeListTypePointer(value); ok {
      n.timetablesubject.OtherCodeList = v
      }
    case "ProposedMaxClassSize":
    
    if v, ok:= FloatPointer(value); ok {
      n.timetablesubject.ProposedMaxClassSize = ((*Float)(v))
      }
    case "ProposedMinClassSize":
    
    if v, ok:= FloatPointer(value); ok {
      n.timetablesubject.ProposedMinClassSize = ((*Float)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.timetablesubject.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.timetablesubject.SIF_Metadata = v
      }
    case "SchoolCourseInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.SchoolCourseInfoRefId = ((*RefIdType)(v))
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.SchoolInfoRefId = ((*String)(v))
      }
    case "SchoolLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.SchoolLocalId = ((*LocalIdType)(v))
      }
    case "SchoolYear":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.SchoolYear = ((*SchoolYearType)(v))
      }
    case "Semester":
    
    if v, ok:= IntPointer(value); ok {
      n.timetablesubject.Semester = ((*Int)(v))
      }
    case "SubjectLocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.SubjectLocalId = ((*LocalIdType)(v))
      }
    case "SubjectLongName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.SubjectLongName = ((*String)(v))
      }
    case "SubjectShortName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.SubjectShortName = ((*String)(v))
      }
    case "SubjectType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.timetablesubject.SubjectType = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TimeTableSubject")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) AcademicYear() *YearLevelType {
    if s.timetablesubject.AcademicYear == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.timetablesubject.AcademicYear = v
      }
      }
      return s.timetablesubject.AcademicYear
    }
// Returns whether the element value for AcademicYear is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) AcademicYear_IsNil() bool {
    return s.timetablesubject.AcademicYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) AcademicYearRange() *YearRangeType {
    if s.timetablesubject.AcademicYearRange == nil {
     if v, ok:= YearRangeTypePointer(YearRangeType{}); ok {
      s.timetablesubject.AcademicYearRange = v
      }
      }
      return s.timetablesubject.AcademicYearRange
    }
// Returns whether the element value for AcademicYearRange is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) AcademicYearRange_IsNil() bool {
    return s.timetablesubject.AcademicYearRange == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) CourseLocalId() *LocalIdType {
    if s.timetablesubject.CourseLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.CourseLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablesubject.CourseLocalId
    }
// Returns whether the element value for CourseLocalId is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) CourseLocalId_IsNil() bool {
    return s.timetablesubject.CourseLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) Faculty() *String {
    if s.timetablesubject.Faculty == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.Faculty = ((*String)(v))
      }
      }
      return s.timetablesubject.Faculty
    }
// Returns whether the element value for Faculty is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) Faculty_IsNil() bool {
    return s.timetablesubject.Faculty == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) LocalCodeList() *LocalCodeListType {
    if s.timetablesubject.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.timetablesubject.LocalCodeList = v
      }
      }
      return s.timetablesubject.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) LocalCodeList_IsNil() bool {
    return s.timetablesubject.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) OtherCodeList() *OtherCodeListType {
    if s.timetablesubject.OtherCodeList == nil {
     if v, ok:= OtherCodeListTypePointer(OtherCodeListType{}); ok {
      s.timetablesubject.OtherCodeList = v
      }
      }
      return s.timetablesubject.OtherCodeList
    }
// Returns whether the element value for OtherCodeList is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) OtherCodeList_IsNil() bool {
    return s.timetablesubject.OtherCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) ProposedMaxClassSize() *Float {
    if s.timetablesubject.ProposedMaxClassSize == nil {
    if v, ok:= FloatPointer(0); ok {
      s.timetablesubject.ProposedMaxClassSize = ((*Float)(v))
      }
      }
      return s.timetablesubject.ProposedMaxClassSize
    }
// Returns whether the element value for ProposedMaxClassSize is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) ProposedMaxClassSize_IsNil() bool {
    return s.timetablesubject.ProposedMaxClassSize == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) ProposedMinClassSize() *Float {
    if s.timetablesubject.ProposedMinClassSize == nil {
    if v, ok:= FloatPointer(0); ok {
      s.timetablesubject.ProposedMinClassSize = ((*Float)(v))
      }
      }
      return s.timetablesubject.ProposedMinClassSize
    }
// Returns whether the element value for ProposedMinClassSize is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) ProposedMinClassSize_IsNil() bool {
    return s.timetablesubject.ProposedMinClassSize == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) RefId() *RefIdType {
    if s.timetablesubject.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.RefId = ((*RefIdType)(v))
      }
      }
      return s.timetablesubject.RefId
    }
// Returns whether the element value for RefId is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) RefId_IsNil() bool {
    return s.timetablesubject.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.timetablesubject.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.timetablesubject.SIF_ExtendedElements = v
      }
      }
      return s.timetablesubject.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SIF_ExtendedElements_IsNil() bool {
    return s.timetablesubject.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SIF_Metadata() *SIF_MetadataType {
    if s.timetablesubject.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.timetablesubject.SIF_Metadata = v
      }
      }
      return s.timetablesubject.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SIF_Metadata_IsNil() bool {
    return s.timetablesubject.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SchoolCourseInfoRefId() *RefIdType {
    if s.timetablesubject.SchoolCourseInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.SchoolCourseInfoRefId = ((*RefIdType)(v))
      }
      }
      return s.timetablesubject.SchoolCourseInfoRefId
    }
// Returns whether the element value for SchoolCourseInfoRefId is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SchoolCourseInfoRefId_IsNil() bool {
    return s.timetablesubject.SchoolCourseInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SchoolInfoRefId() *String {
    if s.timetablesubject.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.timetablesubject.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SchoolInfoRefId_IsNil() bool {
    return s.timetablesubject.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SchoolLocalId() *LocalIdType {
    if s.timetablesubject.SchoolLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.SchoolLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablesubject.SchoolLocalId
    }
// Returns whether the element value for SchoolLocalId is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SchoolLocalId_IsNil() bool {
    return s.timetablesubject.SchoolLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SchoolYear() *SchoolYearType {
    if s.timetablesubject.SchoolYear == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.SchoolYear = ((*SchoolYearType)(v))
      }
      }
      return s.timetablesubject.SchoolYear
    }
// Returns whether the element value for SchoolYear is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SchoolYear_IsNil() bool {
    return s.timetablesubject.SchoolYear == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) Semester() *Int {
    if s.timetablesubject.Semester == nil {
    if v, ok:= IntPointer(0); ok {
      s.timetablesubject.Semester = ((*Int)(v))
      }
      }
      return s.timetablesubject.Semester
    }
// Returns whether the element value for Semester is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) Semester_IsNil() bool {
    return s.timetablesubject.Semester == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SubjectLocalId() *LocalIdType {
    if s.timetablesubject.SubjectLocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.SubjectLocalId = ((*LocalIdType)(v))
      }
      }
      return s.timetablesubject.SubjectLocalId
    }
// Returns whether the element value for SubjectLocalId is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SubjectLocalId_IsNil() bool {
    return s.timetablesubject.SubjectLocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SubjectLongName() *String {
    if s.timetablesubject.SubjectLongName == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.SubjectLongName = ((*String)(v))
      }
      }
      return s.timetablesubject.SubjectLongName
    }
// Returns whether the element value for SubjectLongName is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SubjectLongName_IsNil() bool {
    return s.timetablesubject.SubjectLongName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SubjectShortName() *String {
    if s.timetablesubject.SubjectShortName == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.SubjectShortName = ((*String)(v))
      }
      }
      return s.timetablesubject.SubjectShortName
    }
// Returns whether the element value for SubjectShortName is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SubjectShortName_IsNil() bool {
    return s.timetablesubject.SubjectShortName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TimeTableSubject) SubjectType() *String {
    if s.timetablesubject.SubjectType == nil {
    if v, ok:= StringPointer(""); ok {
      s.timetablesubject.SubjectType = ((*String)(v))
      }
      }
      return s.timetablesubject.SubjectType
    }
// Returns whether the element value for SubjectType is nil in the container TimeTableSubject.
  func (s *TimeTableSubject) SubjectType_IsNil() bool {
    return s.timetablesubject.SubjectType == nil
    }

// Set the value of a property to nil
func (n *TotalEnrollmentsType) Unset(key string) *TotalEnrollmentsType {
        switch key {
  case "Boys":
   n.totalenrollmentstype.Boys = nil
  case "Girls":
   n.totalenrollmentstype.Girls = nil
  case "TotalStudents":
   n.totalenrollmentstype.TotalStudents = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TotalEnrollmentsType")
        }
        return n
}

// Set a sequence of properties
func (n *TotalEnrollmentsType) SetProperties(props ...Prop) *TotalEnrollmentsType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TotalEnrollmentsType) SetProperty(key string, value interface{}) *TotalEnrollmentsType {
        if n == nil {
                n, _ = TotalEnrollmentsTypePointer(TotalEnrollmentsType{})
        }
        switch key {
    case "Boys":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.totalenrollmentstype.Boys = ((*String)(v))
      }
    case "Girls":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.totalenrollmentstype.Girls = ((*String)(v))
      }
    case "TotalStudents":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.totalenrollmentstype.TotalStudents = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TotalEnrollmentsType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TotalEnrollmentsType) Boys() *String {
    if s.totalenrollmentstype.Boys == nil {
    if v, ok:= StringPointer(""); ok {
      s.totalenrollmentstype.Boys = ((*String)(v))
      }
      }
      return s.totalenrollmentstype.Boys
    }
// Returns whether the element value for Boys is nil in the container TotalEnrollmentsType.
  func (s *TotalEnrollmentsType) Boys_IsNil() bool {
    return s.totalenrollmentstype.Boys == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TotalEnrollmentsType) Girls() *String {
    if s.totalenrollmentstype.Girls == nil {
    if v, ok:= StringPointer(""); ok {
      s.totalenrollmentstype.Girls = ((*String)(v))
      }
      }
      return s.totalenrollmentstype.Girls
    }
// Returns whether the element value for Girls is nil in the container TotalEnrollmentsType.
  func (s *TotalEnrollmentsType) Girls_IsNil() bool {
    return s.totalenrollmentstype.Girls == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TotalEnrollmentsType) TotalStudents() *String {
    if s.totalenrollmentstype.TotalStudents == nil {
    if v, ok:= StringPointer(""); ok {
      s.totalenrollmentstype.TotalStudents = ((*String)(v))
      }
      }
      return s.totalenrollmentstype.TotalStudents
    }
// Returns whether the element value for TotalStudents is nil in the container TotalEnrollmentsType.
  func (s *TotalEnrollmentsType) TotalStudents_IsNil() bool {
    return s.totalenrollmentstype.TotalStudents == nil
    }

// Set the value of a property to nil
func (n *TravelDetailsContainerType) Unset(key string) *TravelDetailsContainerType {
        switch key {
  case "FromSchool":
   n.traveldetailscontainertype.FromSchool = nil
  case "ToSchool":
   n.traveldetailscontainertype.ToSchool = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TravelDetailsContainerType")
        }
        return n
}

// Set a sequence of properties
func (n *TravelDetailsContainerType) SetProperties(props ...Prop) *TravelDetailsContainerType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TravelDetailsContainerType) SetProperty(key string, value interface{}) *TravelDetailsContainerType {
        if n == nil {
                n, _ = TravelDetailsContainerTypePointer(TravelDetailsContainerType{})
        }
        switch key {
    case "FromSchool":
    if v, ok:= SchoolTravelTypePointer(value); ok {
      n.traveldetailscontainertype.FromSchool = v
      }
    case "ToSchool":
    if v, ok:= SchoolTravelTypePointer(value); ok {
      n.traveldetailscontainertype.ToSchool = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TravelDetailsContainerType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TravelDetailsContainerType) FromSchool() *SchoolTravelType {
    if s.traveldetailscontainertype.FromSchool == nil {
     if v, ok:= SchoolTravelTypePointer(SchoolTravelType{}); ok {
      s.traveldetailscontainertype.FromSchool = v
      }
      }
      return s.traveldetailscontainertype.FromSchool
    }
// Returns whether the element value for FromSchool is nil in the container TravelDetailsContainerType.
  func (s *TravelDetailsContainerType) FromSchool_IsNil() bool {
    return s.traveldetailscontainertype.FromSchool == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TravelDetailsContainerType) ToSchool() *SchoolTravelType {
    if s.traveldetailscontainertype.ToSchool == nil {
     if v, ok:= SchoolTravelTypePointer(SchoolTravelType{}); ok {
      s.traveldetailscontainertype.ToSchool = v
      }
      }
      return s.traveldetailscontainertype.ToSchool
    }
// Returns whether the element value for ToSchool is nil in the container TravelDetailsContainerType.
  func (s *TravelDetailsContainerType) ToSchool_IsNil() bool {
    return s.traveldetailscontainertype.ToSchool == nil
    }

// Set the value of a property to nil
func (n *TypedIdRefType) Unset(key string) *TypedIdRefType {
        switch key {
  case "SIF_RefObject":
   n.typedidreftype.SIF_RefObject = nil
  case "Value":
   n.typedidreftype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TypedIdRefType")
        }
        return n
}

// Set a sequence of properties
func (n *TypedIdRefType) SetProperties(props ...Prop) *TypedIdRefType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *TypedIdRefType) SetProperty(key string, value interface{}) *TypedIdRefType {
        if n == nil {
                n, _ = TypedIdRefTypePointer(TypedIdRefType{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.typedidreftype.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.typedidreftype.Value = ((*RefIdType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "TypedIdRefType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TypedIdRefType) SIF_RefObject() *String {
    if s.typedidreftype.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.typedidreftype.SIF_RefObject = ((*String)(v))
      }
      }
      return s.typedidreftype.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container TypedIdRefType.
  func (s *TypedIdRefType) SIF_RefObject_IsNil() bool {
    return s.typedidreftype.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *TypedIdRefType) Value() *RefIdType {
    if s.typedidreftype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.typedidreftype.Value = ((*RefIdType)(v))
      }
      }
      return s.typedidreftype.Value
    }
// Returns whether the element value for Value is nil in the container TypedIdRefType.
  func (s *TypedIdRefType) Value_IsNil() bool {
    return s.typedidreftype.Value == nil
    }

// Set the value of a property to nil
func (n *ValidLetterMarkType) Unset(key string) *ValidLetterMarkType {
        switch key {
  case "Code":
   n.validlettermarktype.Code = nil
  case "Description":
   n.validlettermarktype.Description = nil
  case "NumericEquivalent":
   n.validlettermarktype.NumericEquivalent = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ValidLetterMarkType")
        }
        return n
}

// Set a sequence of properties
func (n *ValidLetterMarkType) SetProperties(props ...Prop) *ValidLetterMarkType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *ValidLetterMarkType) SetProperty(key string, value interface{}) *ValidLetterMarkType {
        if n == nil {
                n, _ = ValidLetterMarkTypePointer(ValidLetterMarkType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.validlettermarktype.Code = ((*String)(v))
      }
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.validlettermarktype.Description = ((*String)(v))
      }
    case "NumericEquivalent":
    
    if v, ok:= FloatPointer(value); ok {
      n.validlettermarktype.NumericEquivalent = ((*Float)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "ValidLetterMarkType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ValidLetterMarkType) Code() *String {
    if s.validlettermarktype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.validlettermarktype.Code = ((*String)(v))
      }
      }
      return s.validlettermarktype.Code
    }
// Returns whether the element value for Code is nil in the container ValidLetterMarkType.
  func (s *ValidLetterMarkType) Code_IsNil() bool {
    return s.validlettermarktype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ValidLetterMarkType) Description() *String {
    if s.validlettermarktype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.validlettermarktype.Description = ((*String)(v))
      }
      }
      return s.validlettermarktype.Description
    }
// Returns whether the element value for Description is nil in the container ValidLetterMarkType.
  func (s *ValidLetterMarkType) Description_IsNil() bool {
    return s.validlettermarktype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *ValidLetterMarkType) NumericEquivalent() *Float {
    if s.validlettermarktype.NumericEquivalent == nil {
    if v, ok:= FloatPointer(0); ok {
      s.validlettermarktype.NumericEquivalent = ((*Float)(v))
      }
      }
      return s.validlettermarktype.NumericEquivalent
    }
// Returns whether the element value for NumericEquivalent is nil in the container ValidLetterMarkType.
  func (s *ValidLetterMarkType) NumericEquivalent_IsNil() bool {
    return s.validlettermarktype.NumericEquivalent == nil
    }

// Set the value of a property to nil
func (n *VendorInfo) Unset(key string) *VendorInfo {
        switch key {
  case "ABN":
   n.vendorinfo.ABN = nil
  case "AccountName":
   n.vendorinfo.AccountName = nil
  case "AccountNumber":
   n.vendorinfo.AccountNumber = nil
  case "BPay":
   n.vendorinfo.BPay = nil
  case "BSB":
   n.vendorinfo.BSB = nil
  case "ContactInfo":
   n.vendorinfo.ContactInfo = nil
  case "CustomerId":
   n.vendorinfo.CustomerId = nil
  case "LocalCodeList":
   n.vendorinfo.LocalCodeList = nil
  case "LocalId":
   n.vendorinfo.LocalId = nil
  case "Name":
   n.vendorinfo.Name = nil
  case "PaymentTerms":
   n.vendorinfo.PaymentTerms = nil
  case "RefId":
   n.vendorinfo.RefId = nil
  case "RegisteredForGST":
   n.vendorinfo.RegisteredForGST = nil
  case "SIF_ExtendedElements":
   n.vendorinfo.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.vendorinfo.SIF_Metadata = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "VendorInfo")
        }
        return n
}

// Set a sequence of properties
func (n *VendorInfo) SetProperties(props ...Prop) *VendorInfo {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *VendorInfo) SetProperty(key string, value interface{}) *VendorInfo {
        if n == nil {
                n, _ = VendorInfoPointer(VendorInfo{})
        }
        switch key {
    case "ABN":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.ABN = ((*String)(v))
      }
    case "AccountName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.AccountName = ((*String)(v))
      }
    case "AccountNumber":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.AccountNumber = ((*String)(v))
      }
    case "BPay":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.BPay = ((*String)(v))
      }
    case "BSB":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.BSB = ((*String)(v))
      }
    case "ContactInfo":
    if v, ok:= ContactInfoTypePointer(value); ok {
      n.vendorinfo.ContactInfo = v
      }
    case "CustomerId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.CustomerId = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.vendorinfo.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.LocalId = ((*LocalIdType)(v))
      }
    case "Name":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.Name = ((*String)(v))
      }
    case "PaymentTerms":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.PaymentTerms = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.RefId = ((*RefIdType)(v))
      }
    case "RegisteredForGST":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.vendorinfo.RegisteredForGST = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.vendorinfo.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.vendorinfo.SIF_Metadata = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "VendorInfo")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) ABN() *String {
    if s.vendorinfo.ABN == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.ABN = ((*String)(v))
      }
      }
      return s.vendorinfo.ABN
    }
// Returns whether the element value for ABN is nil in the container VendorInfo.
  func (s *VendorInfo) ABN_IsNil() bool {
    return s.vendorinfo.ABN == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) AccountName() *String {
    if s.vendorinfo.AccountName == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.AccountName = ((*String)(v))
      }
      }
      return s.vendorinfo.AccountName
    }
// Returns whether the element value for AccountName is nil in the container VendorInfo.
  func (s *VendorInfo) AccountName_IsNil() bool {
    return s.vendorinfo.AccountName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) AccountNumber() *String {
    if s.vendorinfo.AccountNumber == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.AccountNumber = ((*String)(v))
      }
      }
      return s.vendorinfo.AccountNumber
    }
// Returns whether the element value for AccountNumber is nil in the container VendorInfo.
  func (s *VendorInfo) AccountNumber_IsNil() bool {
    return s.vendorinfo.AccountNumber == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) BPay() *String {
    if s.vendorinfo.BPay == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.BPay = ((*String)(v))
      }
      }
      return s.vendorinfo.BPay
    }
// Returns whether the element value for BPay is nil in the container VendorInfo.
  func (s *VendorInfo) BPay_IsNil() bool {
    return s.vendorinfo.BPay == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) BSB() *String {
    if s.vendorinfo.BSB == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.BSB = ((*String)(v))
      }
      }
      return s.vendorinfo.BSB
    }
// Returns whether the element value for BSB is nil in the container VendorInfo.
  func (s *VendorInfo) BSB_IsNil() bool {
    return s.vendorinfo.BSB == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) ContactInfo() *ContactInfoType {
    if s.vendorinfo.ContactInfo == nil {
     if v, ok:= ContactInfoTypePointer(ContactInfoType{}); ok {
      s.vendorinfo.ContactInfo = v
      }
      }
      return s.vendorinfo.ContactInfo
    }
// Returns whether the element value for ContactInfo is nil in the container VendorInfo.
  func (s *VendorInfo) ContactInfo_IsNil() bool {
    return s.vendorinfo.ContactInfo == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) CustomerId() *String {
    if s.vendorinfo.CustomerId == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.CustomerId = ((*String)(v))
      }
      }
      return s.vendorinfo.CustomerId
    }
// Returns whether the element value for CustomerId is nil in the container VendorInfo.
  func (s *VendorInfo) CustomerId_IsNil() bool {
    return s.vendorinfo.CustomerId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) LocalCodeList() *LocalCodeListType {
    if s.vendorinfo.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.vendorinfo.LocalCodeList = v
      }
      }
      return s.vendorinfo.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container VendorInfo.
  func (s *VendorInfo) LocalCodeList_IsNil() bool {
    return s.vendorinfo.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) LocalId() *LocalIdType {
    if s.vendorinfo.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.vendorinfo.LocalId
    }
// Returns whether the element value for LocalId is nil in the container VendorInfo.
  func (s *VendorInfo) LocalId_IsNil() bool {
    return s.vendorinfo.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) Name() *String {
    if s.vendorinfo.Name == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.Name = ((*String)(v))
      }
      }
      return s.vendorinfo.Name
    }
// Returns whether the element value for Name is nil in the container VendorInfo.
  func (s *VendorInfo) Name_IsNil() bool {
    return s.vendorinfo.Name == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) PaymentTerms() *String {
    if s.vendorinfo.PaymentTerms == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.PaymentTerms = ((*String)(v))
      }
      }
      return s.vendorinfo.PaymentTerms
    }
// Returns whether the element value for PaymentTerms is nil in the container VendorInfo.
  func (s *VendorInfo) PaymentTerms_IsNil() bool {
    return s.vendorinfo.PaymentTerms == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) RefId() *RefIdType {
    if s.vendorinfo.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.RefId = ((*RefIdType)(v))
      }
      }
      return s.vendorinfo.RefId
    }
// Returns whether the element value for RefId is nil in the container VendorInfo.
  func (s *VendorInfo) RefId_IsNil() bool {
    return s.vendorinfo.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) RegisteredForGST() *AUCodeSetsYesOrNoCategoryType {
    if s.vendorinfo.RegisteredForGST == nil {
    if v, ok:= StringPointer(""); ok {
      s.vendorinfo.RegisteredForGST = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.vendorinfo.RegisteredForGST
    }
// Returns whether the element value for RegisteredForGST is nil in the container VendorInfo.
  func (s *VendorInfo) RegisteredForGST_IsNil() bool {
    return s.vendorinfo.RegisteredForGST == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.vendorinfo.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.vendorinfo.SIF_ExtendedElements = v
      }
      }
      return s.vendorinfo.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container VendorInfo.
  func (s *VendorInfo) SIF_ExtendedElements_IsNil() bool {
    return s.vendorinfo.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VendorInfo) SIF_Metadata() *SIF_MetadataType {
    if s.vendorinfo.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.vendorinfo.SIF_Metadata = v
      }
      }
      return s.vendorinfo.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container VendorInfo.
  func (s *VendorInfo) SIF_Metadata_IsNil() bool {
    return s.vendorinfo.SIF_Metadata == nil
    }

// Set the value of a property to nil
func (n *VisaSubClassType) Unset(key string) *VisaSubClassType {
        switch key {
  case "ATEExpiryDate":
   n.visasubclasstype.ATEExpiryDate = nil
  case "ATEStartDate":
   n.visasubclasstype.ATEStartDate = nil
  case "Code":
   n.visasubclasstype.Code = nil
  case "VisaExpiryDate":
   n.visasubclasstype.VisaExpiryDate = nil
  case "VisaStatisticalCode":
   n.visasubclasstype.VisaStatisticalCode = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "VisaSubClassType")
        }
        return n
}

// Set a sequence of properties
func (n *VisaSubClassType) SetProperties(props ...Prop) *VisaSubClassType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *VisaSubClassType) SetProperty(key string, value interface{}) *VisaSubClassType {
        if n == nil {
                n, _ = VisaSubClassTypePointer(VisaSubClassType{})
        }
        switch key {
    case "ATEExpiryDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.visasubclasstype.ATEExpiryDate = ((*String)(v))
      }
    case "ATEStartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.visasubclasstype.ATEStartDate = ((*String)(v))
      }
    case "Code":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.visasubclasstype.Code = ((*VisaSubClassCodeType)(v))
      }
    case "VisaExpiryDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.visasubclasstype.VisaExpiryDate = ((*String)(v))
      }
    case "VisaStatisticalCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.visasubclasstype.VisaStatisticalCode = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "VisaSubClassType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VisaSubClassType) ATEExpiryDate() *String {
    if s.visasubclasstype.ATEExpiryDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.visasubclasstype.ATEExpiryDate = ((*String)(v))
      }
      }
      return s.visasubclasstype.ATEExpiryDate
    }
// Returns whether the element value for ATEExpiryDate is nil in the container VisaSubClassType.
  func (s *VisaSubClassType) ATEExpiryDate_IsNil() bool {
    return s.visasubclasstype.ATEExpiryDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VisaSubClassType) ATEStartDate() *String {
    if s.visasubclasstype.ATEStartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.visasubclasstype.ATEStartDate = ((*String)(v))
      }
      }
      return s.visasubclasstype.ATEStartDate
    }
// Returns whether the element value for ATEStartDate is nil in the container VisaSubClassType.
  func (s *VisaSubClassType) ATEStartDate_IsNil() bool {
    return s.visasubclasstype.ATEStartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VisaSubClassType) Code() *VisaSubClassCodeType {
    if s.visasubclasstype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.visasubclasstype.Code = ((*VisaSubClassCodeType)(v))
      }
      }
      return s.visasubclasstype.Code
    }
// Returns whether the element value for Code is nil in the container VisaSubClassType.
  func (s *VisaSubClassType) Code_IsNil() bool {
    return s.visasubclasstype.Code == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VisaSubClassType) VisaExpiryDate() *String {
    if s.visasubclasstype.VisaExpiryDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.visasubclasstype.VisaExpiryDate = ((*String)(v))
      }
      }
      return s.visasubclasstype.VisaExpiryDate
    }
// Returns whether the element value for VisaExpiryDate is nil in the container VisaSubClassType.
  func (s *VisaSubClassType) VisaExpiryDate_IsNil() bool {
    return s.visasubclasstype.VisaExpiryDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *VisaSubClassType) VisaStatisticalCode() *String {
    if s.visasubclasstype.VisaStatisticalCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.visasubclasstype.VisaStatisticalCode = ((*String)(v))
      }
      }
      return s.visasubclasstype.VisaStatisticalCode
    }
// Returns whether the element value for VisaStatisticalCode is nil in the container VisaSubClassType.
  func (s *VisaSubClassType) VisaStatisticalCode_IsNil() bool {
    return s.visasubclasstype.VisaStatisticalCode == nil
    }

// Set the value of a property to nil
func (n *WellbeingAlert) Unset(key string) *WellbeingAlert {
        switch key {
  case "AlertAudience":
   n.wellbeingalert.AlertAudience = nil
  case "AlertKeyContact":
   n.wellbeingalert.AlertKeyContact = nil
  case "AlertSeverity":
   n.wellbeingalert.AlertSeverity = nil
  case "Date":
   n.wellbeingalert.Date = nil
  case "EnrolmentRestricted":
   n.wellbeingalert.EnrolmentRestricted = nil
  case "LocalCodeList":
   n.wellbeingalert.LocalCodeList = nil
  case "LocalId":
   n.wellbeingalert.LocalId = nil
  case "RefId":
   n.wellbeingalert.RefId = nil
  case "SIF_ExtendedElements":
   n.wellbeingalert.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.wellbeingalert.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.wellbeingalert.SchoolInfoRefId = nil
  case "StudentPersonalRefId":
   n.wellbeingalert.StudentPersonalRefId = nil
  case "WellbeingAlertCategory":
   n.wellbeingalert.WellbeingAlertCategory = nil
  case "WellbeingAlertDescription":
   n.wellbeingalert.WellbeingAlertDescription = nil
  case "WellbeingAlertEndDate":
   n.wellbeingalert.WellbeingAlertEndDate = nil
  case "WellbeingAlertStartDate":
   n.wellbeingalert.WellbeingAlertStartDate = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingAlert")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingAlert) SetProperties(props ...Prop) *WellbeingAlert {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingAlert) SetProperty(key string, value interface{}) *WellbeingAlert {
        if n == nil {
                n, _ = WellbeingAlertPointer(WellbeingAlert{})
        }
        switch key {
    case "AlertAudience":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.AlertAudience = ((*String)(v))
      }
    case "AlertKeyContact":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.AlertKeyContact = ((*String)(v))
      }
    case "AlertSeverity":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.AlertSeverity = ((*String)(v))
      }
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.Date = ((*String)(v))
      }
    case "EnrolmentRestricted":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.EnrolmentRestricted = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.wellbeingalert.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.LocalId = ((*LocalIdType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.wellbeingalert.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.wellbeingalert.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.SchoolInfoRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.StudentPersonalRefId = ((*String)(v))
      }
    case "WellbeingAlertCategory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingAlertCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingAlertCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.WellbeingAlertCategory = ((*AUCodeSetsWellbeingAlertCategoryType)(v))
      }
    case "WellbeingAlertDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.WellbeingAlertDescription = ((*String)(v))
      }
    case "WellbeingAlertEndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.WellbeingAlertEndDate = ((*String)(v))
      }
    case "WellbeingAlertStartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingalert.WellbeingAlertStartDate = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingAlert")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) AlertAudience() *String {
    if s.wellbeingalert.AlertAudience == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.AlertAudience = ((*String)(v))
      }
      }
      return s.wellbeingalert.AlertAudience
    }
// Returns whether the element value for AlertAudience is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) AlertAudience_IsNil() bool {
    return s.wellbeingalert.AlertAudience == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) AlertKeyContact() *String {
    if s.wellbeingalert.AlertKeyContact == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.AlertKeyContact = ((*String)(v))
      }
      }
      return s.wellbeingalert.AlertKeyContact
    }
// Returns whether the element value for AlertKeyContact is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) AlertKeyContact_IsNil() bool {
    return s.wellbeingalert.AlertKeyContact == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) AlertSeverity() *String {
    if s.wellbeingalert.AlertSeverity == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.AlertSeverity = ((*String)(v))
      }
      }
      return s.wellbeingalert.AlertSeverity
    }
// Returns whether the element value for AlertSeverity is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) AlertSeverity_IsNil() bool {
    return s.wellbeingalert.AlertSeverity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) Date() *String {
    if s.wellbeingalert.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.Date = ((*String)(v))
      }
      }
      return s.wellbeingalert.Date
    }
// Returns whether the element value for Date is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) Date_IsNil() bool {
    return s.wellbeingalert.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) EnrolmentRestricted() *AUCodeSetsYesOrNoCategoryType {
    if s.wellbeingalert.EnrolmentRestricted == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.EnrolmentRestricted = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.wellbeingalert.EnrolmentRestricted
    }
// Returns whether the element value for EnrolmentRestricted is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) EnrolmentRestricted_IsNil() bool {
    return s.wellbeingalert.EnrolmentRestricted == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) LocalCodeList() *LocalCodeListType {
    if s.wellbeingalert.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.wellbeingalert.LocalCodeList = v
      }
      }
      return s.wellbeingalert.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) LocalCodeList_IsNil() bool {
    return s.wellbeingalert.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) LocalId() *LocalIdType {
    if s.wellbeingalert.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingalert.LocalId
    }
// Returns whether the element value for LocalId is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) LocalId_IsNil() bool {
    return s.wellbeingalert.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) RefId() *RefIdType {
    if s.wellbeingalert.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.RefId = ((*RefIdType)(v))
      }
      }
      return s.wellbeingalert.RefId
    }
// Returns whether the element value for RefId is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) RefId_IsNil() bool {
    return s.wellbeingalert.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.wellbeingalert.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.wellbeingalert.SIF_ExtendedElements = v
      }
      }
      return s.wellbeingalert.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) SIF_ExtendedElements_IsNil() bool {
    return s.wellbeingalert.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) SIF_Metadata() *SIF_MetadataType {
    if s.wellbeingalert.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.wellbeingalert.SIF_Metadata = v
      }
      }
      return s.wellbeingalert.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) SIF_Metadata_IsNil() bool {
    return s.wellbeingalert.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) SchoolInfoRefId() *String {
    if s.wellbeingalert.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.wellbeingalert.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) SchoolInfoRefId_IsNil() bool {
    return s.wellbeingalert.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) StudentPersonalRefId() *String {
    if s.wellbeingalert.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.wellbeingalert.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) StudentPersonalRefId_IsNil() bool {
    return s.wellbeingalert.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) WellbeingAlertCategory() *AUCodeSetsWellbeingAlertCategoryType {
    if s.wellbeingalert.WellbeingAlertCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.WellbeingAlertCategory = ((*AUCodeSetsWellbeingAlertCategoryType)(v))
      }
      }
      return s.wellbeingalert.WellbeingAlertCategory
    }
// Returns whether the element value for WellbeingAlertCategory is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) WellbeingAlertCategory_IsNil() bool {
    return s.wellbeingalert.WellbeingAlertCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) WellbeingAlertDescription() *String {
    if s.wellbeingalert.WellbeingAlertDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.WellbeingAlertDescription = ((*String)(v))
      }
      }
      return s.wellbeingalert.WellbeingAlertDescription
    }
// Returns whether the element value for WellbeingAlertDescription is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) WellbeingAlertDescription_IsNil() bool {
    return s.wellbeingalert.WellbeingAlertDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) WellbeingAlertEndDate() *String {
    if s.wellbeingalert.WellbeingAlertEndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.WellbeingAlertEndDate = ((*String)(v))
      }
      }
      return s.wellbeingalert.WellbeingAlertEndDate
    }
// Returns whether the element value for WellbeingAlertEndDate is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) WellbeingAlertEndDate_IsNil() bool {
    return s.wellbeingalert.WellbeingAlertEndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAlert) WellbeingAlertStartDate() *String {
    if s.wellbeingalert.WellbeingAlertStartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingalert.WellbeingAlertStartDate = ((*String)(v))
      }
      }
      return s.wellbeingalert.WellbeingAlertStartDate
    }
// Returns whether the element value for WellbeingAlertStartDate is nil in the container WellbeingAlert.
  func (s *WellbeingAlert) WellbeingAlertStartDate_IsNil() bool {
    return s.wellbeingalert.WellbeingAlertStartDate == nil
    }

// Set the value of a property to nil
func (n *WellbeingAppeal) Unset(key string) *WellbeingAppeal {
        switch key {
  case "AppealNotes":
   n.wellbeingappeal.AppealNotes = nil
  case "AppealOutcome":
   n.wellbeingappeal.AppealOutcome = nil
  case "AppealStatusCode":
   n.wellbeingappeal.AppealStatusCode = nil
  case "Date":
   n.wellbeingappeal.Date = nil
  case "DocumentList":
   n.wellbeingappeal.DocumentList = nil
  case "LocalAppealId":
   n.wellbeingappeal.LocalAppealId = nil
  case "LocalCodeList":
   n.wellbeingappeal.LocalCodeList = nil
  case "LocalId":
   n.wellbeingappeal.LocalId = nil
  case "RefId":
   n.wellbeingappeal.RefId = nil
  case "SIF_ExtendedElements":
   n.wellbeingappeal.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.wellbeingappeal.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.wellbeingappeal.SchoolInfoRefId = nil
  case "StudentPersonalRefId":
   n.wellbeingappeal.StudentPersonalRefId = nil
  case "WellbeingResponseRefId":
   n.wellbeingappeal.WellbeingResponseRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingAppeal")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingAppeal) SetProperties(props ...Prop) *WellbeingAppeal {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingAppeal) SetProperty(key string, value interface{}) *WellbeingAppeal {
        if n == nil {
                n, _ = WellbeingAppealPointer(WellbeingAppeal{})
        }
        switch key {
    case "AppealNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.AppealNotes = ((*String)(v))
      }
    case "AppealOutcome":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.AppealOutcome = ((*String)(v))
      }
    case "AppealStatusCode":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingAppealStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingAppealStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.AppealStatusCode = ((*AUCodeSetsWellbeingAppealStatusType)(v))
      }
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.Date = ((*String)(v))
      }
    case "DocumentList":
    if v, ok:= WellbeingDocumentListTypePointer(value); ok {
      n.wellbeingappeal.DocumentList = v
      }
    case "LocalAppealId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.LocalAppealId = ((*LocalIdType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.wellbeingappeal.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.LocalId = ((*LocalIdType)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.wellbeingappeal.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.wellbeingappeal.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.SchoolInfoRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.StudentPersonalRefId = ((*String)(v))
      }
    case "WellbeingResponseRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingappeal.WellbeingResponseRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingAppeal")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) AppealNotes() *String {
    if s.wellbeingappeal.AppealNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.AppealNotes = ((*String)(v))
      }
      }
      return s.wellbeingappeal.AppealNotes
    }
// Returns whether the element value for AppealNotes is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) AppealNotes_IsNil() bool {
    return s.wellbeingappeal.AppealNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) AppealOutcome() *String {
    if s.wellbeingappeal.AppealOutcome == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.AppealOutcome = ((*String)(v))
      }
      }
      return s.wellbeingappeal.AppealOutcome
    }
// Returns whether the element value for AppealOutcome is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) AppealOutcome_IsNil() bool {
    return s.wellbeingappeal.AppealOutcome == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) AppealStatusCode() *AUCodeSetsWellbeingAppealStatusType {
    if s.wellbeingappeal.AppealStatusCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.AppealStatusCode = ((*AUCodeSetsWellbeingAppealStatusType)(v))
      }
      }
      return s.wellbeingappeal.AppealStatusCode
    }
// Returns whether the element value for AppealStatusCode is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) AppealStatusCode_IsNil() bool {
    return s.wellbeingappeal.AppealStatusCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) Date() *String {
    if s.wellbeingappeal.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.Date = ((*String)(v))
      }
      }
      return s.wellbeingappeal.Date
    }
// Returns whether the element value for Date is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) Date_IsNil() bool {
    return s.wellbeingappeal.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) DocumentList() *WellbeingDocumentListType {
    if s.wellbeingappeal.DocumentList == nil {
     if v, ok:= WellbeingDocumentListTypePointer(WellbeingDocumentListType{}); ok {
      s.wellbeingappeal.DocumentList = v
      }
      }
      return s.wellbeingappeal.DocumentList
    }
// Returns whether the element value for DocumentList is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) DocumentList_IsNil() bool {
    return s.wellbeingappeal.DocumentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) LocalAppealId() *LocalIdType {
    if s.wellbeingappeal.LocalAppealId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.LocalAppealId = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingappeal.LocalAppealId
    }
// Returns whether the element value for LocalAppealId is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) LocalAppealId_IsNil() bool {
    return s.wellbeingappeal.LocalAppealId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) LocalCodeList() *LocalCodeListType {
    if s.wellbeingappeal.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.wellbeingappeal.LocalCodeList = v
      }
      }
      return s.wellbeingappeal.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) LocalCodeList_IsNil() bool {
    return s.wellbeingappeal.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) LocalId() *LocalIdType {
    if s.wellbeingappeal.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingappeal.LocalId
    }
// Returns whether the element value for LocalId is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) LocalId_IsNil() bool {
    return s.wellbeingappeal.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) RefId() *RefIdType {
    if s.wellbeingappeal.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.RefId = ((*RefIdType)(v))
      }
      }
      return s.wellbeingappeal.RefId
    }
// Returns whether the element value for RefId is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) RefId_IsNil() bool {
    return s.wellbeingappeal.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.wellbeingappeal.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.wellbeingappeal.SIF_ExtendedElements = v
      }
      }
      return s.wellbeingappeal.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) SIF_ExtendedElements_IsNil() bool {
    return s.wellbeingappeal.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) SIF_Metadata() *SIF_MetadataType {
    if s.wellbeingappeal.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.wellbeingappeal.SIF_Metadata = v
      }
      }
      return s.wellbeingappeal.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) SIF_Metadata_IsNil() bool {
    return s.wellbeingappeal.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) SchoolInfoRefId() *String {
    if s.wellbeingappeal.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.wellbeingappeal.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) SchoolInfoRefId_IsNil() bool {
    return s.wellbeingappeal.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) StudentPersonalRefId() *String {
    if s.wellbeingappeal.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.wellbeingappeal.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) StudentPersonalRefId_IsNil() bool {
    return s.wellbeingappeal.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingAppeal) WellbeingResponseRefId() *String {
    if s.wellbeingappeal.WellbeingResponseRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingappeal.WellbeingResponseRefId = ((*String)(v))
      }
      }
      return s.wellbeingappeal.WellbeingResponseRefId
    }
// Returns whether the element value for WellbeingResponseRefId is nil in the container WellbeingAppeal.
  func (s *WellbeingAppeal) WellbeingResponseRefId_IsNil() bool {
    return s.wellbeingappeal.WellbeingResponseRefId == nil
    }

// Set the value of a property to nil
func (n *WellbeingCharacteristic) Unset(key string) *WellbeingCharacteristic {
        switch key {
  case "Alert":
   n.wellbeingcharacteristic.Alert = nil
  case "CharacteristicSeverity":
   n.wellbeingcharacteristic.CharacteristicSeverity = nil
  case "ConfidentialFlag":
   n.wellbeingcharacteristic.ConfidentialFlag = nil
  case "DailyManagement":
   n.wellbeingcharacteristic.DailyManagement = nil
  case "DocumentList":
   n.wellbeingcharacteristic.DocumentList = nil
  case "EmergencyManagement":
   n.wellbeingcharacteristic.EmergencyManagement = nil
  case "EmergencyResponsePlan":
   n.wellbeingcharacteristic.EmergencyResponsePlan = nil
  case "LocalCharacteristicCode":
   n.wellbeingcharacteristic.LocalCharacteristicCode = nil
  case "LocalCodeList":
   n.wellbeingcharacteristic.LocalCodeList = nil
  case "LocalId":
   n.wellbeingcharacteristic.LocalId = nil
  case "MedicationList":
   n.wellbeingcharacteristic.MedicationList = nil
  case "PreferredHospital":
   n.wellbeingcharacteristic.PreferredHospital = nil
  case "RefId":
   n.wellbeingcharacteristic.RefId = nil
  case "SIF_ExtendedElements":
   n.wellbeingcharacteristic.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.wellbeingcharacteristic.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.wellbeingcharacteristic.SchoolInfoRefId = nil
  case "StudentPersonalRefId":
   n.wellbeingcharacteristic.StudentPersonalRefId = nil
  case "SymptomList":
   n.wellbeingcharacteristic.SymptomList = nil
  case "Trigger":
   n.wellbeingcharacteristic.Trigger = nil
  case "WellbeingCharacteristicCategory":
   n.wellbeingcharacteristic.WellbeingCharacteristicCategory = nil
  case "WellbeingCharacteristicClassification":
   n.wellbeingcharacteristic.WellbeingCharacteristicClassification = nil
  case "WellbeingCharacteristicEndDate":
   n.wellbeingcharacteristic.WellbeingCharacteristicEndDate = nil
  case "WellbeingCharacteristicNotes":
   n.wellbeingcharacteristic.WellbeingCharacteristicNotes = nil
  case "WellbeingCharacteristicReviewDate":
   n.wellbeingcharacteristic.WellbeingCharacteristicReviewDate = nil
  case "WellbeingCharacteristicStartDate":
   n.wellbeingcharacteristic.WellbeingCharacteristicStartDate = nil
  case "WellbeingCharacteristicSubCategory":
   n.wellbeingcharacteristic.WellbeingCharacteristicSubCategory = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingCharacteristic")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingCharacteristic) SetProperties(props ...Prop) *WellbeingCharacteristic {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingCharacteristic) SetProperty(key string, value interface{}) *WellbeingCharacteristic {
        if n == nil {
                n, _ = WellbeingCharacteristicPointer(WellbeingCharacteristic{})
        }
        switch key {
    case "Alert":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.Alert = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "CharacteristicSeverity":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.CharacteristicSeverity = ((*String)(v))
      }
    case "ConfidentialFlag":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.ConfidentialFlag = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "DailyManagement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.DailyManagement = ((*String)(v))
      }
    case "DocumentList":
    if v, ok:= WellbeingDocumentListTypePointer(value); ok {
      n.wellbeingcharacteristic.DocumentList = v
      }
    case "EmergencyManagement":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.EmergencyManagement = ((*String)(v))
      }
    case "EmergencyResponsePlan":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.EmergencyResponsePlan = ((*String)(v))
      }
    case "LocalCharacteristicCode":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.LocalCharacteristicCode = ((*LocalIdType)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.wellbeingcharacteristic.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.LocalId = ((*LocalIdType)(v))
      }
    case "MedicationList":
    if v, ok:= MedicationListTypePointer(value); ok {
      n.wellbeingcharacteristic.MedicationList = v
      }
    case "PreferredHospital":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.PreferredHospital = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.wellbeingcharacteristic.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.wellbeingcharacteristic.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.SchoolInfoRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.StudentPersonalRefId = ((*String)(v))
      }
    case "SymptomList":
    if v, ok:= SymptomListTypePointer(value); ok {
      n.wellbeingcharacteristic.SymptomList = v
      }
    case "Trigger":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.Trigger = ((*String)(v))
      }
    case "WellbeingCharacteristicCategory":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.WellbeingCharacteristicCategory = ((*String)(v))
      }
    case "WellbeingCharacteristicClassification":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingCharacteristicClassificationType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingCharacteristicClassificationType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.WellbeingCharacteristicClassification = ((*AUCodeSetsWellbeingCharacteristicClassificationType)(v))
      }
    case "WellbeingCharacteristicEndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.WellbeingCharacteristicEndDate = ((*String)(v))
      }
    case "WellbeingCharacteristicNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.WellbeingCharacteristicNotes = ((*String)(v))
      }
    case "WellbeingCharacteristicReviewDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.WellbeingCharacteristicReviewDate = ((*String)(v))
      }
    case "WellbeingCharacteristicStartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.WellbeingCharacteristicStartDate = ((*String)(v))
      }
    case "WellbeingCharacteristicSubCategory":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingcharacteristic.WellbeingCharacteristicSubCategory = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingCharacteristic")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) Alert() *AUCodeSetsYesOrNoCategoryType {
    if s.wellbeingcharacteristic.Alert == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.Alert = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.wellbeingcharacteristic.Alert
    }
// Returns whether the element value for Alert is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) Alert_IsNil() bool {
    return s.wellbeingcharacteristic.Alert == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) CharacteristicSeverity() *String {
    if s.wellbeingcharacteristic.CharacteristicSeverity == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.CharacteristicSeverity = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.CharacteristicSeverity
    }
// Returns whether the element value for CharacteristicSeverity is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) CharacteristicSeverity_IsNil() bool {
    return s.wellbeingcharacteristic.CharacteristicSeverity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) ConfidentialFlag() *AUCodeSetsYesOrNoCategoryType {
    if s.wellbeingcharacteristic.ConfidentialFlag == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.ConfidentialFlag = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.wellbeingcharacteristic.ConfidentialFlag
    }
// Returns whether the element value for ConfidentialFlag is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) ConfidentialFlag_IsNil() bool {
    return s.wellbeingcharacteristic.ConfidentialFlag == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) DailyManagement() *String {
    if s.wellbeingcharacteristic.DailyManagement == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.DailyManagement = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.DailyManagement
    }
// Returns whether the element value for DailyManagement is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) DailyManagement_IsNil() bool {
    return s.wellbeingcharacteristic.DailyManagement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) DocumentList() *WellbeingDocumentListType {
    if s.wellbeingcharacteristic.DocumentList == nil {
     if v, ok:= WellbeingDocumentListTypePointer(WellbeingDocumentListType{}); ok {
      s.wellbeingcharacteristic.DocumentList = v
      }
      }
      return s.wellbeingcharacteristic.DocumentList
    }
// Returns whether the element value for DocumentList is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) DocumentList_IsNil() bool {
    return s.wellbeingcharacteristic.DocumentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) EmergencyManagement() *String {
    if s.wellbeingcharacteristic.EmergencyManagement == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.EmergencyManagement = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.EmergencyManagement
    }
// Returns whether the element value for EmergencyManagement is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) EmergencyManagement_IsNil() bool {
    return s.wellbeingcharacteristic.EmergencyManagement == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) EmergencyResponsePlan() *String {
    if s.wellbeingcharacteristic.EmergencyResponsePlan == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.EmergencyResponsePlan = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.EmergencyResponsePlan
    }
// Returns whether the element value for EmergencyResponsePlan is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) EmergencyResponsePlan_IsNil() bool {
    return s.wellbeingcharacteristic.EmergencyResponsePlan == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) LocalCharacteristicCode() *LocalIdType {
    if s.wellbeingcharacteristic.LocalCharacteristicCode == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.LocalCharacteristicCode = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingcharacteristic.LocalCharacteristicCode
    }
// Returns whether the element value for LocalCharacteristicCode is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) LocalCharacteristicCode_IsNil() bool {
    return s.wellbeingcharacteristic.LocalCharacteristicCode == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) LocalCodeList() *LocalCodeListType {
    if s.wellbeingcharacteristic.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.wellbeingcharacteristic.LocalCodeList = v
      }
      }
      return s.wellbeingcharacteristic.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) LocalCodeList_IsNil() bool {
    return s.wellbeingcharacteristic.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) LocalId() *LocalIdType {
    if s.wellbeingcharacteristic.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingcharacteristic.LocalId
    }
// Returns whether the element value for LocalId is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) LocalId_IsNil() bool {
    return s.wellbeingcharacteristic.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) MedicationList() *MedicationListType {
    if s.wellbeingcharacteristic.MedicationList == nil {
     if v, ok:= MedicationListTypePointer(MedicationListType{}); ok {
      s.wellbeingcharacteristic.MedicationList = v
      }
      }
      return s.wellbeingcharacteristic.MedicationList
    }
// Returns whether the element value for MedicationList is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) MedicationList_IsNil() bool {
    return s.wellbeingcharacteristic.MedicationList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) PreferredHospital() *String {
    if s.wellbeingcharacteristic.PreferredHospital == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.PreferredHospital = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.PreferredHospital
    }
// Returns whether the element value for PreferredHospital is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) PreferredHospital_IsNil() bool {
    return s.wellbeingcharacteristic.PreferredHospital == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) RefId() *RefIdType {
    if s.wellbeingcharacteristic.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.RefId = ((*RefIdType)(v))
      }
      }
      return s.wellbeingcharacteristic.RefId
    }
// Returns whether the element value for RefId is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) RefId_IsNil() bool {
    return s.wellbeingcharacteristic.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.wellbeingcharacteristic.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.wellbeingcharacteristic.SIF_ExtendedElements = v
      }
      }
      return s.wellbeingcharacteristic.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) SIF_ExtendedElements_IsNil() bool {
    return s.wellbeingcharacteristic.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) SIF_Metadata() *SIF_MetadataType {
    if s.wellbeingcharacteristic.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.wellbeingcharacteristic.SIF_Metadata = v
      }
      }
      return s.wellbeingcharacteristic.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) SIF_Metadata_IsNil() bool {
    return s.wellbeingcharacteristic.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) SchoolInfoRefId() *String {
    if s.wellbeingcharacteristic.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) SchoolInfoRefId_IsNil() bool {
    return s.wellbeingcharacteristic.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) StudentPersonalRefId() *String {
    if s.wellbeingcharacteristic.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) StudentPersonalRefId_IsNil() bool {
    return s.wellbeingcharacteristic.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) SymptomList() *SymptomListType {
    if s.wellbeingcharacteristic.SymptomList == nil {
     if v, ok:= SymptomListTypePointer(SymptomListType{}); ok {
      s.wellbeingcharacteristic.SymptomList = v
      }
      }
      return s.wellbeingcharacteristic.SymptomList
    }
// Returns whether the element value for SymptomList is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) SymptomList_IsNil() bool {
    return s.wellbeingcharacteristic.SymptomList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) Trigger() *String {
    if s.wellbeingcharacteristic.Trigger == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.Trigger = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.Trigger
    }
// Returns whether the element value for Trigger is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) Trigger_IsNil() bool {
    return s.wellbeingcharacteristic.Trigger == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) WellbeingCharacteristicCategory() *String {
    if s.wellbeingcharacteristic.WellbeingCharacteristicCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.WellbeingCharacteristicCategory = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.WellbeingCharacteristicCategory
    }
// Returns whether the element value for WellbeingCharacteristicCategory is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) WellbeingCharacteristicCategory_IsNil() bool {
    return s.wellbeingcharacteristic.WellbeingCharacteristicCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) WellbeingCharacteristicClassification() *AUCodeSetsWellbeingCharacteristicClassificationType {
    if s.wellbeingcharacteristic.WellbeingCharacteristicClassification == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.WellbeingCharacteristicClassification = ((*AUCodeSetsWellbeingCharacteristicClassificationType)(v))
      }
      }
      return s.wellbeingcharacteristic.WellbeingCharacteristicClassification
    }
// Returns whether the element value for WellbeingCharacteristicClassification is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) WellbeingCharacteristicClassification_IsNil() bool {
    return s.wellbeingcharacteristic.WellbeingCharacteristicClassification == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) WellbeingCharacteristicEndDate() *String {
    if s.wellbeingcharacteristic.WellbeingCharacteristicEndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.WellbeingCharacteristicEndDate = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.WellbeingCharacteristicEndDate
    }
// Returns whether the element value for WellbeingCharacteristicEndDate is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) WellbeingCharacteristicEndDate_IsNil() bool {
    return s.wellbeingcharacteristic.WellbeingCharacteristicEndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) WellbeingCharacteristicNotes() *String {
    if s.wellbeingcharacteristic.WellbeingCharacteristicNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.WellbeingCharacteristicNotes = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.WellbeingCharacteristicNotes
    }
// Returns whether the element value for WellbeingCharacteristicNotes is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) WellbeingCharacteristicNotes_IsNil() bool {
    return s.wellbeingcharacteristic.WellbeingCharacteristicNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) WellbeingCharacteristicReviewDate() *String {
    if s.wellbeingcharacteristic.WellbeingCharacteristicReviewDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.WellbeingCharacteristicReviewDate = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.WellbeingCharacteristicReviewDate
    }
// Returns whether the element value for WellbeingCharacteristicReviewDate is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) WellbeingCharacteristicReviewDate_IsNil() bool {
    return s.wellbeingcharacteristic.WellbeingCharacteristicReviewDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) WellbeingCharacteristicStartDate() *String {
    if s.wellbeingcharacteristic.WellbeingCharacteristicStartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.WellbeingCharacteristicStartDate = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.WellbeingCharacteristicStartDate
    }
// Returns whether the element value for WellbeingCharacteristicStartDate is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) WellbeingCharacteristicStartDate_IsNil() bool {
    return s.wellbeingcharacteristic.WellbeingCharacteristicStartDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingCharacteristic) WellbeingCharacteristicSubCategory() *String {
    if s.wellbeingcharacteristic.WellbeingCharacteristicSubCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingcharacteristic.WellbeingCharacteristicSubCategory = ((*String)(v))
      }
      }
      return s.wellbeingcharacteristic.WellbeingCharacteristicSubCategory
    }
// Returns whether the element value for WellbeingCharacteristicSubCategory is nil in the container WellbeingCharacteristic.
  func (s *WellbeingCharacteristic) WellbeingCharacteristicSubCategory_IsNil() bool {
    return s.wellbeingcharacteristic.WellbeingCharacteristicSubCategory == nil
    }

// Set the value of a property to nil
func (n *WellbeingDocumentType) Unset(key string) *WellbeingDocumentType {
        switch key {
  case "DocumentDescription":
   n.wellbeingdocumenttype.DocumentDescription = nil
  case "DocumentReviewDate":
   n.wellbeingdocumenttype.DocumentReviewDate = nil
  case "DocumentType":
   n.wellbeingdocumenttype.DocumentType = nil
  case "Location":
   n.wellbeingdocumenttype.Location = nil
  case "Sensitivity":
   n.wellbeingdocumenttype.Sensitivity = nil
  case "URL":
   n.wellbeingdocumenttype.URL = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingDocumentType")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingDocumentType) SetProperties(props ...Prop) *WellbeingDocumentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingDocumentType) SetProperty(key string, value interface{}) *WellbeingDocumentType {
        if n == nil {
                n, _ = WellbeingDocumentTypePointer(WellbeingDocumentType{})
        }
        switch key {
    case "DocumentDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingdocumenttype.DocumentDescription = ((*String)(v))
      }
    case "DocumentReviewDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingdocumenttype.DocumentReviewDate = ((*String)(v))
      }
    case "DocumentType":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingdocumenttype.DocumentType = ((*String)(v))
      }
    case "Location":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingdocumenttype.Location = ((*String)(v))
      }
    case "Sensitivity":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingdocumenttype.Sensitivity = ((*String)(v))
      }
    case "URL":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingdocumenttype.URL = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingDocumentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingDocumentType) DocumentDescription() *String {
    if s.wellbeingdocumenttype.DocumentDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingdocumenttype.DocumentDescription = ((*String)(v))
      }
      }
      return s.wellbeingdocumenttype.DocumentDescription
    }
// Returns whether the element value for DocumentDescription is nil in the container WellbeingDocumentType.
  func (s *WellbeingDocumentType) DocumentDescription_IsNil() bool {
    return s.wellbeingdocumenttype.DocumentDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingDocumentType) DocumentReviewDate() *String {
    if s.wellbeingdocumenttype.DocumentReviewDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingdocumenttype.DocumentReviewDate = ((*String)(v))
      }
      }
      return s.wellbeingdocumenttype.DocumentReviewDate
    }
// Returns whether the element value for DocumentReviewDate is nil in the container WellbeingDocumentType.
  func (s *WellbeingDocumentType) DocumentReviewDate_IsNil() bool {
    return s.wellbeingdocumenttype.DocumentReviewDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingDocumentType) DocumentType() *String {
    if s.wellbeingdocumenttype.DocumentType == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingdocumenttype.DocumentType = ((*String)(v))
      }
      }
      return s.wellbeingdocumenttype.DocumentType
    }
// Returns whether the element value for DocumentType is nil in the container WellbeingDocumentType.
  func (s *WellbeingDocumentType) DocumentType_IsNil() bool {
    return s.wellbeingdocumenttype.DocumentType == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingDocumentType) Location() *String {
    if s.wellbeingdocumenttype.Location == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingdocumenttype.Location = ((*String)(v))
      }
      }
      return s.wellbeingdocumenttype.Location
    }
// Returns whether the element value for Location is nil in the container WellbeingDocumentType.
  func (s *WellbeingDocumentType) Location_IsNil() bool {
    return s.wellbeingdocumenttype.Location == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingDocumentType) Sensitivity() *String {
    if s.wellbeingdocumenttype.Sensitivity == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingdocumenttype.Sensitivity = ((*String)(v))
      }
      }
      return s.wellbeingdocumenttype.Sensitivity
    }
// Returns whether the element value for Sensitivity is nil in the container WellbeingDocumentType.
  func (s *WellbeingDocumentType) Sensitivity_IsNil() bool {
    return s.wellbeingdocumenttype.Sensitivity == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingDocumentType) URL() *String {
    if s.wellbeingdocumenttype.URL == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingdocumenttype.URL = ((*String)(v))
      }
      }
      return s.wellbeingdocumenttype.URL
    }
// Returns whether the element value for URL is nil in the container WellbeingDocumentType.
  func (s *WellbeingDocumentType) URL_IsNil() bool {
    return s.wellbeingdocumenttype.URL == nil
    }

// Set the value of a property to nil
func (n *WellbeingEvent) Unset(key string) *WellbeingEvent {
        switch key {
  case "ConfidentialFlag":
   n.wellbeingevent.ConfidentialFlag = nil
  case "DocumentList":
   n.wellbeingevent.DocumentList = nil
  case "EventId":
   n.wellbeingevent.EventId = nil
  case "FollowUpActionList":
   n.wellbeingevent.FollowUpActionList = nil
  case "GroupIndicator":
   n.wellbeingevent.GroupIndicator = nil
  case "LocalCodeList":
   n.wellbeingevent.LocalCodeList = nil
  case "PersonInvolvementList":
   n.wellbeingevent.PersonInvolvementList = nil
  case "RefId":
   n.wellbeingevent.RefId = nil
  case "ReportingStaffRefId":
   n.wellbeingevent.ReportingStaffRefId = nil
  case "SIF_ExtendedElements":
   n.wellbeingevent.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.wellbeingevent.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.wellbeingevent.SchoolInfoRefId = nil
  case "Status":
   n.wellbeingevent.Status = nil
  case "StudentPersonalRefId":
   n.wellbeingevent.StudentPersonalRefId = nil
  case "WellbeingEventCategoryClass":
   n.wellbeingevent.WellbeingEventCategoryClass = nil
  case "WellbeingEventCategoryList":
   n.wellbeingevent.WellbeingEventCategoryList = nil
  case "WellbeingEventCreationTimeStamp":
   n.wellbeingevent.WellbeingEventCreationTimeStamp = nil
  case "WellbeingEventDate":
   n.wellbeingevent.WellbeingEventDate = nil
  case "WellbeingEventDescription":
   n.wellbeingevent.WellbeingEventDescription = nil
  case "WellbeingEventLocationDetails":
   n.wellbeingevent.WellbeingEventLocationDetails = nil
  case "WellbeingEventNotes":
   n.wellbeingevent.WellbeingEventNotes = nil
  case "WellbeingEventTime":
   n.wellbeingevent.WellbeingEventTime = nil
  case "WellbeingEventTimePeriod":
   n.wellbeingevent.WellbeingEventTimePeriod = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingEvent")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingEvent) SetProperties(props ...Prop) *WellbeingEvent {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingEvent) SetProperty(key string, value interface{}) *WellbeingEvent {
        if n == nil {
                n, _ = WellbeingEventPointer(WellbeingEvent{})
        }
        switch key {
    case "ConfidentialFlag":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYesOrNoCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYesOrNoCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.ConfidentialFlag = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
    case "DocumentList":
    if v, ok:= WellbeingDocumentListTypePointer(value); ok {
      n.wellbeingevent.DocumentList = v
      }
    case "EventId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.EventId = ((*LocalIdType)(v))
      }
    case "FollowUpActionList":
    if v, ok:= FollowUpActionListTypePointer(value); ok {
      n.wellbeingevent.FollowUpActionList = v
      }
    case "GroupIndicator":
    
    if v, ok:= BoolPointer(value); ok {
      n.wellbeingevent.GroupIndicator = ((*Bool)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.wellbeingevent.LocalCodeList = v
      }
    case "PersonInvolvementList":
    if v, ok:= PersonInvolvementListTypePointer(value); ok {
      n.wellbeingevent.PersonInvolvementList = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.RefId = ((*RefIdType)(v))
      }
    case "ReportingStaffRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.ReportingStaffRefId = ((*String)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.wellbeingevent.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.wellbeingevent.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.SchoolInfoRefId = ((*String)(v))
      }
    case "Status":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingStatusType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingStatusType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.StudentPersonalRefId = ((*String)(v))
      }
    case "WellbeingEventCategoryClass":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingEventCategoryClassType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingEventCategoryClassType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.WellbeingEventCategoryClass = ((*AUCodeSetsWellbeingEventCategoryClassType)(v))
      }
    case "WellbeingEventCategoryList":
    if v, ok:= WellbeingEventCategoryListTypePointer(value); ok {
      n.wellbeingevent.WellbeingEventCategoryList = v
      }
    case "WellbeingEventCreationTimeStamp":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.WellbeingEventCreationTimeStamp = ((*String)(v))
      }
    case "WellbeingEventDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.WellbeingEventDate = ((*String)(v))
      }
    case "WellbeingEventDescription":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.WellbeingEventDescription = ((*String)(v))
      }
    case "WellbeingEventLocationDetails":
    if v, ok:= WellbeingEventLocationDetailsTypePointer(value); ok {
      n.wellbeingevent.WellbeingEventLocationDetails = v
      }
    case "WellbeingEventNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.WellbeingEventNotes = ((*String)(v))
      }
    case "WellbeingEventTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.WellbeingEventTime = ((*String)(v))
      }
    case "WellbeingEventTimePeriod":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingEventTimePeriodType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingEventTimePeriodType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingevent.WellbeingEventTimePeriod = ((*AUCodeSetsWellbeingEventTimePeriodType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingEvent")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) ConfidentialFlag() *AUCodeSetsYesOrNoCategoryType {
    if s.wellbeingevent.ConfidentialFlag == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.ConfidentialFlag = ((*AUCodeSetsYesOrNoCategoryType)(v))
      }
      }
      return s.wellbeingevent.ConfidentialFlag
    }
// Returns whether the element value for ConfidentialFlag is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) ConfidentialFlag_IsNil() bool {
    return s.wellbeingevent.ConfidentialFlag == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) DocumentList() *WellbeingDocumentListType {
    if s.wellbeingevent.DocumentList == nil {
     if v, ok:= WellbeingDocumentListTypePointer(WellbeingDocumentListType{}); ok {
      s.wellbeingevent.DocumentList = v
      }
      }
      return s.wellbeingevent.DocumentList
    }
// Returns whether the element value for DocumentList is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) DocumentList_IsNil() bool {
    return s.wellbeingevent.DocumentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) EventId() *LocalIdType {
    if s.wellbeingevent.EventId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.EventId = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingevent.EventId
    }
// Returns whether the element value for EventId is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) EventId_IsNil() bool {
    return s.wellbeingevent.EventId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) FollowUpActionList() *FollowUpActionListType {
    if s.wellbeingevent.FollowUpActionList == nil {
     if v, ok:= FollowUpActionListTypePointer(FollowUpActionListType{}); ok {
      s.wellbeingevent.FollowUpActionList = v
      }
      }
      return s.wellbeingevent.FollowUpActionList
    }
// Returns whether the element value for FollowUpActionList is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) FollowUpActionList_IsNil() bool {
    return s.wellbeingevent.FollowUpActionList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) GroupIndicator() *Bool {
    if s.wellbeingevent.GroupIndicator == nil {
    if v, ok:= BoolPointer(false); ok {
      s.wellbeingevent.GroupIndicator = ((*Bool)(v))
      }
      }
      return s.wellbeingevent.GroupIndicator
    }
// Returns whether the element value for GroupIndicator is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) GroupIndicator_IsNil() bool {
    return s.wellbeingevent.GroupIndicator == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) LocalCodeList() *LocalCodeListType {
    if s.wellbeingevent.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.wellbeingevent.LocalCodeList = v
      }
      }
      return s.wellbeingevent.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) LocalCodeList_IsNil() bool {
    return s.wellbeingevent.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) PersonInvolvementList() *PersonInvolvementListType {
    if s.wellbeingevent.PersonInvolvementList == nil {
     if v, ok:= PersonInvolvementListTypePointer(PersonInvolvementListType{}); ok {
      s.wellbeingevent.PersonInvolvementList = v
      }
      }
      return s.wellbeingevent.PersonInvolvementList
    }
// Returns whether the element value for PersonInvolvementList is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) PersonInvolvementList_IsNil() bool {
    return s.wellbeingevent.PersonInvolvementList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) RefId() *RefIdType {
    if s.wellbeingevent.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.RefId = ((*RefIdType)(v))
      }
      }
      return s.wellbeingevent.RefId
    }
// Returns whether the element value for RefId is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) RefId_IsNil() bool {
    return s.wellbeingevent.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) ReportingStaffRefId() *String {
    if s.wellbeingevent.ReportingStaffRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.ReportingStaffRefId = ((*String)(v))
      }
      }
      return s.wellbeingevent.ReportingStaffRefId
    }
// Returns whether the element value for ReportingStaffRefId is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) ReportingStaffRefId_IsNil() bool {
    return s.wellbeingevent.ReportingStaffRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.wellbeingevent.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.wellbeingevent.SIF_ExtendedElements = v
      }
      }
      return s.wellbeingevent.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) SIF_ExtendedElements_IsNil() bool {
    return s.wellbeingevent.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) SIF_Metadata() *SIF_MetadataType {
    if s.wellbeingevent.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.wellbeingevent.SIF_Metadata = v
      }
      }
      return s.wellbeingevent.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) SIF_Metadata_IsNil() bool {
    return s.wellbeingevent.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) SchoolInfoRefId() *String {
    if s.wellbeingevent.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.wellbeingevent.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) SchoolInfoRefId_IsNil() bool {
    return s.wellbeingevent.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) Status() *AUCodeSetsWellbeingStatusType {
    if s.wellbeingevent.Status == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.Status = ((*AUCodeSetsWellbeingStatusType)(v))
      }
      }
      return s.wellbeingevent.Status
    }
// Returns whether the element value for Status is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) Status_IsNil() bool {
    return s.wellbeingevent.Status == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) StudentPersonalRefId() *String {
    if s.wellbeingevent.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.wellbeingevent.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) StudentPersonalRefId_IsNil() bool {
    return s.wellbeingevent.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) WellbeingEventCategoryClass() *AUCodeSetsWellbeingEventCategoryClassType {
    if s.wellbeingevent.WellbeingEventCategoryClass == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.WellbeingEventCategoryClass = ((*AUCodeSetsWellbeingEventCategoryClassType)(v))
      }
      }
      return s.wellbeingevent.WellbeingEventCategoryClass
    }
// Returns whether the element value for WellbeingEventCategoryClass is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) WellbeingEventCategoryClass_IsNil() bool {
    return s.wellbeingevent.WellbeingEventCategoryClass == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) WellbeingEventCategoryList() *WellbeingEventCategoryListType {
    if s.wellbeingevent.WellbeingEventCategoryList == nil {
     if v, ok:= WellbeingEventCategoryListTypePointer(WellbeingEventCategoryListType{}); ok {
      s.wellbeingevent.WellbeingEventCategoryList = v
      }
      }
      return s.wellbeingevent.WellbeingEventCategoryList
    }
// Returns whether the element value for WellbeingEventCategoryList is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) WellbeingEventCategoryList_IsNil() bool {
    return s.wellbeingevent.WellbeingEventCategoryList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) WellbeingEventCreationTimeStamp() *String {
    if s.wellbeingevent.WellbeingEventCreationTimeStamp == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.WellbeingEventCreationTimeStamp = ((*String)(v))
      }
      }
      return s.wellbeingevent.WellbeingEventCreationTimeStamp
    }
// Returns whether the element value for WellbeingEventCreationTimeStamp is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) WellbeingEventCreationTimeStamp_IsNil() bool {
    return s.wellbeingevent.WellbeingEventCreationTimeStamp == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) WellbeingEventDate() *String {
    if s.wellbeingevent.WellbeingEventDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.WellbeingEventDate = ((*String)(v))
      }
      }
      return s.wellbeingevent.WellbeingEventDate
    }
// Returns whether the element value for WellbeingEventDate is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) WellbeingEventDate_IsNil() bool {
    return s.wellbeingevent.WellbeingEventDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) WellbeingEventDescription() *String {
    if s.wellbeingevent.WellbeingEventDescription == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.WellbeingEventDescription = ((*String)(v))
      }
      }
      return s.wellbeingevent.WellbeingEventDescription
    }
// Returns whether the element value for WellbeingEventDescription is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) WellbeingEventDescription_IsNil() bool {
    return s.wellbeingevent.WellbeingEventDescription == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) WellbeingEventLocationDetails() *WellbeingEventLocationDetailsType {
    if s.wellbeingevent.WellbeingEventLocationDetails == nil {
     if v, ok:= WellbeingEventLocationDetailsTypePointer(WellbeingEventLocationDetailsType{}); ok {
      s.wellbeingevent.WellbeingEventLocationDetails = v
      }
      }
      return s.wellbeingevent.WellbeingEventLocationDetails
    }
// Returns whether the element value for WellbeingEventLocationDetails is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) WellbeingEventLocationDetails_IsNil() bool {
    return s.wellbeingevent.WellbeingEventLocationDetails == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) WellbeingEventNotes() *String {
    if s.wellbeingevent.WellbeingEventNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.WellbeingEventNotes = ((*String)(v))
      }
      }
      return s.wellbeingevent.WellbeingEventNotes
    }
// Returns whether the element value for WellbeingEventNotes is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) WellbeingEventNotes_IsNil() bool {
    return s.wellbeingevent.WellbeingEventNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) WellbeingEventTime() *String {
    if s.wellbeingevent.WellbeingEventTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.WellbeingEventTime = ((*String)(v))
      }
      }
      return s.wellbeingevent.WellbeingEventTime
    }
// Returns whether the element value for WellbeingEventTime is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) WellbeingEventTime_IsNil() bool {
    return s.wellbeingevent.WellbeingEventTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEvent) WellbeingEventTimePeriod() *AUCodeSetsWellbeingEventTimePeriodType {
    if s.wellbeingevent.WellbeingEventTimePeriod == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingevent.WellbeingEventTimePeriod = ((*AUCodeSetsWellbeingEventTimePeriodType)(v))
      }
      }
      return s.wellbeingevent.WellbeingEventTimePeriod
    }
// Returns whether the element value for WellbeingEventTimePeriod is nil in the container WellbeingEvent.
  func (s *WellbeingEvent) WellbeingEventTimePeriod_IsNil() bool {
    return s.wellbeingevent.WellbeingEventTimePeriod == nil
    }

// Set the value of a property to nil
func (n *WellbeingEventCategoryType) Unset(key string) *WellbeingEventCategoryType {
        switch key {
  case "EventCategory":
   n.wellbeingeventcategorytype.EventCategory = nil
  case "WellbeingEventSubCategoryList":
   n.wellbeingeventcategorytype.WellbeingEventSubCategoryList = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingEventCategoryType")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingEventCategoryType) SetProperties(props ...Prop) *WellbeingEventCategoryType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingEventCategoryType) SetProperty(key string, value interface{}) *WellbeingEventCategoryType {
        if n == nil {
                n, _ = WellbeingEventCategoryTypePointer(WellbeingEventCategoryType{})
        }
        switch key {
    case "EventCategory":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingeventcategorytype.EventCategory = ((*String)(v))
      }
    case "WellbeingEventSubCategoryList":
    if v, ok:= WellbeingEventSubCategoryListTypePointer(value); ok {
      n.wellbeingeventcategorytype.WellbeingEventSubCategoryList = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingEventCategoryType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEventCategoryType) EventCategory() *String {
    if s.wellbeingeventcategorytype.EventCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingeventcategorytype.EventCategory = ((*String)(v))
      }
      }
      return s.wellbeingeventcategorytype.EventCategory
    }
// Returns whether the element value for EventCategory is nil in the container WellbeingEventCategoryType.
  func (s *WellbeingEventCategoryType) EventCategory_IsNil() bool {
    return s.wellbeingeventcategorytype.EventCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEventCategoryType) WellbeingEventSubCategoryList() *WellbeingEventSubCategoryListType {
    if s.wellbeingeventcategorytype.WellbeingEventSubCategoryList == nil {
     if v, ok:= WellbeingEventSubCategoryListTypePointer(WellbeingEventSubCategoryListType{}); ok {
      s.wellbeingeventcategorytype.WellbeingEventSubCategoryList = v
      }
      }
      return s.wellbeingeventcategorytype.WellbeingEventSubCategoryList
    }
// Returns whether the element value for WellbeingEventSubCategoryList is nil in the container WellbeingEventCategoryType.
  func (s *WellbeingEventCategoryType) WellbeingEventSubCategoryList_IsNil() bool {
    return s.wellbeingeventcategorytype.WellbeingEventSubCategoryList == nil
    }

// Set the value of a property to nil
func (n *WellbeingEventLocationDetailsType) Unset(key string) *WellbeingEventLocationDetailsType {
        switch key {
  case "Class":
   n.wellbeingeventlocationdetailstype.Class = nil
  case "EventLocation":
   n.wellbeingeventlocationdetailstype.EventLocation = nil
  case "FurtherLocationNotes":
   n.wellbeingeventlocationdetailstype.FurtherLocationNotes = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingEventLocationDetailsType")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingEventLocationDetailsType) SetProperties(props ...Prop) *WellbeingEventLocationDetailsType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingEventLocationDetailsType) SetProperty(key string, value interface{}) *WellbeingEventLocationDetailsType {
        if n == nil {
                n, _ = WellbeingEventLocationDetailsTypePointer(WellbeingEventLocationDetailsType{})
        }
        switch key {
    case "Class":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingeventlocationdetailstype.Class = ((*String)(v))
      }
    case "EventLocation":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingEventLocationType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingEventLocationType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingeventlocationdetailstype.EventLocation = ((*AUCodeSetsWellbeingEventLocationType)(v))
      }
    case "FurtherLocationNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingeventlocationdetailstype.FurtherLocationNotes = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingEventLocationDetailsType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEventLocationDetailsType) Class() *String {
    if s.wellbeingeventlocationdetailstype.Class == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingeventlocationdetailstype.Class = ((*String)(v))
      }
      }
      return s.wellbeingeventlocationdetailstype.Class
    }
// Returns whether the element value for Class is nil in the container WellbeingEventLocationDetailsType.
  func (s *WellbeingEventLocationDetailsType) Class_IsNil() bool {
    return s.wellbeingeventlocationdetailstype.Class == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEventLocationDetailsType) EventLocation() *AUCodeSetsWellbeingEventLocationType {
    if s.wellbeingeventlocationdetailstype.EventLocation == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingeventlocationdetailstype.EventLocation = ((*AUCodeSetsWellbeingEventLocationType)(v))
      }
      }
      return s.wellbeingeventlocationdetailstype.EventLocation
    }
// Returns whether the element value for EventLocation is nil in the container WellbeingEventLocationDetailsType.
  func (s *WellbeingEventLocationDetailsType) EventLocation_IsNil() bool {
    return s.wellbeingeventlocationdetailstype.EventLocation == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingEventLocationDetailsType) FurtherLocationNotes() *String {
    if s.wellbeingeventlocationdetailstype.FurtherLocationNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingeventlocationdetailstype.FurtherLocationNotes = ((*String)(v))
      }
      }
      return s.wellbeingeventlocationdetailstype.FurtherLocationNotes
    }
// Returns whether the element value for FurtherLocationNotes is nil in the container WellbeingEventLocationDetailsType.
  func (s *WellbeingEventLocationDetailsType) FurtherLocationNotes_IsNil() bool {
    return s.wellbeingeventlocationdetailstype.FurtherLocationNotes == nil
    }

// Set the value of a property to nil
func (n *WellbeingPersonLink) Unset(key string) *WellbeingPersonLink {
        switch key {
  case "FollowUpActionList":
   n.wellbeingpersonlink.FollowUpActionList = nil
  case "GroupId":
   n.wellbeingpersonlink.GroupId = nil
  case "HowInvolved":
   n.wellbeingpersonlink.HowInvolved = nil
  case "LocalCodeList":
   n.wellbeingpersonlink.LocalCodeList = nil
  case "LocalId":
   n.wellbeingpersonlink.LocalId = nil
  case "OtherPersonContactDetails":
   n.wellbeingpersonlink.OtherPersonContactDetails = nil
  case "OtherPersonId":
   n.wellbeingpersonlink.OtherPersonId = nil
  case "PersonRefId":
   n.wellbeingpersonlink.PersonRefId = nil
  case "PersonRole":
   n.wellbeingpersonlink.PersonRole = nil
  case "RefId":
   n.wellbeingpersonlink.RefId = nil
  case "SIF_ExtendedElements":
   n.wellbeingpersonlink.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.wellbeingpersonlink.SIF_Metadata = nil
  case "ShortName":
   n.wellbeingpersonlink.ShortName = nil
  case "WellbeingEventRefId":
   n.wellbeingpersonlink.WellbeingEventRefId = nil
  case "WellbeingResponseRefId":
   n.wellbeingpersonlink.WellbeingResponseRefId = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingPersonLink")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingPersonLink) SetProperties(props ...Prop) *WellbeingPersonLink {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingPersonLink) SetProperty(key string, value interface{}) *WellbeingPersonLink {
        if n == nil {
                n, _ = WellbeingPersonLinkPointer(WellbeingPersonLink{})
        }
        switch key {
    case "FollowUpActionList":
    if v, ok:= FollowUpActionListTypePointer(value); ok {
      n.wellbeingpersonlink.FollowUpActionList = v
      }
    case "GroupId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.GroupId = ((*LocalIdType)(v))
      }
    case "HowInvolved":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.HowInvolved = ((*String)(v))
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.wellbeingpersonlink.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.LocalId = ((*LocalIdType)(v))
      }
    case "OtherPersonContactDetails":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.OtherPersonContactDetails = ((*String)(v))
      }
    case "OtherPersonId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.OtherPersonId = ((*LocalIdType)(v))
      }
    case "PersonRefId":
    if v, ok:= WellbeingPersonLink_PersonRefIdPointer(value); ok {
      n.wellbeingpersonlink.PersonRefId = v
      }
    case "PersonRole":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.PersonRole = ((*String)(v))
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.wellbeingpersonlink.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.wellbeingpersonlink.SIF_Metadata = v
      }
    case "ShortName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.ShortName = ((*String)(v))
      }
    case "WellbeingEventRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.WellbeingEventRefId = ((*String)(v))
      }
    case "WellbeingResponseRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink.WellbeingResponseRefId = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingPersonLink")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) FollowUpActionList() *FollowUpActionListType {
    if s.wellbeingpersonlink.FollowUpActionList == nil {
     if v, ok:= FollowUpActionListTypePointer(FollowUpActionListType{}); ok {
      s.wellbeingpersonlink.FollowUpActionList = v
      }
      }
      return s.wellbeingpersonlink.FollowUpActionList
    }
// Returns whether the element value for FollowUpActionList is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) FollowUpActionList_IsNil() bool {
    return s.wellbeingpersonlink.FollowUpActionList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) GroupId() *LocalIdType {
    if s.wellbeingpersonlink.GroupId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.GroupId = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingpersonlink.GroupId
    }
// Returns whether the element value for GroupId is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) GroupId_IsNil() bool {
    return s.wellbeingpersonlink.GroupId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) HowInvolved() *String {
    if s.wellbeingpersonlink.HowInvolved == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.HowInvolved = ((*String)(v))
      }
      }
      return s.wellbeingpersonlink.HowInvolved
    }
// Returns whether the element value for HowInvolved is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) HowInvolved_IsNil() bool {
    return s.wellbeingpersonlink.HowInvolved == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) LocalCodeList() *LocalCodeListType {
    if s.wellbeingpersonlink.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.wellbeingpersonlink.LocalCodeList = v
      }
      }
      return s.wellbeingpersonlink.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) LocalCodeList_IsNil() bool {
    return s.wellbeingpersonlink.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) LocalId() *LocalIdType {
    if s.wellbeingpersonlink.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingpersonlink.LocalId
    }
// Returns whether the element value for LocalId is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) LocalId_IsNil() bool {
    return s.wellbeingpersonlink.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) OtherPersonContactDetails() *String {
    if s.wellbeingpersonlink.OtherPersonContactDetails == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.OtherPersonContactDetails = ((*String)(v))
      }
      }
      return s.wellbeingpersonlink.OtherPersonContactDetails
    }
// Returns whether the element value for OtherPersonContactDetails is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) OtherPersonContactDetails_IsNil() bool {
    return s.wellbeingpersonlink.OtherPersonContactDetails == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) OtherPersonId() *LocalIdType {
    if s.wellbeingpersonlink.OtherPersonId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.OtherPersonId = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingpersonlink.OtherPersonId
    }
// Returns whether the element value for OtherPersonId is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) OtherPersonId_IsNil() bool {
    return s.wellbeingpersonlink.OtherPersonId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) PersonRefId() *WellbeingPersonLink_PersonRefId {
    if s.wellbeingpersonlink.PersonRefId == nil {
     if v, ok:= WellbeingPersonLink_PersonRefIdPointer(WellbeingPersonLink_PersonRefId{}); ok {
      s.wellbeingpersonlink.PersonRefId = v
      }
      }
      return s.wellbeingpersonlink.PersonRefId
    }
// Returns whether the element value for PersonRefId is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) PersonRefId_IsNil() bool {
    return s.wellbeingpersonlink.PersonRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) PersonRole() *String {
    if s.wellbeingpersonlink.PersonRole == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.PersonRole = ((*String)(v))
      }
      }
      return s.wellbeingpersonlink.PersonRole
    }
// Returns whether the element value for PersonRole is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) PersonRole_IsNil() bool {
    return s.wellbeingpersonlink.PersonRole == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) RefId() *RefIdType {
    if s.wellbeingpersonlink.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.RefId = ((*RefIdType)(v))
      }
      }
      return s.wellbeingpersonlink.RefId
    }
// Returns whether the element value for RefId is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) RefId_IsNil() bool {
    return s.wellbeingpersonlink.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.wellbeingpersonlink.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.wellbeingpersonlink.SIF_ExtendedElements = v
      }
      }
      return s.wellbeingpersonlink.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) SIF_ExtendedElements_IsNil() bool {
    return s.wellbeingpersonlink.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) SIF_Metadata() *SIF_MetadataType {
    if s.wellbeingpersonlink.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.wellbeingpersonlink.SIF_Metadata = v
      }
      }
      return s.wellbeingpersonlink.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) SIF_Metadata_IsNil() bool {
    return s.wellbeingpersonlink.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) ShortName() *String {
    if s.wellbeingpersonlink.ShortName == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.ShortName = ((*String)(v))
      }
      }
      return s.wellbeingpersonlink.ShortName
    }
// Returns whether the element value for ShortName is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) ShortName_IsNil() bool {
    return s.wellbeingpersonlink.ShortName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) WellbeingEventRefId() *String {
    if s.wellbeingpersonlink.WellbeingEventRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.WellbeingEventRefId = ((*String)(v))
      }
      }
      return s.wellbeingpersonlink.WellbeingEventRefId
    }
// Returns whether the element value for WellbeingEventRefId is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) WellbeingEventRefId_IsNil() bool {
    return s.wellbeingpersonlink.WellbeingEventRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink) WellbeingResponseRefId() *String {
    if s.wellbeingpersonlink.WellbeingResponseRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink.WellbeingResponseRefId = ((*String)(v))
      }
      }
      return s.wellbeingpersonlink.WellbeingResponseRefId
    }
// Returns whether the element value for WellbeingResponseRefId is nil in the container WellbeingPersonLink.
  func (s *WellbeingPersonLink) WellbeingResponseRefId_IsNil() bool {
    return s.wellbeingpersonlink.WellbeingResponseRefId == nil
    }

// Set the value of a property to nil
func (n *WellbeingPersonLink_PersonRefId) Unset(key string) *WellbeingPersonLink_PersonRefId {
        switch key {
  case "SIF_RefObject":
   n.wellbeingpersonlink_personrefid.SIF_RefObject = nil
  case "Value":
   n.wellbeingpersonlink_personrefid.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingPersonLink_PersonRefId")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingPersonLink_PersonRefId) SetProperties(props ...Prop) *WellbeingPersonLink_PersonRefId {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingPersonLink_PersonRefId) SetProperty(key string, value interface{}) *WellbeingPersonLink_PersonRefId {
        if n == nil {
                n, _ = WellbeingPersonLink_PersonRefIdPointer(WellbeingPersonLink_PersonRefId{})
        }
        switch key {
    case "SIF_RefObject":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink_personrefid.SIF_RefObject = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingpersonlink_personrefid.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingPersonLink_PersonRefId")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink_PersonRefId) SIF_RefObject() *String {
    if s.wellbeingpersonlink_personrefid.SIF_RefObject == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink_personrefid.SIF_RefObject = ((*String)(v))
      }
      }
      return s.wellbeingpersonlink_personrefid.SIF_RefObject
    }
// Returns whether the element value for SIF_RefObject is nil in the container WellbeingPersonLink_PersonRefId.
  func (s *WellbeingPersonLink_PersonRefId) SIF_RefObject_IsNil() bool {
    return s.wellbeingpersonlink_personrefid.SIF_RefObject == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPersonLink_PersonRefId) Value() *String {
    if s.wellbeingpersonlink_personrefid.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingpersonlink_personrefid.Value = ((*String)(v))
      }
      }
      return s.wellbeingpersonlink_personrefid.Value
    }
// Returns whether the element value for Value is nil in the container WellbeingPersonLink_PersonRefId.
  func (s *WellbeingPersonLink_PersonRefId) Value_IsNil() bool {
    return s.wellbeingpersonlink_personrefid.Value == nil
    }

// Set the value of a property to nil
func (n *WellbeingPlanType) Unset(key string) *WellbeingPlanType {
        switch key {
  case "PersonalisedPlanRefId":
   n.wellbeingplantype.PersonalisedPlanRefId = nil
  case "PlanNotes":
   n.wellbeingplantype.PlanNotes = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingPlanType")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingPlanType) SetProperties(props ...Prop) *WellbeingPlanType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingPlanType) SetProperty(key string, value interface{}) *WellbeingPlanType {
        if n == nil {
                n, _ = WellbeingPlanTypePointer(WellbeingPlanType{})
        }
        switch key {
    case "PersonalisedPlanRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingplantype.PersonalisedPlanRefId = ((*String)(v))
      }
    case "PlanNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingplantype.PlanNotes = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingPlanType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPlanType) PersonalisedPlanRefId() *String {
    if s.wellbeingplantype.PersonalisedPlanRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingplantype.PersonalisedPlanRefId = ((*String)(v))
      }
      }
      return s.wellbeingplantype.PersonalisedPlanRefId
    }
// Returns whether the element value for PersonalisedPlanRefId is nil in the container WellbeingPlanType.
  func (s *WellbeingPlanType) PersonalisedPlanRefId_IsNil() bool {
    return s.wellbeingplantype.PersonalisedPlanRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingPlanType) PlanNotes() *String {
    if s.wellbeingplantype.PlanNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingplantype.PlanNotes = ((*String)(v))
      }
      }
      return s.wellbeingplantype.PlanNotes
    }
// Returns whether the element value for PlanNotes is nil in the container WellbeingPlanType.
  func (s *WellbeingPlanType) PlanNotes_IsNil() bool {
    return s.wellbeingplantype.PlanNotes == nil
    }

// Set the value of a property to nil
func (n *WellbeingResponse) Unset(key string) *WellbeingResponse {
        switch key {
  case "Award":
   n.wellbeingresponse.Award = nil
  case "Date":
   n.wellbeingresponse.Date = nil
  case "Detention":
   n.wellbeingresponse.Detention = nil
  case "DocumentList":
   n.wellbeingresponse.DocumentList = nil
  case "LocalCodeList":
   n.wellbeingresponse.LocalCodeList = nil
  case "LocalId":
   n.wellbeingresponse.LocalId = nil
  case "OtherResponse":
   n.wellbeingresponse.OtherResponse = nil
  case "PersonInvolvementList":
   n.wellbeingresponse.PersonInvolvementList = nil
  case "PlanRequired":
   n.wellbeingresponse.PlanRequired = nil
  case "RefId":
   n.wellbeingresponse.RefId = nil
  case "SIF_ExtendedElements":
   n.wellbeingresponse.SIF_ExtendedElements = nil
  case "SIF_Metadata":
   n.wellbeingresponse.SIF_Metadata = nil
  case "SchoolInfoRefId":
   n.wellbeingresponse.SchoolInfoRefId = nil
  case "StudentPersonalRefId":
   n.wellbeingresponse.StudentPersonalRefId = nil
  case "Suspension":
   n.wellbeingresponse.Suspension = nil
  case "WellbeingResponseCategory":
   n.wellbeingresponse.WellbeingResponseCategory = nil
  case "WellbeingResponseEndDate":
   n.wellbeingresponse.WellbeingResponseEndDate = nil
  case "WellbeingResponseNotes":
   n.wellbeingresponse.WellbeingResponseNotes = nil
  case "WellbeingResponseStartDate":
   n.wellbeingresponse.WellbeingResponseStartDate = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingResponse")
        }
        return n
}

// Set a sequence of properties
func (n *WellbeingResponse) SetProperties(props ...Prop) *WellbeingResponse {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WellbeingResponse) SetProperty(key string, value interface{}) *WellbeingResponse {
        if n == nil {
                n, _ = WellbeingResponsePointer(WellbeingResponse{})
        }
        switch key {
    case "Award":
    if v, ok:= AwardContainerTypePointer(value); ok {
      n.wellbeingresponse.Award = v
      }
    case "Date":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingresponse.Date = ((*String)(v))
      }
    case "Detention":
    if v, ok:= DetentionContainerTypePointer(value); ok {
      n.wellbeingresponse.Detention = v
      }
    case "DocumentList":
    if v, ok:= WellbeingDocumentListTypePointer(value); ok {
      n.wellbeingresponse.DocumentList = v
      }
    case "LocalCodeList":
    if v, ok:= LocalCodeListTypePointer(value); ok {
      n.wellbeingresponse.LocalCodeList = v
      }
    case "LocalId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingresponse.LocalId = ((*LocalIdType)(v))
      }
    case "OtherResponse":
    if v, ok:= OtherWellbeingResponseContainerTypePointer(value); ok {
      n.wellbeingresponse.OtherResponse = v
      }
    case "PersonInvolvementList":
    if v, ok:= PersonInvolvementListTypePointer(value); ok {
      n.wellbeingresponse.PersonInvolvementList = v
      }
    case "PlanRequired":
    if v, ok:= PlanRequiredContainerTypePointer(value); ok {
      n.wellbeingresponse.PlanRequired = v
      }
    case "RefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingresponse.RefId = ((*RefIdType)(v))
      }
    case "SIF_ExtendedElements":
    if v, ok:= SIF_ExtendedElementsTypePointer(value); ok {
      n.wellbeingresponse.SIF_ExtendedElements = v
      }
    case "SIF_Metadata":
    if v, ok:= SIF_MetadataTypePointer(value); ok {
      n.wellbeingresponse.SIF_Metadata = v
      }
    case "SchoolInfoRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingresponse.SchoolInfoRefId = ((*String)(v))
      }
    case "StudentPersonalRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingresponse.StudentPersonalRefId = ((*String)(v))
      }
    case "Suspension":
    if v, ok:= SuspensionContainerTypePointer(value); ok {
      n.wellbeingresponse.Suspension = v
      }
    case "WellbeingResponseCategory":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsWellbeingResponseCategoryType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsWellbeingResponseCategoryType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.wellbeingresponse.WellbeingResponseCategory = ((*AUCodeSetsWellbeingResponseCategoryType)(v))
      }
    case "WellbeingResponseEndDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingresponse.WellbeingResponseEndDate = ((*String)(v))
      }
    case "WellbeingResponseNotes":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingresponse.WellbeingResponseNotes = ((*String)(v))
      }
    case "WellbeingResponseStartDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.wellbeingresponse.WellbeingResponseStartDate = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WellbeingResponse")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) Award() *AwardContainerType {
    if s.wellbeingresponse.Award == nil {
     if v, ok:= AwardContainerTypePointer(AwardContainerType{}); ok {
      s.wellbeingresponse.Award = v
      }
      }
      return s.wellbeingresponse.Award
    }
// Returns whether the element value for Award is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) Award_IsNil() bool {
    return s.wellbeingresponse.Award == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) Date() *String {
    if s.wellbeingresponse.Date == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingresponse.Date = ((*String)(v))
      }
      }
      return s.wellbeingresponse.Date
    }
// Returns whether the element value for Date is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) Date_IsNil() bool {
    return s.wellbeingresponse.Date == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) Detention() *DetentionContainerType {
    if s.wellbeingresponse.Detention == nil {
     if v, ok:= DetentionContainerTypePointer(DetentionContainerType{}); ok {
      s.wellbeingresponse.Detention = v
      }
      }
      return s.wellbeingresponse.Detention
    }
// Returns whether the element value for Detention is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) Detention_IsNil() bool {
    return s.wellbeingresponse.Detention == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) DocumentList() *WellbeingDocumentListType {
    if s.wellbeingresponse.DocumentList == nil {
     if v, ok:= WellbeingDocumentListTypePointer(WellbeingDocumentListType{}); ok {
      s.wellbeingresponse.DocumentList = v
      }
      }
      return s.wellbeingresponse.DocumentList
    }
// Returns whether the element value for DocumentList is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) DocumentList_IsNil() bool {
    return s.wellbeingresponse.DocumentList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) LocalCodeList() *LocalCodeListType {
    if s.wellbeingresponse.LocalCodeList == nil {
     if v, ok:= LocalCodeListTypePointer(LocalCodeListType{}); ok {
      s.wellbeingresponse.LocalCodeList = v
      }
      }
      return s.wellbeingresponse.LocalCodeList
    }
// Returns whether the element value for LocalCodeList is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) LocalCodeList_IsNil() bool {
    return s.wellbeingresponse.LocalCodeList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) LocalId() *LocalIdType {
    if s.wellbeingresponse.LocalId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingresponse.LocalId = ((*LocalIdType)(v))
      }
      }
      return s.wellbeingresponse.LocalId
    }
// Returns whether the element value for LocalId is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) LocalId_IsNil() bool {
    return s.wellbeingresponse.LocalId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) OtherResponse() *OtherWellbeingResponseContainerType {
    if s.wellbeingresponse.OtherResponse == nil {
     if v, ok:= OtherWellbeingResponseContainerTypePointer(OtherWellbeingResponseContainerType{}); ok {
      s.wellbeingresponse.OtherResponse = v
      }
      }
      return s.wellbeingresponse.OtherResponse
    }
// Returns whether the element value for OtherResponse is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) OtherResponse_IsNil() bool {
    return s.wellbeingresponse.OtherResponse == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) PersonInvolvementList() *PersonInvolvementListType {
    if s.wellbeingresponse.PersonInvolvementList == nil {
     if v, ok:= PersonInvolvementListTypePointer(PersonInvolvementListType{}); ok {
      s.wellbeingresponse.PersonInvolvementList = v
      }
      }
      return s.wellbeingresponse.PersonInvolvementList
    }
// Returns whether the element value for PersonInvolvementList is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) PersonInvolvementList_IsNil() bool {
    return s.wellbeingresponse.PersonInvolvementList == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) PlanRequired() *PlanRequiredContainerType {
    if s.wellbeingresponse.PlanRequired == nil {
     if v, ok:= PlanRequiredContainerTypePointer(PlanRequiredContainerType{}); ok {
      s.wellbeingresponse.PlanRequired = v
      }
      }
      return s.wellbeingresponse.PlanRequired
    }
// Returns whether the element value for PlanRequired is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) PlanRequired_IsNil() bool {
    return s.wellbeingresponse.PlanRequired == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) RefId() *RefIdType {
    if s.wellbeingresponse.RefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingresponse.RefId = ((*RefIdType)(v))
      }
      }
      return s.wellbeingresponse.RefId
    }
// Returns whether the element value for RefId is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) RefId_IsNil() bool {
    return s.wellbeingresponse.RefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) SIF_ExtendedElements() *SIF_ExtendedElementsType {
    if s.wellbeingresponse.SIF_ExtendedElements == nil {
     if v, ok:= SIF_ExtendedElementsTypePointer(SIF_ExtendedElementsType{}); ok {
      s.wellbeingresponse.SIF_ExtendedElements = v
      }
      }
      return s.wellbeingresponse.SIF_ExtendedElements
    }
// Returns whether the element value for SIF_ExtendedElements is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) SIF_ExtendedElements_IsNil() bool {
    return s.wellbeingresponse.SIF_ExtendedElements == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) SIF_Metadata() *SIF_MetadataType {
    if s.wellbeingresponse.SIF_Metadata == nil {
     if v, ok:= SIF_MetadataTypePointer(SIF_MetadataType{}); ok {
      s.wellbeingresponse.SIF_Metadata = v
      }
      }
      return s.wellbeingresponse.SIF_Metadata
    }
// Returns whether the element value for SIF_Metadata is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) SIF_Metadata_IsNil() bool {
    return s.wellbeingresponse.SIF_Metadata == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) SchoolInfoRefId() *String {
    if s.wellbeingresponse.SchoolInfoRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingresponse.SchoolInfoRefId = ((*String)(v))
      }
      }
      return s.wellbeingresponse.SchoolInfoRefId
    }
// Returns whether the element value for SchoolInfoRefId is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) SchoolInfoRefId_IsNil() bool {
    return s.wellbeingresponse.SchoolInfoRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) StudentPersonalRefId() *String {
    if s.wellbeingresponse.StudentPersonalRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingresponse.StudentPersonalRefId = ((*String)(v))
      }
      }
      return s.wellbeingresponse.StudentPersonalRefId
    }
// Returns whether the element value for StudentPersonalRefId is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) StudentPersonalRefId_IsNil() bool {
    return s.wellbeingresponse.StudentPersonalRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) Suspension() *SuspensionContainerType {
    if s.wellbeingresponse.Suspension == nil {
     if v, ok:= SuspensionContainerTypePointer(SuspensionContainerType{}); ok {
      s.wellbeingresponse.Suspension = v
      }
      }
      return s.wellbeingresponse.Suspension
    }
// Returns whether the element value for Suspension is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) Suspension_IsNil() bool {
    return s.wellbeingresponse.Suspension == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) WellbeingResponseCategory() *AUCodeSetsWellbeingResponseCategoryType {
    if s.wellbeingresponse.WellbeingResponseCategory == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingresponse.WellbeingResponseCategory = ((*AUCodeSetsWellbeingResponseCategoryType)(v))
      }
      }
      return s.wellbeingresponse.WellbeingResponseCategory
    }
// Returns whether the element value for WellbeingResponseCategory is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) WellbeingResponseCategory_IsNil() bool {
    return s.wellbeingresponse.WellbeingResponseCategory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) WellbeingResponseEndDate() *String {
    if s.wellbeingresponse.WellbeingResponseEndDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingresponse.WellbeingResponseEndDate = ((*String)(v))
      }
      }
      return s.wellbeingresponse.WellbeingResponseEndDate
    }
// Returns whether the element value for WellbeingResponseEndDate is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) WellbeingResponseEndDate_IsNil() bool {
    return s.wellbeingresponse.WellbeingResponseEndDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) WellbeingResponseNotes() *String {
    if s.wellbeingresponse.WellbeingResponseNotes == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingresponse.WellbeingResponseNotes = ((*String)(v))
      }
      }
      return s.wellbeingresponse.WellbeingResponseNotes
    }
// Returns whether the element value for WellbeingResponseNotes is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) WellbeingResponseNotes_IsNil() bool {
    return s.wellbeingresponse.WellbeingResponseNotes == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WellbeingResponse) WellbeingResponseStartDate() *String {
    if s.wellbeingresponse.WellbeingResponseStartDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.wellbeingresponse.WellbeingResponseStartDate = ((*String)(v))
      }
      }
      return s.wellbeingresponse.WellbeingResponseStartDate
    }
// Returns whether the element value for WellbeingResponseStartDate is nil in the container WellbeingResponse.
  func (s *WellbeingResponse) WellbeingResponseStartDate_IsNil() bool {
    return s.wellbeingresponse.WellbeingResponseStartDate == nil
    }

// Set the value of a property to nil
func (n *WithdrawalType) Unset(key string) *WithdrawalType {
        switch key {
  case "ScheduledActivityRefId":
   n.withdrawaltype.ScheduledActivityRefId = nil
  case "TimeTableCellRefId":
   n.withdrawaltype.TimeTableCellRefId = nil
  case "TimeTableSubjectRefId":
   n.withdrawaltype.TimeTableSubjectRefId = nil
  case "WithdrawalDate":
   n.withdrawaltype.WithdrawalDate = nil
  case "WithdrawalEndTime":
   n.withdrawaltype.WithdrawalEndTime = nil
  case "WithdrawalStartTime":
   n.withdrawaltype.WithdrawalStartTime = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WithdrawalType")
        }
        return n
}

// Set a sequence of properties
func (n *WithdrawalType) SetProperties(props ...Prop) *WithdrawalType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WithdrawalType) SetProperty(key string, value interface{}) *WithdrawalType {
        if n == nil {
                n, _ = WithdrawalTypePointer(WithdrawalType{})
        }
        switch key {
    case "ScheduledActivityRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.withdrawaltype.ScheduledActivityRefId = ((*String)(v))
      }
    case "TimeTableCellRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.withdrawaltype.TimeTableCellRefId = ((*String)(v))
      }
    case "TimeTableSubjectRefId":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.withdrawaltype.TimeTableSubjectRefId = ((*String)(v))
      }
    case "WithdrawalDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.withdrawaltype.WithdrawalDate = ((*String)(v))
      }
    case "WithdrawalEndTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.withdrawaltype.WithdrawalEndTime = ((*String)(v))
      }
    case "WithdrawalStartTime":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.withdrawaltype.WithdrawalStartTime = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WithdrawalType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WithdrawalType) ScheduledActivityRefId() *String {
    if s.withdrawaltype.ScheduledActivityRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.withdrawaltype.ScheduledActivityRefId = ((*String)(v))
      }
      }
      return s.withdrawaltype.ScheduledActivityRefId
    }
// Returns whether the element value for ScheduledActivityRefId is nil in the container WithdrawalType.
  func (s *WithdrawalType) ScheduledActivityRefId_IsNil() bool {
    return s.withdrawaltype.ScheduledActivityRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WithdrawalType) TimeTableCellRefId() *String {
    if s.withdrawaltype.TimeTableCellRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.withdrawaltype.TimeTableCellRefId = ((*String)(v))
      }
      }
      return s.withdrawaltype.TimeTableCellRefId
    }
// Returns whether the element value for TimeTableCellRefId is nil in the container WithdrawalType.
  func (s *WithdrawalType) TimeTableCellRefId_IsNil() bool {
    return s.withdrawaltype.TimeTableCellRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WithdrawalType) TimeTableSubjectRefId() *String {
    if s.withdrawaltype.TimeTableSubjectRefId == nil {
    if v, ok:= StringPointer(""); ok {
      s.withdrawaltype.TimeTableSubjectRefId = ((*String)(v))
      }
      }
      return s.withdrawaltype.TimeTableSubjectRefId
    }
// Returns whether the element value for TimeTableSubjectRefId is nil in the container WithdrawalType.
  func (s *WithdrawalType) TimeTableSubjectRefId_IsNil() bool {
    return s.withdrawaltype.TimeTableSubjectRefId == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WithdrawalType) WithdrawalDate() *String {
    if s.withdrawaltype.WithdrawalDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.withdrawaltype.WithdrawalDate = ((*String)(v))
      }
      }
      return s.withdrawaltype.WithdrawalDate
    }
// Returns whether the element value for WithdrawalDate is nil in the container WithdrawalType.
  func (s *WithdrawalType) WithdrawalDate_IsNil() bool {
    return s.withdrawaltype.WithdrawalDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WithdrawalType) WithdrawalEndTime() *String {
    if s.withdrawaltype.WithdrawalEndTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.withdrawaltype.WithdrawalEndTime = ((*String)(v))
      }
      }
      return s.withdrawaltype.WithdrawalEndTime
    }
// Returns whether the element value for WithdrawalEndTime is nil in the container WithdrawalType.
  func (s *WithdrawalType) WithdrawalEndTime_IsNil() bool {
    return s.withdrawaltype.WithdrawalEndTime == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WithdrawalType) WithdrawalStartTime() *String {
    if s.withdrawaltype.WithdrawalStartTime == nil {
    if v, ok:= StringPointer(""); ok {
      s.withdrawaltype.WithdrawalStartTime = ((*String)(v))
      }
      }
      return s.withdrawaltype.WithdrawalStartTime
    }
// Returns whether the element value for WithdrawalStartTime is nil in the container WithdrawalType.
  func (s *WithdrawalType) WithdrawalStartTime_IsNil() bool {
    return s.withdrawaltype.WithdrawalStartTime == nil
    }

// Set the value of a property to nil
func (n *WorkingWithChildrenCheckType) Unset(key string) *WorkingWithChildrenCheckType {
        switch key {
  case "CheckDate":
   n.workingwithchildrenchecktype.CheckDate = nil
  case "Determination":
   n.workingwithchildrenchecktype.Determination = nil
  case "DeterminationDate":
   n.workingwithchildrenchecktype.DeterminationDate = nil
  case "ExpiryDate":
   n.workingwithchildrenchecktype.ExpiryDate = nil
  case "HolderName":
   n.workingwithchildrenchecktype.HolderName = nil
  case "Number":
   n.workingwithchildrenchecktype.Number = nil
  case "Reasons":
   n.workingwithchildrenchecktype.Reasons = nil
  case "StateTerritory":
   n.workingwithchildrenchecktype.StateTerritory = nil
  case "Type":
   n.workingwithchildrenchecktype.Type = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WorkingWithChildrenCheckType")
        }
        return n
}

// Set a sequence of properties
func (n *WorkingWithChildrenCheckType) SetProperties(props ...Prop) *WorkingWithChildrenCheckType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *WorkingWithChildrenCheckType) SetProperty(key string, value interface{}) *WorkingWithChildrenCheckType {
        if n == nil {
                n, _ = WorkingWithChildrenCheckTypePointer(WorkingWithChildrenCheckType{})
        }
        switch key {
    case "CheckDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.workingwithchildrenchecktype.CheckDate = ((*String)(v))
      }
    case "Determination":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.workingwithchildrenchecktype.Determination = ((*String)(v))
      }
    case "DeterminationDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.workingwithchildrenchecktype.DeterminationDate = ((*String)(v))
      }
    case "ExpiryDate":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.workingwithchildrenchecktype.ExpiryDate = ((*String)(v))
      }
    case "HolderName":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.workingwithchildrenchecktype.HolderName = ((*String)(v))
      }
    case "Number":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.workingwithchildrenchecktype.Number = ((*String)(v))
      }
    case "Reasons":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.workingwithchildrenchecktype.Reasons = ((*String)(v))
      }
    case "StateTerritory":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.workingwithchildrenchecktype.StateTerritory = ((*StateProvinceType)(v))
      }
    case "Type":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.workingwithchildrenchecktype.Type = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "WorkingWithChildrenCheckType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WorkingWithChildrenCheckType) CheckDate() *String {
    if s.workingwithchildrenchecktype.CheckDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.workingwithchildrenchecktype.CheckDate = ((*String)(v))
      }
      }
      return s.workingwithchildrenchecktype.CheckDate
    }
// Returns whether the element value for CheckDate is nil in the container WorkingWithChildrenCheckType.
  func (s *WorkingWithChildrenCheckType) CheckDate_IsNil() bool {
    return s.workingwithchildrenchecktype.CheckDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WorkingWithChildrenCheckType) Determination() *String {
    if s.workingwithchildrenchecktype.Determination == nil {
    if v, ok:= StringPointer(""); ok {
      s.workingwithchildrenchecktype.Determination = ((*String)(v))
      }
      }
      return s.workingwithchildrenchecktype.Determination
    }
// Returns whether the element value for Determination is nil in the container WorkingWithChildrenCheckType.
  func (s *WorkingWithChildrenCheckType) Determination_IsNil() bool {
    return s.workingwithchildrenchecktype.Determination == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WorkingWithChildrenCheckType) DeterminationDate() *String {
    if s.workingwithchildrenchecktype.DeterminationDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.workingwithchildrenchecktype.DeterminationDate = ((*String)(v))
      }
      }
      return s.workingwithchildrenchecktype.DeterminationDate
    }
// Returns whether the element value for DeterminationDate is nil in the container WorkingWithChildrenCheckType.
  func (s *WorkingWithChildrenCheckType) DeterminationDate_IsNil() bool {
    return s.workingwithchildrenchecktype.DeterminationDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WorkingWithChildrenCheckType) ExpiryDate() *String {
    if s.workingwithchildrenchecktype.ExpiryDate == nil {
    if v, ok:= StringPointer(""); ok {
      s.workingwithchildrenchecktype.ExpiryDate = ((*String)(v))
      }
      }
      return s.workingwithchildrenchecktype.ExpiryDate
    }
// Returns whether the element value for ExpiryDate is nil in the container WorkingWithChildrenCheckType.
  func (s *WorkingWithChildrenCheckType) ExpiryDate_IsNil() bool {
    return s.workingwithchildrenchecktype.ExpiryDate == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WorkingWithChildrenCheckType) HolderName() *String {
    if s.workingwithchildrenchecktype.HolderName == nil {
    if v, ok:= StringPointer(""); ok {
      s.workingwithchildrenchecktype.HolderName = ((*String)(v))
      }
      }
      return s.workingwithchildrenchecktype.HolderName
    }
// Returns whether the element value for HolderName is nil in the container WorkingWithChildrenCheckType.
  func (s *WorkingWithChildrenCheckType) HolderName_IsNil() bool {
    return s.workingwithchildrenchecktype.HolderName == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WorkingWithChildrenCheckType) Number() *String {
    if s.workingwithchildrenchecktype.Number == nil {
    if v, ok:= StringPointer(""); ok {
      s.workingwithchildrenchecktype.Number = ((*String)(v))
      }
      }
      return s.workingwithchildrenchecktype.Number
    }
// Returns whether the element value for Number is nil in the container WorkingWithChildrenCheckType.
  func (s *WorkingWithChildrenCheckType) Number_IsNil() bool {
    return s.workingwithchildrenchecktype.Number == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WorkingWithChildrenCheckType) Reasons() *String {
    if s.workingwithchildrenchecktype.Reasons == nil {
    if v, ok:= StringPointer(""); ok {
      s.workingwithchildrenchecktype.Reasons = ((*String)(v))
      }
      }
      return s.workingwithchildrenchecktype.Reasons
    }
// Returns whether the element value for Reasons is nil in the container WorkingWithChildrenCheckType.
  func (s *WorkingWithChildrenCheckType) Reasons_IsNil() bool {
    return s.workingwithchildrenchecktype.Reasons == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WorkingWithChildrenCheckType) StateTerritory() *StateProvinceType {
    if s.workingwithchildrenchecktype.StateTerritory == nil {
    if v, ok:= StringPointer(""); ok {
      s.workingwithchildrenchecktype.StateTerritory = ((*StateProvinceType)(v))
      }
      }
      return s.workingwithchildrenchecktype.StateTerritory
    }
// Returns whether the element value for StateTerritory is nil in the container WorkingWithChildrenCheckType.
  func (s *WorkingWithChildrenCheckType) StateTerritory_IsNil() bool {
    return s.workingwithchildrenchecktype.StateTerritory == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *WorkingWithChildrenCheckType) Type() *String {
    if s.workingwithchildrenchecktype.Type == nil {
    if v, ok:= StringPointer(""); ok {
      s.workingwithchildrenchecktype.Type = ((*String)(v))
      }
      }
      return s.workingwithchildrenchecktype.Type
    }
// Returns whether the element value for Type is nil in the container WorkingWithChildrenCheckType.
  func (s *WorkingWithChildrenCheckType) Type_IsNil() bool {
    return s.workingwithchildrenchecktype.Type == nil
    }

// Set the value of a property to nil
func (n *XMLDataType) Unset(key string) *XMLDataType {
        switch key {
  case "Description":
   n.xmldatatype.Description = nil
  case "Value":
   n.xmldatatype.Value = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "XMLDataType")
        }
        return n
}

// Set a sequence of properties
func (n *XMLDataType) SetProperties(props ...Prop) *XMLDataType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *XMLDataType) SetProperty(key string, value interface{}) *XMLDataType {
        if n == nil {
                n, _ = XMLDataTypePointer(XMLDataType{})
        }
        switch key {
    case "Description":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.xmldatatype.Description = ((*String)(v))
      }
    case "Value":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.xmldatatype.Value = ((*String)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "XMLDataType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *XMLDataType) Description() *String {
    if s.xmldatatype.Description == nil {
    if v, ok:= StringPointer(""); ok {
      s.xmldatatype.Description = ((*String)(v))
      }
      }
      return s.xmldatatype.Description
    }
// Returns whether the element value for Description is nil in the container XMLDataType.
  func (s *XMLDataType) Description_IsNil() bool {
    return s.xmldatatype.Description == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *XMLDataType) Value() *String {
    if s.xmldatatype.Value == nil {
    if v, ok:= StringPointer(""); ok {
      s.xmldatatype.Value = ((*String)(v))
      }
      }
      return s.xmldatatype.Value
    }
// Returns whether the element value for Value is nil in the container XMLDataType.
  func (s *XMLDataType) Value_IsNil() bool {
    return s.xmldatatype.Value == nil
    }

// Set the value of a property to nil
func (n *YearLevelEnrollmentType) Unset(key string) *YearLevelEnrollmentType {
        switch key {
  case "Enrollment":
   n.yearlevelenrollmenttype.Enrollment = nil
  case "Year":
   n.yearlevelenrollmenttype.Year = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "YearLevelEnrollmentType")
        }
        return n
}

// Set a sequence of properties
func (n *YearLevelEnrollmentType) SetProperties(props ...Prop) *YearLevelEnrollmentType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *YearLevelEnrollmentType) SetProperty(key string, value interface{}) *YearLevelEnrollmentType {
        if n == nil {
                n, _ = YearLevelEnrollmentTypePointer(YearLevelEnrollmentType{})
        }
        switch key {
    case "Enrollment":
    value = fmt.Sprintf("%s", value)
    
    if v, ok:= StringPointer(value); ok {
      n.yearlevelenrollmenttype.Enrollment = ((*String)(v))
      }
    case "Year":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYearLevelCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYearLevelCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.yearlevelenrollmenttype.Year = ((*AUCodeSetsYearLevelCodeType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "YearLevelEnrollmentType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *YearLevelEnrollmentType) Enrollment() *String {
    if s.yearlevelenrollmenttype.Enrollment == nil {
    if v, ok:= StringPointer(""); ok {
      s.yearlevelenrollmenttype.Enrollment = ((*String)(v))
      }
      }
      return s.yearlevelenrollmenttype.Enrollment
    }
// Returns whether the element value for Enrollment is nil in the container YearLevelEnrollmentType.
  func (s *YearLevelEnrollmentType) Enrollment_IsNil() bool {
    return s.yearlevelenrollmenttype.Enrollment == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *YearLevelEnrollmentType) Year() *AUCodeSetsYearLevelCodeType {
    if s.yearlevelenrollmenttype.Year == nil {
    if v, ok:= StringPointer(""); ok {
      s.yearlevelenrollmenttype.Year = ((*AUCodeSetsYearLevelCodeType)(v))
      }
      }
      return s.yearlevelenrollmenttype.Year
    }
// Returns whether the element value for Year is nil in the container YearLevelEnrollmentType.
  func (s *YearLevelEnrollmentType) Year_IsNil() bool {
    return s.yearlevelenrollmenttype.Year == nil
    }

// Set the value of a property to nil
func (n *YearLevelType) Unset(key string) *YearLevelType {
        switch key {
  case "Code":
   n.yearleveltype.Code = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "YearLevelType")
        }
        return n
}

// Set a sequence of properties
func (n *YearLevelType) SetProperties(props ...Prop) *YearLevelType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *YearLevelType) SetProperty(key string, value interface{}) *YearLevelType {
        if n == nil {
                n, _ = YearLevelTypePointer(YearLevelType{})
        }
        switch key {
    case "Code":
    value = fmt.Sprintf("%s", value)
        if !CodesetContains(AUCodeSetsYearLevelCodeType_map, value) {
      log.Fatalf("%s is not present in %s\n", value, "AUCodeSetsYearLevelCodeType_values")
      }

    if v, ok:= StringPointer(value); ok {
      n.yearleveltype.Code = ((*AUCodeSetsYearLevelCodeType)(v))
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "YearLevelType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *YearLevelType) Code() *AUCodeSetsYearLevelCodeType {
    if s.yearleveltype.Code == nil {
    if v, ok:= StringPointer(""); ok {
      s.yearleveltype.Code = ((*AUCodeSetsYearLevelCodeType)(v))
      }
      }
      return s.yearleveltype.Code
    }
// Returns whether the element value for Code is nil in the container YearLevelType.
  func (s *YearLevelType) Code_IsNil() bool {
    return s.yearleveltype.Code == nil
    }

// Set the value of a property to nil
func (n *YearRangeType) Unset(key string) *YearRangeType {
        switch key {
  case "End":
   n.yearrangetype.End = nil
  case "Start":
   n.yearrangetype.Start = nil
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "YearRangeType")
        }
        return n
}

// Set a sequence of properties
func (n *YearRangeType) SetProperties(props ...Prop) *YearRangeType {
 	for _, p := range props {
 		n.SetProperty(p.Key, p.Value)
 	}
 	return n
 }

// Set a property to a value. Aborts if property name is undefined for the type. Aborts if the list is a list of codeset values,
// and the value does not match the codeset.
func (n *YearRangeType) SetProperty(key string, value interface{}) *YearRangeType {
        if n == nil {
                n, _ = YearRangeTypePointer(YearRangeType{})
        }
        switch key {
    case "End":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.yearrangetype.End = v
      }
    case "Start":
    if v, ok:= YearLevelTypePointer(value); ok {
      n.yearrangetype.Start = v
      }
        default:
          log.Fatalf("%s is not a valid element name in %s\n", key, "YearRangeType")
        }
        return n
}

// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *YearRangeType) End() *YearLevelType {
    if s.yearrangetype.End == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.yearrangetype.End = v
      }
      }
      return s.yearrangetype.End
    }
// Returns whether the element value for End is nil in the container YearRangeType.
  func (s *YearRangeType) End_IsNil() bool {
    return s.yearrangetype.End == nil
    }
// Return the element value (as a pointer to the container, list, or primitive representing it).
  func (s *YearRangeType) Start() *YearLevelType {
    if s.yearrangetype.Start == nil {
     if v, ok:= YearLevelTypePointer(YearLevelType{}); ok {
      s.yearrangetype.Start = v
      }
      }
      return s.yearrangetype.Start
    }
// Returns whether the element value for Start is nil in the container YearRangeType.
  func (s *YearRangeType) Start_IsNil() bool {
    return s.yearrangetype.Start == nil
    }
