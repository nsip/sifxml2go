package populate

import (
	"github.com/nsip/sifxml2go/sifxml"
)

// All the SIF objects generated by MakeUsecaseObjects(), bundled up as a single object.
type UseCaseObjects struct {
	Schools             []*sifxml.SchoolInfo
	Students            []*sifxml.StudentPersonal
	Staff               []*sifxml.StaffPersonal
	Enrolments          []*sifxml.StudentSchoolEnrollment
	Assignments         []*sifxml.StaffAssignment
	TeachingGroups      []*sifxml.TeachingGroup
	TimeTables          []*sifxml.TimeTable
	TimeTableSubjects   []*sifxml.TimeTableSubject
	TimeTableCells      []*sifxml.TimeTableCell
	Rooms               []*sifxml.RoomInfo
	Contacts            []*sifxml.StudentContactPersonal
	Relationships       []*sifxml.StudentContactRelationship
	FinancialAccounts   []*sifxml.FinancialAccount
	Vendors             []*sifxml.VendorInfo
	Debtors             []*sifxml.Debtor
	ChargedLocations    []*sifxml.ChargedLocationInfo
	Terms               []*sifxml.TermInfo
	CalendarSummarys    []*sifxml.CalendarSummary
	CalendarDates       []*sifxml.CalendarDate
	SessionInfos        []*sifxml.SessionInfo
	SchoolCourses       []*sifxml.SchoolCourseInfo
	ScheduledActivities []*sifxml.ScheduledActivity
	CollectionRounds    []*sifxml.CollectionRound
	CollectionStatuses  []*sifxml.CollectionStatus
}

// The counts of different SIF objects to be generated by MakeUsecaseObjects(), for each object that it makes sense
// to specify a count for as an indepedent variable. Each count is a count of objects to be generated
// per school (except for Schools itself).
type MakeUsecaseCounts struct {
	Students          int
	Staff             int
	Schools           int
	Rooms             int
	Vendors           int
	ChargedLocations  int
	FinancialAccounts int
}

// The different HITS use cases that MakeUsecaseObjects() is to generate objects for. These use cases are documented
// in https://github.com/nsip/usecases/tree/master/docs, replicated in HITS http://hits.nsip.edu.au/dashboard/usecase.html
type MakeUsecases struct {
	DailyAttendance           bool
	Financial                 bool
	Enrolment                 bool
	Gradebook                 bool
	StudentAttendanceTimeList bool
	TeacherJudgement          bool
	Timetable                 bool
	Wellbeing                 bool
	Provisioning              bool
	AGCollections             bool
}

/*
The design of use cases is going to be different to the Perl, which retrieved objects from the database.
Use case creators will by default create all the objects they need, but can optionally be fed objects to use.
*/

func initUseCaseObjects() UseCaseObjects {
	return UseCaseObjects{
		Schools:             sifxml.SchoolInfoSlice(),
		Students:            sifxml.StudentPersonalSlice(),
		Staff:               sifxml.StaffPersonalSlice(),
		Enrolments:          sifxml.StudentSchoolEnrollmentSlice(),
		Assignments:         sifxml.StaffAssignmentSlice(),
		TeachingGroups:      sifxml.TeachingGroupSlice(),
		TimeTables:          sifxml.TimeTableSlice(),
		TimeTableSubjects:   sifxml.TimeTableSubjectSlice(),
		TimeTableCells:      sifxml.TimeTableCellSlice(),
		Rooms:               sifxml.RoomInfoSlice(),
		Contacts:            sifxml.StudentContactPersonalSlice(),
		Relationships:       sifxml.StudentContactRelationshipSlice(),
		FinancialAccounts:   sifxml.FinancialAccountSlice(),
		Vendors:             sifxml.VendorInfoSlice(),
		Debtors:             sifxml.DebtorSlice(),
		ChargedLocations:    sifxml.ChargedLocationInfoSlice(),
		Terms:               sifxml.TermInfoSlice(),
		CalendarSummarys:    sifxml.CalendarSummarySlice(),
		CalendarDates:       sifxml.CalendarDateSlice(),
		SessionInfos:        sifxml.SessionInfoSlice(),
		SchoolCourses:       sifxml.SchoolCourseInfoSlice(),
		ScheduledActivities: sifxml.ScheduledActivitySlice(),
		CollectionRounds:    sifxml.CollectionRoundSlice(),
		CollectionStatuses:  sifxml.CollectionStatusSlice(),
	}
}

func appendUseCaseObjects(ret UseCaseObjects, add UseCaseObjects) UseCaseObjects {
	ret.Schools = append(ret.Schools, add.Schools...)
	ret.Students = append(ret.Students, add.Students...)
	ret.Staff = append(ret.Staff, add.Staff...)
	ret.Rooms = append(ret.Rooms, add.Rooms...)
	ret.Enrolments = append(ret.Enrolments, add.Enrolments...)
	ret.Assignments = append(ret.Assignments, add.Assignments...)
	ret.TimeTables = append(ret.TimeTables, add.TimeTables...)
	ret.TeachingGroups = append(ret.TeachingGroups, add.TeachingGroups...)
	ret.TimeTableSubjects = append(ret.TimeTableSubjects, add.TimeTableSubjects...)
	ret.TimeTableCells = append(ret.TimeTableCells, add.TimeTableCells...)
	ret.Contacts = append(ret.Contacts, add.Contacts...)
	ret.Relationships = append(ret.Relationships, add.Relationships...)
	ret.FinancialAccounts = append(ret.FinancialAccounts, add.FinancialAccounts...)
	ret.Vendors = append(ret.Vendors, add.Vendors...)
	ret.Debtors = append(ret.Debtors, add.Debtors...)
	ret.ChargedLocations = append(ret.ChargedLocations, add.ChargedLocations...)
	ret.Terms = append(ret.Terms, add.Terms...)
	ret.CalendarSummarys = append(ret.CalendarSummarys, add.CalendarSummarys...)
	ret.CalendarDates = append(ret.CalendarDates, add.CalendarDates...)
	ret.SessionInfos = append(ret.SessionInfos, add.SessionInfos...)
	ret.SchoolCourses = append(ret.SchoolCourses, add.SchoolCourses...)
	ret.ScheduledActivities = append(ret.ScheduledActivities, add.ScheduledActivities...)
	ret.CollectionRounds = append(ret.CollectionRounds, add.CollectionRounds...)
	ret.CollectionStatuses = append(ret.CollectionStatuses, add.CollectionStatuses...)
	return ret
}

// The default counts of objects that MakeUsecaseObjects() is to generate, if they are not overtly
// specified in the call to MakeUsecaseObjects(). As noted, all counts but Schools are counts per school. The defaults are:
//
// * SchoolInfo: 1
//
// * StaffPersonal: 50
//
// * StudentPersonal: 500
//
// * RoomInfo: 100
//
// * VendorInfo: 20
//
// * ChargedLocationInfo: 10
//
// * FinancialAccount: 100
func Initcounts(counts MakeUsecaseCounts) MakeUsecaseCounts {
	if counts.Schools == 0 {
		counts.Schools = 1
	}
	if counts.Staff == 0 {
		counts.Staff = 50
	}
	if counts.Students == 0 {
		counts.Students = 500
	}
	if counts.Rooms == 0 {
		counts.Rooms = 100
	}
	if counts.Vendors == 0 {
		counts.Vendors = 20
	}
	if counts.ChargedLocations == 0 {
		counts.ChargedLocations = 10
	}
	if counts.FinancialAccounts == 0 {
		counts.FinancialAccounts = 100
	}
	return counts
}

// Given a list of HITS use cases to fulfil, and a list of counts of objects to generate (for those counts which are independent
// variables), generate all the SIF objects required to fulfil those use case requirements, ensuring that the objects
// are interrelated as appropriate. Objects are generated one school at a time, and the objects for each school have no
// connection to the objects generated for other schools.
//
// All objects are generated using Create_Xs where appropriate, to guarantee that they are interrelated.
// The only parametrisations local to this function are:
//
// * All schools generated are of School Type "Pri/Sec", i.e. they are combined schools
//
// * Timetable subjects are drawn from All_teachingSubjects()
func MakeUsecaseObjects(usecases MakeUsecases, counts MakeUsecaseCounts) UseCaseObjects {
	ret := initUseCaseObjects()
	counts = Initcounts(counts)

	for i := 0; i < counts.Schools; i++ {
		school := Create_SchoolInfo("Pri/Sec")
		add := initUseCaseObjects()
		add.Schools = append(add.Schools, school)

		if usecases.Provisioning || usecases.Gradebook || usecases.StudentAttendanceTimeList || usecases.Financial || usecases.TeacherJudgement || usecases.Timetable || usecases.Wellbeing || usecases.DailyAttendance {
			add.Students = Create_StudentPersonals(counts.Students, Schooltype2Yearlevels(add.Schools[0].SchoolType().String()))
			add.Enrolments = Create_StudentSchoolEnrollments(add.Students, add.Schools[0])
		}
		if usecases.Provisioning || usecases.Gradebook || usecases.StudentAttendanceTimeList || usecases.Financial || usecases.TeacherJudgement || usecases.Timetable || usecases.Wellbeing {
			add.Staff = Create_StaffPersonals(counts.Staff)
			add.Assignments = Create_StaffAssignments(add.Staff, add.Schools[0])
		}
		if usecases.Financial || usecases.Wellbeing {
			add.Contacts, add.Relationships = Create_StudentContactPersonalAndRelationship(add.Students)
		}
		if usecases.Financial {
			add.Vendors = Create_VendorInfos(counts.Vendors)
			add.Debtors = Create_Debtors(add.Students, add.Staff, add.Contacts, add.Vendors)
			add.ChargedLocations = Create_ChargedLocationInfos(counts.ChargedLocations, add.Schools)
			add.FinancialAccounts = Create_FinancialAccounts(counts.FinancialAccounts, add.ChargedLocations)
		}
		if usecases.Provisioning || usecases.Gradebook || usecases.StudentAttendanceTimeList || usecases.TeacherJudgement || usecases.Timetable || usecases.Wellbeing {
			add.Terms = Create_TermInfos(add.Schools[0])
			add.TimeTableSubjects = Create_TimeTableSubjects(add.Schools[0], All_teachingSubjects(), add.Terms)
		}
		if usecases.Provisioning || usecases.Gradebook || usecases.StudentAttendanceTimeList || usecases.TeacherJudgement || usecases.Wellbeing {

			add.TeachingGroups = Create_TeachingGroups(add.Schools[0], add.Staff, add.Students, add.TimeTableSubjects)
		}
		if usecases.StudentAttendanceTimeList || usecases.Timetable || usecases.Wellbeing {
			add.Rooms = Create_RoomInfos(counts.Rooms, add.Schools[0])
		}
		if usecases.StudentAttendanceTimeList || usecases.Wellbeing {
			add.TimeTables = append(add.TimeTables, Create_TimeTable(school))
			add.TimeTableCells = Create_TimeTableCells(add.Schools[0], add.TimeTables[0], add.TeachingGroups, add.Staff, add.Rooms, add.TimeTableSubjects)
		}
		if usecases.StudentAttendanceTimeList || usecases.DailyAttendance {
			add.CalendarSummarys = append(add.CalendarSummarys, Create_CalendarSummary(add.Schools[0]))
			add.CalendarDates = append(add.CalendarDates, Create_CalendarDates(add.CalendarSummarys[0], add.Schools[0])...)
		}
		if usecases.StudentAttendanceTimeList || usecases.Wellbeing {
			add.ScheduledActivities = Create_ScheduledActivities(add.TimeTableCells, add.CalendarDates, add.TeachingGroups)
		}
		if usecases.StudentAttendanceTimeList {
			add.SessionInfos = Create_SessionInfos(add.TimeTableCells, add.CalendarDates)
		}
		if usecases.Timetable {
			add.SchoolCourses = Create_SchoolCourseInfos(add.TimeTableSubjects, add.Terms)
		}
		if usecases.AGCollections {
			add.CollectionStatuses = Create_CollectionStatuses(add.Schools[0])
		}
		ret = appendUseCaseObjects(ret, add)
	}
	if usecases.AGCollections {
		// rounds apply across all schools
		add := initUseCaseObjects()
		add.CollectionRounds = Create_CollectionRounds()
		ret = appendUseCaseObjects(ret, add)
	}
	return ret
}
